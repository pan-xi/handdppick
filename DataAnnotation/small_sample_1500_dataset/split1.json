[
    {
        "source_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200005;\n\nint n,k;\nint siz[N],dep[N],a[N];\n\nint head[N],cnt;\nstruct nod{\n\tint nxt,to;\n}e[N*4];\nvoid add(int u,int v)\n{\n\te[++cnt].nxt = head[u];\n\te[cnt].to = v;\n\thead[u] = cnt;\n}\n\nvoid dfs(int u,int father)\n{\n\tdep[u] = dep[father] + 1;\n\t\n\tsiz[u] = 1;\n\t\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif(v == father) continue;\n\t\tdfs(v,u);\n\t\tsiz[u] += siz[v];\n\t}\n\t\n\ta[u] = dep[u] - 1 - (siz[u]-1);\n\treturn ;\n}\n\nbool com(int a,int b)\n{\n\treturn a>b;\n}\n\nint main()\n{\n\tint x,y;\n\t\n\tscanf(\"%d%d\",&n,&k);\n\t\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\t\n\tdfs(1,0);\n\t\n\tsort(a+1,a+1+n,com);\n\t\n/*\tfor(int i=1;i<=n;++i){\n\t\tcout<<a[i]<<\" \";\n\t}\n\tcout<<endl;\n*/\n\n\tint ans = 0;\n\tfor(int i=1;i<=k;++i){\n\t\tans += a[i];\n\t}\n\tcout<<ans;\n\t\n\treturn 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long//记得开long long！\nvector<int>g[200010];\nint de[200010],siz[200010],p[200010];\nbool cmp(int x,int y)\n{\n    return x>y;\n}\nvoid dfs(int f,int x)\n{\n    de[x]=de[f]+1;\n    siz[x]=1;\n    for(int i=0;i<g[x].size();i++)\n        if(g[x][i]!=f)\n        {\n            dfs(x,g[x][i]);\n            siz[x]+=siz[g[x][i]];\n        }\n}\nsigned main()\n{\n    int n,k,i,u,v,ans=0;\n    cin>>n>>k;\n    for(i=1;i<n;i++)\n    {\n        cin>>u>>v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0,1);\n    for(i=1;i<=n;i++)\n        p[i]=de[i]-siz[i];\n    sort(p+1,p+n+1,cmp);\n    for(i=1;i<=k;i++)\n        ans+=p[i];\n    cout<<ans;\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<stdio.h>\n#include<unordered_set>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing std::vector;\nusing std::unordered_multiset;\n\n\nstruct indexed_tree {\n\tvector<unordered_multiset<int>> tree;\n\tint k = 1;\n\tindexed_tree(int n) {\n\t\twhile (k < n) { k *= 2; }\n\t\ttree.resize(k * 3);\n\t}\n\tvoid update(int left, int right,int a) {\n\t\tleft += k;\n\t\tright += k;\n\t\twhile (1) {\n\t\t\tif (left > right) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (left == right) {\n\t\t\t\ttree[left].insert(a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (left % 2 == 1) {\n\t\t\t\ttree[left].insert(a);\n\t\t\t}\n\t\t\tif (right % 2 == 0) {\n\t\t\t\ttree[right].insert(a);\n\t\t\t}\n\t\t\tleft = (left + 1) / 2;\n\t\t\tright = (right - 1) / 2;\n\t\t}\n\t}\n\n\tint count(int i, int a) {\n\t\tint ret = 0;\n\t\tint idx = k + i;\n\t\twhile (idx) {\n\t\t\tret += tree[idx].count(a);\n\t\t\tret -= tree[idx].count(-a);\n\t\t\tidx /= 2;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nusing std::tuple;\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<tuple<int, int, int>> q;\n\tvector<int> T;\n\tvector<int> X;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tq.emplace_back(a, b, c);\n\t\tT.push_back(b);\n\t\tX.push_back(c);\n\t}\n\tstd::sort(T.begin(), T.end());\n\tstd::sort(X.begin(), X.end());\n\tT.erase(std::unique(T.begin(), T.end()), T.end());\n\tX.erase(std::unique(X.begin(), X.end()), X.end());\n\tindexed_tree tree(n + 5);\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tstd::tie(a, b, c) = q[i];\n\t\tb = std::lower_bound(T.begin(), T.end(), b) - T.begin()+1;\n\t\tc = std::lower_bound(X.begin(), X.end(), c) - X.begin()+1;\n\t\tif (a == 1) {\n\t\t\ttree.update(b, T.size(), c);\n\t\t}\n\t\tif (a == 2) {\n\t\t\ttree.update(b, T.size(), -c);\n\t\t}\n\t\tif (a == 3) {\n\t\t\tprintf(\"%d\\n\", tree.count(b, c));\n\t\t}\n\t}\n}",
        "fixed_code": "#include<stdio.h>\n#include<unordered_map>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing std::vector;\nusing std::unordered_map;\n\n\nstruct indexed_tree {\n\tvector<unordered_map<int,int>> tree;\n\tint k = 1;\n\tindexed_tree(int n) {\n\t\twhile (k < n) { k *= 2; }\n\t\ttree.resize(k * 3);\n\t}\n\tvoid update(int left, int right, int a) {\n\t\tleft += k;\n\t\tright += k;\n\t\twhile (1) {\n\t\t\tif (left > right) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (left == right) {\n\t\t\t\ttree[left][a]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (left % 2 == 1) {\n\t\t\t\ttree[left][a]++;\n\t\t\t}\n\t\t\tif (right % 2 == 0) {\n\t\t\t\ttree[right][a]++;\n\t\t\t}\n\t\t\tleft = (left + 1) / 2;\n\t\t\tright = (right - 1) / 2;\n\t\t}\n\t}\n\tvoid remove(int left, int right, int a) {\n\t\tleft += k;\n\t\tright += k;\n\t\twhile (1) {\n\t\t\tif (left > right) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (left == right) {\n\t\t\t\ttree[left][a]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (left % 2 == 1) {\n\t\t\t\ttree[left][a]--;\n\t\t\t}\n\t\t\tif (right % 2 == 0) {\n\t\t\t\ttree[right][a]--;\n\t\t\t}\n\t\t\tleft = (left + 1) / 2;\n\t\t\tright = (right - 1) / 2;\n\t\t}\n\t}\n\tint count(int i, int a) {\n\t\tint ret = 0;\n\t\tint idx = k + i;\n\t\twhile (idx) {\n\t\t\tret += tree[idx][a];\n\t\t\tidx /= 2;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nusing std::tuple;\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<tuple<int, int, int>> q;\n\tvector<int> T;\n\tvector<int> X;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tq.emplace_back(a, b, c);\n\t\tT.push_back(b);\n\t\tX.push_back(c);\n\t}\n\tstd::sort(T.begin(), T.end());\n\tstd::sort(X.begin(), X.end());\n\tT.erase(std::unique(T.begin(), T.end()), T.end());\n\tX.erase(std::unique(X.begin(), X.end()), X.end());\n\tindexed_tree tree(n + 5);\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tstd::tie(a, b, c) = q[i];\n\t\tb = std::lower_bound(T.begin(), T.end(), b) - T.begin() + 1;\n\t\tc = std::lower_bound(X.begin(), X.end(), c) - X.begin() + 1;\n\t\tif (a == 1) {\n\t\t\ttree.update(b, T.size(), c);\n\t\t}\n\t\tif (a == 2) {\n\t\t\ttree.remove(b, T.size(), c);\n\t\t}\n\t\tif (a == 3) {\n\t\t\tprintf(\"%d\\n\", tree.count(b, c));\n\t\t}\n\t}\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <set>\r\n#include <map>\r\n#include <cmath>\r\n#include <queue>\r\n#include <stack>\r\n#define int long long\r\n\r\nusing namespace std;\r\n\r\nconst int mod = 998244353;\r\n\r\ninline int add(int a, int b)\r\n{\r\n    if (a + b < mod)\r\n        return a + b;\r\n    return a + b - mod;\r\n}\r\n\r\ninline int sub(int a, int b)\r\n{\r\n    if (a - b < 0)\r\n        return a - b + mod;\r\n    return a - b;\r\n}\r\n\r\ninline mul(int a, int b)\r\n{\r\n    return (a * b) % mod;\r\n}\r\n\r\nint bin_pow(int a, int degree)\r\n{\r\n    if (degree == 0)\r\n        return 1;\r\n    if (degree == 1)\r\n        return a;\r\n    if (degree % 2 == 0)\r\n    {\r\n        int num = bin_pow(a, degree / 2);\r\n        return mul(num, num);\r\n    }\r\n    else\r\n    {\r\n        return mul(a, bin_pow(a, degree - 1));\r\n    }\r\n}\r\n\r\nmap<int, int> factorize(int n)\r\n{\r\n    map<int, int> res;\r\n    for (int i = 2; i * i <= n; i++)\r\n    {\r\n        while(n % i == 0)\r\n        {\r\n            res[i]++;\r\n            n /= i;\r\n        }\r\n    }\r\n    if (n != 1)\r\n        res[n]++;\r\n    return res;\r\n}\r\n\r\nsigned main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    int t;\r\n    cin >> t;\r\n    while(t--)\r\n    {\r\n        int n;\r\n        cin >> n;\r\n        map<pair<int, int>, pair<int, int>> ratio_m;\r\n        vector<set<int>> connect(n);\r\n        for (int i1 = 0; i1 < n - 1; i1++)\r\n        {\r\n            int i, j, x, y;\r\n            cin >> i >> j >> x >> y;\r\n            i--, j--;\r\n            ratio_m[{i, j}] = {x, y};\r\n            ratio_m[{j, i}] = {y, x};\r\n            connect[i].insert(j);\r\n            connect[j].insert(i);\r\n        }\r\n        vector<pair<int, int>> have(n, {1, 1});\r\n        queue<int> q;\r\n        q.push(0);\r\n        while(!q.empty())\r\n        {\r\n            int now = q.front();\r\n            q.pop();\r\n            while(!connect[now].empty())\r\n            {\r\n                int beg = *connect[now].begin();\r\n                connect[now].erase(beg);\r\n                connect[beg].erase(now);\r\n                q.push(beg);\r\n                auto p = ratio_m[{now, beg}];\r\n                have[beg] = {mul(have[now].first, p.second), mul(have[now].second, p.first)};\r\n            }\r\n        }\r\n        int res = 1;\r\n        vector<int> must(200000, 0);\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            map<int, int> f = factorize(have[i].first);\r\n            map<int, int> s = factorize(have[i].second);\r\n            auto it = f.begin();\r\n            while(it != f.end())\r\n            {\r\n                pair<int, int> check = {it->first, it->second};\r\n                int can_del = min(check.second, s[check.first]);\r\n                for (int y = 0; y < can_del; y++)\r\n                {\r\n                    have[i].first /= check.first;\r\n                    have[i].second /= check.first;\r\n                }\r\n                s[check.first] -= check.second;\r\n                it++;\r\n            }\r\n            it = s.begin();\r\n            while(it != s.end())\r\n            {\r\n                pair<int, int> check = {it->first, it->second};\r\n                must[check.first] = max(check.second, must[check.first]);\r\n                it++;\r\n            }\r\n        }\r\n        for (int i = 2; i < 200000; i++)\r\n        {\r\n            res = mul(res, bin_pow(i, must[i]));\r\n        }\r\n        int itog = 0;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            itog = add(itog, (res * have[i].first / max(1, have[i].second)) % mod);\r\n        }\r\n        cout << itog << \"\\n\";\r\n    }\r\n\r\n}\r\n",
        "fixed_code": "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <set>\r\n#include <map>\r\n#include <cmath>\r\n#include <fstream>\r\n#define int long long\r\n\r\nusing namespace std;\r\n\r\nconst int mod = 998244353;\r\n\r\ninline int add(int a, int b)\r\n{\r\n    if (a + b >= mod)\r\n        return a + b - mod;\r\n    return a + b;\r\n}\r\n\r\ninline int sub(int a, int b)\r\n{\r\n    if (a - b < 0)\r\n        return a - b + mod;\r\n    return a - b;\r\n}\r\n\r\ninline int mul(int a, int b)\r\n{\r\n    return (a * b) % mod;\r\n}\r\n\r\nint bin_pow(int a, int degree)\r\n{\r\n    if (degree == 0)\r\n        return 1;\r\n    if (degree == 1)\r\n        return a;\r\n    if (degree % 2 == 1)\r\n        return mul(a, bin_pow(a, degree - 1));\r\n    int num = bin_pow(a, degree / 2);\r\n    return mul(num, num);\r\n}\r\n\r\nint divide(int a, int b)\r\n{\r\n    return mul(a, bin_pow(b, mod - 2));\r\n}\r\n\r\nvector<int> sieve(300000, 0);\r\n\r\nvoid gen_sieve()\r\n{\r\n    sieve[1] = 1;\r\n    for (int i = 2; i < 300000; i++)\r\n    {\r\n        if (!sieve[i])\r\n        {\r\n            sieve[i] = i;\r\n            for (int y = 2; y * i < 300000; y++)\r\n            {\r\n                if (!sieve[y * i])\r\n                    sieve[y * i] = i;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvector<int> factorize(int a)\r\n{\r\n    vector<int> res;\r\n    while (a > 1)\r\n    {\r\n        res.push_back(sieve[a]);\r\n        a = a / sieve[a];\r\n    }\r\n    return res;\r\n}\r\n\r\nvector<vector<vector<int>>> gr;\r\nvector<int> degrees;\r\nvector<int> now;\r\nvector<pair<int, int>> have;\r\n\r\nvoid dfs(int v, int last)\r\n{\r\n    for (int i = 0; i < gr[v].size(); i++)\r\n    {\r\n        int to = gr[v][i][0];\r\n        int x = gr[v][i][1];\r\n        int y = gr[v][i][2];\r\n        if (to != last)\r\n        {\r\n            have[to].first = mul(have[v].first, y), have[to].second = mul(have[v].second, x);\r\n            vector<int> x_f = factorize(x);\r\n            vector<int> y_f = factorize(y);\r\n            for (int i = 0; i < y_f.size(); i++)\r\n                now[y_f[i]]--;\r\n            for (int i = 0; i < x_f.size(); i++)\r\n            {\r\n                now[x_f[i]]++;\r\n                degrees[x_f[i]] = max(degrees[x_f[i]], now[x_f[i]]);\r\n            }\r\n            dfs(to, v);\r\n            // return to previous\r\n            for (int i = 0; i < x_f.size(); i++)\r\n                now[x_f[i]]--;\r\n            for (int i = 0; i < y_f.size(); i++)\r\n                now[y_f[i]]++;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nsigned main()\r\n{\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    gen_sieve();\r\n    int t;\r\n    cin >> t;\r\n    while (t--)\r\n    {\r\n        int n;\r\n        cin >> n;\r\n        degrees = vector<int>(n + 2, 0);\r\n        now = vector<int>(n + 2, 0);\r\n        have = vector<pair<int, int>>(n, { 1, 1 });\r\n        gr = vector<vector<vector<int>>>(n);\r\n        for (int i1 = 0; i1 < n - 1; i1++)\r\n        {\r\n            int i, j, x, y;\r\n            cin >> i >> j >> x >> y;\r\n            i--, j--;\r\n            gr[i].push_back({ j, x, y });\r\n            gr[j].push_back({ i, y, x });\r\n        }\r\n        dfs(0, 0);\r\n        int res = 1;\r\n        for (int i = 2; i < n + 1; i++)\r\n        {\r\n            res = mul(res, bin_pow(i, degrees[i]));\r\n        }\r\n        int itog = 0;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            pair<int, int> p = have[i];\r\n            itog = add(itog, divide(mul(p.first, res), p.second));\r\n        }\r\n        cout << itog << \"\\n\";\r\n    }\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int n, d, x[100];\n    int temp[100], kiekis=2;\n    int k=0;\n    ifstream in(\"duom.txt\");\n    cin>>n>>d;\n    for(int i=0; i<n; ++i)\n    {\n        cin>>x[i];\n    }\n\n    for(int i=0; i<n; i++)\n    {\n        if(x[i]+d<=x[i+1]-d)\n        {\n            //cout<<x[i]+d<<endl;\n            kiekis++;\n        }\n    }\n    for(int i=0; i<n; i++)\n    {\n        if(x[i+1]-d>x[i]+d)\n        {\n            //cout<<x[i+1]-d<<endl;\n            kiekis++;\n        }\n        if(i+1==n)\n            break;\n    }\n    cout<<kiekis;\n\nreturn 0;\n}\n",
        "fixed_code": "\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int n, d, x[100];\n    int temp[100], kiekis=2;\n    int k=0;\n    ifstream in(\"duom.txt\");\n    cin>>n>>d;\n    for(int i=0; i<n; ++i)\n    {\n        cin>>x[i];\n    }\n\n    for(int i=0; i<n-1; i++)\n    {\n        if(x[i]+d<=x[i+1]-d)\n        {\n            //cout<<x[i]+d<<endl;\n            kiekis++;\n        }\n        /*if(i+1==n)\n            break;*/\n    }\n    //cout<<endl;\n    for(int i=0; i<n-1; i++)\n    {\n        if(x[i+1]-d>x[i]+d)\n        {\n            //cout<<x[i+1]-d<<endl;\n            kiekis++;\n        }\n        /*if(i+1==n)\n            break;*/\n    }\n    //cout<<endl;\n    cout<<kiekis;\n\nreturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//============================================================================\n// Author       : LAM PHAN VIET - lamphanviet@gmail.com\n// Problem Name : \n// Time Limit   : .000s\n// Description  : \n//============================================================================\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (int i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (int i = (n) - 1; i >= 0; i--)\n#define foreach(it, ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar, val) memset(ar, val, sizeof(ar))\n\n#define uint64 unsigned long long\n#define int64 long long\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n\n#define BIT(n) (1<<(n))\n#define sqr(x) ((x) * (x))\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#define PI 3.1415926535897932385\n#define INF 1000111222\n#define eps 1e-7\n#define maxN 100111\n#define maxM 3003\n\nconst int m = 3003;\nint n, ax[maxN], bx[maxN], ay[maxN], by[maxN];\nint pos[maxM][maxM], sum[maxM][maxM];\nint difcol[maxM][maxM], difrow[maxM][maxM];\nbool head[maxM][maxM];\n\ninline int getSum(int x1, int y1, int x2, int y2) {\n\treturn sum[x2][y2] + sum[x1 - 1][y1 - 1] - sum[x2][y1 - 1] - sum[x1 - 1][y2];\n}\n\nbool isRect(int x1, int y1, int x2, int y2) {\n\t//printf(\"get %d %d %d %d\\n\", x1, y1, x2, y2);\n\tif (getSum(x1, y1, x2, y2) != (x2 - x1 + 1) * (y2 - y1 + 1)) return false;\n\t//printf(\"get %d %d %d %d\\n\", x1, y1, x2, y2);\n\tif (difcol[x2][y2 + 1] - difcol[x1 - 1][y2 + 1] != x2 - x1 + 1) return false;\n\tif (difrow[x2 + 1][y2] - difrow[x2 + 1][y1 - 1] != y2 - y1 + 1) return false;\n\treturn true;\n}\n\nbool solve() {\n\t/*fr(i, 1, m) {\n\t\tfr(j, 1, m) printf(\"%4d\", pos[i][j]);\n\t\tputs(\"\");\n\t}*/\n\tfr(x, 1, m) fr(y, 1, m) if (head[x][y]) {\n\t\tint id = pos[x][y];\n\t\tint r = ax[id], c = ay[id];\n\t\twhile (true) {\n\t\t\t//printf(\"thsi %d %d %d %d\\n\", x, y, r, c);\n\t\t\tif (pos[r][y] < 0 || pos[x][c] < 0) break;\n\t\t\tif (!head[r][y] || !head[x][c]) break;\n\t\t\t\n\t\t\tr = bx[pos[r][y]];\n\t\t\tc = by[pos[x][c]];\n\t\t\t\n\t\t\t\n\t\t\tif (r - x == c - y) {\n\t\t\t\t//printf(\"ok %d %d %d %d\\n\", x, y, r, c);\n\t\t\t\tif (isRect(x, y, r, c)) {\n\t\t\t\t\tvi res;\n\t\t\t\t\tfr(i, x, r) fr(j, y, c)\n\t\t\t\t\t\tif (head[i][j]) res.pb(pos[i][j]);\n\t\t\t\t\tsort(all(res));\n\t\t\t\t\tprintf(\"YES %d\\n\", res.size());\n\t\t\t\t\trep(i, res.size()) printf(\"%d \", res[i] + 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (r - x < c - y) {\n\t\t\t\tc = ay[pos[x][c]];\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr = ax[pos[r][y]];\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"test.inp\", \"r\", stdin);\n\t\t//freopen(\"test.out\", \"w\", stdout);\n\t#endif\n\tscanf(\"%d\", &n);\n\tfill(pos, -1);\n\tfill(head, false);\n\trep(i, n) {\n\t\tscanf(\"%d %d %d %d\", &ax[i], &ay[i], &bx[i], &by[i]);\n\t\tax[i]++; ay[i]++;\n\t\t//bx[i]++; by[i]++;\n\t\thead[ax[i]][ay[i]] = true;\n\t\tfr(x, ax[i], bx[i]) fr(y, ay[i], by[i])\n\t\t\tpos[x][y] = i;\n\t}\n\tfill(sum, 0);\n\tfill(difcol, 0); fill(difrow, 0);\n\tfr(i, 1, m) fr(j, 1, m) {\n\t\tsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\n\t\tif (pos[i][j] >= 0) sum[i][j]++;\n\t\tdifcol[i][j] = difcol[i - 1][j];\n\t\tif (pos[i][j] != pos[i][j - 1]) difcol[i][j]++;\n\t\t\n\t\tdifrow[i][j] = difrow[i][j - 1];\n\t\tif (pos[i][j] != pos[i - 1][j]) difrow[i][j]++;\n\t}\n\tif (!solve()) puts(\"NO\");\n\t//printf(\"%d\\n\", getSum(3, 3, 7, 7));\n\treturn 0;\n}\n",
        "fixed_code": "//============================================================================\n// Author       : LAM PHAN VIET - lamphanviet@gmail.com\n// Problem Name : \n// Time Limit   : .000s\n// Description  : \n//============================================================================\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (int i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (int i = (n) - 1; i >= 0; i--)\n#define foreach(it, ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar, val) memset(ar, val, sizeof(ar))\n\n#define uint64 unsigned long long\n#define int64 long long\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n\n#define BIT(n) (1<<(n))\n#define sqr(x) ((x) * (x))\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#define PI 3.1415926535897932385\n#define INF 1000111222\n#define eps 1e-7\n#define maxN 100111\n#define maxM 3003\n\nconst int m = 3001;\nint n, ax[maxN], bx[maxN], ay[maxN], by[maxN];\nint pos[maxM][maxM], sum[maxM][maxM];\nint difcol[maxM][maxM], difrow[maxM][maxM];\nbool head[maxM][maxM];\n\ninline int getSum(int x1, int y1, int x2, int y2) {\n\treturn sum[x2][y2] + sum[x1 - 1][y1 - 1] - sum[x2][y1 - 1] - sum[x1 - 1][y2];\n}\n\nbool isRect(int x1, int y1, int x2, int y2) {\n\t//printf(\"get %d %d %d %d\\n\", x1, y1, x2, y2);\n\tif (getSum(x1, y1, x2, y2) != (x2 - x1 + 1) * (y2 - y1 + 1)) return false;\n\t//printf(\"get %d %d %d %d\\n\", x1, y1, x2, y2);\n\tif (difcol[x2][y2 + 1] - difcol[x1 - 1][y2 + 1] != x2 - x1 + 1) return false;\n\tif (difrow[x2 + 1][y2] - difrow[x2 + 1][y1 - 1] != y2 - y1 + 1) return false;\n\treturn true;\n}\n\nbool solve() {\n\t/*fr(i, 1, m) {\n\t\tfr(j, 1, m) printf(\"%4d\", pos[i][j]);\n\t\tputs(\"\");\n\t}*/\n\tfr(x, 1, m) fr(y, 1, m) if (head[x][y]) {\n\t\tint id = pos[x][y];\n\t\tint r = ax[id], c = ay[id];\n\t\twhile (true) {\n\t\t\t//printf(\"thsi %d %d %d %d\\n\", x, y, r, c);\n\t\t\tif (pos[r][y] < 0 || pos[x][c] < 0) break;\n\t\t\tif (!head[r][y] || !head[x][c]) break;\n\t\t\t\n\t\t\tr = bx[pos[r][y]];\n\t\t\tc = by[pos[x][c]];\n\t\t\t\n\t\t\t\n\t\t\tif (r - x == c - y) {\n\t\t\t\t//printf(\"ok %d %d %d %d\\n\", x, y, r, c);\n\t\t\t\t//puts(\"Yes\");\n\t\t\t\tif (isRect(x, y, r, c)) {\n\t\t\t\t\tvi res;\n\t\t\t\t\tfr(i, x, r) fr(j, y, c)\n\t\t\t\t\t\tif (head[i][j]) res.pb(pos[i][j]);\n\t\t\t\t\tsort(all(res));\n\t\t\t\t\tprintf(\"YES %d\\n\", res.size());\n\t\t\t\t\trep(i, res.size()) printf(\"%d \", res[i] + 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (r - x < c - y) {\n\t\t\t\tc = ay[pos[x][c]];\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr = ax[pos[r][y]];\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"test.inp\", \"r\", stdin);\n\t\t//freopen(\"test.out\", \"w\", stdout);\n\t#endif\n\tscanf(\"%d\", &n);\n\tfill(pos, -1);\n\tfill(head, false);\n\trep(i, n) {\n\t\tscanf(\"%d %d %d %d\", &ax[i], &ay[i], &bx[i], &by[i]);\n\t\tax[i]++; ay[i]++;\n\t\t//bx[i]++; by[i]++;\n\t\thead[ax[i]][ay[i]] = true;\n\t\tfr(x, ax[i], bx[i]) fr(y, ay[i], by[i])\n\t\t\tpos[x][y] = i;\n\t}\n\tfill(sum, 0);\n\tfill(difcol, 0); fill(difrow, 0);\n\tfr(i, 1, m) fr(j, 1, m) {\n\t\tsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\n\t\tif (pos[i][j] >= 0) sum[i][j]++;\n\t\tdifcol[i][j] = difcol[i - 1][j];\n\t\tif (pos[i][j] != pos[i][j - 1]) difcol[i][j]++;\n\t\t\n\t\tdifrow[i][j] = difrow[i][j - 1];\n\t\tif (pos[i][j] != pos[i - 1][j]) difrow[i][j]++;\n\t}\n\tif (!solve()) puts(\"NO\");\n\t//printf(\"%d\\n\", getSum(3, 3, 7, 7));\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint arr[100] = { 0 };\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint temp;\n\t\tcin >> temp;\n\t\tarr[temp]++;\n\t}\n\tint counter = 0;\n\tint temp = 0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tif (arr[i] >= 2)\n\t\t{\n\t\t\tarr[i] -= 2;\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (arr[j] >= 2)\n\t\t\t\t{\n\t\t\t\t\tcounter++;\n\t\t\t\t\tarr[j] -= 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcout << counter << endl;\n\n}",
        "fixed_code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint arr[101] = { 0 };\n\tbool flag;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint temp;\n\t\tcin >> temp;\n\t\tarr[temp]++;\n\t}\n\tint counter = 0;\n\tint i = 0;\n\twhile (i != 101)\n\t{\n\t\tflag = false;\n\t\tif (arr[i] >= 2)\n\t\t{\n\t\t\tarr[i] -= 2;\n\t\t\tint j = 0;\n\t\t\twhile (j != 101)\n\t\t\t{\n\t\t\t\tif (arr[j] >= 2)\n\t\t\t\t{\n\t\t\t\t\tcounter++;\n\t\t\t\t\tarr[j] -= 2;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\ti = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tcout << counter << endl;\n\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<int, int> pii;\r\nconst int MAXN = 5e5 + 20;\r\nconst int MAXM = 1e6 + 20;\r\nconst int INF = 0x3f3f3f3f;\r\nconst ll MOD = 1e9 + 7;\r\nint n, m;\r\n\r\nstruct node {\r\n    int x, y;\r\n\r\n    bool operator<(const node &A) const {\r\n        return x < A.x;\r\n    }\r\n} p[MAXN];\r\nbool check(){\r\n    int flag=0,sum=0;\r\n    for(int i=1;i<=m;i++){\r\n        if(p[i].x==p[i+1].x){\r\n            if(flag!=0)return false;\r\n            else i++;\r\n        }\r\n        else{\r\n            if(flag==0)sum=p[i].x+p[i].y,flag=1;\r\n            else{\r\n                int s=p[i].x+p[i].y;\r\n                if((s+sum)%2==0)return false;\r\n                flag=0;\r\n            }\r\n        }\r\n    }\r\n    if(flag)return false;\r\n    return true;\r\n}\r\nint main() {\r\n    //freopen(\"1.in\", \"r\", stdin);\r\n    //ios::sync_with_stdio(false);\r\n    //cin.tie(0), cout.tie(0);\r\n    int test;\r\n    scanf(\"%d\", &test);\r\n    while (test--) {\r\n        scanf(\"%d%d\", &n, &m);\r\n        for (int i = 1; i <= m; i++) {\r\n            scanf(\"%d%d\", &p[i].y, &p[i].x);\r\n        }\r\n        sort(p + 1, p + 1 + m);\r\n\r\n        if(check())printf(\"YES\\n\");\r\n        else printf(\"NO\\n\");\r\n    }\r\n\r\n\r\n}\r\n",
        "fixed_code": "#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<int, int> pii;\r\nconst int MAXN = 5e5 + 20;\r\nconst int MAXM = 1e6 + 20;\r\nconst int INF = 0x3f3f3f3f;\r\nconst ll MOD = 1e9 + 7;\r\nint n, m;\r\n\r\nstruct node {\r\n    int x, y;\r\n\r\n    bool operator<(const node &A) const {\r\n        return x < A.x;\r\n    }\r\n} p[MAXN];\r\nbool check(){\r\n    int flag=0,sum=0;\r\n    for(int i=1;i<=m;i++){\r\n        if(p[i].x==p[i+1].x){\r\n            if(flag!=0)return false;\r\n            else i++;\r\n        }\r\n        else{\r\n            if(flag==0)sum=p[i].x+p[i].y,flag=1;\r\n            else{\r\n                int s=p[i].x+p[i].y;\r\n                if((s+sum)%2==0)return false;\r\n                flag=0;\r\n            }\r\n        }\r\n    }\r\n    if(flag)return false;\r\n    return true;\r\n}\r\nint main() {\r\n    //freopen(\"1.in\", \"r\", stdin);\r\n    //ios::sync_with_stdio(false);\r\n    //cin.tie(0), cout.tie(0);\r\n    int test;\r\n    scanf(\"%d\", &test);\r\n    while (test--) {\r\n        scanf(\"%d%d\", &n, &m);\r\n        for (int i = 1; i <= m; i++) {\r\n            scanf(\"%d%d\", &p[i].y, &p[i].x);\r\n        }\r\n        sort(p + 1, p + 1 + m);\r\n        p[m+1].x=-1;\r\n\r\n        if(check())printf(\"YES\\n\");\r\n        else printf(\"NO\\n\");\r\n    }\r\n\r\n\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\nprotected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {\n    java.lang.String[] args = uk.ac.dundee.computing.aec.instagrim.servlets.Convertors.SplitRequestPath(request);\n    request.setAttribute(\"image_url\", args[2]);\n    uk.ac.dundee.computing.aec.instagrim.models.Comment c = new uk.ac.dundee.computing.aec.instagrim.models.Comment();\n    c.setCluster(cluster);\n    java.util.TreeSet<uk.ac.dundee.computing.aec.instagrim.servlets.CommentWrapper> comments = null;\n    try {\n        comments = c.GetComments(args[2]);\n    } catch (uk.ac.dundee.computing.aec.instagrim.servlets.DataException e) {\n        e.printStackTrace();\n    }\n    java.util.Iterator<uk.ac.dundee.computing.aec.instagrim.servlets.CommentWrapper> it = comments.iterator();\n    request.setAttribute(\"commentsi\", it);\n    javax.servlet.RequestDispatcher rd = request.getRequestDispatcher(\"/ViewImage.jsp\");\n    rd.forward(request, response);\n}",
        "fixed_code": "@java.lang.Override\nprotected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {\n    java.lang.String[] args = uk.ac.dundee.computing.aec.instagrim.servlets.Convertors.SplitRequestPath(request);\n    request.setAttribute(\"image_url\", args[2]);\n    uk.ac.dundee.computing.aec.instagrim.models.Comment c = new uk.ac.dundee.computing.aec.instagrim.models.Comment();\n    c.setCluster(cluster);\n    java.util.TreeSet<uk.ac.dundee.computing.aec.instagrim.servlets.CommentWrapper> comments = null;\n    comments = c.GetComments(args[2]);\n    java.util.Iterator<uk.ac.dundee.computing.aec.instagrim.servlets.CommentWrapper> itr = comments.iterator();\n    request.setAttribute(\"comments\", itr);\n    javax.servlet.RequestDispatcher rd = request.getRequestDispatcher(\"/ViewImage.jsp\");\n    rd.forward(request, response);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<iostream>\r\nusing namespace std;\r\nint main()\r\n \r\n{ int m = 3;\r\n    int a  , b ,  c, d , k;\r\n    cin >> k ;\r\n    for ( int i=0; i<=k ; i ++) \r\n{\r\n    \r\n    cin >> a ;\r\n    cin >> b;\r\n    cin >> c;\r\n    cin >> d ;} \r\n    for ( int i=0; i<=k ; i ++) {\r\n    if ( a > b )  m-- ;\r\n    if ( a > c )  m--; \r\n    if ( a > d )  m--; \r\n    cout << m;}",
        "fixed_code": "#include<iostream>\r\nusing namespace std;\r\nint main()\r\n \r\n{ int m = 3;\r\n    int a  , b ,  c, d ;\r\n   int t ;\r\n    cin >> t ;\r\n   while ( t --){ int k =0 ;\r\n    cin >> a  >> b>> c>>d;\r\n    if ( a < b ) k++ ;\r\n    if ( a < c )  k++; \r\n    if ( a < d )  k++;\r\n    cout << k << endl;\r\n       k=0; \r\n   }\r\n   }",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#ifdef DEBUG\r\n#define _GLIBCXX_DEBUG\r\n#endif\r\n#pragma GCC optimize(\"O3\")\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\ntypedef long double ld;\r\ntypedef long long ll;\r\nint n;\r\nconst int maxN = 2e5 + 10;\r\nint a[maxN];\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n//    freopen(\"input.txt\", \"r\", stdin);\r\n    int tst;\r\n    cin >> tst;\r\n    while (tst--) {\r\n        int n;\r\n        cin >> n;\r\n        for (int i = 1; i <= n; i++) {\r\n            cin >> a[i];\r\n        }\r\n        set<int> s;\r\n        s.insert(a[1]);\r\n        bool ok = true;\r\n        for (int i = 2; i <= n; i++) {\r\n            int prv = a[i];\r\n            if (prv != a[i]) {\r\n                if (prv < a[i]) {\r\n                    auto it = s.upper_bound(prv);\r\n                    if (it != s.end() && (*it < a[i])) {\r\n                        ok = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (prv > a[i]) {\r\n                    auto it = s.lower_bound(prv);\r\n                    if (it != s.begin() && (*(--it) > a[i])) {\r\n                        ok = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            s.insert(a[i]);\r\n        }\r\n        if (ok) cout << \"YES\\n\";\r\n        else cout << \"NO\\n\";\r\n    }\r\n    return 0;\r\n}",
        "fixed_code": "#ifdef DEBUG\r\n#define _GLIBCXX_DEBUG\r\n#endif\r\n#pragma GCC optimize(\"O3\")\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\ntypedef long double ld;\r\ntypedef long long ll;\r\nint n;\r\nconst int maxN = 2e5 + 10;\r\nint a[maxN];\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n//    freopen(\"input.txt\", \"r\", stdin);\r\n    int tst;\r\n    cin >> tst;\r\n    while (tst--) {\r\n        int n;\r\n        cin >> n;\r\n        for (int i = 1; i <= n; i++) {\r\n            cin >> a[i];\r\n        }\r\n        set<int> s;\r\n        s.insert(a[1]);\r\n        bool ok = true;\r\n        for (int i = 2; i <= n; i++) {\r\n            int prv = a[i - 1];\r\n            if (prv != a[i]) {\r\n                if (prv < a[i]) {\r\n                    auto it = s.upper_bound(prv);\r\n                    if (it != s.end() && (*it < a[i])) {\r\n                        ok = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (prv > a[i]) {\r\n                    auto it = s.lower_bound(prv);\r\n                    if (it != s.begin() && (*(--it) > a[i])) {\r\n                        ok = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            s.insert(a[i]);\r\n        }\r\n        if (ok) cout << \"YES\\n\";\r\n        else cout << \"NO\\n\";\r\n    }\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fst first\n#define snd second\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define pb push_back\n#define for_tests(t, tt) int t; scanf(\"%d\", &t); for(int tt = 1; tt <= t; tt++)\ntemplate<typename T> inline T abs(T t) { return t < 0? -t : t; }\nconst ull modn = 1000000007;\ninline ull mod(ull x) { return x % modn; }\n\null fexp(ull x, ull p) {\n\tull resp = 1;\n\tfor(ull i = 1; i <= p; i <<= 1) {\n\t\tif(i & p) resp = mod(resp * x);\n\t\tx = mod(x * x);\n\t}\n\treturn resp;\n}\null fat[450009];\n\null comb(ull p, ull n) {\n\tull r = mod(fat[n] * fexp(mod(fat[p] * fat[n - p]), modn - 2));\n\treturn r;\n}\n\nvoid pre() {\n\tfat[0] = 1ull;\n\tfor(ull i = 1; i < 450009ull; i++)\n\t\tfat[i] = mod(i * fat[i - 1]);\n}\n\nstruct st {\n\tint r, c;\n\tull le, ri;\n\tst() {}\n\tst(int a, int b, ull aa, ull bb) : r(a), c(b), le(aa), ri(bb) {}\n} s[2002];\nint degin[2002];\n\nvector<int> sof;\nvector<int> adj[2003];\nint seen[2003][2003];\nvoid dfs(int u) {\n\tfor(int v : sof) {\n\t\tif(!seen[u][v]) {\n\t\t\tseen[u][v] = 1;\n\t\t\ts[u].le = mod(s[u].le + modn - mod(s[v].le * comb(s[u].r - s[v].r, s[u].r - s[v].r + s[u].c - s[v].c)));\n\t\t}\n\t}\n\tsof.pb(u);\n\tfor(int v : adj[u])\n\t\tdfs(v);\n\tsof.pop_back();\n}\n\nint main() {\n\tpre();\n\tint h, w, n, i, r, c, j;\n\tscanf(\"%d %d %d\", &h, &w, &n);\n\tfor(i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &r, &c);\n\t\ts[i] = st(r, c, comb(r-1, r + c-2), comb(h - r, (h - r) + (w - c)));\n\t}\n\tfor(i = 0; i < n; i++)\n\t\tfor(j = 0; j < n; j++) {\n\t\t\tif(i == j) continue;\n\t\t\tif(s[j].r >= s[i].r && s[j].c >= s[i].c) adj[i].pb(j);\n\t\t}\n\tfor(i = 0; i < n; i++)\n\t\tfor(int v : adj[i])\n\t\t\tdegin[v]++;\n\tfor(i = 0; i < n; i++)\n\t\tif(!degin[i]) {\n\t\t\t//adj[n].pb(i);\n\t\t\tdfs(i);\n\t\t}\n\t//st[n] = st(1, 1, 0, 0);\n\t//dfs(n);\n\tull totw = 0;\n\tfor(i = 0; i < n; i++) {\n\t\ttotw = mod(totw + mod(s[i].le * s[i].ri));\n\t}\n\ttotw = mod(comb(h-1, h + w-2) + modn - totw);\n\tprintf(\"%d\\n\", (int) totw);\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fst first\n#define snd second\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define pb push_back\n#define for_tests(t, tt) int t; scanf(\"%d\", &t); for(int tt = 1; tt <= t; tt++)\ntemplate<typename T> inline T abs(T t) { return t < 0? -t : t; }\nconst ull modn = 1000000007;\ninline ull mod(ull x) { return x % modn; }\n\null fexp(ull x, ull p) {\n\tull resp = 1;\n\tfor(ull i = 1; i <= p; i <<= 1) {\n\t\tif(i & p) resp = mod(resp * x);\n\t\tx = mod(x * x);\n\t}\n\treturn resp;\n}\null fat[450009];\n\null comb(ull p, ull n) {\n\tull r = mod(fat[n] * fexp(mod(fat[p] * fat[n - p]), modn - 2));\n\treturn r;\n}\n\nvoid pre() {\n\tfat[0] = 1ull;\n\tfor(ull i = 1; i < 450009ull; i++)\n\t\tfat[i] = mod(i * fat[i - 1]);\n}\n\nstruct st {\n\tint r, c;\n\tull le, ri;\n\tst() {}\n\tst(int a, int b, ull aa, ull bb) : r(a), c(b), le(aa), ri(bb) {}\n} s[2002];\nint degin[2002];\n\nvector<int> sof;\nvector<int> adj[2003];\nint seen[2003];\nvoid dfs(int u) {\n\tif(seen[u]) return;\n\tseen[u] = 1;\n\t//if(!sof.empty()) {\n\t//\tint v = sof.back();\n\t//\tif(!seen[u][v]) {\n\t//\t\tseen[u][v] = 1;\n\t//\t\ts[u].le = mod(s[u].le + modn - mod(s[v].le * comb(s[u].r - s[v].r, s[u].r - s[v].r + s[u].c - s[v].c)));\n\t//\t}\n\t//}\n\tfor(int v : adj[u])\n\t\tdfs(v);\n\tsof.pb(u);\n}\n\nvector<int> adj2[2003];\nint main() {\n\tpre();\n\tint h, w, n, i, r, c, j;\n\tscanf(\"%d %d %d\", &h, &w, &n);\n\tfor(i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &r, &c);\n\t\ts[i] = st(r, c, comb(r-1, r + c-2), comb(h - r, (h - r) + (w - c)));\n\t}\n\tfor(i = 0; i < n; i++)\n\t\tfor(j = 0; j < n; j++) {\n\t\t\tif(i == j) continue;\n\t\t\tif(s[j].r >= s[i].r && s[j].c >= s[i].c) { adj[i].pb(j); adj2[j].pb(i); }\n\t\t}\n\tfor(i = 0; i < n; i++)\n\t\tfor(int v : adj[i])\n\t\t\tdegin[v]++;\n\tfor(i = 0; i < n; i++)\n\t\tdfs(i);\n\treverse(sof.begin(), sof.end());\n\tfor(int u : sof)\n\t\tfor(int v : adj2[u]) {\n\t\t\ts[u].le = mod(s[u].le + modn - mod(s[v].le * comb(s[u].r - s[v].r, s[u].r - s[v].r + s[u].c - s[v].c)));\n\t\t}\n\tull totw = 0;\n\tfor(i = 0; i < n; i++) {\n\t\ttotw = mod(totw + mod(s[i].le * s[i].ri));\n\t}\n\ttotw = mod(comb(h-1, h + w-2) + modn - totw);\n\tprintf(\"%d\\n\", (int) totw);\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void run() {\n    models.items.takeable.TakeableItem currentItem = itemNodeArrayList.get(selectedItemIndex).getItem();\n    if (currentItem.isEquipable()) {\n        avatar.buyItem(currentItem);\n        ((models.entities.npc.ShopKeeper) (shopKeeper)).sell(currentItem);\n    }else {\n    }\n}",
        "fixed_code": "@java.lang.Override\npublic void run() {\n    models.items.takeable.TakeableItem currentItem = itemNodeArrayList.get(selectedItemIndex).getItem();\n    if ((avatar.getAmountofMoney()) > (currentItem.getMonetaryValue())) {\n        ((models.entities.npc.ShopKeeper) (shopKeeper)).sell(currentItem);\n        avatar.buyItem(currentItem);\n    }else {\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n\nmap<int,set<int>> g;\n\nint calc(int v, int from) {\n  int res = 1;\n  for (int c : g.at(v)) {\n    if ( c == from ) {\n      continue;\n    }\n    res += calc(c, v);\n  }\n  return res;\n}\n\nvoid solve() {\n  int n, x;\n  cin >> n >> x;\n  for (int i = 1, a, b; i < n; ++i) {\n    cin >> a >> b;\n    g[a].insert(b);\n    g[b].insert(a);\n  }\n  if (g[x].size() == 1 || g[x].size() == 0) {\n    cout << \"Ayush\\n\";\n    return;\n  }\n  if (calc(x, x) % 2 == 0) {\n    cout << \"Ashish\\n\";\n  } else {\n    cout << \"Ayush\\n\";\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  ll t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define ull unsigned long long\n \nvector<vector<int>> g;\n \nint calc(int v, int n) {\n  int res = 1;\n  vector<int> to_del;\n  for (int i = 1; i <= n; ++i) {\n    if (g[i].size() == 1) {\n      to_del.push_back(i);\n    }\n  }\n \n  //for ( int i = 0; i < n; ++i ) {\n    //for ( int kek : g[i]) {\n      //cout << kek << ' ';\n    //}\n    //cout << endl;\n  //}\n  while (n != 1) {\n    //cout << n << endl;\n    vector<int> new_to_del;\n    for (int c : to_del) {\n      if ( c == v ) {\n        continue;\n      }\n \n      ++res;\n      --n;\n      int vv = g[c][0];\n      g[vv].erase(find(g[vv].begin(), g[vv].end(), c));\n      if (g[vv].size() == 1) {\n        new_to_del.push_back(vv);\n      }\n    }\n    to_del = new_to_del;\n  }\n \n  return res;\n}\n \nvoid solve() {\n  int n, x;\n  cin >> n >> x;\n  g = vector<vector<int>>(n + 1);\n  for (int i = 1, a, b; i < n; ++i) {\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (g[x].size() == 1 || g[x].size() == 0) {\n    cout << \"Ayush\\n\";\n    return;\n  }\n  if (calc(x, n) % 2 == 0) {\n    cout << \"Ayush\\n\";\n  } else {\n    cout << \"Ashish\\n\";\n  }\n}\n \nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  ll t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.Scanner;\n\npublic class ABC {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int t = scn.nextInt();\n\n        while(t-->0){\n            int n = scn.nextInt();\n            String s = scn.next();\n\n            if(n==1) {\n                System.out.println(\"YES\");\n               \n            } else if(n==2){\n                if(s.charAt(0) != s.charAt(1)){\n                    System.out.println(\"YES\");\n                }\n            } else{\n                System.out.println(\"NO\");\n            }\n        }\n    }\n    \n}\n",
        "fixed_code": "import java.util.Scanner;\n\npublic class ABC {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int t = scn.nextInt();\n\n        while(t-->0){\n            int n = scn.nextInt();\n            String s = scn.next();\n\n            if(n==1) {\n                System.out.println(\"YES\");\n               \n            } else if(n==2){\n                if(s.charAt(0) != s.charAt(1)){\n                    System.out.println(\"YES\");\n                } else{\n                    System.out.println(\"NO\");\n                }\n            } else{\n                System.out.println(\"NO\");\n            }\n        }\n    }\n    \n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define ll long long\n#define fl(i,j,n,ind) for(int i=j;i<n;i+=ind)\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define sov(a) sort(a.begin(),a.end())\n#define soa(a,n) sort(a,a+n)\n#define lld long long double\n#define ull unsigned long long\n#define nl() <<endl\n#define inchar\t\t\tgetchar//_unlocked\n#define outchar(x)\t\tputchar(x)//_unlocked(x)\nusing namespace std;\ntemplate<typename T> void in(T &x) {\n\tx = 0;\n\tregister T c = inchar();\n\twhile(((c < 48) || (c > 57)) && (c != '-')) c = inchar();\n\tbool neg = false;\n\tif (c=='-') neg = true;\n\tfor(; c < 48 || c > 57; c = inchar()) ;\n\tfor(; c > 47 && c < 58; c = inchar()) {\n\t\tx = (x<<3) + (x<<1) + (c&15);\n\t}\n\tif(neg) x = -x;\n}\n\ntemplate<typename T> void out(T n) {\n\tif(n < 0) { outchar('-'); n *= -1; }\n\tchar snum[65];\n\tint i = 0;\n\tdo {\n\t\tsnum[i++] = n % 10 + '0';\n\t\tn /= 10;\n\t} while(n);\n\ti = i - 1;\n\twhile (i >= 0) outchar(snum[i--]);\n\toutchar('\\n');\n}\ntemplate<typename T> void outs(T n) {\n\tif(n < 0) { outchar('-'); n *= -1; }\n\tchar snum[65];\n\tint i = 0;\n\tdo {\n\t\tsnum[i++] = n % 10 + '0';\n\t\tn /= 10;\n\t} while(n);\n\ti = i - 1;\n\twhile (i >= 0) outchar(snum[i--]);\n\toutchar(' ');\n}\n\n//Fast I/O for character arrays (not for stings in c++)\ninline void instr(char *str) {\n\tregister char c = 0;\n\tregister int i = 0;\n\twhile (c < 33) c = inchar();\n\twhile (c != '\\n' && c != ' ' && c != EOF) {\n\t\tstr[i] = c;\n\t\tc = inchar(); ++i;\n\t}\n\tstr[i] = '\\0';\n}\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? __gcd(a,b) : a); }\n \ntemplate<typename T> T lcm(T a, T b) { return (a * (b / gcd(a,b))); }\n/*\nll power(ll a, ll n, ll m) {\n\tll x = 1, p = a % m;\n\twhile(n) {\n\t\tif(n & 1) x = mul(x, p, m);\n\t\tp = mul(p, p, m);\n\t\tn >>= 1;\n\t}\n\treturn (x == 0 ? 9 : x);\n}*/\nll ceil1(double x){\n\treturn (ll)x+1;\n}\nint main(){\n\tll n,q;\n\tcin>>n>>q;\n\twhile(q--){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tif((x+y)%2==0){\n\t\t\tif(n%2==0){\n\t\t\t\tcout<<(x-1)*(n/2)+ceil1((double)y/2)<<endl;\n\t\t\t\t//cout<<(x-1)*(n/2)<<\" \"<<ceil(y/2)<<endl;\n\t\t\t}else{\n\t\t\t\tif(x%2==0){\n\t\t\t\t\tcout<<((x-2)/2)*(n/2+n/2+1)+n/2+1+ceil1((double)y/2)<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<((x-1)/2)*(n/2+n/2+1)+ceil1((double)y/2)<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tdouble n1=n;\n\t\t\tdouble q=n1*n1/2;\n\t\t\tif(n%2==0){\n\t\t\t\tcout<<ceil1(q)+(x-1)*(n/2)+ceil1((double)y/2)<<endl;\n\t\t\t}else{//2 1\n\t\t \t\tif(x%2==0){\n\t\t\t\t\tcout<<ceil1(q)+((x-2)/2)*(n/2+n/2+1)+n/2+ceil1((double)y/2)<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<ceil1(q)+((x-1)/2)*(n/2+n/2+1)+ceil1((double)y/2)<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n2 4\n1 3\n2 4\n1 3\n4 2\nn*x-1\n*/\n",
        "fixed_code": "#include<bits/stdc++.h>\n#define ll long long\n#define fl(i,j,n,ind) for(int i=j;i<n;i+=ind)\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define sov(a) sort(a.begin(),a.end())\n#define soa(a,n) sort(a,a+n)\n#define lld long long double\n#define ull unsigned long long\n#define nl() <<endl\n#define inchar\t\t\tgetchar//_unlocked\n#define outchar(x)\t\tputchar(x)//_unlocked(x)\nusing namespace std;\ntemplate<typename T> void in(T &x) {\n\tx = 0;\n\tregister T c = inchar();\n\twhile(((c < 48) || (c > 57)) && (c != '-')) c = inchar();\n\tbool neg = false;\n\tif (c=='-') neg = true;\n\tfor(; c < 48 || c > 57; c = inchar()) ;\n\tfor(; c > 47 && c < 58; c = inchar()) {\n\t\tx = (x<<3) + (x<<1) + (c&15);\n\t}\n\tif(neg) x = -x;\n}\n\ntemplate<typename T> void out(T n) {\n\tif(n < 0) { outchar('-'); n *= -1; }\n\tchar snum[65];\n\tint i = 0;\n\tdo {\n\t\tsnum[i++] = n % 10 + '0';\n\t\tn /= 10;\n\t} while(n);\n\ti = i - 1;\n\twhile (i >= 0) outchar(snum[i--]);\n\toutchar('\\n');\n}\ntemplate<typename T> void outs(T n) {\n\tif(n < 0) { outchar('-'); n *= -1; }\n\tchar snum[65];\n\tint i = 0;\n\tdo {\n\t\tsnum[i++] = n % 10 + '0';\n\t\tn /= 10;\n\t} while(n);\n\ti = i - 1;\n\twhile (i >= 0) outchar(snum[i--]);\n\toutchar(' ');\n}\n\n//Fast I/O for character arrays (not for stings in c++)\ninline void instr(char *str) {\n\tregister char c = 0;\n\tregister int i = 0;\n\twhile (c < 33) c = inchar();\n\twhile (c != '\\n' && c != ' ' && c != EOF) {\n\t\tstr[i] = c;\n\t\tc = inchar(); ++i;\n\t}\n\tstr[i] = '\\0';\n}\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? __gcd(a,b) : a); }\n \ntemplate<typename T> T lcm(T a, T b) { return (a * (b / gcd(a,b))); }\n/*\nll power(ll a, ll n, ll m) {\n\tll x = 1, p = a % m;\n\twhile(n) {\n\t\tif(n & 1) x = mul(x, p, m);\n\t\tp = mul(p, p, m);\n\t\tn >>= 1;\n\t}\n\treturn (x == 0 ? 9 : x);\n}*/\nll ceil1(double x){\n\tif(x-(ll)x>0.0)\n\t\treturn (ll)x+1;\n\telse\n\t\treturn (ll)x;\n}\nint main(){\n\tll n,q;\n\tcin>>n>>q;\n\twhile(q--){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tif((x+y)%2==0){\n\t\t\tif(n%2==0){\n\t\t\t\tcout<<(x-1)*(n/2)+ceil1((double)y/2)<<endl;\n\t\t\t\t//cout<<(x-1)*(n/2)<<\" \"<<ceil(y/2)<<endl;\n\t\t\t}else{\n\t\t\t\tif(x%2==0){\n\t\t\t\t\tcout<<((x-2)/2)*(n/2+n/2+1)+n/2+1+ceil1((double)y/2)<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<((x-1)/2)*(n/2+n/2+1)+ceil1((double)y/2)<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tdouble n1=n;\n\t\t\tdouble q=n1*n1/2;\n\t\t\tif(n%2==0){\n\t\t\t\tcout<<ceil1(q)+(x-1)*(n/2)+ceil1((double)y/2)<<endl;\n\t\t\t}else{//2 1\n\t\t \t\tif(x%2==0){\n\t\t\t\t\tcout<<ceil1(q)+((x-2)/2)*(n/2+n/2+1)+n/2+ceil1((double)y/2)<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<ceil1(q)+((x-1)/2)*(n/2+n/2+1)+ceil1((double)y/2)<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n2 4\n1 3\n2 4\n1 3\n4 2\nn*x-1\n*/\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private boolean updateExistingItem(hudson.model.AbstractItem item, hudson.model.Item dslItem) {\n    java.lang.String config = dslItem.getXml();\n    boolean created;\n    item.checkPermission(Item.EXTENDED_READ);\n    org.custommonkey.xmlunit.Diff diff;\n    try {\n        java.lang.String oldJob = item.getConfigFile().asString();\n        diff = org.custommonkey.xmlunit.XMLUnit.compareXML(oldJob, config);\n        if (diff.identical()) {\n            javaposse.jobdsl.plugin.JenkinsJobManagement.LOGGER.log(java.util.logging.Level.FINE, java.lang.String.format(\"Item %s is identical\", item.getName()));\n            notifyItemUpdated(item, dslItem);\n            return false;\n        }\n    } catch (java.lang.Exception e) {\n        javaposse.jobdsl.plugin.JenkinsJobManagement.LOGGER.warning(e.getMessage());\n    }\n    checkItemType(item, dslItem);\n    javaposse.jobdsl.plugin.JenkinsJobManagement.LOGGER.log(java.util.logging.Level.FINE, java.lang.String.format(\"Updating item %s as %s\", item.getName(), config));\n    javax.xml.transform.Source streamSource = new javax.xml.transform.stream.StreamSource(new java.io.StringReader(config));\n    try {\n        item.updateByXml(streamSource);\n        notifyItemUpdated(item, dslItem);\n        created = true;\n    } catch (java.io.IOException e) {\n        javaposse.jobdsl.plugin.JenkinsJobManagement.LOGGER.log(java.util.logging.Level.WARNING, \"Error writing updated item to file.\", e);\n        created = false;\n    }\n    return created;\n}",
        "fixed_code": "private boolean updateExistingItem(hudson.model.AbstractItem item, hudson.model.Item dslItem) {\n    java.lang.String config = dslItem.getXml();\n    item.checkPermission(Item.EXTENDED_READ);\n    org.custommonkey.xmlunit.Diff diff;\n    try {\n        java.lang.String oldJob = item.getConfigFile().asString();\n        diff = org.custommonkey.xmlunit.XMLUnit.compareXML(oldJob, config);\n        if (diff.identical()) {\n            javaposse.jobdsl.plugin.JenkinsJobManagement.LOGGER.log(java.util.logging.Level.FINE, java.lang.String.format(\"Item %s is identical\", item.getName()));\n            notifyItemUpdated(item, dslItem);\n            return false;\n        }\n    } catch (java.lang.Exception e) {\n        javaposse.jobdsl.plugin.JenkinsJobManagement.LOGGER.warning(e.getMessage());\n    }\n    checkItemType(item, dslItem);\n    javaposse.jobdsl.plugin.JenkinsJobManagement.LOGGER.log(java.util.logging.Level.FINE, java.lang.String.format(\"Updating item %s as %s\", item.getName(), config));\n    javax.xml.transform.Source streamSource = new javax.xml.transform.stream.StreamSource(new java.io.StringReader(config));\n    try {\n        item.updateByXml(streamSource);\n        notifyItemUpdated(item, dslItem);\n    } catch (java.io.IOException e) {\n        throw new javaposse.jobdsl.dsl.DslException(e);\n    }\n    return true;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <stack>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define vi vector\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n\nll mod = 998244353;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<ll> a;\n    vector<ll> s(n);\n    forn(i, n) {\n        ll temp;\n        cin >> temp;\n        a.pb(temp);\n    }\n\n    s[1] = a[0];\n    n++;\n\n    for (int i = 2; i <= n - 1; ++i) {\n        s[i] = s[i - 1] + a[i - 1];\n    }\n\n    vector<ll> ans(n, 0);\n\n    vector<ll> rs(n);\n\n    rs[1] = s[1];\n\n    vector<ll> rans(n, 0);\n\n    for (int i = 1; i <= n - 1; ++i) {\n        ans[i] += rs[i];\n        ans[i] %= mod;\n        if (i + 1 <= n - 1) {\n            rs[i + 1] = (rs[i] - s[i]) * 2 + s[i] +  s[i + 1];\n            rs[i + 1] %= mod;\n        }\n        ans[i] += rans[i - 1];\n        ans[i] %= mod;\n        rans[i] = rans[i - 1] + ans[i];\n        rans[i] %= mod;\n    }\n\n    cout << ans[n - 1];\n    return 0;\n}",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <stack>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define vi vector\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n\nll mod = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<ll> a;\n    vector<ll> s(n + 1);\n    forn(i, n) {\n        ll temp; cin >> temp;\n        a.pb(temp);\n    }\n\n    s[1] = a[0];\n    n++;\n\n    for (int i = 2; i <= n - 1; ++i) {\n        s[i] = s[i - 1] + a[i - 1];\n    }\n\n    vector<ll> ans(n, 0);\n\n    vector<ll> rs(n);\n\n    rs[1] = s[1];\n\n    vector<ll> rans(n, 0);\n\n    for (int i = 1; i <= n - 1; ++i) {\n        ans[i] += rs[i];\n        ans[i] %= mod;\n        if (i + 1 <= n - 1) {\n            rs[i + 1] = (rs[i] - s[i]) * 2 + s[i] +  s[i + 1];\n            rs[i + 1] %= mod;\n        }\n        ans[i] += rans[i - 1];\n        ans[i] %= mod;\n        rans[i] = rans[i - 1] + ans[i];\n        rans[i] %= mod;\n    }\n\n    cout << ans[n - 1];\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@org.springframework.security.access.annotation.Secured(value = { \"USER\" })\n@org.springframework.web.bind.annotation.RequestMapping(value = \"user/entry/edit\", method = org.springframework.web.bind.annotation.RequestMethod.GET)\npublic java.lang.String showEntryEditPage(@org.springframework.web.bind.annotation.RequestParam(value = \"id\")\nfinal java.lang.Long id, final org.springframework.ui.ModelMap model, final java.security.Principal currentUser) {\n    this.fillupModelForEntryEdit(model, currentUser, id, de.hhn.labswps.wefactor.web.EntryController.EntryEditMode.MASTER);\n    return \"entryedit\";\n}",
        "fixed_code": "@org.springframework.security.access.annotation.Secured(value = { \"USER\" })\n@org.springframework.web.bind.annotation.RequestMapping(value = \"user/entry/edit\", method = org.springframework.web.bind.annotation.RequestMethod.GET)\npublic java.lang.String showEntryEditPage(@org.springframework.web.bind.annotation.RequestParam(value = \"id\")\nfinal java.lang.Long id, final org.springframework.ui.ModelMap model, final java.security.Principal currentUser) {\n    de.hhn.labswps.wefactor.domain.UserProfile profile = this.userProfileRepository.findByUsername(currentUser.getName());\n    de.hhn.labswps.wefactor.domain.Account account = profile.getAccount();\n    de.hhn.labswps.wefactor.domain.MasterEntry entry = this.entryRepository.findOne(id);\n    if (((!(entry.getVersions().isEmpty())) || (!(entry.getProposals().isEmpty()))) || (!(account.equals(entry.getAccount())))) {\n        throw new java.lang.IllegalArgumentException();\n    }\n    this.fillupModelForEntryEdit(model, currentUser, id, de.hhn.labswps.wefactor.web.EntryController.EntryEditMode.MASTER);\n    return \"entryedit\";\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "protected int getDefaultStyle() {\n    return R.attr.characterCounterViewStyle;\n}",
        "fixed_code": "@java.lang.Override\nprotected int getDefaultStyleAttr() {\n    return R.attr.characterCounterViewStyle;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "public void run() {\n    consumerPollLoop();\n}",
        "fixed_code": "@java.lang.Override\npublic void run() {\n    consumerPollLoop();\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "public void listAllItems() throws java.io.IOException, java.lang.InterruptedException {\n    java.util.List<org.openqa.selenium.WebElement> iListOnPage = getDriver().findElements(net.serenitybdd.core.annotations.findby.By.xpath(\"//*[@id='items']/div/div[3]/div[2]/div/*\"));\n    java.io.File src = new java.io.File(\"src/test/resources/myfile.xlsx\");\n    java.io.FileInputStream fileInputStream = new java.io.FileInputStream(src);\n    org.apache.poi.xssf.usermodel.XSSFWorkbook wb = new org.apache.poi.xssf.usermodel.XSSFWorkbook(fileInputStream);\n    org.apache.poi.xssf.usermodel.XSSFSheet sheet1 = wb.getSheetAt(0);\n    java.lang.System.out.println((\"iList.size() = \" + (iListOnPage.size())));\n    for (int i = 1; i < 3; i++) {\n        getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(((\"//*[@id='items']/div/div[3]/div[2]/div/div[\" + i) + \"]/a/div/div[1]\"))).click();\n        java.lang.Thread.sleep(3000);\n        org.openqa.selenium.WebElement we = getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(\"//*[@id='circles']\"));\n        java.util.List<org.openqa.selenium.WebElement> iList = we.findElements(net.serenitybdd.core.annotations.findby.By.cssSelector(\".thumbnail-nav img\"));\n        java.lang.System.out.println((\"iList.size() = \" + (iList.size())));\n        int iColumnNumber = 4;\n        int iLastUsedRow = sheet1.getPhysicalNumberOfRows();\n        int iJavlue = 4;\n        for (int inG = 0; i < (sheet1.getPhysicalNumberOfRows()); i++) {\n            for (int j = 0; j < (sheet1.getRow(inG).getLastCellNum()); j++) {\n                sheet1.getRow(inG).createCell(iJavlue).setCellValue((\"Hello \" + inG));\n                java.io.FileOutputStream fout = new java.io.FileOutputStream(new java.io.File(\"src/test/resources/myfile2.xlsx\"));\n                wb.write(fout);\n                fout.close();\n            }\n        }\n        wb.close();\n        for (int iIntRow = 0; iIntRow < (sheet1.getPhysicalNumberOfRows()); iIntRow++) {\n            for (int j = 0; j < (sheet1.getRow(iIntRow).getLastCellNum()); j++) {\n                java.lang.System.out.println(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(\"//div[@id='listing-page-cart-inner']/h1/span\")).getText());\n                java.lang.String tempValue = getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(\"//div[@id='listing-page-cart-inner']/h1/span\")).getText();\n                sheet1.getRow(iIntRow).createCell((iColumnNumber + 1)).setCellValue(1);\n                java.lang.System.out.println(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"listing-price\")).getText());\n                sheet1.getRow(iIntRow).createCell((iColumnNumber + 2)).setCellValue(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"listing-price\")).getText());\n                java.lang.System.out.println(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"description-text\")).getText());\n                sheet1.getRow(iIntRow).createCell((iColumnNumber + 3)).setCellValue(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"description-text\")).getText());\n                int iNewColumnValue = iColumnNumber + 3;\n                for (int k = 0; k < (iList.size()); k++) {\n                    java.lang.System.out.println((((\"This is k = \" + k) + \" = \") + (iList.get(k).getAttribute(\"src\"))));\n                    sheet1.getRow(iIntRow).createCell((++iNewColumnValue)).setCellValue(iList.get(k).getAttribute(\"src\"));\n                }\n                java.io.FileOutputStream fout = new java.io.FileOutputStream(new java.io.File(\"src/test/resources/myfile2.xlsx\"));\n                wb.write(fout);\n                fout.close();\n            }\n        }\n        wb.close();\n        java.lang.System.out.println(\"STOP\");\n    }\n}",
        "fixed_code": "public void listAllItems() throws java.io.IOException, java.lang.InterruptedException {\n    java.util.List<org.openqa.selenium.WebElement> iListOnPage = getDriver().findElements(net.serenitybdd.core.annotations.findby.By.xpath(\"//*[@id='items']/div/div[3]/div[2]/div/*\"));\n    java.lang.System.out.println((\"iList.size() = \" + (iListOnPage.size())));\n    int iColumnNumber = 0;\n    int iIntRow = 5;\n    int iPageNumber = 5;\n    getDriver().get((\"https://www.etsy.com/uk/shop/JeenMata/items?ref=pagination&page=\" + iPageNumber));\n    for (int i = 6; i < (iListOnPage.size()); i++) {\n        try {\n            java.io.File src = new java.io.File(\"src/test/resources/myfile.xlsx\");\n            java.io.FileInputStream fileInputStream = new java.io.FileInputStream(src);\n            org.apache.poi.xssf.usermodel.XSSFWorkbook wb = new org.apache.poi.xssf.usermodel.XSSFWorkbook(fileInputStream);\n            org.apache.poi.xssf.usermodel.XSSFSheet sheet1 = wb.getSheetAt(0);\n            getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(((\"//*[@id='items']/div/div[3]/div[2]/div/div[\" + i) + \"]/a/div/div[1]\"))).click();\n            java.lang.Thread.sleep(3000);\n            org.openqa.selenium.WebElement we = getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(\"//*[@id='circles']\"));\n            java.util.List<org.openqa.selenium.WebElement> iList = we.findElements(net.serenitybdd.core.annotations.findby.By.cssSelector(\".thumbnail-nav img\"));\n            java.lang.System.out.println((\"iList.size() = \" + (iList.size())));\n            java.lang.System.out.println(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(\"//div[@id='listing-page-cart-inner']/h1/span\")).getText());\n            sheet1.getRow(iIntRow).createCell((iColumnNumber + 1)).setCellValue(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.xpath(\"//div[@id='listing-page-cart-inner']/h1/span\")).getText());\n            java.lang.System.out.println(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"listing-price\")).getText());\n            sheet1.getRow(iIntRow).createCell((iColumnNumber + 2)).setCellValue(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"listing-price\")).getText());\n            java.lang.System.out.println(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"description-text\")).getText());\n            sheet1.getRow(iIntRow).createCell((iColumnNumber + 3)).setCellValue(getDriver().findElement(net.serenitybdd.core.annotations.findby.By.id(\"description-text\")).getText());\n            int iNewColumnValue = iColumnNumber + 4;\n            for (int k = 0; k < (iList.size()); k++) {\n                java.lang.System.out.println((((\"This is k = \" + k) + \" = \") + (iList.get(k).getAttribute(\"src\"))));\n                sheet1.getRow(iIntRow).createCell((iNewColumnValue++)).setCellValue(iList.get(k).getAttribute(\"src\"));\n            }\n            java.io.FileOutputStream fout = new java.io.FileOutputStream(new java.io.File(\"src/test/resources/myfile.xlsx\"));\n            wb.write(fout);\n            fout.close();\n            wb.close();\n            iIntRow++;\n            java.lang.System.out.println(\"STOP\");\n            getDriver().navigate().back();\n            java.lang.Thread.sleep(4000);\n        } catch (org.openqa.selenium.NoSuchElementException e) {\n            break;\n        }\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int odd=0,even=0;\n    int n,k;\n    cin>>n;\n    cin>>k;\n    int z;\n    bool l;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>z;\n        l=z%2;\n        if(l==1)\n        odd++;\n        else\n        even++;\n    }\n    if(n==k)\n    if(odd%2==1)\n    cout<<\"Stannis\";\n    else\n    cout<<\"Daenerys\";\n    else\n    {\n    \n    if(odd%2==0&&even%2==0)\n    if(k%2==n%2)\n    cout<<\"Daenerys\";\n    else\n    {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k-1)/2)\n        cout<<\"Stannis\";\n        else\n        cout<<\"Stannis\";\n    }\n    if (odd%2==1&&even%2==1)\n    if(k%2==n%2)\n    {\n    cout<<\"Daenerys\";   \n    }\n    else\n    {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k+1)/2)\n        cout<<\"Stannis\";\n        else\n        cout<<\"Stannis\";\n    }\n    if (odd%2==0&&even%2==1)\n    if(n%2==k%2)\n    {\n    if(even<=(n-k)/2)\n    cout<<\"Stannis\";\n    else\n    if (odd<=(n-k)/2)\n    cout<<\"Daenerys\";\n    else\n    cout<<\"Daenerys\";\n    }\n    else\n        {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k+1)/2)\n        cout<<\"Stannis\";\n        else\n        cout<<\"Stannis\";\n        }\n        if (odd%2==1&&even%2==0)\n        if(n%2==k%2)\n        {\n        if(even<=(n-k)/2)\n        cout<<\"Stannis\";\n        else\n        if (odd<=(n-k)/2)\n        cout<<\"Daenerys\";\n        else\n        cout<<\"Daenerys\";   \n        }\n        else\n        {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        cout<<\"Stannis\";\n        }\n}\n}",
        "fixed_code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int odd=0,even=0;\n    int n,k;\n    cin>>n;\n    cin>>k;\n    int z;\n    bool l;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>z;\n        l=z%2;\n        if(l==1)\n        odd++;\n        else\n        even++;\n    }\n    if(n==k)\n    if(odd%2==1)\n    cout<<\"Stannis\";\n    else\n    cout<<\"Daenerys\";\n    else\n    {\n    \n    if(odd%2==0&&even%2==0)\n    if(k%2==n%2)\n    cout<<\"Daenerys\";\n    else\n    {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k-1)/2)\n        cout<<\"Stannis\";\n        else\n        cout<<\"Stannis\";\n    }\n    if (odd%2==1&&even%2==1)\n    if(k%2==n%2)\n    {\n    cout<<\"Daenerys\";   \n    }\n    else\n    {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k+1)/2)\n        cout<<\"Stannis\";\n        else\n        cout<<\"Stannis\";\n    }\n    if (odd%2==0&&even%2==1)\n    if(n%2==k%2)\n    {\n    if(even<=(n-k)/2)\n    cout<<\"Stannis\";\n    else\n    if (odd<=(n-k)/2)\n    cout<<\"Daenerys\";\n    else\n    cout<<\"Daenerys\";\n    }\n    else\n        {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k+1)/2)\n        cout<<\"Daenerys\";\n        else\n        cout<<\"Stannis\";\n        }\n        if (odd%2==1&&even%2==0)\n        if(n%2==k%2)\n        {\n        if(even<=(n-k)/2)\n        cout<<\"Stannis\";\n        else\n        if (odd<=(n-k)/2)\n        cout<<\"Daenerys\";\n        else\n        cout<<\"Daenerys\";   \n        }\n        else\n        {\n        if(odd<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        if(even<=(n-k-1)/2)\n        cout<<\"Daenerys\";\n        else\n        cout<<\"Stannis\";\n        }\n}\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "﻿#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF (ll)1 << 60\n#define MINF (-1 * INF)\n#define ALL(n) n.begin(),n.end()\n#define MOD 1000000007\n#define P pair<ll, ll>\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll t;\n\tcin >> t;\n\tREP(tt, t) {\n\t\tll n, m, x, y, a1 = 0, a2 = 0;\n\t\tbool xused[110000] = {}, yused[110000] = {};\n\t\tcin >> n >> m >> x >> y;\n\t\tvector<vector<ll>> g(n);\n\t\tx--;\n\t\ty--;\n\t\tREP(i, m) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tqueue<ll> q;\n\t\tq.push(x);\n\t\twhile (!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\txused[now] = true;\n\t\t\tif (now == y)continue;\n\t\t\tREP(i, g[now].size()) {\n\t\t\t\tif (!xused[g[now][i]])q.push(g[now][i]);\n\t\t\t}\n\t\t}\n\t\tq.push(y);\n\t\twhile (!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tyused[now] = true;\n\t\t\tif (now == x)continue;\n\t\t\tREP(i, g[now].size()) {\n\t\t\t\tif (!yused[g[now][i]])q.push(g[now][i]);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tif (i == x or i == y)continue;\n\t\t\telse if (xused[i] and yused[i])continue;\n\t\t\telse if (xused[i])a1++;\n\t\t\telse if (yused[i])a2++;\n\t\t}\n\t\tcout << a1 * a2 << endl;\n\t}\n}\n",
        "fixed_code": "﻿#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF (ll)1 << 60\n#define MINF (-1 * INF)\n#define ALL(n) n.begin(),n.end()\n#define MOD 1000000007\n#define P pair<ll, ll>\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll t;\n\tcin >> t;\n\tREP(tt, t) {\n\t\tll n, m, x, y, a1 = 0, a2 = 0;\n\t\tcin >> n >> m >> x >> y;\n\t\tvector<bool> xused(n), yused(n);\n\t\tvector<vector<ll>> g(n);\n\t\tx--;\n\t\ty--;\n\t\tREP(i, m) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tqueue<ll> q;\n\t\tq.push(x);\n\t\twhile (!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\txused[now] = true;\n\t\t\tif (now == y)continue;\n\t\t\tREP(i, g[now].size()) {\n\t\t\t\tif (!xused[g[now][i]])q.push(g[now][i]);\n\t\t\t}\n\t\t}\n\t\tq.push(y);\n\t\twhile (!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tyused[now] = true;\n\t\t\tif (now == x)continue;\n\t\t\tREP(i, g[now].size()) {\n\t\t\t\tif (!yused[g[now][i]])q.push(g[now][i]);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tif (i == x or i == y)continue;\n\t\t\telse if (xused[i] and yused[i])continue;\n\t\t\telse if (xused[i])a1++;\n\t\t\telse if (yused[i])a2++;\n\t\t}\n\t\tcout << a1 * a2 << endl;\n\t}\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Otbor {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter writer = new PrintWriter(System.out);\n        int t = Integer.parseInt(reader.readLine());\n        for(int q = 0; q < t; ++q){\n            StringTokenizer st = new StringTokenizer(reader.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n            TreeSet<Integer> set = new TreeSet<>();\n            st = new StringTokenizer(reader.readLine());\n            for(int i = 0; i < n; ++i){\n                set.add(Integer.parseInt(st.nextToken()));\n            }\n            if(k == 1){\n                if(set.size() > 1){\n                    System.out.println(-1);\n                }\n                else{\n                    System.out.println(1);\n                }\n                continue;\n            }\n            System.out.println((set.size() + k - 3) / (k - 1));\n        }\n    }\n}",
        "fixed_code": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Otbor {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter writer = new PrintWriter(System.out);\n        int t = Integer.parseInt(reader.readLine());\n        for(int q = 0; q < t; ++q){\n            StringTokenizer st = new StringTokenizer(reader.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n            TreeSet<Integer> set = new TreeSet<>();\n            st = new StringTokenizer(reader.readLine());\n            for(int i = 0; i < n; ++i){\n                set.add(Integer.parseInt(st.nextToken()));\n            }\n            if(k == 1){\n                if(set.size() > 1){\n                    System.out.println(-1);\n                }\n                else{\n                    System.out.println(1);\n                }\n                continue;\n            }\n            System.out.println(Math.max(1,(set.size() + k - 3) / (k - 1)));\n        }\n    }\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <fstream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tifstream fin(\"input.txt\");\n\tofstream fout(\"output.txt\");\n\n\tint n, m;\n\tfin >> n >> m;\n\tvector<vector<int>>v(n, vector<int>(m));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfin >> v[i][j];\n\t\t}\n\t}\n\n\tint counter = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (v[i][j] == 0) {\n\t\t\t\tfor (int h = 0; h + j < m; h++) {\n\t\t\t\t\tif (v[i][h + j] == 1) {\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int h = 0; j - h >= 0; h++) {\n\t\t\t\t\tif (v[i][j - h] == 1) {\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int h = 0; i + h < n; h++) {\n\t\t\t\t\tif (v[i + h][j] == 1) {\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int h = 0; i - h >= 0; h++) {\n\t\t\t\t\tif (v[i - h][j] == 1) {\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfout << counter;\n}",
        "fixed_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\t/*ifstream fin(\"input.txt\");\n\tofstream fout(\"output.txt\");*/\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>>g(n, vector<int>(m));\n\tvector<vector<int>>red(n, vector<int>(m));\n\tvector<vector<int>>blue(n, vector<int>(m));\n\tvector<vector<int>>green(n, vector<int>(m));\n\tvector<vector<int>>purple(n, vector<int>(m));\n\n\tbool redb = false;\n\tbool greenb = false;\n\tbool purpleb = false;\n\tbool blueb = false;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> g[i][j];\n\t\t\tif (g[i][j] == 1 || redb == true) {\n\t\t\t\tred[i][j] = 1;\n\t\t\t\tredb = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tred[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tredb = false;\n\t}\n\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = m - 1; j > -1; j--) {\n\t\t\tif (g[i][j] == 1 || blueb == true) {\n\t\t\t\tblue[i][j] = 1;\n\t\t\t\tblueb = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tblue[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tblueb = false;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (g[j][i] == 1 || greenb == true) {\n\t\t\t\tgreen[j][i] = 1;\n\t\t\t\tgreenb = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgreen[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tgreenb = false;\n\t}\n\n\tfor (int j = 0; j < m; j++) {\n\t\tfor (int i = n - 1; i > -1; i--) {\n\t\t\tif (g[i][j] == 1 || purpleb == true) {\n\t\t\t\tpurple[i][j] = 1;\n\t\t\t\tpurpleb = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpurple[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tpurpleb = false;\n\t}\n\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (g[i][j] == 0) {\n\t\t\t\tsum += red[i][j] + blue[i][j] + green[i][j] + purple[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << sum;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n\tlong long l, r, as = 0;\n\tlong long res = 0;\n\tlong long num;\n\tlong long a[100000];\n\tlong long ls = -1;\nvoid rec (int x, int len, long long num = 0) {\n\tif (x == len) {\n\t\tif (num > r && (ls == -1 || num < ls)) ls = num;\n\t\tif (num >= l && num <= r) a[as++] = num;\n\t\treturn;\n\t}\n\trec(x+1,len,num*1LL*10+4);\n\trec(x+1,len,num*1LL*10+7);\n}\n\nint main ()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tbool ok = 0;\n\tstring s;\n\tcin >> s;\n\twhile (k) {\n\t\tok = 0;\n//\t\tcout << k << \" \" << s << endl;\n\t\tfor (int i = 0; i < n-1; i++)\n\t\t\tif (s[i] == '4' && s[i+1] == '7') {\n\t\t\t\tif (i%2 == 1) {\n\t\t\t\t\tif (i > 0 && s[i-1] == '4')k %= 2;\n\t\t\t\t\tif (!k)break;\n\t\t\t\t\ts[i] = s[i+1] = '7';\t\n\t\t\t\t}\n\t\t\t\telse\ts[i] = s[i+1] = '4';\n\t\t\t\tok = 1;\n\t\t\t\tk--;\n\t\t\t\tbreak;/*\n\t\t\t\tok = 1;\n\t\t\t\tif (i > 0 && s[i-1] == '4' && s[i] == '7') {\n\t\t\t\t\tif (k&1) s[i] = '4',s[i+1] = '7';\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}/*\n\t\t\t\tif (i < n-2 && s[i+1] == '4' && s[i+2] == '7') {\n\t\t\t\t\tif (k&1) s[i] = '4',s[i+1] = '7';\t\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\t}\n\t\tif (!ok)break;\n\t}\n\tcout << s;\n\treturn 0;\n}\n\n",
        "fixed_code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n\tlong long l, r, as = 0;\n\tlong long res = 0;\n\tlong long num;\n\tlong long a[100000];\n\tlong long ls = -1;\nvoid rec (int x, int len, long long num = 0) {\n\tif (x == len) {\n\t\tif (num > r && (ls == -1 || num < ls)) ls = num;\n\t\tif (num >= l && num <= r) a[as++] = num;\n\t\treturn;\n\t}\n\trec(x+1,len,num*1LL*10+4);\n\trec(x+1,len,num*1LL*10+7);\n}\n\nint main ()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tbool ok = 0;\n\tstring s;\n\tcin >> s;\n\tint id = 0;\n\twhile (k) {\n\t\tok = 0;\n//\t\tcout << k << \" \" << s << endl;\n\t\tfor (int i = id; i < n-1; i++)\n\t\t\tif (s[i] == '4' && s[i+1] == '7') {\n\t\t\t\tif (i%2 == 1) {\n\t\t\t\t\tif (i > 0 && s[i-1] == '4')k %= 2;\n\t\t\t\t\tif (!k)break;\n\t\t\t\t\ts[i] = s[i+1] = '7';\t\n\t\t\t\t}\n\t\t\t\telse\ts[i] = s[i+1] = '4';\n\t\t\t\tid = i;\n\t\t\t\tok = 1;\n\t\t\t\tk--;\n\t\t\t\tbreak;/*\n\t\t\t\tok = 1;\n\t\t\t\tif (i > 0 && s[i-1] == '4' && s[i] == '7') {\n\t\t\t\t\tif (k&1) s[i] = '4',s[i+1] = '7';\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}/*\n\t\t\t\tif (i < n-2 && s[i+1] == '4' && s[i+2] == '7') {\n\t\t\t\t\tif (k&1) s[i] = '4',s[i+1] = '7';\t\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\t}\n\t\tif (!ok)break;\n\t}\n\tcout << s;\n\treturn 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\n#define ff first\n#define ss second\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\n\nconst int N = 505;\n\nint n;\nint v[N];\nshort int dp[N][N][N];\n\nshort int f(int id, int at, int volta, int pa){\n\tif(pa && volta == 0){\n\t\tat++;\n\t\tpa = 0;\n\t}\n\tif(volta){\n\t\tpa = 1;\n\t}\n\tif(id == n) return volta == 0 ? 0 : -1e9;\n\tshort int &ans = dp[id][at][volta];\n\tif(ans != -1) return ans;\n\tans = -1e9;\n\tif(id != n-1 && v[id] + at == v[id+1]){\n\t\tans = max(ans, f(id+1, at+1, max(0, volta-1), pa) + 1);\n\t}\n\tif(id != n-1 && v[id] + at > v[id+1]){\n\t\tans = max(ans, f(id+1, 0, (volta ? volta - 1 : 0) + (v[id] + at - v[id + 1]), pa) + 1);\n\t}\n\tif(volta == 0)\n\t\tans = max(ans, f(id+1, 0, 0, pa));\n\treturn ans;\n}\n\nint main() {\n\tmemset(dp, -1, sizeof dp);\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", v+i);\n\t}\n\tprintf(\"%d\\n\", n - f(0, 0, 0, 0));\n\n\treturn 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 510;\nconst int inf = 1e9+10;\n\nint n;\nint a[maxn];\n\nint dp1[maxn][maxn], dp2[maxn][maxn];\n\nint solve1(int l, int r)\n{\n\tif (l == r) return dp1[l][r] = a[l];\n\tif (l > r) return dp1[l][r] = 0;\n\tif (dp1[l][r] != -1) return dp1[l][r];\n\n\tint ans = 0;\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tsolve1(l, i); solve1(i+1, r);\n\n\t\tif (dp1[l][i] != 0 && dp1[i+1][r] != 0 && (dp1[l][i] == dp1[i+1][r]))\n\t\t\tans = dp1[l][i]+1;\n\t}\n\n\treturn dp1[l][r] = ans;\n}\n\nint solve2(int l, int r)\n{\n\tif (l > r) return inf;\n\tif (l == r || dp1[l][r] > 0) return 0;\n\tif (dp2[l][r] != -1) return dp2[l][r];\n\n\tint ans = inf;\n\n\tfor (int i = l; i < r; i++)\n\t\tans = min(ans, 1+solve2(l, i)+solve2(i+1, r));\n\n\treturn dp2[l][r] = ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\n\tmemset(dp1, -1, sizeof dp1);\n\tmemset(dp2, -1, sizeof dp2);\n\n\tfor (int l = 1; l <= n; l++)\n\t\tfor (int r = l; r <= n; r++)\n\t\t\tsolve1(l, r);\n\n\tprintf(\"%d\\n\", solve2(1, n)+1);\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    vector <int> v;\n    cin>>n;\n    for(int i = 1 ; i <= n ; i++)\n    {\n        int a;\n        cin>>a;\n        v.push_back(a);\n    }\n    if(n == 1)\n    {\n        cout<<v[0]<<endl;\n        return 0;\n    }   \n    int ans = v[0] ;\n    for(int i = 1 ; i  < int(v.size()) ; i++)\n        ans += (v[i] - 1) * (i + 1) + 1;\n    cout<<ans<<endl;\n    return 0;\n}",
        "fixed_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main()\n{\n    ll n;\n    vector <ll> v;\n    cin>>n;\n    for(ll i = 1 ; i <= n ; i++)\n    {\n        ll a;\n        cin>>a;\n        v.push_back(a);\n    }\n    if(n == 1)\n    {\n        cout<<v[0]<<endl;\n        return 0;\n    }   \n    ll ans = v[0] ;\n    for(ll i = 1 ; i  < ll(v.size()) ; i++)\n        ans += (v[i] - 1) * (i + 1) + 1;\n    cout<<ans<<endl;\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\n#define INF (1LL << 60)\n#define LL long long\n#define lson pos << 1\n#define rson pos << 1 | 1\n#define N 100005\n\nstruct Node\n{\n    int l, r, cnt;\n    int mid()\n    {\n        return (l + r) >> 1;\n    }\n};\nint n, m, np, val[N];\nLL sum[N], x[N];\nNode tree[N << 2];\nvoid build(int pos, int l, int r)\n{\n    tree[pos].l = l;\n    tree[pos].r = r;\n    tree[pos].cnt = 0;\n    if(l == r)  return ;\n    int mid = tree[pos].mid();\n    build(lson, l, mid);\n    build(rson, mid + 1, r);\n}\nvoid update(int pos, int idx, int cnt)\n{\n    if(tree[pos].l == tree[pos].r)\n    {\n        tree[pos].cnt += cnt;\n        return ;\n    }\n    int mid = tree[pos].mid();\n    if(idx <= mid)  update(lson, idx, cnt);\n    else            update(rson, idx, cnt);\n    tree[pos].cnt = tree[lson].cnt + tree[rson].cnt;\n}\nint query(int pos, int l, int r)\n{\n    if(l <= tree[pos].l && tree[pos].r <= r)\n        return tree[pos].cnt;\n    int ret = 0, mid = tree[pos].mid();\n    if(l <= mid)    ret += query(lson, l, r);\n    if(r > mid)     ret += query(rson, l, r);\n    return ret;\n}\nint lower(LL val) // <=\n{\n    int l = 1, r = np, mid;\n    if(x[r] <= val) return r;\n    if(x[l] > val)  return -1;\n    while(l + 1 < r)\n    {\n        mid = (l + r) >> 1;\n        if(x[mid] <= val)   l = mid;\n        else                r = mid;\n    }\n    return l;\n}\nint check(LL mid)\n{\n    int i, j;\n    LL ret = 0;\n    build(1, 1, np);\n    update(1, lower(sum[0]), 1);\n    for(i = 1; i <= n; i++)\n    {\n        j = lower(sum[i] - mid);\n        if(j != -1)\n            ret += query(1, 1, j);\n        update(1, lower(sum[i]), 1);\n    }\n    return ret >= m;\n}\nint main()\n{\n    int i, j, k;\n    while(scanf(\"%d%d\", &n, &m) != EOF)\n\t{\n\t    for(i = 1, sum[0] = 0; i <= n; i++)\n        {\n            scanf(\"%d\", &val[i]);\n            sum[i] = sum[i - 1] + val[i];\n            x[i] = sum[i];\n        }\n        x[n + 1] = 0;\n        sort(x + 1, x + n + 2);\n        for(i = 1, np = 1; i <= n + 1; i++)\n        {\n            if(x[i] != x[np])\n                x[++np] = x[i];\n        }\n        //cout << check(4) << endl;\n        LL l = -INF, r = INF, mid;\n        while(l + 1 < r)\n        {\n            mid = (l + r) >> 1;\n            if(check(mid))  l = mid;\n            else            r = mid;\n        }\n        printf(\"%I64d\\n\", l);\n\t}\n\treturn 0;\n}\n/*\n8 10\n1 -2 3 -4 5 -6 7 -8\n4 6\n2 -1 2 -1\n3 4\n1 4 2\n*/\n",
        "fixed_code": "#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\n#define INF (1LL << 60)\n#define LL long long\n#define lson pos << 1\n#define rson pos << 1 | 1\n#define N 100005\n\nstruct Node\n{\n    int l, r, cnt;\n    int mid()\n    {\n        return (l + r) >> 1;\n    }\n};\nint n, np, val[N];\nLL m, sum[N], x[N];\nNode tree[N << 2];\nvoid build(int pos, int l, int r)\n{\n    tree[pos].l = l;\n    tree[pos].r = r;\n    tree[pos].cnt = 0;\n    if(l == r)  return ;\n    int mid = tree[pos].mid();\n    build(lson, l, mid);\n    build(rson, mid + 1, r);\n}\nvoid update(int pos, int idx, int cnt)\n{\n    if(tree[pos].l == tree[pos].r)\n    {\n        tree[pos].cnt += cnt;\n        return ;\n    }\n    int mid = tree[pos].mid();\n    if(idx <= mid)  update(lson, idx, cnt);\n    else            update(rson, idx, cnt);\n    tree[pos].cnt = tree[lson].cnt + tree[rson].cnt;\n}\nint query(int pos, int l, int r)\n{\n    if(l <= tree[pos].l && tree[pos].r <= r)\n        return tree[pos].cnt;\n    int ret = 0, mid = tree[pos].mid();\n    if(l <= mid)    ret += query(lson, l, r);\n    if(r > mid)     ret += query(rson, l, r);\n    return ret;\n}\nint lower(LL val) // <=\n{\n    int l = 1, r = np, mid;\n    if(x[r] <= val) return r;\n    if(x[l] > val)  return -1;\n    while(l + 1 < r)\n    {\n        mid = (l + r) >> 1;\n        if(x[mid] <= val)   l = mid;\n        else                r = mid;\n    }\n    return l;\n}\nint check(LL mid)\n{\n    int i, j;\n    LL ret = 0;\n    build(1, 1, np);\n    update(1, lower(sum[0]), 1);\n    for(i = 1; i <= n; i++)\n    {\n        j = lower(sum[i] - mid);\n        if(j != -1)\n            ret += query(1, 1, j);\n        update(1, lower(sum[i]), 1);\n    }\n    return ret >= m;\n}\nint main()\n{\n    int i, j, k;\n    while(scanf(\"%d%I64d\", &n, &m) != EOF)\n\t{\n\t    for(i = 1, sum[0] = 0; i <= n; i++)\n        {\n            scanf(\"%d\", &val[i]);\n            sum[i] = sum[i - 1] + val[i];\n            x[i] = sum[i];\n        }\n        x[n + 1] = 0;\n        sort(x + 1, x + n + 2);\n        for(i = 1, np = 1; i <= n + 1; i++)\n        {\n            if(x[i] != x[np])\n                x[++np] = x[i];\n        }\n        LL l = -INF, r = INF, mid;\n        while(l + 1 < r)\n        {\n            mid = (l + r) >> 1;\n            if(check(mid))  l = mid;\n            else            r = mid;\n        }\n        printf(\"%I64d\\n\", l);\n\t}\n\treturn 0;\n}\n/*\n8 10\n1 -2 3 -4 5 -6 7 -8\n4 6\n2 -1 2 -1\n3 4\n1 4 2\n*/\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class C {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tstatic int[]t;\n\tstatic int n;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tn = nextInt();\n\t\tt = new int[n+1];\n\t\tint k = nextInt();\n\t\tlong ans = 1;\n\t\tint cur = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tinc(cur);\n\t\t\tint next = cur + k;\n\t\t\tif (next > n)\n\t\t\t\tnext -= n;\n\t\t\tif (next > cur)\n\t\t\t\tans += (sum(next-1)-sum(cur)) + 1;\n\t\t\telse\n\t\t\t\tans += (sum(n)-sum(cur)+sum(next-1)) + 1;\n\t\t\tinc(next);\n\t\t\tcur = next;\n\t\t\tpw.print(ans+\" \");\n\t\t}\n\t\tpw.close();\n\t}\n\tprivate static void inc(int ind) {\n\t\tfor (int i = ind; i <= n; i = (i | (i-1))+1) {\n\t\t\tt[i]++;\n\t\t}\n\t}\n\tprivate static int sum(int ind) {\n\t\tint res = 0;\n\t\tfor (int i = ind; i >= 1; i = (i & (i-1))) {\n\t\t\tres += t[i];\n\t\t}\n\t\treturn res;\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}",
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n\npublic class D {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tstatic ArrayList<Integer>[]L;\n\tstatic boolean[]used;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = nextInt();\n\t\tint[]p = new int[n+1];\n\t\tL = new ArrayList[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tL[i] = new ArrayList<Integer>();\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tp[i] = nextInt();\n\t\t\tL[i].add(p[i]);\n\t\t\tL[p[i]].add(i);\n\t\t}\n\t\tint ans = 0;\n\t\tused = new boolean[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!used[i]) {\n\t\t\t\tans++;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tpw.close();\n\t}\n\tprivate static void dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int to : L[v]) {\n\t\t\tif (!used[to])\n\t\t\t\tdfs(to);\n\t\t}\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <stdio.h>\n#include <queue>\n#include <set>\n#include <list>\n#include <cmath>\n#include <assert.h>\n#include <bitset>\n#include <cstring>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip> //cout << setprecision(node) << fixed << num\n#include <stack>\n#include <sstream>\n \n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n#define print(arr) for (auto it = arr.begin(); it != arr.end(); ++it) cout << *it << \" \"; cout << endl;\n#define debug(x) cout << x << endl;\n#define debug2(x,y) cout << x << \" \" << y << endl;\ntypedef long long int ll;\ntypedef long double ld;\ntypedef unsigned long long int ull;\ntypedef std::pair <int, int> ii;\ntypedef std::vector <int> vi;\ntypedef std::vector <ll> vll;\ntypedef std::vector <ld> vld;\n\nconst int INF = int(1e9);\nconst ll INF64 = ll(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\nusing namespace std;\n\nconst int maxn = 1e5+7;\n\nint dpDown[maxn], dpUp[maxn];\nvector <vi> tree(maxn), distances(maxn);\nvector <bool> affected(maxn, 0);\nvi closest(maxn, 0), farthest(maxn);\n\nint N, M, D, root = 0;\n\nvoid dfs(int node, int par) {\n\t//debug2(node, par);\n\tif (affected[node]) {\n\t\tdpDown[node] = 0;\n\t\tfarthest[node] = node;\n\t}\n\telse {\n\t\tdpDown[node] = -INF;\n\t\tfarthest[node] = 0;\n\t}\n\tfor (int adj : tree[node]) {\n\t\tif (adj != par) {\n\t\t\tdfs(adj, node);\n\t\t\tif (dpDown[adj] + 1 > dpDown[node] && farthest[adj]) {\n\t\t\t\tdpDown[node] = dpDown[adj] + 1;\n\t\t\t\tfarthest[node] = farthest[adj];\n\t\t\t}\n\t\t\tdistances[node].pb(dpDown[adj] + 1);\n\t\t}\n\t}\n\tsort(distances[node].rbegin(), distances[node].rend());\n}\n/*\nint dfs2(int node, int par, int d, int add) {\n\tint ret = 0;\n\tif (dpDown[node] <= D && d+add <= D) \n\t\tret = 1;\n\tfor (int adj : tree[node]) {\n\t\tif (adj != par) {\n\t\t\tret += dfs2(adj, node, d+1, add);\n\t\t}\n\t}\n\treturn ret;\n}\n*/\nvoid dfs2(int node, int par, int d, int add) {\n\tif (dpDown[node] + 1 == distances[par][0]) {\n\t\tif (dpDown[node] <= D && d+add <= D) {\n\t\t\tdpUp[node] = 1;\n\t\t}\n\t}\n\telse {\n\t\tif (1 + distances[par][0] <= D && d+add <= D)\n\t\t\tdpUp[node] = 1;\n\t}\n\tfor (int adj : tree[node]) {\n\t\tif (adj != par) {\n\t\t\tdfs2(adj, node, d+1, add);\n\t\t}\n\t}\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"inp.txt\", \"r\", stdin);\n\t#endif\n\tscanf(\"%d %d %d\", &N, &M, &D);\n\tint u, v;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d\", &u);\n\t\taffected[u] = 1;\n\t\tif (!root)\n\t\t\troot = u;\n\t}\n\tfor (int i = 0; i < N-1; i++) {\n\t\tscanf(\"%d %d\", &u, &v);\n\t\ttree[u].pb(v);\n\t\ttree[v].pb(u);\n\t}\n\n\tdfs(root, 0);\n\n\tint cnt = 0, ans = 0;\n\tfor (int child : tree[root]) {\n\t\tif (dpDown[child] + 1 > D) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (cnt > 1) {\n\t\tcout << 0 << endl;\n\t}\n\telse {\n\t\tif (dpDown[root] <= D)\n\t\t\tdpUp[root] = 1;\n\n\t\tfor (int child : tree[root]) {\n\t\t\tif (dpDown[child] + 1 == distances[root][0]) {\n\t\t\t\tif (distances[root].size() == 1)\n\t\t\t\t\tdfs2(child, root, 1, 0);\n\t\t\t\telse\n\t\t\t\t\tdfs2(child, root, 1, distances[root][1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdfs2(child, root, 1, distances[root][0]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (dpDown[i] <= D && dpUp[i] == 1) {\n\t\t\t\tans++;\n\t\t\t\t//cout << i << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <stdio.h>\n#include <queue>\n#include <set>\n#include <list>\n#include <cmath>\n#include <assert.h>\n#include <bitset>\n#include <cstring>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip> //cout << setprecision(node) << fixed << num\n#include <stack>\n#include <sstream>\n \n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n#define print(arr) for (auto it = arr.begin(); it != arr.end(); ++it) cout << *it << \" \"; cout << endl;\n#define debug(x) cout << x << endl;\n#define debug2(x,y) cout << x << \" \" << y << endl;\ntypedef long long int ll;\ntypedef long double ld;\ntypedef unsigned long long int ull;\ntypedef std::pair <int, int> ii;\ntypedef std::vector <int> vi;\ntypedef std::vector <ll> vll;\ntypedef std::vector <ld> vld;\n\nconst int INF = int(1e9);\nconst ll INF64 = ll(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\nusing namespace std;\n\nconst int maxn = 1e5+7;\n\nint dpDown[maxn], dpUp[maxn];\nvector <vi> tree(maxn), distances(maxn);\nvector <bool> affected(maxn, 0);\nvi closest(maxn, 0), farthest(maxn);\n\nint N, M, D, root = 0;\n\nvoid dfs(int node, int par) {\n\t//debug2(node, par);\n\tif (affected[node]) {\n\t\tdpDown[node] = 0;\n\t\tfarthest[node] = node;\n\t}\n\telse {\n\t\tdpDown[node] = -INF;\n\t\tfarthest[node] = 0;\n\t}\n\tfor (int adj : tree[node]) {\n\t\tif (adj != par) {\n\t\t\tdfs(adj, node);\n\t\t\tif (dpDown[adj] + 1 > dpDown[node] && farthest[adj]) {\n\t\t\t\tdpDown[node] = dpDown[adj] + 1;\n\t\t\t\tfarthest[node] = farthest[adj];\n\t\t\t}\n\t\t\tdistances[node].pb(dpDown[adj]);\n\t\t}\n\t}\n\tsort(distances[node].rbegin(), distances[node].rend());\n}\nvoid dfs2(int node, int par) {\n\n\tif (node == root) \n\t\tdpUp[node] = 0;\n\telse \n\t\tdpUp[node] = max(dpUp[node], dpUp[par] + 1);\n\n\tfor (int adj : tree[node]) {\n\t\tif (adj != par) {\n\t\t\tif (distances[node].size() > 1) {\n\t\t\t\tif (dpDown[adj] == distances[node][0]) {\n\t\t\t\t\tdpUp[adj] = max(dpUp[adj], distances[node][1] + 2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdpUp[adj] = max(dpUp[adj], distances[node][0] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs2(adj, node);\n\t\t}\n\t}\n\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"inp.txt\", \"r\", stdin);\n\t#endif\n\tscanf(\"%d %d %d\", &N, &M, &D);\n\tint u, v;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d\", &u);\n\t\taffected[u] = 1;\n\t\tif (!root)\n\t\t\troot = u;\n\t}\n\tfor (int i = 0; i < N-1; i++) {\n\t\tscanf(\"%d %d\", &u, &v);\n\t\ttree[u].pb(v);\n\t\ttree[v].pb(u);\n\t}\n\n\tdfs(root, 0);\n\tdfs2(root, 0);\n\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\t//cout << i << \": \"; debug2(dpDown[i], dpUp[i]);\n\t\tif (dpDown[i] <= D && dpUp[i] <= D) ans++;\n\t}\n\tcout << ans << endl;\n\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <fstream>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst long mod=1000000007;\n\nint main()\n{\n\tifstream cin(\"input.txt\");\n\tofstream out(\"output.txt\");\n\tlong k,n,h;\n\tcin>>n>>k>>h;\n\tvector < pair<pair<long,long>,long> > mass(n);\n\tfor(long i=0;i<n;i++)\n\t{\n\t\tcin>>mass[i].first.first;\n\t\tmass[i].first.second=i+1;\n\t}\n\tfor(long i=0;i<n;i++)\n\t\tcin>>mass[i].second;\n\n\tsort(mass.begin(),mass.end());\n\tlong l=0, r=n*h, m, kol;\n\twhile(l!=r)\n\t{\n\t\tm=(l+r)/2;\n\t\tkol=0;\t\n\t\tfor(long i=0;i<n;i++)\n\t\t\tif(((kol+1)*h+mass[i].second-1)/mass[i].second<=m)\n\t\t\t\tkol++;\n\t\tif(kol<k)\n\t\t\tl=m+1;\n\t\telse\n\t\t\tr=m;\n\t}\n\tkol=0;\n\tfor(long i=0;i<n && kol<k;i++)\n\t\tif(((kol+1)*h+mass[i].second-1)/mass[i].second<=l)\n\t\t{\n\t\t\tcout<<mass[i].first.second<<\" \";\n\t\t\tkol++;\n\t\t}\n}\n",
        "fixed_code": "#include <fstream>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst long mod=1000000007; \n\nstruct str\n{\n\tlong m;\n\tlong double v;\n\tlong num;\n};\n\nbool mf(str a, str b)\n{\n\treturn (a.m==b.m ? a.v<b.v : a.m<b.m);\n}\n\nint main()\n{\n\t//ifstream cin(\"input.txt\");\n\t//ofstream out(\"output.txt\");\n\tlong double k,n,h;\n\tcin>>n>>k>>h;\n\tvector < str > mass(n);\n\tfor(long i=0;i<n;i++)\n\t{\n\t\tcin>>mass[i].m;\n\t\tmass[i].num=i+1;\n\t}\n\tfor(long i=0;i<n;i++)\n\t\tcin>>mass[i].v;\n\n\tsort(mass.begin(),mass.end(),mf);\n\tlong double l=0, r=n*h, m, kol;\n\tlong koll=0;\n\twhile(koll<90)\n\t{\n\t\tm=(l+r)/2;\n\t\tkol=0;\t\n\t\tfor(long i=0;i<n;i++)\n\t\t\tif((kol+1)*h/mass[i].v<=m)\n\t\t\t\tkol++;\n\t\tif(kol<k)\n\t\t\tl=m;\n\t\telse\n\t\t\tr=m;\n\t\tkoll++;\n\t}\n\tkol=0;\n\tfor(long i=0;i<n && kol<k;i++)\n\t\tif((kol+1)*h/mass[i].v<=r)\n\t\t{\n\t\t\tcout<<mass[i].num<<\" \";//<<((kol+1)*h+mass[i].v-1)/mass[i].v<<\"\\n\";\n\t\t\tkol++;\n\t\t}\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\n int main()\n{\n    string s;\n    cin>>s;\n\n    ll n=s.length();\n\n    ll a,b;\n    cin>>a>>b;\n\n    ll x=0,y=0;\n\n    ll l=-1, m=-1;\n    for(ll i=0;i<n;i++)\n    {\n          x+=(int(s[i]))-48;\n\n        y=0;\n         for(ll j=i+1;j<n;j++)\n         {\n            y+=int(s[j])-48;\n\n            if(j!=n-1)\n            y*=10;\n         }\n            cout<<x<<\" \"<<y<<endl;\n         if(( x%a==0 && y%b==0 ) || ( y%a ==0 && x%b==0 ) && y!=0)\n         {\n             l=x;\n             m=y;\n         }\n\n         x*=10;\n    }\n\n    if(l==-1 || l==0 || m==0)\n    cout<<\"NO\"<<endl;\n\n    else\n    {\n        cout<<\"YES\"<<endl;\n        cout<<l<<endl;\n        cout<<m<<endl;\n    }\n\n    return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\n int main()\n{\n    string s;\n    cin>>s;\n\n    ll n=s.length();\n\n    ll a,b;\n    cin>>a>>b;\n\n    ll r[n];\n\n    r[0]=(s[0]-'0')%a;\n\n    for(ll i=1;i<n;i++)\n    r[i]=(r[i-1]*10 + s[i]-'0')%a;\n\n    ll sum=0;\n    ll p=1;\n    for(ll i=n-1;i>0;i--)\n    {\n        sum+= p*(s[i]-'0')%b ;\n\n        if(sum%b==0 && !r[i-1] && s[i]!='0')\n        {\n            cout<<\"YES\"<<endl;\n            cout<<s.substr(0,i)<<endl;\n            cout<<s.substr(i,n)<<endl;\n            return 0;\n        }\n\n        p=(p*10)%b;\n    }\n\n    cout<<\"NO\"<<endl;\n\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\n\ntypedef long long INT;\ntypedef pair<int, int> pii;\n\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\", \"r\", stdin);\n\tfreopen(\"out.out\", \"w\", stdout);\n#endif\n\tint test;\n\tscanf(\"%d\", &test);\n\twhile(test--){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n < 4) {puts(\"-1\"); continue;}\n\t\tif(n == 4) {puts(\"3 1 4 2\"); continue;}\n\t\tif(n == 5) {puts(\"1 3 5 2 4\"); continue;}\n\t\tfor(int i = 1; i <= n; i += 2) printf(\"%d \", i);\n\t\tif(n & 1) {\n\t\t\tprintf(\"%d %d \", n - 3, n - 1);\n\t\t\tfor(int i = n - 5; i >= 2; i -= 2) {\t\n\t\t\t\tif(i == 2) printf(\"%d\\n\", i);\n\t\t\t\telse printf(\"%d \", i);\n\t\t\t}\n\t\t}\n\t\telse  {\n\t\t\tprintf(\"%d %d \", n - 2, n);\n\t\t\tfor(int i = n - 4; i >= 2; i -= 2) {\t\n\t\t\t\tif(i == 2) printf(\"%d\\n\", i);\n\t\t\t\telse printf(\"%d \", i);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\n                      ",
        "fixed_code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\n\ntypedef long long INT;\ntypedef pair<int, int> pii;\n\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\", \"r\", stdin);\n\tfreopen(\"out.out\", \"w\", stdout);\n#endif\n\tint test;\n\tscanf(\"%d\", &test);\n\twhile(test--){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n < 4) {puts(\"-1\"); continue;}\n\t\tif(n == 4) {puts(\"3 1 4 2\"); continue;}\n\t\tif(n == 5) {puts(\"1 3 5 2 4\"); continue;}\n\t\tfor(int i = 1; i <= n; i += 2) printf(\"%d \", i);\n\t\tif(n & 1) {\n\t\t\tprintf(\"%d %d \", n - 3, n - 1);\n\t\t\tfor(int i = n - 5; i >= 2; i -= 2) {\t\n\t\t\t\tif(i == 2) printf(\"%d\\n\", i);\n\t\t\t\telse printf(\"%d \", i);\n\t\t\t}\n\t\t}\n\t\telse  {\n\t\t\tprintf(\"%d %d %d\", n - 4, n, n - 2);\n\t\t\tfor(int i = n - 6; i >= 2; i -= 2) {\t\n\t\t\t\tprintf(\"% d\", i);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\n                     ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void windowClosing(java.awt.event.WindowEvent e) {\n    if (exit())\n        java.lang.System.exit(0);\n    \n}",
        "fixed_code": "@java.lang.Override\npublic void windowClosing(java.awt.event.WindowEvent e) {\n    exit(( ev) -> java.lang.System.exit(0));\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n int n;\n cin>>n;\n while(n){\n  int flag=0;\n  int P;\n  cin>>P;\n  for(int i=2;i<=P;i++){\n    if(flag==0){\n      for(int j=i+1;j<=P;j++){\n        if(P%i==P%j and flag==0){\n          cout<< i<<\" \"<< j<<endl;\n          flag=1;\n        }\n        if(flag==1){\n          break;\n        }\n      }\n    }\n    if(flag==1){\n      break;\n    }\n  }\n  n--;\n  }\n }\n\t\t   \t\t\t\t  \t      \t\t\t  \t \t\t\t  \t",
        "fixed_code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\nvoid basesprimo (int numero) {\n    int base = (numero-1)/2;\n    if (numero==5) {\n        cout << 2 << \" \" << 4 << endl;\n    }\n    else {\n        cout << 2 << \" \" << base << endl;\n    }\n}\nint main() {\n    int t;\n    cin >> t;\n    int P[t];\n    for (int i = 0; i < t; i++) {\n\t\tint primo;\n        cin >> primo;\n        P[i] = primo;\n\t}\n    for (int i = 0; i < t; i++) {\n        basesprimo(P[i]);\n    }\n    return 0;\n}\n    \t \t   \t\t\t\t  \t\t    \t \t \t\t \t\t",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public static java.util.List<Specialty> all() {\n    java.lang.String sql = \"SELECT type FROM specialties\";\n    try (Connection con = DB.sql2o.open()) {\n        return con.createQuery(sql).executeAndFetch(Specialty.class);\n    }\n}",
        "fixed_code": "public static java.util.List<Specialty> all() {\n    java.lang.String sql = \"SELECT type, id FROM specialties\";\n    try (Connection con = DB.sql2o.open()) {\n        return con.createQuery(sql).executeAndFetch(Specialty.class);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <stdio.h>\n#include <tchar.h>\n\nint TakeNumber(FILE* f)\n{\n    char ch=fgetc(f);\n    int chislo=0; \n    while((int(ch)>47)&&(int(ch)<58))\n    {\n        chislo*=10;\n        chislo+=int(ch)-48;\n        ch=fgetc(f);\n    }\n    return chislo;\n}\n\nint ToChar(int i,char* buff)\n{\n    int n=0;\n    int j=i;\n    while(int(j/=10)) n++;\n    for(int k=n;k>=0;k--)\n    {\n        buff[k]=(i%10)+48;\n        i/=10;\n    }\n    return n+1;\n}\n\nstruct Object\n{\n    int N;\n    int* chook;\n    int a;\n    int b;\n    int TotalTime;\n    Object();\n    void FindSolution();\n    void OutPut();\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    Object obj;\n    obj.FindSolution();\n    obj.OutPut();\n    return 0;\n}\n\nObject::Object()\n{\n    FILE* file=::fopen(\"stdin.txt\",\"r\");\n    N=::TakeNumber(file);\n    chook=new int[N];\n    TotalTime=0;\n    a=b=0;\n    int agent;\n    for(int i=0;i<N;i++)\n    {\n        agent=::TakeNumber(file);\n        chook[i]=agent;\n        TotalTime+=chook[i];\n    }\n    ::fclose(file);\n}\n\nvoid Object::FindSolution()\n{\n    int HalfTime=int(TotalTime/2);\n    if(TotalTime%2) HalfTime++;\n    int i=0;\n    while(HalfTime>0)\n    {\n        i++;\n        HalfTime-=chook[i];\n    }\n    a=i;\n    b=N-a;\n}\n\nvoid Object::OutPut()\n{\n    FILE* file=::fopen(\"stdout.txt\",\"w+\");\n    char* buff=new char[6];\n    int n=::ToChar(a,buff);\n    buff[n]=' ';\n    ::fwrite(buff,1,n+1,file);\n    n=::ToChar(b,buff);\n    buff[n]=0x0a;\n    ::fwrite(buff,1,n+1,file);\n    ::fclose(file);\n}\n",
        "fixed_code": "#include<iostream>\nusing namespace std;\n\nstruct Object\n{\n    int N;\n    int* chook;\n    int a;\n    int b;\n    int TotalTime;\n    Object();\n    void FindSolution();\n};\n\nint main()\n{\n    Object obj;\n    obj.FindSolution();\n    cout<<obj.a<<' '<<obj.b;\n    return 0;\n}\n\nObject::Object()\n{\n    cin>>N;\n    chook=new int[N];\n    TotalTime=0;\n    a=b=0;\n    int agent;\n    for(int i=0;i<N;i++)\n    {\n        cin>>agent;\n        chook[i]=agent;\n        TotalTime+=chook[i];\n    }\n}\n\nvoid Object::FindSolution()\n{\n    int HalfTime=int(TotalTime/2);\n    int i=0;\n    int agent=chook[0];\n    while((HalfTime-agent)>=0)\n    {\n        i++;\n        agent+=chook[i];\n    }\n    a=i;\n    agent-=chook[i];\n    int t=TotalTime-chook[i]-agent;\n    if(agent<=t) a++;\n    b=N-a;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h> \nusing namespace std;  \nint main(){\n\tint t;\n\tcin>>t;\n\tchar c[t];\n\tchar a[t];\n\tint j=0;\n\tint c1=0,d1=0;\n\tint f=0;\n\tif(t%2==1){\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin>>c[i];\n\t\t}\n\t\tcout<<-1<<endl;\n\t}\n\telse{\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin>>c[i];\n\t\t\tif(c[i]==')'){\n\t\t\t\tc1++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\td1++;\n\t\t\t}\n\t\t\tif(j==0){\n\t\t\t\ta[j++]=c[i];\n\t\t\t}\n\t\t\telse if(a[j-1]=='('&&c[i]==')'){\n\t\t\t\tj--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[j++]=c[i];\n\t\t\t}\n\t\t}\n\t\tif(c1!=d1){\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<j<<endl;\n\t\t}\n\t}\n}",
        "fixed_code": "#include <bits/stdc++.h> \nusing namespace std;  \nint main(){\n\tint t;\n\tcin>>t;\n\tchar c[t];\n\tchar a[t];\n\tint j=0;\n\tint c1=0,d1=0;\n\tint f=0;\n\tif(t%2==1){\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin>>c[i];\n\t\t}\n\t\tcout<<-1<<endl;\n\t}\n\telse{\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin>>c[i];\n\t\t\tif(c[i]==')'){\n\t\t\t\tc1++;\n\t\t\t\tif(c1>d1){\n\t\t\t\t\tf++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\td1++;\n\t\t\t}\n\t\t}\n\t\tif(c1!=d1){\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<f*2<<endl;\n\t\t}\n\t}\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define dec(i, l, r) for (int i = l; i>=r;i--)\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define pb(c) push_back(c)\n#define vii vector<pair<int,int>>\n#define ii pair<int,int>\n#define mp(i, j) make_pair(i,j)\n#define ull unsigned long long int\n#define ll  long long int\n#define pie 3.141592653589793238\n#define inf ((ll)1e18)\n#define eps 1e-14\n#define mod ((int)1e9+7)\n#define maxlg 18\n#define maxn 1000002\n#define left(i) ((i)<<1)\n#define right(i) (((i)<<1)+1)\nbool primes[1000001];\nbool in[1000001];\nvoid sieve(int limit){\n\n    memset(in,true,sizeof(in));\n    for (int i=2;i<=limit;i++) {\n        if(in[i]) {\n            primes[i] = true;\n            for (int j=i;j<=limit;j+=i)\n                in[j]=false;\n        }\n    }\n}\nvi even,odd;\n typedef long long LL;\n\nstruct Edge {\n    int from, to, cap, flow, index;\n    Edge(int from, int to, int cap, int flow, int index) :\n            from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n    int N;\n    vector<vector<Edge> > G;\n    vector<LL> excess;\n    vector<int> dist, active, count;\n    queue<int> Q;\n\n    PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n    void AddEdge(int from, int to, int cap) {\n        G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n        if (from == to) G[from].back().index++;\n        G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n    }\n\n    void Enqueue(int v) {\n        if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); }\n    }\n\n    void Push(Edge &e) {\n        int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n        if (dist[e.from] <= dist[e.to] || amt == 0) return;\n        e.flow += amt;\n        G[e.to][e.index].flow -= amt;\n        excess[e.to] += amt;\n        excess[e.from] -= amt;\n        Enqueue(e.to);\n    }\n\n    void Gap(int k) {\n        for (int v = 0; v < N; v++) {\n            if (dist[v] < k) continue;\n            count[dist[v]]--;\n            dist[v] = max(dist[v], N+1);\n            count[dist[v]]++;\n            Enqueue(v);\n        }\n    }\n\n    void Relabel(int v) {\n        count[dist[v]]--;\n        dist[v] = 2*N;\n        for (int i = 0; i < G[v].size(); i++)\n            if (G[v][i].cap - G[v][i].flow > 0)\n                dist[v] = min(dist[v], dist[G[v][i].to] + 1);\n        count[dist[v]]++;\n        Enqueue(v);\n    }\n\n    void Discharge(int v) {\n        for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n        if (excess[v] > 0) {\n            if (count[dist[v]] == 1)\n                Gap(dist[v]);\n            else\n                Relabel(v);\n        }\n    }\n\n    LL GetMaxFlow(int s, int t) {\n        count[0] = N-1;\n        count[N] = 1;\n        dist[s] = N;\n        active[s] = active[t] = true;\n        for (int i = 0; i < G[s].size(); i++) {\n            excess[s] += G[s][i].cap;\n            Push(G[s][i]);\n        }\n\n        while (!Q.empty()) {\n            int v = Q.front();\n            Q.pop();\n            active[v] = false;\n            Discharge(v);\n        }\n\n        LL totflow = 0;\n        for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n        return totflow;\n    }\n};\nvi edge[maxn];\nvi pe,po;\nbool added[2001];\ndeque<int> table[maxn];\nint cyc = 0;\n\nvoid dfs(int curr,vi graph[202],int par=-1,int front = 1) {\n    if (front==1)\n        table[cyc].push_front(curr);\n    else\n        table[cyc].push_back(curr);\n    int done = 0;\n    for (int nxt : graph[curr]) {\n        if (nxt!=par) {\n             dfs(nxt,graph,curr,(front+done)%2);\n            done++;\n        }\n    }\n}\nvi ans;\nint arr[maxn];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifndef ONLINE_JUDGE\n    freopen(\"input\", \"r\", stdin);\n#endif\n    int n;\n    cin>>n;\n    rep (i,0,n) {\n\n        int g;\n        cin>>g;\n        arr[i+1]=g;\n        if (g&1)\n            odd.push_back(g),po.push_back(i);\n        else\n            even.push_back(g),pe.push_back(i);\n    }\n    PushRelabel pr(n+2);\n    sieve((int)1e8);\n    rep (i,0,odd.size()) {\n        rep (j,0,even.size()) {\n            if (primes[odd[i]+even[j]]) {\n                pr.AddEdge(1+i,n/2 + 1 +j,1);\n                edge[1+i].push_back(odd.size() + 1 +j);\n                edge[odd.size() + 1 +j].push_back(1+i);\n            }\n        }\n    }\n\n    rep (i,0,odd.size()) {\n        pr.AddEdge(0,i+1,2);\n    }\n    rep (i,0,even.size()) {\n        pr.AddEdge(odd.size() + 1 +i,n+1,2);\n    }\n    ll f = pr.GetMaxFlow(0,n+1);\n    if (f==n) {\n        rep (i,0,odd.size()) {\n            queue<int> q;\n            if (!added[i]) {\n                vi graph[202];\n                q.push(1+i);\n                added[1+i]=true;\n                deque<int> d;\n                d.push_back(i+1);\n                while (!q.empty()) {\n                    int curr = q.front();\n                    q.pop();\n                    if (curr<odd.size()+1) {\n                    for (Edge e : pr.G[curr]) {\n                        if (e.flow==1 && !added[e.to]) {\n                            q.push(e.to);\n                            added[e.to]=true;\n                            graph[curr].push_back(e.to);\n                            graph[e.to].push_back(curr);\n                        }\n                    }\n                    } else {\n                        for (int check : edge[curr]) {\n                            if (!added[check])\n                            for (Edge e : pr.G[check]) {\n                                if (e.flow==1 && e.to==curr) {\n                                    q.push(check);\n                                    added[check]=true;\n                                    graph[curr].push_back(check);\n                                    graph[check].push_back(curr);\n\n                                }\n                            }\n                        }\n                    }\n                }\n                dfs(i+1,graph);\n                cyc++;\n\n            }\n        }\n        cout<<cyc<<endl;\n        rep (i,0,cyc) {\n            cout<<table[i].size()<< \" \";\n            while (!table[i].empty()) {\n                int c = table[i].front();\n                table[i].pop_front();\n                if (c<=odd.size()) {\n                    ans.push_back(po[c-1]);\n                    cout<<po[c-1]+1<<\" \";\n                } else {\n                    ans.push_back(pe[c-1-n/2]);\n                    cout<<pe[c-1-n/2]+1<<\" \";\n                }\n            }\n\n            cout<<endl;\n        }\n    } else {\n        cout<<\"Impossible\";\n    }\n    return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define dec(i, l, r) for (int i = l; i>=r;i--)\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define pb(c) push_back(c)\n#define vii vector<pair<int,int>>\n#define ii pair<int,int>\n#define mp(i, j) make_pair(i,j)\n#define ull unsigned long long int\n#define ll  long long int\n#define pie 3.141592653589793238\n#define inf ((ll)1e18)\n#define eps 1e-14\n#define mod ((int)1e9+7)\n#define maxlg 18\n#define maxn 100002\n#define left(i) ((i)<<1)\n#define right(i) (((i)<<1)+1)\nbool primes[100001];\nbool in[100001];\nvoid sieve(int limit){\n\n    memset(in,true,sizeof(in));\n    for (int i=2;i<=limit;i++) {\n        if(in[i]) {\n            primes[i] = true;\n            for (int j=i;j<=limit;j+=i)\n                in[j]=false;\n        }\n    }\n}\nvi even,odd;\n typedef long long LL;\n\nstruct Edge {\n    int from, to, cap, flow, index;\n    Edge(int from, int to, int cap, int flow, int index) :\n            from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n    int N;\n    vector<vector<Edge> > G;\n    vector<LL> excess;\n    vector<int> dist, active, count;\n    queue<int> Q;\n\n    PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n    void AddEdge(int from, int to, int cap) {\n        G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n        if (from == to) G[from].back().index++;\n        G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n    }\n\n    void Enqueue(int v) {\n        if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); }\n    }\n\n    void Push(Edge &e) {\n        int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n        if (dist[e.from] <= dist[e.to] || amt == 0) return;\n        e.flow += amt;\n        G[e.to][e.index].flow -= amt;\n        excess[e.to] += amt;\n        excess[e.from] -= amt;\n        Enqueue(e.to);\n    }\n\n    void Gap(int k) {\n        for (int v = 0; v < N; v++) {\n            if (dist[v] < k) continue;\n            count[dist[v]]--;\n            dist[v] = max(dist[v], N+1);\n            count[dist[v]]++;\n            Enqueue(v);\n        }\n    }\n\n    void Relabel(int v) {\n        count[dist[v]]--;\n        dist[v] = 2*N;\n        for (int i = 0; i < G[v].size(); i++)\n            if (G[v][i].cap - G[v][i].flow > 0)\n                dist[v] = min(dist[v], dist[G[v][i].to] + 1);\n        count[dist[v]]++;\n        Enqueue(v);\n    }\n\n    void Discharge(int v) {\n        for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n        if (excess[v] > 0) {\n            if (count[dist[v]] == 1)\n                Gap(dist[v]);\n            else\n                Relabel(v);\n        }\n    }\n\n    LL GetMaxFlow(int s, int t) {\n        count[0] = N-1;\n        count[N] = 1;\n        dist[s] = N;\n        active[s] = active[t] = true;\n        for (int i = 0; i < G[s].size(); i++) {\n            excess[s] += G[s][i].cap;\n            Push(G[s][i]);\n        }\n\n        while (!Q.empty()) {\n            int v = Q.front();\n            Q.pop();\n            active[v] = false;\n            Discharge(v);\n        }\n\n        LL totflow = 0;\n        for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n        return totflow;\n    }\n};\nvi edge[230];\nvi pe,po;\nbool added[2001];\ndeque<int> table[230];\nint cyc = 0;\n\nvoid dfs(int curr,vi graph[202],int par=-1,int front = 1) {\n    if (front==1)\n        table[cyc].push_front(curr);\n    else\n        table[cyc].push_back(curr);\n    int done = 0;\n    for (int nxt : graph[curr]) {\n        if (nxt!=par) {\n             dfs(nxt,graph,curr,(front+done)%2);\n            done++;\n        }\n    }\n}\nvi ans;\nint arr[maxn];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifndef ONLINE_JUDGE\n    freopen(\"input\", \"r\", stdin);\n#endif\n    int n;\n    cin>>n;\n    rep (i,0,n) {\n\n        int g;\n        cin>>g;\n        arr[i+1]=g;\n        if (g&1)\n            odd.push_back(g),po.push_back(i);\n        else\n            even.push_back(g),pe.push_back(i);\n    }\n    PushRelabel pr(n+2);\n    sieve((int)20003);\n    rep (i,0,odd.size()) {\n        rep (j,0,even.size()) {\n            if (primes[odd[i]+even[j]]) {\n                pr.AddEdge(1+i,odd.size() + 1 +j,1);\n                edge[1+i].push_back(odd.size() + 1 +j);\n                edge[odd.size() + 1 +j].push_back(1+i);\n            }\n        }\n    }\n\n    rep (i,0,odd.size()) {\n        pr.AddEdge(0,i+1,2);\n    }\n    rep (i,0,even.size()) {\n        pr.AddEdge(odd.size() + 1 +i,n+1,2);\n    }\n    ll f = pr.GetMaxFlow(0,n+1);\n    if (f==n) {\n        rep (i,0,odd.size()) {\n            queue<int> q;\n            if (!added[i+1]) {\n                vi graph[202];\n                q.push(1+i);\n                added[1+i]=true;\n                deque<int> d;\n                d.push_back(i+1);\n                while (!q.empty()) {\n                    int curr = q.front();\n                    q.pop();\n                    if (curr<odd.size()+1) {\n                    for (Edge e : pr.G[curr]) {\n                        if (e.flow==1 && !added[e.to]) {\n                            q.push(e.to);\n                            added[e.to]=true;\n                            graph[curr].push_back(e.to);\n                            graph[e.to].push_back(curr);\n                        }\n                    }\n                    } else {\n                        for (int check : edge[curr]) {\n                            if (!added[check])\n                            for (Edge e : pr.G[check]) {\n                                if (e.flow==1 && e.to==curr) {\n                                    q.push(check);\n                                    added[check]=true;\n                                    graph[curr].push_back(check);\n                                    graph[check].push_back(curr);\n\n                                }\n                            }\n                        }\n                    }\n                }\n                dfs(i+1,graph);\n                cyc++;\n            }\n        }\n        cout<<cyc<<endl;\n        rep (i,0,cyc) {\n            cout<<table[i].size()<< \" \";\n            while (!table[i].empty()) {\n                int c = table[i].front();\n                table[i].pop_front();\n                if (c<=odd.size()) {\n                    ans.push_back(po[c-1]);\n                    cout<<po[c-1]+1<<\" \";\n                } else {\n                    ans.push_back(pe[c-1-n/2]);\n                    cout<<pe[c-1-n/2]+1<<\" \";\n                }\n            }\n\n            cout<<endl;\n        }\n    } else {\n        cout<<\"Impossible\";\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nvoid INOUT() {\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"A_input.txt\", \"r\", stdin);\r\n    freopen(\"A_output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nvoid subseq(string s1, string s2, int com) {\r\n    string ans = \"\";\r\n    char c;\r\n    if (com == 0) {\r\n        c = '0';\r\n    } else {\r\n        c = '1';\r\n    }\r\n    int l = 0, r = 0;\r\n    while (l < s1.length() && r < s2.length()) {\r\n        while (l < s1.length()) {\r\n            if (s1[l] == c) {\r\n                break;\r\n            } else {\r\n                ans = ans + s1[l];\r\n                l++;\r\n            }\r\n        }\r\n        if(s1.length() <= l){\r\n            break;\r\n        }\r\n        while (r < s2.length()) {\r\n            if (s2[r] == c) {\r\n                break;\r\n            } else {\r\n                ans = ans + s2[r];\r\n                r++;\r\n            }\r\n        }\r\n        if(s2.length() <= r){\r\n            break;\r\n        }\r\n        if (s1[l] == s2[r]) {\r\n            ans = ans + s1[l];\r\n            l++;\r\n            r++;\r\n        }\r\n    }\r\n    while (l < s1.length()) {\r\n        ans = ans + s1[l];\r\n        l++;\r\n    }\r\n    while (r < s2.length()) {\r\n        ans = ans + s2[r];\r\n        r++;\r\n    }\r\n    cout<<ans<<endl;\r\n}\r\n\r\nvoid ICanDoit() {\r\n    int n;\r\n    cin >> n;\r\n    // cout << n << endl;\r\n    int n1 = 2 * n;\r\n    int n2 = 3 * n;\r\n\r\n    string s1, s2, s3;\r\n\r\n    cin >> s1 >> s2 >> s3;\r\n\r\n    // cout << s1 << \" \" << s2 << \" \" << s3 << endl;\r\n\r\n    vector<int> v(3);\r\n    int zero1 = 0;\r\n    int zero2 = 0;\r\n    int zero3 = 0;\r\n    \r\n    for (int i = 0; i < n1; i++) {\r\n        if (s1[i] == '0') {\r\n            zero1++;\r\n        }\r\n        if (s2[i] == '0') {\r\n            zero2++;\r\n        }\r\n        if (s3[i] == '0') {\r\n            zero3++;\r\n        }\r\n\r\n    }\r\n    \r\n    if(n1-zero1 > zero1){\r\n        v[0] = 1;\r\n    }else{\r\n        v[0] = 0;\r\n    }\r\n\r\n    if(n1-zero2 > zero2){\r\n        v[1] = 1;\r\n    }else{\r\n        v[1] = 0;\r\n    }\r\n\r\n    if(n1-zero3 > zero3){\r\n        v[2] = 1;\r\n    }else{\r\n        v[2] = 0;\r\n    }\r\n\r\n    if (v[0] == v[1]) {\r\n        subseq(s1, s2, v[0]);\r\n    } else if (v[0] == v[2]) {\r\n        subseq(s1, s3, v[0]);\r\n    } else {\r\n        subseq(s2, s3, v[2]);\r\n    }\r\n}\r\n\r\nint main() {\r\n    // INOUT();\r\n\r\n    int test;\r\n\r\n    // test = 1;\r\n    cin >> test;\r\n\r\n    while (test--) {\r\n        ICanDoit();\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
        "fixed_code": "#include<bits/stdc++.h>\r\n#define REP(i,n) for (int i = 1; i <= n; i++)\r\n#define mod 1000000007\r\n#define pb push_back\r\n#define ff first\r\n#define ss second\r\n#define ii pair<int,int>\r\n#define vi vector<int>\r\n#define vii vector<ii>\r\n#define lli long long int\r\n#define INF 1000000000\r\n#define endl '\\n'\r\nconst double PI = 3.141592653589793238460;\r\ntypedef std::complex<double> Complex;\r\ntypedef std::valarray<Complex> CArray;\r\nusing namespace std;\r\n \r\nchar getFC(string st)\r\n{\r\n\tint ar[] = {0 , 0};\r\n \r\n\tfor(char ch : st)\r\n\tar[ch - '0']++;\r\n \r\n\tif(ar[0] > ar[1]) return '0';\r\n\telse\t\t\t  return '1';\r\n}\r\n \r\nint main()\r\n{\r\n\tint t , n;\r\n\tstring a , b , c;\r\n \r\n\tcin>>t;\r\n\twhile(t--)\r\n\t{\r\n\t\tcin>>n;\r\n\t\tcin>>a>>b>>c;\r\n \r\n\t\tstring x , y;\r\n\t\tchar code;\r\n \r\n\t\tif(getFC(a) == getFC(b))\r\n\t\tx = a , y = b , code = getFC(a);\r\n\t\telse\r\n\t\tif(getFC(a) == getFC(c))\r\n\t\tx = a , y = c , code = getFC(a);\r\n\t\telse\r\n\t\tx = b , y = c , code = getFC(b);\r\n \r\n\t\tint l = 0 , r = 0;\r\n \r\n\t\twhile(l < x.size() && r < y.size())\r\n\t\t{\r\n\t\t\twhile(l < x.size() && x[l] != code) cout<<x[l++];\r\n\t\t\tif(l == x.size()) break;\r\n \r\n\t\t\twhile(r < y.size() && y[r] != code) cout<<y[r++];\r\n\t\t\tif(r == y.size()) break;\r\n \r\n\t\t\tif(x[l] == y[r]) cout<<x[l] , l++,r++;\r\n\t\t\telse\t\t\t cout<<x[l] , l++;\r\n\t\t}\r\n \r\n\t\twhile(l < x.size())\r\n\t\tcout<<x[l++];\r\n \r\n\t\twhile(r < y.size())\r\n\t\tcout<<y[r++];\r\n \r\n\t\tcout<<endl;\r\n\t}\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#include<vector>\n#define pb push_back\nusing namespace std;\ntemplate <class T>\ninline void scan(T &ret) {\n    char c; ret=0;\n    while((c=getchar())<'0'||c>'9');\n    while(c>='0'&&c<='9') ret=ret*10+(c-'0'),c=getchar();\n}\n\nint n,m;\nconst int maxn=500000+10;\ntypedef vector<int> vi;\ntypedef set<int>si;\nsi mp[maxn];\nvi ans[maxn];\nset<int>::iterator it,it2;\nint f[maxn];\nint find(int x)\n{\n    if(f[x]==x)return f[x];\n    return f[x]=find(f[x]);\n}\nint cnt;\nvoid dfs(int u)\n{\n    ans[cnt].pb(u);\n    f[u]=u+1;\n    it=mp[u].begin();\n    for(int i=find(1);i<=n;i=find(i+1))\n    {\n//        it=mp[u].find(i);\n        it=lower_bound(it,mp[u].end(),i);\n        if(it!=mp[u].end())continue;\n            dfs(i);\n    }\n}\nint main()\n{\n//    ios::sync_with_stdio(false);\n\n//    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    scan(n);scan(m);\n    {\n        for(int i=0;i<=n+1;i++)\n            f[i]=i;\n        for(int i=0;i<m;i++)\n        {\n            int u,v;\n            //cin>>u>>v;\n//            scanf(\"%d%d\",&u,&v);\n            scan(u);scan(v);\n            mp[u].insert(v);\n            mp[v].insert(u);\n        }\n        cnt=0;\n        for(int i=1;i<=n;i++)\n        {\n            if(f[i]==i)\n            {\n                dfs(i);\n                cnt++;\n            }\n        }\n//        cout<<cnt<<endl;\n        printf(\"%d\\n\",cnt);\n        for(int i=0;i<cnt;i++)\n        {\n            int sz=ans[i].size();\n\n            printf(\"%d\",sz);\n            for(int j=0;j<sz;j++)\n            {\n                printf(\" %d\",ans[i][j]);\n                //cout<<\" \"<<ans[i][j];\n            }\n            printf(\"\\n\");\n//            cout<<endl;\n        }\n    }\n}\n",
        "fixed_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define pb push_back\nusing namespace std;\nconst int MAXN=500000+10;\nvector<int > mp[MAXN],ans[MAXN];\nint n,m,cnt=0,f[MAXN];\nint find(int x)\n{\n    return f[x]!=x?f[x]=find(f[x]):f[x];\n}\nvoid dfs(int x)\n{\n    ans[cnt].pb(x);\n    f[x]=x+1;\n    for(int j=0,i=find(1); i<=n; i=find(i+1))\n    {\n        for(; j<mp[x].size() && mp[x][j]<i; j++);\n//        j=lower_bound(mp[x].begin(),mp[x].end(),i)-mp[x].begin();\n        if(j==mp[x].size()||mp[x][j]>i)\n            dfs(i);\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(int i=0; i<=n+1; i++)\n    {\n//        mp[i].clear();\n//        ans[i].clear();\n        f[i]=i;\n    }\n    for(int i=0; i<m; i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        mp[x].pb(y);\n        mp[y].pb(x);\n    }\n    for(int i=1; i<=n; i++)\n        sort(mp[i].begin(),mp[i].end());\n    for(int i=1; i<=n; i++)\n        if(f[i]==i)\n        {\n            dfs(i);\n            cnt++;\n        }\n    cout<<cnt<<endl;\n    for(int i=0; i<cnt; i++)\n    {\n        cout<<ans[i].size();\n        for(int j=0; j<ans[i].size(); j++)\n            cout<<\" \"<<ans[i][j];\n        cout<<endl;\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#define int long long\nusing namespace std;\nconst int N=200005;\nint tot,n;\nint root[N<<2],ls[N<<2],rs[N<<2],sum[N<<2],ans[N<<2];\nvector<int>va[N];\nint val[N];\nvoid up(int k)\n{\n\tif(sum[ls[k]]>sum[rs[k]])\n\t{\n\t\tsum[k]=sum[ls[k]];\n\t\tans[k]=ans[ls[k]];\n\t}\n\tif(sum[rs[k]]>sum[ls[k]])\n\t{\n\t\tsum[k]=sum[rs[k]];\n\t\tans[k]=ans[rs[k]];\n\t}\n\tif(sum[ls[k]]==sum[rs[k]])\n\t{\n\t\tsum[k]=sum[ls[k]];\n\t\tans[k]=ans[ls[k]]+ans[rs[k]];\n\t}\n}\nvoid change(int &k,int l,int r,int clo)\n{\n\tif(!k) k=++tot;\n\tif(l==r)return(void)(sum[k]=1,ans[k]=clo);\n\tint mid=(l+r)>>1;\n\tif(clo<=mid) change(ls[k],l,mid,clo);\n\telse change(rs[k],mid+1,r,clo);\n\tup(k);\n}\nint merge(int k,int pre,int l,int r)\n{\n\tif(!k||!pre)return k+pre;\n\tif(l==r)\n\t{\n\t\tsum[k]+=sum[pre];\n\t\tans[k]=l;\n\t\treturn k;\n\t}\n\tint mid=(l+r)>>1;\n\tls[k]=merge(ls[k],ls[pre],l,mid);\n\trs[k]=merge(rs[k],rs[pre],mid+1,r);\n\tup(k);\n\treturn k;\n}\nint ansl[N];\nvoid dfs(int now,int f)\n{\n\tfor(int i=0;i<va[now].size();i++)\n\t{\n\t\tint to=va[now][i];\n\t\tif(to==f)continue;\n\t\tdfs(to,now);\n\t\troot[now]=merge(root[now],root[to],1,n);\n\t}\n\tansl[now]=ans[root[now]];\n}\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(int i=1,clo;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&clo);\n\t\tchange(root[i],1,n,clo);\n\t}\n\tfor(int i=1,u,v;i<=n-1;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&u,&v);\n\t\tva[u].push_back(v);\n\t\tva[v].push_back(u);\n\t}\n\tdfs(1,-1);\n\tfor(int i=1;i<=n;i++)cout<<ansl[i]<<\" \";\n}\n/*\n3\n2 3 4\n1 2\n1 3\n*/",
        "fixed_code": "#include<bits/stdc++.h>\n#define IL inline\n#define LL long long\nusing namespace std;\nconst int N=1e5+3;\nstruct hh{\n\tint to,nxt;\n}e[N<<1];\nint fir[N],col[N],cnt[N],n,num,fa[N],siz[N],son[N],ch;\nLL ans[N],Mx,S;\nIL int in(){\n\tchar c;int f=1;\n\twhile((c=getchar())<'0'||c>'9')\n\t  if(c=='-') f=0;\n\tint x=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')\n\t  x=x*10+c-'0';\n\treturn f?x:-x;\n}\nIL void add(int x,int y){e[++num]=(hh){y,fir[x]},fir[x]=num;}\nvoid dfs1(int u){\n\tsiz[u]=1;\n\tfor(int i=fir[u],v;v=e[i].to;i=e[i].nxt)\n\t  if(v^fa[u]){\n\t  \tfa[v]=u,dfs1(v),siz[u]+=siz[v];\n\t  \tif(siz[son[u]]<=siz[v]) son[u]=v;\n\t\t}\n}\nvoid upd(int u,int val){\n\tcnt[col[u]]+=val;\n\tif(Mx<cnt[col[u]]) Mx=cnt[col[u]],S=col[u];\n\telse if(Mx==cnt[col[u]]) S+=col[u];\n\tfor(int i=fir[u],v;v=e[i].to;i=e[i].nxt)\n\t  if(v^fa[u]&&v^ch) upd(v,val);\n}\nvoid dfs2(int u,int op){\n\tLL Mx1=Mx,S1=S;\n\tfor(int i=fir[u],v;v=e[i].to;i=e[i].nxt)\n\t  if(v^fa[u]&&v^son[u]) dfs2(v,0);\n\tif(son[u]) dfs2(son[u],1),ch=son[u];\n\tupd(u,1),ch=0;\n\tans[u]=S;\n\tif(!op) upd(u,-1),Mx=Mx1,S=S1;\n}\nint main()\n{\n\tn=in();int x,y;\n\tfor(int i=1;i<=n;++i) col[i]=in();\n\tfor(int i=1;i<n;++i) x=in(),y=in(),add(x,y),add(y,x);\n\tdfs1(1);dfs2(1,1);\n\tfor(int i=1;i<=n;++i) printf(\"%lld \",ans[i]);\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define INF 1e6\ntypedef pair<int, int> pii;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n \n\tll int t,n,i,k,a;\n\tcin>>t;\n\twhile(t--){\n \n\tcin>>n;\n\tvector<ll int>v;\n\tk=(ll int)0;\n \n\tfor(i=0;i<n;i++){\n \n\tcin>>a;\n\tv.push_back(a);\n \n\tif(v[i]<i&&v[i]<n-i-1){\n \n\tcout <<\"No\\n\";\n\tk=(ll int)1;\n\tbreak;\n \n}\n \n}\n \n\tif(k!=(ll int)1&&n%2==1){\n \n\tcout <<\"Yes\\n\";\n \n}else if(k!=(ll int)1){\n \n \n\tn/=2;\n\tif(v[n]>=n||v[n-1]>=n){\n \n\tcout<<\"Yes\\n\";\n \n\t}else{\n \n\tcout <<\"No\\n\";\n \n}\n \n \n \n \n \n \n}\n \n \n \n \n \n \n \n \n \n \n \n \n \n}\n \n\treturn 0;\n}\n \n \n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define INF 1e6\ntypedef pair<int, int> pii;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n \n\tll int t,n,i,k,a;\n\tcin>>t;\n\twhile(t--){\n \n\tcin>>n;\n\tvector<ll int>v;\n\tk=(ll int)0;\n \n\tfor(i=0;i<n;i++){\n\n\tcin>>a;\n\tv.push_back(a);\n\n}\n\n\tfor(i=0;i<n;i++){\n \n\tif(v[i]<i&&v[i]<n-i-1){\n \n\tcout <<\"No\\n\";\n\tk=(ll int)1;\n\tbreak;\n \n}\n \n}\n \n\tif(k!=(ll int)1&&n%2==1){\n \n\tcout <<\"Yes\\n\";\n \n}else if(k!=(ll int)1){\n \n \n\tn/=2;\n\tif(v[n]>=n||v[n-1]>=n){\n \n\tcout<<\"Yes\\n\";\n \n\t}else{\n \n\tcout <<\"No\\n\";\n \n}\n \n \n \n \n \n \n}\n \n \n \n \n \n \n \n \n \n \n \n \n \n}\n \n\treturn 0;\n}\n \n \n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "from math import ceil,floor\nt=int(input())\nfor _ in range(t):\n    a,b=map(int,input().split())\n    if a == b:\n        print((a+b)//3)\n        continue\n    if a > 2*b:\n        print(b)\n        continue\n    if b > a*2:\n        print(a)\n        continue\n    if a > b:\n        count=0\n        while a > b:\n            a-=2\n            b-=1\n            count+=1\n        count+=(a+b)//3\n        \n        print(count)\n    else:\n        count=0\n        while a < b:\n            a-=2\n            b-=1\n            count+=1\n        count+=(a+b)//3\n       \n        print(count)\n                ",
        "fixed_code": "from math import ceil,floor\nt=int(input())\nfor _ in range(t):\n    a,b=map(int,input().split())\n    if a == b:\n        print((a+b)//3)\n        continue\n    if a > 2*b:\n        print(b)\n        continue\n    if b > a*2:\n        print(a)\n        continue\n    if a > b:\n        count=0\n        count+=(a+b)//3\n        print(count)\n    else:\n        count=0\n        count+=(a+b)//3\n        print(count)\n                ",
        "source": "Python_461356.json"
    },
    {
        "source_code": "# 2**60 > 1e18\nN, K = map(int, input().split())\na = [0] * 60\nk = 0\nh = l = -1\nfor i in range(60):\n\tif N & (1<<i):\n\t\tif l == -1: \n\t\t\tl = i\n\t\ta[i] = 1\n\t\th = i\n\t\tk += 1\n\nif k > K:\n\tprint(\"No\")\n\texit()\n\nwhile k != K:\n\twhile a[h] == 0: \n\t\th -= 1\n\tif k + a[h] <= K and h != l:\n\t\ta[h] -= 1\n\t\ta[h - 1] += 2\n\telse:\n\t\tbreak\n\tk += 1\n\nans = []\nfor i in range(60-1, l, -1):\n\tans += [i] * a[i]\nif k == K:\n\tans += [l]\nelse:\n\tans += [l] * (a[l] - 1)\n\tcount = K - k\n\tfirst = l - 1\n\tlast = first - count + 1\n\tans += list(range(first, last - 1, -1))\n\tans += [last]\nans = map(str, ans)\nans = \"Yes\\n\" + \" \".join(ans)\nprint(ans)\n",
        "fixed_code": "from collections import *\nN, K = map(int, input().split())\n\na = deque()\nfor i in range(60): # 2**60 > 1e18\n\tif N & (1<<i):\n\t\ta.appendleft([i,1])\nk = len(a)\n\nif k > K:\n\tprint(\"No\")\n\texit()\n\n# high\nwhile k + a[0][1] <= K:\n\te, c = a.popleft()\n\tif len(a) == 0 or a[0][0] != e - 1:\n\t\ta.appendleft([e-1,0])\n\ta[0][1] += 2 * c\n\tk += c\n\n# low\nif K - k:\n\ta[-1][1] -= 1\n\tcount = K - k\n\tfirst = a[-1][0] - 1\n\tlast = first - count + 1\n\tfor i in range(first, last - 1, -1):\n\t\ta.append([i,1])\n\ta.append([last,1])\n\tk = K\n\nans = []\t\t\nfor i in a:\n\tans += [i[0]] * i[1]\nans = map(str, ans)\nans = \"Yes\\n\" + \" \".join(ans)\nprint(ans)\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <map>\n#include <set>\n#include <stack>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int max_l = 11, mod = 10000, Len_digit = 4;\n\nint Len(int x) {\n    if (x == 0) {\n        return 1;\n    }\n    int res = 0;\n    while (x != 0) {\n        ++res;\n        x /= 10;\n    }\n    return res;\n}\n\nstruct very_long {\n    int len;\n    int digit[max_l];\n    very_long() {\n        len = 0;\n        memset(digit, 0, sizeof(digit));\n    }\n    very_long(const string &s) {\n        len = 0;\n        for (int i = s.length() - 1; i >= 0; i -= Len_digit) {\n            int x = 0;\n            for (int j = max(0, i - Len_digit + 1); j <= i; ++j) {\n                x = x * 10 + s[j] - '0';\n            }\n            digit[len] = x;\n            ++len;\n        }\n    }\n    very_long(long long a) {\n        len = 0;\n        if (a == 0) {\n            len = 1;\n            digit[0] = 0;\n        }\n        while (a != 0) {\n            digit[len] = a % mod;\n            len++;\n            a /= mod;\n        }\n    }\n    void operator = (const very_long &a) {\n        len = a.len;\n        for (int i = 0; i < a.len; i++)\n            digit[i] = a.digit[i];\n    }\n    void operator = (const long long &a) {\n        *this = very_long(a);\n    }\n    bool operator == (const very_long &a) const {\n        if (len != a.len) return false;\n        for (int i = 0; i < len; i++) {\n            if (digit[i] != a.digit[i]) return false;\n        }\n        return true;\n    }\n    bool operator != (const very_long &a) const {\n        return !(*this == a);\n    }\n    bool operator < (const very_long &a) const {\n        if (len < a.len) return true;\n        if (len > a.len) return false;\n        for (int i = len - 1; i >= 0; i--) {\n            if (digit[i] < a.digit[i]) return true;\n            if (digit[i] > a.digit[i]) return false;\n        }\n        return false;\n    }\n    bool operator <= (const very_long &a) const {\n        return *this == a || *this < a;\n    }\n    bool operator > (const very_long &a) const {\n        return !(*this <= a);\n    }\n    bool operator >= (const very_long &a) const {\n        return !(*this < a);\n    }\n    bool operator == (long long a) const {\n        return *this == very_long(a);\n    }\n    bool operator < (long long a) const {\n        return *this < very_long(a);\n    }\n    bool operator <= (long long a) const {\n        return *this <= very_long(a);\n    }\n    bool operator > (long long a) const {\n        return *this > very_long(a);\n    }\n    bool operator >= (long long a) {\n        return *this >= very_long(a);\n    }\n    very_long operator + (const very_long &a) const {\n        int p = 0, l = max(len, a.len);\n        very_long res;\n        for (int i = 0; i < l; i++) {\n            int x = digit[i] + a.digit[i] + p;\n            if (len <= i) x -= digit[i];\n            if (a.len <= i) x -= a.digit[i];\n            res.digit[i] = x % mod;\n            p = x / mod;\n        }\n        res.len = l;\n        if (p != 0) {\n            res.len++;\n            res.digit[l] = p;\n        }\n        return res;\n    }\n    very_long operator - (const very_long &q) const {\n        very_long a = *this, b = q, res;\n        if (a < b) swap(a, b);\n        int p = 0;\n        for (int i = 0; i < a.len; i++) {\n            int x = a.digit[i] - b.digit[i] - p;\n            if (b.len <= i) x += b.digit[i];\n            p = 0;\n            if (x < 0) {\n                p = 1;//??????????????\n                x += mod;\n            }\n            res.digit[i] = x;\n        }\n        res.len = a.len;\n        while (res.digit[res.len - 1] == 0 && res.len > 1)\n            res.len--;\n        return res;\n    }\n    very_long operator * (const very_long &a) const {\n        very_long b, res = 0;\n        if (a == 0) {\n            return res;\n        }\n        for (int i = 0; i < len; i++) {\n            if (i != 0) {\n                b.digit[i - 1] = 0;\n            }\n            if (digit[i] != 0) {\n                int p = 0;\n                for (int j = 0; j < a.len; j++) {\n                    int x = digit[i] * a.digit[j] + p;\n                    b.digit[i + j] = x % mod;\n                    p = x / mod;\n                }\n                b.len = i + a.len;\n                if (p != 0) {\n                    b.len++;\n                    b.digit[i + a.len] = p;\n                }\n                res = res + b;\n            }\n        }\n        return res;\n    }\n    very_long operator / (const very_long &a) const {\n        very_long res = 0, c = 0;\n        for (int ii = len - 1; ii >= -1; --ii) {\n            int l = 0, r = 10;\n            while (r - l > 1) {\n                int mid = (l + r) / 2;\n                if (a * mid <= c) {\n                    l = mid;\n                } else {\n                    r = mid;\n                }\n            }\n            res.digit[res.len] = l;\n            ++res.len;\n            if (ii >= 0) {\n                c = c - a * l;\n                c = c * 10 + digit[ii];\n            }\n        }\n        reverse(res.digit, res.digit + res.len);\n        while (res.len > 1 && res.digit[res.len - 1] == 0) {\n            --res.len;\n        }\n        return res;\n    }\n    very_long operator + (const long long a) const {\n        return *this + very_long(a);\n    }\n    very_long operator - (const long long a) const {\n        return *this - very_long(a);\n    }\n    very_long operator * (const long long a) const {\n        //return very_long(a) * *this;  ?????error\n        return *this * very_long(a);//++++\n    }\n    very_long operator / (int a) const {\n        very_long b;\n        long long x = 0;\n        b.len = len;\n        for (int i = len - 1; i >= 0; i--) {\n            x = x * mod + digit[i];\n            b.digit[i] = x / a;\n            x %= a;\n        }\n        while (b.len > 1 && b.digit[b.len - 1] == 0) {\n            b.len--;\n        }\n        return b;\n    }\n    long long operator % (long long a) const {\n        long long res = 0;\n        for (int i = len - 1; i >= 0; i--) {\n            res = (res * mod + digit[i]) % a;\n        }\n        return res;\n    }\n    void write() const {\n        for (int i = len - 1; i >= 0; --i) {\n            if (i != len - 1) {\n                for (int j = 0; j < Len_digit - Len(digit[i]); ++j) {\n                    printf(\"0\");\n                }\n            }\n            printf(\"%d\", digit[i]);\n        }\n    }\n};\n\nconst int max_n = 111111, inf = 1111111111;\n\nint n;\npair<int, pair<int, int> > p[max_n];\n\nint get_num(pair<int, pair<int, int> > p) {\n    if (p.first >= 0) {\n        if (p.second.first >= 0) {\n            return 1;\n        }\n        return 4;\n    }\n    if (p.second.first >= 0) {\n        return 2;\n    }\n    return 3;\n}\n\nbool cmp(pair<int, pair<int, int> > p1, pair<int, pair<int, int> > p2) {\n    int n1 = get_num(p1);\n    int n2 = get_num(p2);\n    if (n1 != n2) {\n        return n1 < n2;\n    }\n    return p1.second.first * p2.first < p2.second.first * p1.first;\n}\n\nvector<pair<long long, pair<long long, pair<long long, int> > > > v;\n\nbool cmp2(pair<long long, pair<long long, pair<long long, int> > > p1, pair<long long, pair<long long, pair<long long, int> > > p2) {\n    very_long a1 = p1.first;\n    very_long b1 = p1.second.first;\n    very_long c1 = p1.second.second.first;\n    very_long a2 = p2.first;\n    very_long b2 = p2.second.first;\n    very_long c2 = p2.second.second.first;\n    if (a1 < 0 && a2 > 0) {\n        return true;\n    }\n    if (a1 > 0 && a2 < 0) {\n        return false;\n    }\n    if (a1 < 0 && a2 < 0) {\n        return a1 * a1 * b2 * c2 > a2 * a2 * b1 * c1;\n    }\n    return a1 * a1 * b2 * c2 < a2 * a2 * b1 * c1;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d%d\", &p[i].first, &p[i].second.first);\n        p[i].second.second = i + 1;\n    }\n    sort(p, p + n, cmp);\n    int num1 = 1, num2 = 2;\n    for (int i = 0; i < n; ++i) {\n        long long x = p[i].first, y = p[i].second.first;\n        long long xx = p[(i + 1) % n].first, yy = p[(i + 1) % n].second.first;\n        v.push_back(make_pair((x * xx + y * yy), make_pair(x * x + y * y, make_pair(xx * xx + yy * yy, i))));\n    }\n    sort(v.begin(), v.end(), cmp2);\n    int i = v.back().second.second.second;\n    num1 = p[i].second.second;\n    num2 = p[(i + 1) % n].second.second;\n    cout << num1 << \" \" << num2 << endl;\n    return 0;\n}\n",
        "fixed_code": "#include <map>\n#include <set>\n#include <stack>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int max_l = 11, mod = 10000, Len_digit = 4;\n\nint Len(int x) {\n    if (x == 0) {\n        return 1;\n    }\n    int res = 0;\n    while (x != 0) {\n        ++res;\n        x /= 10;\n    }\n    return res;\n}\n\nstruct very_long {\n    int len;\n    int digit[max_l];\n    very_long() {\n        len = 0;\n        memset(digit, 0, sizeof(digit));\n    }\n    very_long(const string &s) {\n        len = 0;\n        for (int i = s.length() - 1; i >= 0; i -= Len_digit) {\n            int x = 0;\n            for (int j = max(0, i - Len_digit + 1); j <= i; ++j) {\n                x = x * 10 + s[j] - '0';\n            }\n            digit[len] = x;\n            ++len;\n        }\n    }\n    very_long(long long a) {\n        len = 0;\n        if (a == 0) {\n            len = 1;\n            digit[0] = 0;\n        }\n        while (a != 0) {\n            digit[len] = a % mod;\n            len++;\n            a /= mod;\n        }\n    }\n    void operator = (const very_long &a) {\n        len = a.len;\n        for (int i = 0; i < a.len; i++)\n            digit[i] = a.digit[i];\n    }\n    void operator = (const long long &a) {\n        *this = very_long(a);\n    }\n    bool operator == (const very_long &a) const {\n        if (len != a.len) return false;\n        for (int i = 0; i < len; i++) {\n            if (digit[i] != a.digit[i]) return false;\n        }\n        return true;\n    }\n    bool operator != (const very_long &a) const {\n        return !(*this == a);\n    }\n    bool operator < (const very_long &a) const {\n        if (len < a.len) return true;\n        if (len > a.len) return false;\n        for (int i = len - 1; i >= 0; i--) {\n            if (digit[i] < a.digit[i]) return true;\n            if (digit[i] > a.digit[i]) return false;\n        }\n        return false;\n    }\n    bool operator <= (const very_long &a) const {\n        return *this == a || *this < a;\n    }\n    bool operator > (const very_long &a) const {\n        return !(*this <= a);\n    }\n    bool operator >= (const very_long &a) const {\n        return !(*this < a);\n    }\n    bool operator == (long long a) const {\n        return *this == very_long(a);\n    }\n    bool operator < (long long a) const {\n        return *this < very_long(a);\n    }\n    bool operator <= (long long a) const {\n        return *this <= very_long(a);\n    }\n    bool operator > (long long a) const {\n        return *this > very_long(a);\n    }\n    bool operator >= (long long a) {\n        return *this >= very_long(a);\n    }\n    very_long operator + (const very_long &a) const {\n        int p = 0, l = max(len, a.len);\n        very_long res;\n        for (int i = 0; i < l; i++) {\n            int x = digit[i] + a.digit[i] + p;\n            if (len <= i) x -= digit[i];\n            if (a.len <= i) x -= a.digit[i];\n            res.digit[i] = x % mod;\n            p = x / mod;\n        }\n        res.len = l;\n        if (p != 0) {\n            res.len++;\n            res.digit[l] = p;\n        }\n        return res;\n    }\n    very_long operator - (const very_long &q) const {\n        very_long a = *this, b = q, res;\n        if (a < b) swap(a, b);\n        int p = 0;\n        for (int i = 0; i < a.len; i++) {\n            int x = a.digit[i] - b.digit[i] - p;\n            if (b.len <= i) x += b.digit[i];\n            p = 0;\n            if (x < 0) {\n                p = 1;//??????????????\n                x += mod;\n            }\n            res.digit[i] = x;\n        }\n        res.len = a.len;\n        while (res.digit[res.len - 1] == 0 && res.len > 1)\n            res.len--;\n        return res;\n    }\n    very_long operator * (const very_long &a) const {\n        very_long b, res = 0;\n        if (a == 0) {\n            return res;\n        }\n        for (int i = 0; i < len; i++) {\n            if (i != 0) {\n                b.digit[i - 1] = 0;\n            }\n            if (digit[i] != 0) {\n                int p = 0;\n                for (int j = 0; j < a.len; j++) {\n                    int x = digit[i] * a.digit[j] + p;\n                    b.digit[i + j] = x % mod;\n                    p = x / mod;\n                }\n                b.len = i + a.len;\n                if (p != 0) {\n                    b.len++;\n                    b.digit[i + a.len] = p;\n                }\n                res = res + b;\n            }\n        }\n        return res;\n    }\n    very_long operator / (const very_long &a) const {\n        very_long res = 0, c = 0;\n        for (int ii = len - 1; ii >= -1; --ii) {\n            int l = 0, r = 10;\n            while (r - l > 1) {\n                int mid = (l + r) / 2;\n                if (a * mid <= c) {\n                    l = mid;\n                } else {\n                    r = mid;\n                }\n            }\n            res.digit[res.len] = l;\n            ++res.len;\n            if (ii >= 0) {\n                c = c - a * l;\n                c = c * 10 + digit[ii];\n            }\n        }\n        reverse(res.digit, res.digit + res.len);\n        while (res.len > 1 && res.digit[res.len - 1] == 0) {\n            --res.len;\n        }\n        return res;\n    }\n    very_long operator + (const long long a) const {\n        return *this + very_long(a);\n    }\n    very_long operator - (const long long a) const {\n        return *this - very_long(a);\n    }\n    very_long operator * (const long long a) const {\n        //return very_long(a) * *this;  ?????error\n        return *this * very_long(a);//++++\n    }\n    very_long operator / (int a) const {\n        very_long b;\n        long long x = 0;\n        b.len = len;\n        for (int i = len - 1; i >= 0; i--) {\n            x = x * mod + digit[i];\n            b.digit[i] = x / a;\n            x %= a;\n        }\n        while (b.len > 1 && b.digit[b.len - 1] == 0) {\n            b.len--;\n        }\n        return b;\n    }\n    long long operator % (long long a) const {\n        long long res = 0;\n        for (int i = len - 1; i >= 0; i--) {\n            res = (res * mod + digit[i]) % a;\n        }\n        return res;\n    }\n    void write(string s = \"\") const {\n        for (int i = len - 1; i >= 0; --i) {\n            if (i != len - 1) {\n                for (int j = 0; j < Len_digit - Len(digit[i]); ++j) {\n                    printf(\"0\");\n                }\n            }\n            printf(\"%d\", digit[i]);\n        }\n        cout << s;\n    }\n};\n\nconst int max_n = 111111, inf = 1111111111;\n\nint n;\npair<int, pair<int, int> > p[max_n];\n\nint get_num(pair<int, pair<int, int> > p) {\n    if (p.first >= 0) {\n        if (p.second.first >= 0) {\n            return 1;\n        }\n        return 4;\n    }\n    if (p.second.first >= 0) {\n        return 2;\n    }\n    return 3;\n}\n\nbool cmp(pair<int, pair<int, int> > p1, pair<int, pair<int, int> > p2) {\n    int n1 = get_num(p1);\n    int n2 = get_num(p2);\n    if (n1 != n2) {\n        return n1 < n2;\n    }\n    return p1.second.first * p2.first < p2.second.first * p1.first;\n}\n\nbool cmp2(pair<long long, pair<long long, pair<long long, int> > > p1, pair<long long, pair<long long, pair<long long, int> > > p2) {\n    int z1 = 0;\n    if (p1.first < 0) {\n        z1 = 1;\n        p1.first *= -1;\n    }\n    int z2 = 0;\n    if (p2.first < 0) {\n        z2 = 1;\n        p2.first *= -1;\n    }\n    very_long a1 = p1.first;\n    very_long b1 = p1.second.first;\n    very_long c1 = p1.second.second.first;\n    very_long a2 = p2.first;\n    very_long b2 = p2.second.first;\n    very_long c2 = p2.second.second.first;\n    //a1.write(\" = a1\\n\");\n    //a2.write(\" = a2\\n\");\n    if (z1 == 1) {\n        if (z2 == 0) return true;\n        return a1 * a1 * b2 * c2 > a2 * a2 * b1 * c1;\n    }\n    if (z2 == 1) {\n        return false;\n    }\n    //(a1 * a1 * b2 * c2).write(\"\\n\");\n    //(a2 * a2 * b1 * c1).write(\"\\n\");\n    return a1 * a1 * b2 * c2 < a2 * a2 * b1 * c1;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d%d\", &p[i].first, &p[i].second.first);\n        p[i].second.second = i + 1;\n    }\n    sort(p, p + n, cmp);\n    int num1 = 1, num2 = 2, ii;\n    pair<long long, pair<long long, pair<long long, int> > > last;\n    for (int i = 0; i < n; ++i) {\n        long long x = p[i].first, y = p[i].second.first;\n        long long xx = p[(i + 1) % n].first, yy = p[(i + 1) % n].second.first;\n        pair<long long, pair<long long, pair<long long, int> > > p;\n        p = make_pair((x * xx + y * yy), make_pair(x * x + y * y, make_pair(xx * xx + yy * yy, i)));\n        //cout << p.first << \" \" << p.second.first << \" \" << p.second.second.first << endl;\n        if (i == 0) {\n            ii = 0;\n            last = p;\n        } else if (cmp2(last, p)){\n            ii = i;\n            last = p;\n        }\n    }\n    num1 = p[ii].second.second;\n    num2 = p[(ii + 1) % n].second.second;\n    cout << num1 << \" \" << num2 << endl;\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m, k, cnt;\nconst int N = 300003,INF = 0x3f3f3f3f;\nint root[N], seg[N << 5],ls[N << 5],rs[N << 5];\nstruct Seg {\n    int l,r,p;\n    inline bool operator < (const Seg &o) const {return l < o.l || l == o.l && r < o.r;}\n} a[N];\ninline void change(int &nx, int ox, int L, int R, int pos, int val){\n    seg[nx = ++ cnt] = seg[ox];\n    ls[nx] = ls[ox]; \n\trs[nx] = rs[ox];\n    if(L == R){\n        seg[nx] = min(seg[nx], val);\n        return;\n    }\n    int mid = L + R >> 1;\n    if(pos<=mid) {\n    \tchange(ls[nx], ls[ox], L, mid, pos, val);\n\t}\n    else{\n    \tchange(rs[nx], rs[ox], mid + 1, R, pos, val);\n\t} \n    pushup(nx);\n}\ninline void build(int &x, int L, int R){\n    seg[x = ++ cnt] = INF;\n    if(L == R) return;\n    int mid = L + R >> 1;\n    build(ls[x], L, mid);\n    build(rs[x], mid + 1, R);\n}\ninline void pushup(int x){\n    seg[x] = max(seg[ls[x]], seg[rs[x]]);\n}\ninline int query(int a, int L, int R, int l, int r){\n    if(l <= L && R <= r){\n    \treturn seg[a];\n\t}\n    int mid = L + R >> 1, ans = 0;\n    if(l <= mid){\n    \tans = max(ans, query(ls[a], L, mid, l, r));\n\t} \n    if(mid < r){\n    \tans = max(ans, query(rs[a], mid + 1, R, l, r));\n\t} \n    return ans;\n}\n\t//freopen(\"10.in\", \"r\", stdin);   // 读入刚写的文件\n//\tfreopen(\"10.out\", \"w\", stdout);  // 输出将要输出的数据\nint main(){\n    scanf(\"%d%d%d\", &n, &m, &k);\n    for(int i = 1;i <= k;i ++)\n        scanf(\"%d%d%d\", &a[i].l, &a[i].r, &a[i].p);\n    sort(a + 1, a + k + 1);\n    build(root[k + 1], 1, n);\n    for(int i = k;i;i --)\n        change(root[i], root[i + 1], 1, n, a[i].p, a[i].r);\n    a[k + 1].l = INF; \n    while(m --){\n        int A, B, X, Y;\n        scanf(\"%d%d%d%d\", &A, &B, &X, &Y);\n        int ans = -1, mid, left = 1, right = k + 1;\n        while(left <= right){\n            mid = left + right >> 1;\n            if(a[mid].l >= X) ans = mid, right = mid - 1;\n            else left = mid + 1;\n        }\n        puts(query(root[ans], 1, n, A, B) <= Y ? \"yes\" : \"no\");\n        fflush(stdout);\n    }\n    //fclose(stdin);   //结束\n\t//fclose(stdout);\t  //结束\n}",
        "fixed_code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nint n, m, k, cnt;\nconst int N = 300003,INF = 0x3f3f3f3f;\nint root[N], seg[N << 5],ls[N << 5],rs[N << 5];\nstruct Seg {\n    int l,r,p;\n    inline bool operator < (const Seg &o) const {return l < o.l || l == o.l && r < o.r;}\n} a[N];\ninline void pushup(int a){\n    seg[a] = max(seg[ls[a]], seg[rs[a]]);\n}\ninline void change(int &nx, int ox, int L, int R, int pos, int val){\n    seg[nx = ++ cnt] = seg[ox];\n    ls[nx] = ls[ox]; \n\trs[nx] = rs[ox];\n    if(L == R){\n        seg[nx] = min(seg[nx], val);\n        return;\n    }\n    int mid = L + R >> 1;\n    if(pos<=mid) {\n    \tchange(ls[nx], ls[ox], L, mid, pos, val);\n\t}\n    else{\n    \tchange(rs[nx], rs[ox], mid + 1, R, pos, val);\n\t} \n    pushup(nx);\n}\ninline void build(int &x, int L, int R){\n    seg[x = ++ cnt] = INF;\n    if(L == R) return;\n    int mid = L + R >> 1;\n    build(ls[x], L, mid);\n    build(rs[x], mid + 1, R);\n}\ninline int query(int a, int L, int R, int l, int r){\n    if(l <= L && R <= r){\n    \treturn seg[a];\n\t}\n    int mid = L + R >> 1, ans = 0;\n    if(l <= mid){\n    \tans = max(ans, query(ls[a], L, mid, l, r));\n\t} \n    if(mid < r){\n    \tans = max(ans, query(rs[a], mid + 1, R, l, r));\n\t} \n    return ans;\n}\n\t//freopen(\"10.in\", \"r\", stdin);   // 读入刚写的文件\n//\tfreopen(\"10.out\", \"w\", stdout);  // 输出将要输出的数据\nint main(){\n    scanf(\"%d%d%d\", &n, &m, &k);\n    for(int i = 1;i <= k;i ++)\n        scanf(\"%d%d%d\", &a[i].l, &a[i].r, &a[i].p);\n    sort(a + 1, a + k + 1);\n    build(root[k + 1], 1, n);\n    for(int i = k;i;i --)\n        change(root[i], root[i + 1], 1, n, a[i].p, a[i].r);\n    a[k + 1].l = INF; \n    while(m --){\n        int A, B, X, Y;\n        scanf(\"%d%d%d%d\", &A, &B, &X, &Y);\n        int ans = -1, mid, left = 1, right = k + 1;\n        while(left <= right){\n            mid = left + right >> 1;\n            if(a[mid].l >= X) ans = mid, right = mid - 1;\n            else left = mid + 1;\n        }\n        puts(query(root[ans], 1, n, A, B) <= Y ? \"yes\" : \"no\");\n        fflush(stdout);\n    }\n    //fclose(stdin);   //结束\n\t//fclose(stdout);\t  //结束\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\nusing namespace std;\n\nint main()\n{\n\tll n,k,mi,a;\n\tcin>>n>>k;\n\n\tcin>>mi;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tcin>>a;\n\t\tif(k==1)\n\t\tmi=min(mi,a);\n\t\telse\n\t\tmi=max(mi,a);\n\t}\n\n\tcout<<mi;\n}",
        "fixed_code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\nusing namespace std;\n\nint main()\n{\n\tll n,k,mi,a,b,c;\n\tcin>>n>>k;\n\n\tcin>>mi;\n\tb=mi;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tcin>>a;\n\t\tif(i==n)\n\t\t\tc=a;\n\t\tif(k==1)\n\t\tmi=min(mi,a);\n\t\telse if(k>2)\n\t\tmi=max(mi,a);\n\t}\n\tif(k==2)\n\t\tmi=max(b,c);\n\tcout<<mi;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.SuppressWarnings(value = \"unchecked\")\n@java.lang.Override\npublic java.util.List<com.softserve.edu.model.Event> searchEvent(org.springframework.data.jpa.domain.Specifications<com.softserve.edu.model.Event> specifications) {\n    return eventRepository.findAll(specifications);\n}",
        "fixed_code": "@java.lang.SuppressWarnings(value = \"unchecked\")\n@java.lang.Override\npublic java.util.List<com.softserve.edu.model.Event> searchEvent(org.springframework.data.jpa.domain.Specifications<com.softserve.edu.model.Event> specifications) {\n    return eventRepository.findAll(specifications);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <algorithm>\nusing namespace std;\n\n#define nln        puts(\"\")                         ///prLLInewline\n#define getLLI(a)  scanf(\"%d\",&a);\n#define max3(a,b,c) max(a,max(b,c))                  ///3 ta theke max\n#define min3(a,b,c) min(a,min(b,c))                  ///3 ta theke min\n\n#define FOR1(i,n)  for(LLI i=1;i<=n;i++)\n#define FOR0(i,n)  for(LLI i=0;i<n;i++)                 ///looping\n#define FORR(i,n)  for(LLI i=n-1;i>=0;i--)\n#define ALL(p)     p.begin(),p.end()\n\n#define SET(p)     memset(p,-1,sizeof(p))\n#define CLR(p)     memset(p,0,sizeof(p))            ///memset\n#define MEM(p,v)   memset(p,v,sizeof(p))\n\n#define READ(f)    freopen(f, \"r\", stdin)           /// file\n#define WRITE(f)   freopen(f, \"w\", stdout)\n\n#define SZ(c)      (LLI)c.size()\n#define PB(x)      push_back(x)                     ///STL defines\n#define MP(x,y)    make_pair(x,y)\n#define ff         first\n#define ss         second\n\n#define LI         long LLI\n#define LLI         long long\n#define f64        long double\n#define PI         acos(-1.0)                        ///PI er value\n\nLLI Set(LLI N,LLI pos)\n{\n    return N=N | (1<<pos);\n}\nLLI reset(LLI N,LLI pos)\n{\n    return N= N & ~(1<<pos);\n}\nbool check(LLI N,LLI pos)\n{\n    return (bool)(N & (1<<pos));\n}\nvoid CI(LLI &_x)\n{\n    scanf(\"%d\",&_x);\n}\n\nvoid CO(LLI &_x)\n{\n    cout<<_x;\n}\n\ntemplate<typename T> void getarray(T a[],LLI n)\n{\n    for(LLI i=0; i<n; i++) cin>>a[i];\n}\ntemplate<typename T> void prLLIarray(T a[],LLI n)\n{\n    for(LLI i=0; i<n-1; i++) cout<<a[i]<<\" \";\n    cout<<a[n-1]<<endl;\n}\n\nconst double EPS=1e-9;                              ///constatnts\nconst LLI INF=0x7f7f7f7f;\n\nLLI dr8[8]= {1,-1,0,0,1,-1,-1,1};            ///8 direction move\nLLI dc8[8]= {0,0,-1,1,1,1,-1,-1};\nLLI dr4[4]= {0,0,1,-1};                      ///4 direction move\nLLI dc4[4]= {-1,1,0,0};                      ///or adjacent dir.\nLLI kn8r[8]= {1,2,2,1,-1,-2,-2,-1};          ///knight moves\nLLI kn8c[8]= {2,1,-1,-2,-2,-1,1,2};\nLLI dis2(pair<LLI,LLI> a,pair<LLI,LLI> b)\n{\n\n    LLI f=a.ff-b.ff;\n    LLI s=a.ss-b.ss;\n    f=f*f;\n    s=s*s;\n    return f+s;\n\n}\nvector<pair<LLI,LLI> >V;\n\nint main()\n{\n\n    LLI n,x1,y1,x2,y2;\n    cin>>n;\n    cin>>x1>>y1>>x2>>y2;\n    FOR0(i,n)\n    {\n        LLI a,b;\n        cin>>a>>b;\n        V.PB(MP(a,b));\n    }\n    LLI ans=100000000000000000ll;\n    for(int i=0;i<n;i++)\n        ans=min(ans,dis2(MP(x2,y2),V[i]));\n    for(LLI i=0; i<n; i++)\n    {\n\n        LLI r1=dis2(V[i],MP(x1,y1));\n       // cout<<i<<\" : \"<<r1<<\"\\n\";\n        LLI r2=0;\n        for(LLI j=0; j<n; j++)\n            if(i!=j&&dis2(V[j],MP(x1,y1))>=r1)\n            {\n                 r2=max(r2,dis2(V[j],MP(x2,y2)));\n//                cout<<\"PP \"<<i<<\" \"<<j<<\" \"<<r1<<\" \"<<r2<<\"\\n\";\n\n            }\n//            return 0;\n        ans=min(ans,r1+r2);\n    }\n//     for(LLI i=0; i<n; i++)\n//    {\n//\n//        LLI r1=dis2(V[i],MP(x2,y2));\n//       // cout<<i<<\" : \"<<r1<<\"\\n\";\n//        LLI r2=0;\n//        for(LLI j=0; j<n; j++)\n//            if(i!=j&&dis2(V[j],MP(x2,y2))>=r1)\n//            {\n//                 r2=max(r2,dis2(V[j],MP(x1,y1)));\n////                cout<<\"PP \"<<i<<\" \"<<j<<\" \"<<r1<<\" \"<<r2<<\"\\n\";\n//\n//            }\n////            return 0;\n//        ans=min(ans,r1+r2);\n//    }\n    cout<<ans<<\"\\n\";\n}\n",
        "fixed_code": "#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <algorithm>\nusing namespace std;\n\n#define nln        puts(\"\")                         ///prLLInewline\n#define getLLI(a)  scanf(\"%d\",&a);\n#define max3(a,b,c) max(a,max(b,c))                  ///3 ta theke max\n#define min3(a,b,c) min(a,min(b,c))                  ///3 ta theke min\n\n#define FOR1(i,n)  for(LLI i=1;i<=n;i++)\n#define FOR0(i,n)  for(LLI i=0;i<n;i++)                 ///looping\n#define FORR(i,n)  for(LLI i=n-1;i>=0;i--)\n#define ALL(p)     p.begin(),p.end()\n\n#define SET(p)     memset(p,-1,sizeof(p))\n#define CLR(p)     memset(p,0,sizeof(p))            ///memset\n#define MEM(p,v)   memset(p,v,sizeof(p))\n\n#define READ(f)    freopen(f, \"r\", stdin)           /// file\n#define WRITE(f)   freopen(f, \"w\", stdout)\n\n#define SZ(c)      (LLI)c.size()\n#define PB(x)      push_back(x)                     ///STL defines\n#define MP(x,y)    make_pair(x,y)\n#define ff         first\n#define ss         second\n\n#define LI         long LLI\n#define LLI         long long\n#define f64        long double\n#define PI         acos(-1.0)                        ///PI er value\n\nLLI Set(LLI N,LLI pos)\n{\n    return N=N | (1<<pos);\n}\nLLI reset(LLI N,LLI pos)\n{\n    return N= N & ~(1<<pos);\n}\nbool check(LLI N,LLI pos)\n{\n    return (bool)(N & (1<<pos));\n}\nvoid CI(LLI &_x)\n{\n    scanf(\"%d\",&_x);\n}\n\nvoid CO(LLI &_x)\n{\n    cout<<_x;\n}\n\ntemplate<typename T> void getarray(T a[],LLI n)\n{\n    for(LLI i=0; i<n; i++) cin>>a[i];\n}\ntemplate<typename T> void prLLIarray(T a[],LLI n)\n{\n    for(LLI i=0; i<n-1; i++) cout<<a[i]<<\" \";\n    cout<<a[n-1]<<endl;\n}\n\nconst double EPS=1e-9;                              ///constatnts\nconst LLI INF=0x7f7f7f7f;\n\nLLI dr8[8]= {1,-1,0,0,1,-1,-1,1};            ///8 direction move\nLLI dc8[8]= {0,0,-1,1,1,1,-1,-1};\nLLI dr4[4]= {0,0,1,-1};                      ///4 direction move\nLLI dc4[4]= {-1,1,0,0};                      ///or adjacent dir.\nLLI kn8r[8]= {1,2,2,1,-1,-2,-2,-1};          ///knight moves\nLLI kn8c[8]= {2,1,-1,-2,-2,-1,1,2};\nLLI dis2(pair<LLI,LLI> a,pair<LLI,LLI> b)\n{\n\n    LLI f=a.ff-b.ff;\n    LLI s=a.ss-b.ss;\n    f=f*f;\n    s=s*s;\n    return f+s;\n\n}\nvector<pair<LLI,LLI> >V;\n\nint main()\n{\n\n    LLI n,x1,y1,x2,y2;\n    cin>>n;\n    cin>>x1>>y1>>x2>>y2;\n    FOR0(i,n)\n    {\n        LLI a,b;\n        cin>>a>>b;\n        V.PB(MP(a,b));\n    }\n    LLI ans=0;\n    for(int i=0;i<n;i++)\n        ans=max(ans,dis2(MP(x2,y2),V[i]));\n    for(LLI i=0; i<n; i++)\n    {\n\n        LLI r1=dis2(V[i],MP(x1,y1));\n       // cout<<i<<\" : \"<<r1<<\"\\n\";\n        LLI r2=0;\n        for(LLI j=0; j<n; j++)\n            if(i!=j&&dis2(V[j],MP(x1,y1))>=r1)\n            {\n                 r2=max(r2,dis2(V[j],MP(x2,y2)));\n//                cout<<\"PP \"<<i<<\" \"<<j<<\" \"<<r1<<\" \"<<r2<<\"\\n\";\n\n            }\n//            return 0;\n        ans=min(ans,r1+r2);\n    }\n//     for(LLI i=0; i<n; i++)\n//    {\n//\n//        LLI r1=dis2(V[i],MP(x2,y2));\n//       // cout<<i<<\" : \"<<r1<<\"\\n\";\n//        LLI r2=0;\n//        for(LLI j=0; j<n; j++)\n//            if(i!=j&&dis2(V[j],MP(x2,y2))>=r1)\n//            {\n//                 r2=max(r2,dis2(V[j],MP(x1,y1)));\n////                cout<<\"PP \"<<i<<\" \"<<j<<\" \"<<r1<<\" \"<<r2<<\"\\n\";\n//\n//            }\n////            return 0;\n//        ans=min(ans,r1+r2);\n//    }\n    cout<<ans<<\"\\n\";\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{long long n;cin>>n;\nlong long A[n],i,j,min=5*pow(10,5),p,r=1;\nfor(i=0;i<n;i++)\ncin>>A[i];\nfor(i=0;i<n;i++)\n{\n    if(A[i]<min)\n       min=A[i];\n}\n\nfor(i=min;i>1;i--)\n {  p=0;\n     for(j=0;j<n;j++)\n     {\n         if(A[j]%i!=0)\n         {\n             p=1;break;\n         }\n     }\n     if(p==0)\n    r++;\n     \n }\n cout<<r;\nreturn 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#include<algorithm>\n \nusing namespace std;\nint main()\n {long long n;cin>>n;\n        long long A[n],i,j,p,r=0,res=0,h=0;\n        for(i=0;i<n;i++)\n        cin>>A[i];\n       for(i=0;i<n;i++)\n       {\n           h=__gcd(h,A[i]);\n       }\n        \nfor(i=1;i*i<=h;i++)\n        {if(i*i==h)\n            res++;\n            else if(h%i==0)\n            res+=2;\n        }\n        cout<<res;\n        return 0;\n }",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\nn= int(input())\n#val= list(map(int,input().split()))\n\nans=[0]*8\nfor i in map(int,input().split()):\n    ans[i]+=1\ngrp=n//3\nif ans[1]==grp and (ans[2]+ans[3])==grp and (ans[4]+ans[6])==grp and ans[3]<=ans[6]:\n    print('1 2 4\\n'*ans[4]+ '1 2 6\\n'*(ans[3]-ans[6]) + '1 3 6\\n'*(ans[3]))\nelse:\n    print(-1)\n\n\n\n\n\n",
        "fixed_code": "\nn= int(input())\n#val= list(map(int,input().split()))\n\nans=[0]*8\nfor i in map(int,input().split()):\n    ans[i]+=1\ngrp=n//3\nif ans[1]==grp and (ans[2]+ans[3])==grp and (ans[4]+ans[6])==grp and ans[3]<=ans[6]:\n    print('1 2 4\\n'*ans[4]+ '1 2 6\\n'*(ans[6]-ans[3]) + '1 3 6\\n'*(ans[3]))\nelse:\n    print(-1)\n\n\n\n\n\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n \n#define forn(i, n) for (llong i = 0ll; i < (llong) n; ++i)\n#define fornn(i, l, r) for (llong i = (llong) l; i < (llong) r; ++i)\n#define size(x) ((int) (x.size()))\n \nusing namespace std;\n \ntypedef long long llong;\nconst llong inf = (llong) 1e+9 + 7ll;\nconst llong linf = (llong) 1e+18 + 7ll;\nconst long double eps = (long double) 1e-9;\nconst long double pi = acosl((long double) -1.0);\nconst int alph = 26;\n\nmt19937 mrand(random_device{} ()); \n\ntemplate<typename T, typename U> inline llong umin(const T& a, const U& b) { return a < b ? a : b; }\ntemplate<typename T, typename U> inline llong umax(const T& a, const U& b) { return a > b ? a : b; }\n \nstatic char buff[(int) 2e6 + 17]; // reads std::string\nconst int maxn = (int) 2e2 + 17;\n\nint n;\nllong k;\nllong a[maxn];\n\nbool read()\n{\n\tif (scanf(\"%d %lld\", &n, &k) != 2)\n\t\treturn false;\n\n\tforn (i, n)\n\t\tscanf(\"%lld\", a + i);\n\n\treturn true;\n}\n\nllong z(llong a, llong b) { return (a + b - 1) / b; }\n\nllong get(llong x)\n{\n\tllong res = 0;\n\n\tforn (i, n)\n\t\tres += z(a[i], x);\n\n\treturn res;\n}\n\nvoid solve()\n{\n\tset<llong> ls;\n\n\tforn (i, n)\n\t{\n\t\tvector<llong> t;\n\n\t\tfor (llong j = 1; (j - 1) * (j - 1) <= a[i]; ++j)\n\t\t\tt.push_back(z(a[i], j));\n\n\t\tfor (llong j = 1; j * j <= a[i]; ++j)\n\t\t\tt.push_back(j);\n\n\t\tsort(t.begin(), t.end());\n\t\tt.resize(unique(t.begin(), t.end()) - t.begin());\n\n\t\tforn (i, size(t))\n\t\t\tls.insert(t[i]);\n\t}\n\n\tllong ans = 1, sm = k + accumulate(a, a + n, 0ll);\n\n\tfor (auto p = ls.begin(); p != ls.end(); ++p)\n\t{\n\t\tllong x = *p;\n\t\tllong lq = x;\n\t\tllong rq = (x == *ls.rbegin() ? z(linf, sm) : *ls.upper_bound(x));\n\t\tllong rr = get(lq);\n\t\tllong l = lq, r = rq;\n\n\t\tfor (; l < r; )\n\t\t{\n\t\t\tllong m = (l + r + 1) / 2;\n\n\t\t\tif (m * rr <= sm)\n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m - 1;\n\t\t}\n\n\t\tif (l * rr <= sm)\n\t\t\tans = max(ans, l);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#if SEREZHKA\n\tfreopen(\"file.in\", \"r\", stdin);\n#endif\n\n\twhile (read())\n\t\tsolve();\n\n\treturn 0;\n}\n\n",
        "fixed_code": "#include <bits/stdc++.h>\n \n#define forn(i, n) for (llong i = 0ll; i < (llong) n; ++i)\n#define fornn(i, l, r) for (llong i = (llong) l; i < (llong) r; ++i)\n#define size(x) ((int) (x.size()))\n \nusing namespace std;\n \ntypedef long long llong;\nconst llong inf = (llong) 1e+9 + 7ll;\nconst llong linf = (llong) 1e+18 + 7ll;\nconst long double eps = (long double) 1e-9;\nconst long double pi = acosl((long double) -1.0);\nconst int alph = 26;\n\nmt19937 mrand(random_device{} ()); \n\ntemplate<typename T, typename U> inline llong umin(const T& a, const U& b) { return a < b ? a : b; }\ntemplate<typename T, typename U> inline llong umax(const T& a, const U& b) { return a > b ? a : b; }\n \nstatic char buff[(int) 2e6 + 17]; // reads std::string\nconst int maxn = (int) 2e2 + 17;\n\nint n;\nllong k;\nllong a[maxn];\n\nbool read()\n{\n\tif (scanf(\"%d %lld\", &n, &k) != 2)\n\t\treturn false;\n\n\tforn (i, n)\n\t\tscanf(\"%lld\", a + i);\n\n\treturn true;\n}\n\nllong z(llong a, llong b) { return (a + b - 1) / b; }\n\nllong get(llong x)\n{\n\tllong res = 0;\n\n\tforn (i, n)\n\t\tres += z(a[i], x);\n\n\treturn res;\n}\n\nvoid solve()\n{\n\tset<llong> ls;\n\n\tforn (i, n)\n\t{\n\t\tvector<llong> t;\n\n\t\tfor (llong j = 1; (j - 1) * (j - 1) <= a[i]; ++j)\n\t\t\tt.push_back(z(a[i], j));\n\n\t\tfor (llong j = 1; j * j <= a[i]; ++j)\n\t\t\tt.push_back(j);\n\n\t\tsort(t.begin(), t.end());\n\t\tt.resize(unique(t.begin(), t.end()) - t.begin());\n\n\t\tforn (i, size(t))\n\t\t\tls.insert(t[i]);\n\t}\n\n\tllong ans = 1, sm = k + accumulate(a, a + n, 0ll);\n\n\tfor (auto p = ls.begin(); p != ls.end(); ++p)\n\t{\n\t\tllong x = *p;\n\t\tllong rr = get(x);\n\t\tllong lq = x;\n\t\tllong rq = (x == *ls.rbegin() ? z(sm, rr) : *ls.upper_bound(x));\n\t\tllong l = lq, r = rq;\n\n\t\tfor (; l < r; )\n\t\t{\n\t\t\tllong m = (l + r + 1) / 2;\n\n\t\t\tif (m * rr <= sm)\n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m - 1;\n\t\t}\n\n\t\tif (l * rr <= sm)\n\t\t\tans = max(ans, l);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#if SEREZHKA\n\tfreopen(\"file.in\", \"r\", stdin);\n#endif\n\n\twhile (read())\n\t\tsolve();\n\n\treturn 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std ;\nconst int maxn = 520 ;\nconst int mmax = 250005 ;\nstruct Node\n{\n    int sc , xx ; \n};\nNode A[maxn] ;\nint nowcnt = 0 , a[mmax] , ans[maxn] , ccnt = 0 ;\n\nvoid ins(int val)\n{\n    for (int i = 0 ; i < nowcnt ; ++ i) {\n        if (A[i].xx == val) {\n            A[i].sc ++ ;\n            return ;\n        }\n    }\n    A[nowcnt].xx = val ;\n    A[nowcnt++].sc = 1 ;\n}\n\nint fi(int val)\n{\n    for (int i =  0 ; i < nowcnt ; ++ i) {\n        if (A[i].xx == val) return i ;\n    }\n    return 0 ;\n}\n\nbool cmp(const int &x_ , const int &y_)\n{\n    if (x_ < y_) return false ;\n    return true ;\n}\n\nint gcd(int x_,int y_)\n{\n    return (y_ == 0 ? x_ : gcd(y_,x_%y_)) ;\n}\n\nvoid sol(int val)\n{\n    int gg , id ;\n    for (int i = 0 ; i < ccnt ; ++ i) {\n        gg = gcd(val,ans[i]) ;\n        id = fi(gg) ;\n        A[id].sc -= 2 ;\n    }\n}\n\nint main()\n{\n    int n , N ;\n    cin >> n ;\n    N = n * n ;\n    for (int i =  0 ; i < N ; ++ i) {\n        scanf(\"%d\",&a[i]) ;\n        ins(a[i]) ;\n    }\n    sort(a,a+N,cmp) ;\n    ans[ccnt++] = a[0] ;\n    int id , tmpnum ;\n    id = fi(a[0]) ;\n    A[id].sc -- ;\n    for (int i = 1 ; i < N ; ++ i) {\n        id = fi(a[i]) ;\n         tmpnum = A[id].sc ;\n        if (tmpnum <= 0) continue ;\n        else {\n            sol(a[i]) ;\n            ans[ccnt++] = a[i] ;\n            id = fi(a[i]) ;\n            A[id].sc -- ;\n        }\n    }\n    for (int i = 0 ; i < ccnt ; ++ i) {\n        printf(\"%d \", ans[i]);\n    }\n    puts(\"\") ;\n    return 0 ;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "fixed_code": "\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std ;\n#define LL long long\n#define rep(i,n) for (int i = 0 ; i < n ; ++ i)\n#define REP(i,n) for (int i = n - 1 ; i >= 0 ; i --)\nconst int maxn = 250010 ;\nLL in[maxn] , n , N , ans[maxn] , anscnt , A[maxn] , cnt , x , y , g , nu[maxn] ;\n\ninline LL gcd(LL a,LL b)\n{\n    return (b == 0 ? a : gcd(b,a%b)) ;\n}\n\nbool cmp(LL a,LL b)\n{\n    return b < a ;\n}\n\ninline int ser(LL x)\n{\n    int le = 0 , ri = cnt - 1 , mid ;\n    while (le <= ri) {\n        mid = (le + ri)/2 ;\n        if (x > A[mid]) ri = mid - 1 ;\n        else if (x < A[mid]) le = mid + 1 ;\n        else return mid ;\n    }\n    return -1 ;\n}\n\nint main()\n{\n  //  freopen(\"in.txt\",\"r\",stdin) ;\n    while (scanf(\"%I64d\",&N) == 1) {\n        n = N*N , cnt = anscnt = 0 ;\n        memset(nu,0,sizeof(nu)) ;\n        rep(i,n) {\n            scanf(\"%I64d\",&in[i]) ;\n        }\n        sort(in,in+n,cmp) ;\n        A[cnt] = in[0] , nu[cnt] = 1 ;\n        for (int i = 1 ; i < n ; ++ i) {\n            if (in[i] == in[i-1]) nu[cnt] ++ ;\n            else cnt++ , A[cnt] = in[i] , nu[cnt] = 1 ;\n        }\n        cnt ++ ;\n    //    rep(i,cnt) printf(\"%I64d %I64d\\n\",A[i],nu[i]) ;\n        ans[anscnt++] = A[0] , nu[0] -- ;\n        int id ;\n        rep(i,cnt) {\n            while (nu[i] > 0) {\n                x = A[i] ;\n                rep(j,anscnt) {\n                    y = ans[j] ;\n                    g = gcd(x,y) ;\n                    id = ser(g) ;\n                    if (id >= i && id < cnt) nu[id] -= 2 ;\n                }\n                ans[anscnt++] = x ;\n                nu[i] -- ;\n            }\n        }\n        rep(i,anscnt) printf(\"%I64d \",ans[i]) ;\n        puts(\"\") ;\n    }\n    return 0 ;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CodeForces {\n\t\n\tpublic static void main(String[] args) {\n\t\tInputReader inp = new InputReader(System.in);\n\t\tint n = inp.nextInt();\n\t\tint a = 1, b = 0;\n\t\tString t1,t = \"\";\n\t\tt1 = inp.next();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tt = inp.next();\n\t\t\tif (t1.equals(t)) {\n\t\t\t\ta++;\n\t\t\t} else {\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a > b ? t1 : t);\n\t}\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}",
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CodeForces {\n\t\n\tpublic static void main(String[] args) {\n\t\tInputReader inp = new InputReader(System.in);\n\t\tint n = inp.nextInt();\n\t\tint a = 1, b = 0;\n\t\tString t1, t, t2 = \"\";\n\t\tt1 = inp.next();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tt = inp.next();\n\t\t\tif (t1.equals(t)) {\n\t\t\t\ta++;\n\t\t\t} else {\n\t\t\t\tt2 = t;\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a > b ? t1 : t2);\n\t}\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\r\nusing namespace std;\r\nint main(){\r\n\tlong long a, b[500], c[500][600];\r\n\tcin>>a;\r\n\tfor(int i=0;i<a;i++){\r\n\t\tcin>>b[i];\r\n\t\tfor(int ii=0;ii<b[i];ii++){\r\n\t\t\tcin>>c[i][ii];\r\n\t\t}\r\n\t}\r\n\r\n\tfor(int i=0;i<a;i++){\r\n\t\t\r\n\t\tfor(int ii=0;ii<b[i];ii++){\r\n\t\t\tif(c[i][ii]%2){\r\n\t\t\t\tcout<<c[i][ii]<<\" \";\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int ii=0;ii<b[i];ii++){\r\n\t\t\tif(c[i][ii]%2==0||c[i][ii]==0){\r\n\t\t\t\tcout<<c[i][ii]<<\" \";\r\n\t\t\t}\r\n\t\t}\r\n\t\tcout<<endl;\r\n\t}\r\n\treturn 0;\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\nint main(){\r\n\tint t = 0;  //t组数据\r\n\tcin >> t;\r\n\tint n = 0, num[2000] = {0};\r\n\t\r\n\tfor(int i = 0; i < t; i++){\r\n\t\tcin >> n;\r\n\t\tfor(int j = 0; j < n; j++){\r\n\t\t\tcin >> num[j];\r\n\t\t}\r\n\t\tfor(int j = 0; j < n; j++){\r\n\t\t\tif(num[j] % 2 != 0){\r\n\t\t\t\tcout << num[j] << \" \";\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int j = 0; j < n; j++){\r\n\t\t\tif(num[j] % 2 == 0){\r\n\t\t\t\tcout << num[j] << \" \";\r\n\t\t\t}\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\t\r\n\t\r\n\treturn 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@org.parboiled.annotations.SuppressSubnodes\npublic org.parboiled.Rule NamedParameter() {\n    org.parboiled.support.StringVar name = new org.parboiled.support.StringVar(\"\");\n    return Sequence(ParameterBeginDelimiter(), Sequence(OneOrMore(Letter()), ZeroOrMore(Digit())), name.set(match()), getAdapter().addNamedParameter(name.get(), currentIndex()));\n}",
        "fixed_code": "@org.parboiled.annotations.SuppressSubnodes\npublic org.parboiled.Rule NamedParameter() {\n    org.parboiled.support.StringVar name = new org.parboiled.support.StringVar(\"\");\n    return Sequence(ParameterBeginDelimiter(), Sequence(OneOrMore(Letter()), ZeroOrMore(Digit())), name.set(match()), adapter.addNamedParameter(name.get(), currentIndex()));\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n<CodeBlocks_project_file>\n\t<FileVersion major=\"1\" minor=\"6\" />\n\t<Project>\n\t\t<Option title=\"766D\" />\n\t\t<Option pch_mode=\"2\" />\n\t\t<Option compiler=\"gcc\" />\n\t\t<Build>\n\t\t\t<Target title=\"Debug\">\n\t\t\t\t<Option output=\"bin/Debug/766D\" prefix_auto=\"1\" extension_auto=\"1\" />\n\t\t\t\t<Option object_output=\"obj/Debug/\" />\n\t\t\t\t<Option type=\"1\" />\n\t\t\t\t<Option compiler=\"gcc\" />\n\t\t\t\t<Compiler>\n\t\t\t\t\t<Add option=\"-g\" />\n\t\t\t\t</Compiler>\n\t\t\t</Target>\n\t\t\t<Target title=\"Release\">\n\t\t\t\t<Option output=\"bin/Release/766D\" prefix_auto=\"1\" extension_auto=\"1\" />\n\t\t\t\t<Option object_output=\"obj/Release/\" />\n\t\t\t\t<Option type=\"1\" />\n\t\t\t\t<Option compiler=\"gcc\" />\n\t\t\t\t<Compiler>\n\t\t\t\t\t<Add option=\"-O2\" />\n\t\t\t\t</Compiler>\n\t\t\t\t<Linker>\n\t\t\t\t\t<Add option=\"-s\" />\n\t\t\t\t</Linker>\n\t\t\t</Target>\n\t\t</Build>\n\t\t<Compiler>\n\t\t\t<Add option=\"-Wall\" />\n\t\t\t<Add option=\"-fexceptions\" />\n\t\t</Compiler>\n\t\t<Unit filename=\"766D.cpp\" />\n\t\t<Extensions>\n\t\t\t<code_completion />\n\t\t\t<envvars />\n\t\t\t<debugger />\n\t\t\t<lib_finder disable_auto=\"1\" />\n\t\t</Extensions>\n\t</Project>\n</CodeBlocks_project_file>\n",
        "fixed_code": "#include <iostream>\n#include <stdio.h>\n#include <map>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nchar s[50];\ninline void read(int &x){\n    x=0;char ch;bool flag = false;\n    while(ch=getchar(),ch<'!');if(ch == '-') ch=getchar(),flag = true;\n    while(x=10*x+ch-'0',ch=getchar(),ch>'!');if(flag) x=-x;\n}\nconst int maxn = 100010;\nint fa[maxn],num[maxn];\ninline int find(int x){\n    int f = x;while(f != fa[f]) f = fa[f];\n    int y = fa[x],z;\n    while(y != f){\n        z = fa[x];\n        while(z != f){\n            num[x] ^= num[z];\n            z = fa[z];\n        }fa[x] = f;\n        x = y;y = fa[x];\n    }return f;\n}\nconst int maxnode = maxn*22 + 10;\nint ch[maxnode][27],idx[maxnode],nodecnt;\ninline void insert(int x){\n    scanf(\"%s\",s);\n    int nw = 0;\n    for (int i = 0;i < strlen(s) ;i++)\n    {\n        if(ch[nw][s[i] - 'a'] == 0) ch[nw][s[i] - 'a'] = ++nodecnt;\n        nw = ch[nw][s[i] - 'a'];\n    }\n    idx[nw] = x;\n}\ninline int query(){\n    char c;while(c = getchar(),c<'!');\n    int nw = 0;\n    while(c >= 'a' && c <= 'z'){\n        nw = ch[nw][c - 'a'];\n        c = getchar();\n    }return idx[nw];\n}\nint main(){\n    int n,m,q;\n    scanf(\"%d %d %d\",&n,&m,&q);\n    for(int i=1;i<=n;++i){\n        insert(i);\n        fa[i] = i;\n    }\n    for(int i=1,c;i<=m;++i){\n        read(c);--c;\n        int x = query();\n        int y = query();\n        //printf(\"linking %d %d\\n\",x,y);\n        int fx = find(x);\n        int fy = find(y);\n        if(fx == fy){\n            if( (c == 0) == (num[x] == num[y]) ) puts(\"YES\");\n            if( (c == 0) != (num[x] == num[y]) ) puts(\"NO\");\n        }else{\n            fa[fx] = fy;\n            if(num[x]^num[y] == c) num[fx] = 0;\n            else num[fx] = 1;\n            puts(\"YES\");\n        }\n    }\n    while(q--){\n        int x = query();\n        int y = query();\n        int fx = find(x);\n        int fy = find(y);\n        if(fx != fy) puts(\"3\");\n        else printf(\"%d\\n\",(num[x] != num[y]) + 1);\n    }\n    getchar();getchar();\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public java.util.List<ru.runa.wfe.task.dto.WfTask> getTasks(ru.runa.wfe.user.User user, ru.runa.wfe.presentation.BatchPresentation batchPresentation) {\n    if ((batchPresentation.getClassPresentation()) instanceof ru.runa.wfe.task.TaskObservableClassPresentation) {\n        return taskListBuilder.getTasks(user.getActor(), batchPresentation);\n    }\n    if (!(executorLogic.isAdministrator(user))) {\n        throw new ru.runa.wfe.security.AuthorizationException((user + \" is not Administrator\"));\n    }\n    com.google.common.base.Preconditions.checkNotNull(batchPresentation, \"batchPresentation\");\n    ru.runa.wfe.user.Actor actor = user.getActor();\n    java.util.List<ru.runa.wfe.task.dto.WfTask> result = com.google.common.collect.Lists.newArrayList();\n    java.util.List<ru.runa.wfe.task.Task> tasks = new ru.runa.wfe.presentation.hibernate.PresentationCompiler<ru.runa.wfe.task.Task>(batchPresentation).getBatch(ru.runa.wfe.presentation.hibernate.CompilerParameters.createNonPaged());\n    for (ru.runa.wfe.task.Task task : tasks) {\n        try {\n            result.add(taskObjectFactory.create(task, actor, false, batchPresentation.getDynamicFieldsToDisplay(true)));\n        } catch (java.lang.Exception e) {\n            log.error((\"Unable to build \" + task), e);\n        }\n    }\n    return result;\n}",
        "fixed_code": "public java.util.List<ru.runa.wfe.task.dto.WfTask> getTasks(ru.runa.wfe.user.User user, ru.runa.wfe.presentation.BatchPresentation batchPresentation) {\n    if ((batchPresentation.getClassPresentation()) instanceof ru.runa.wfe.task.TaskObservableClassPresentation) {\n        return taskListBuilder.getObservableTasks(user.getActor(), batchPresentation);\n    }\n    if (!(executorLogic.isAdministrator(user))) {\n        throw new ru.runa.wfe.security.AuthorizationException((user + \" is not Administrator\"));\n    }\n    com.google.common.base.Preconditions.checkNotNull(batchPresentation, \"batchPresentation\");\n    ru.runa.wfe.user.Actor actor = user.getActor();\n    java.util.List<ru.runa.wfe.task.dto.WfTask> result = com.google.common.collect.Lists.newArrayList();\n    java.util.List<ru.runa.wfe.task.Task> tasks = new ru.runa.wfe.presentation.hibernate.PresentationCompiler<ru.runa.wfe.task.Task>(batchPresentation).getBatch(ru.runa.wfe.presentation.hibernate.CompilerParameters.createNonPaged());\n    for (ru.runa.wfe.task.Task task : tasks) {\n        try {\n            result.add(taskObjectFactory.create(task, actor, false, batchPresentation.getDynamicFieldsToDisplay(true)));\n        } catch (java.lang.Exception e) {\n            log.error((\"Unable to build \" + task), e);\n        }\n    }\n    return result;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "private void updateReadWPList(is.erle.mavlink.msg_mission_item mavMissionItem, byte tSystem, byte tComponent) {\n    java.lang.String[] tempWP = new java.lang.String[12];\n    tempWP[0] = java.lang.Short.toString(mavMissionItem.seq);\n    tempWP[1] = java.lang.Byte.toString(mavMissionItem.current);\n    tempWP[2] = java.lang.Byte.toString(mavMissionItem.frame);\n    tempWP[3] = java.lang.Short.toString(mavMissionItem.command);\n    tempWP[4] = java.lang.Float.toString(mavMissionItem.param1);\n    tempWP[5] = java.lang.Float.toString(mavMissionItem.param2);\n    tempWP[6] = java.lang.Float.toString(mavMissionItem.param3);\n    tempWP[7] = java.lang.Float.toString(mavMissionItem.param4);\n    tempWP[8] = java.lang.Float.toString(mavMissionItem.x);\n    tempWP[9] = java.lang.Float.toString(mavMissionItem.y);\n    tempWP[10] = java.lang.Float.toString(mavMissionItem.z);\n    tempWP[11] = java.lang.Byte.toString(mavMissionItem.autocontinue);\n    readWaypointList.add(tempWP);\n    if ((readWaypointCount) == ((mavMissionItem.seq) + 1)) {\n        sendMissionAck(((byte) (MAV_MISSION_RESULT.MAV_MISSION_ACCEPTED)));\n        readWaypointCount = -1;\n    }else {\n        sendWPRequest(((short) ((mavMissionItem.seq) + 1)), tSystem, tComponent);\n    }\n}",
        "fixed_code": "private void updateReadWPList(is.erle.mavlink.msg_mission_item mavMissionItem, byte tSystem, byte tComponent) {\n    java.lang.String[] tempWP = new java.lang.String[12];\n    tempWP[0] = java.lang.Short.toString(mavMissionItem.seq);\n    tempWP[1] = java.lang.Byte.toString(mavMissionItem.current);\n    tempWP[2] = java.lang.Byte.toString(mavMissionItem.frame);\n    tempWP[3] = java.lang.Short.toString(mavMissionItem.command);\n    tempWP[4] = java.lang.Float.toString(mavMissionItem.param1);\n    tempWP[5] = java.lang.Float.toString(mavMissionItem.param2);\n    tempWP[6] = java.lang.Float.toString(mavMissionItem.param3);\n    tempWP[7] = java.lang.Float.toString(mavMissionItem.param4);\n    tempWP[8] = java.lang.Float.toString(mavMissionItem.x);\n    tempWP[9] = java.lang.Float.toString(mavMissionItem.y);\n    tempWP[10] = java.lang.Float.toString(mavMissionItem.z);\n    tempWP[11] = java.lang.Byte.toString(mavMissionItem.autocontinue);\n    if (!(readWaypointList.isEmpty())) {\n        if (!(readWaypointList.get(((readWaypointList.size()) - 1))[0].equals(tempWP[0]))) {\n            readWaypointList.add(tempWP);\n        }\n    }else {\n        readWaypointList.add(tempWP);\n    }\n    if ((readWaypointCount) == ((mavMissionItem.seq) + 1)) {\n        sendMissionAck(((byte) (MAV_MISSION_RESULT.MAV_MISSION_ACCEPTED)));\n        readWaypointCount = -1;\n    }else {\n        sendWPRequest(((short) ((mavMissionItem.seq) + 1)), tSystem, tComponent);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "n = int(input())\narr = (list(map(int, input().split())))\narr=sorted(ls)\nfor i in range(1, n):\n    if i%2==1 and i != n - 1:\n        arr[i], arr[i+1] = arr[i+1], arr[i]\nprint(*arr)",
        "fixed_code": "n = int(input())\narr = (list(map(int, input().split())))\narr=sorted(arr)\nfor i in range(1, n):\n    if i%2==1 and i != n - 1:\n        arr[i], arr[i+1] = arr[i+1], arr[i]\nprint(*arr)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "import java.io.*;\r\nimport java.util.*;\r\nimport java.text.*;\r\nimport java.math.*;\r\nimport java.util.regex.*;\r\nimport java.awt.Point;\r\n\r\npublic class Main {  \r\n  public static void main(String args[]) { \r\n    \r\n    Scanner sc = new Scanner(System.in);\r\n    String p = sc.nextLine();\r\n    int tc = Integer.parseInt(p.charAt(0));\r\n    int sum1 = 0, sum2 = 0;\r\n\r\n    for(int t = 0; t < tc; t++){\r\n      \r\n      String line = sc.nextLine();\r\n      sum1 = sum2 = 0;\r\n      \r\n      for(int i = 0; i < 3; i++){\r\n        sum1 += Character.getNumericValue(line.charAt(i));\r\n        sum2 += Character.getNumericValue(line.charAt(5-i));\r\n      }\r\n      \r\n      if(sum1 == sum2)\r\n        System.out.println(\"Yes\");\r\n      else\r\n        System.out.println(\"No\");\r\n      \r\n    }\r\n    \r\n  } \r\n}",
        "fixed_code": "import java.io.*;\r\nimport java.util.*;\r\nimport java.text.*;\r\nimport java.math.*;\r\nimport java.util.regex.*;\r\nimport java.awt.Point;\r\n\r\npublic class Main {  \r\n  public static void main(String args[]) { \r\n    \r\n    Scanner sc = new Scanner(System.in);\r\n    \r\n    String p = sc.nextLine();\r\n    int tc = Integer.parseInt(p);\r\n    \r\n    int length = 6;\r\n    int sum1 = 0, sum2 = 0;\r\n\r\n    for(int t = 0; t < tc; t++){\r\n      \r\n      String line = sc.nextLine();\r\n\r\n      sum1 = sum2 = 0;\r\n      for(int i = 0; i < length/2; i++){\r\n        sum1 +=             \r\n        Character.getNumericValue(line.charAt(i));\r\n        sum2 +=   \r\n        Character.getNumericValue(line.charAt(length-1-i));\r\n      }\r\n      if(sum1 == sum2)\r\n        System.out.println(\"Yes\");\r\n      else\r\n        System.out.println(\"No\");\r\n      \r\n    }\r\n    \r\n  } \r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "import java.awt.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Abc {\n    static int n,m,k;\n    static char[] s,t;\n    static int dp[][][][];\n    public static void main(String[] args) throws Exception {\n//        FastReader sc = new FastReader();\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        n=Integer.parseInt(st.nextToken());\n        m=Integer.parseInt(st.nextToken());\n        k=Integer.parseInt(st.nextToken());\n        s=bf.readLine().toCharArray();\n        t=bf.readLine().toCharArray();\n//        dp=new int[n][m][k+1][2];\n////        for (int ar[][][]:dp){\n////            for (int arr[][]:ar){\n////                for (int a[]:arr)Arrays.fill(a,-1);\n////            }\n////        }\n        dp = new int[n+1][m+1][k+1][2];\n        for (int i =0 ; i < n+1; i++)\n            for (int j = 0; j < m + 1; j++)\n                for (int l = 0; l < k + 1; l++)\n                    Arrays.fill(dp[i][j][l], -1);\n        System.out.println(dp(0,0,0,0));\n    }\n    static int dp(int i,int j,int rem,int con){\n        if (rem>=k || i>=n || j>=m)return 0;\n        if (dp[i][j][rem][con]!=-1)return dp[i][j][rem][con];\n        if (con==1){\n            dp[i][j][rem][con]=dp(i,j,rem+1,0);\n        }else {\n            dp[i][j][rem][con]=Math.max(dp(i+1,j,rem,0),dp(i,j+1,rem,0));\n        }\n        if (s[i]==t[j])dp[i][j][rem][con]=Math.max(dp(i+1,j+1,rem,1)+1,dp[i][j][rem][con]);\n        return dp[i][j][rem][con];\n    }\n//static int dp(int b, int rem, int i, int j) {\n//    if (rem >=k  || i >= n || j >= m)\n//        return 0;\n//    if (dp[b][rem][i][j] != -1)\n//        return dp[b][rem][i][j];\n//    if (b == 1)\n//        dp[b][rem][i][j] = dp(0, rem + 1, i, j);\n//    else\n//        dp[b][rem][i][j] = Math.max(dp(0, rem, i + 1, j), dp(0, rem, i, j + 1));\n//    if (s[i] == t[j])\n//        dp[b][rem][i][j] = Math.max(dp[b][rem][i][j], 1 + dp(1, rem, i + 1, j + 1));\n//    return dp[b][rem][i][j];\n//}\n\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}",
        "fixed_code": "import java.awt.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Abc {\n    static int n,m,k;\n    static char[] s,t;\n    static int dp[][][][];\n\n    public static void main(String[] args) throws Exception {\n        FastReader sc = new FastReader();\n        n=sc.nextInt();\n        m=sc.nextInt();\n        k=sc.nextInt();\n        s=sc.next().toCharArray();\n        t=sc.next().toCharArray();\n        dp=new int[2][11][n][m];\n        for (int ar[][][]:dp){\n            for (int arr[][]:ar){\n                for (int a[]:arr)Arrays.fill(a,-1);\n            }\n        }\n        System.out.println(dp(0,0,k,0));\n    }\n    static int dp(int i,int j,int rem,int con){\n        if (i>=n || j>=m)return 0;\n        if (rem==0 && con==0)return 0;\n        if (dp[con][rem][i][j]!=-1)return dp[con][rem][i][j];\n        dp[con][rem][i][j]=Math.max(dp(i+1,j,rem,0),dp(i,j+1,rem,0));\n        if (con==1){\n            if (s[i]==t[j]) {\n                dp[con][rem][i][j] = Math.max(dp[con][rem][i][j],dp(i+1,j+1,rem,1)+1);\n            }\n        }else {\n            if (s[i]==t[j])dp[con][rem][i][j]=Math.max(dp(i+1,j+1,rem-1,1)+1,dp[con][rem][i][j]);\n        }\n        return dp[con][rem][i][j];\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "//never use ioss and scanf together .\n#include <bits/stdc++.h>\nusing namespace std;\n\n//typedef  long long ll;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int ;\nusing ull = unsigned long long;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define endl \"\\n\"\n#define ioss ios::sync_with_stdio(false);cin.tie(NULL);\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n//#define all(x) x.begin(),x.end();\n//#define fi first\n//#define se second\n\ndouble startTime;\ndouble getCurrentTime()\n{\n    return ((double)clock()-startTime)/CLOCKS_PER_SEC;\n}\n\n\n\n\n\n\n\n\n\nvoid suraj()\n{//if n is odd then....(n-1)/2   1median     (n-1)/2\nint n,k,p,x,y;cin>>n>>k>>p>>x>>y;\nint less=0;//less than y;\nint notless=0;//>=y\nint sum=0;\nvector<int>vk(k);for(int &i:vk){cin>>i;sum+=i;if(i<y)less++;else notless++;}\nif(less>(n-1)/2)cout<<-1<<endl;\nelse{\n    vector<int>ansv;\n    int rem=(n-1)/2-less;\n    for(int i=0;i<rem;i++)ansv.pb(1);\n    rem=((n-1)/2+1)-notless;\n    for(int i=0;i<rem;i++){\n        ansv.pb(y);\n    }\n    for(int i:ansv)sum+=i;//cout<<sum<<endl;\n    if(sum>x)cout<<-1<<endl;\n    else{\n        for(int j:ansv)cout<<j<<\" \";cout<<endl;\n    }\n}\n\n\n\n\n}\n\n\n\n\n\n\n\nint main()\n{\n    startTime=(double)clock();\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt,\"w\",stdout);\n    ioss\n    //int t;cin>>t;while(t--)\n    suraj();\n    return 0;\n}\n",
        "fixed_code": "//never use ioss and scanf together .\n#include <bits/stdc++.h>\nusing namespace std;\n\n//typedef  long long ll;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int ;\nusing ull = unsigned long long;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define endl \"\\n\"\n#define ioss ios::sync_with_stdio(false);cin.tie(NULL);\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n//#define all(x) x.begin(),x.end();\n//#define fi first\n//#define se second\n\ndouble startTime;\ndouble getCurrentTime()\n{\n    return ((double)clock()-startTime)/CLOCKS_PER_SEC;\n}\n\n\n\n\n\n\n\n\n\nvoid suraj()\n{//if n is odd then....(n-1)/2   1median     (n-1)/2\nint n,k,p,x,y;cin>>n>>k>>p>>x>>y;\nint less=0;//less than y;\nint notless=0;//>=y\nint sum=0;\nvector<int>vk(k);for(int &i:vk){cin>>i;sum+=i;if(i<y)less++;else notless++;}\nif(less>(n-1)/2)cout<<-1<<endl;\nelse{\n    vector<int>ansv;\n    int rem1=(n-1)/2-less;\n    //for(int i=0;i<rem1;i++)ansv.pb(1);\n    int rem2=((n-1)/2+1)-notless;\n    if(rem2<0){\n        rem1=rem1-(-rem2);rem2=0;\n    }\n    for(int i=0;i<rem1;i++)ansv.pb(1);\n    for(int i=0;i<rem2;i++){\n        ansv.pb(y);\n    }\n    for(int i:ansv)sum+=i;//cout<<sum<<endl;\n    if(sum>x)cout<<-1<<endl;\n    else{\n        for(int j:ansv)cout<<j<<\" \";cout<<endl;\n    }\n}\n\n\n\n\n}\n\n\n\n\n\n\n\nint main()\n{\n    startTime=(double)clock();\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt,\"w\",stdout);\n    ioss\n    //int t;cin>>t;while(t--)\n    suraj();\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public boolean isEmpty() {\n    return (first) == null;\n}",
        "fixed_code": "public void addFirst(Item item) {\n    if (item == null)\n        throw new java.lang.NullPointerException();\n    \n    Deque<Item>.Node oldFirst = first;\n    first = new Node();\n    first.item = item;\n    first.prev = null;\n    first.next = oldFirst;\n    if (isEmpty()) {\n        last = first;\n    }else {\n        oldFirst.prev = first;\n    }\n    (n)++;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\n#define oo (100000000000000000)\n\n#define ff first\n#define ss second\n#define mp make_pair\n\nusing namespace std;\n\nvector<pair<int, long long> > g[1000006]; // vx, cost\n\nlong long dist[1000006];\n\nclass Segtree{\n\tvector<int> st;\n\tint n;\n\n\tvector<int> ans;\n\n\tvoid get(int p, int L, int R, int i, int j){\n\t\tif(j < L || i > R) return;\n\t\tif(i <= L && R <= j){\n\t\t\t// CONSIDERA\n\t\t\tans.push_back(n+p);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tget(2*p, L, mid, i, j);\n\t\tget(2*p+1, mid+1, R, i, j);\n\t}\n\n\tvoid init(int p, int L, int R){\n\t\tif(L == R){\n\t\t\t// g[L].push_back(mp(n+p,0));\n\t\t\tg[n+p].push_back(mp(L,0));\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tinit(2*p, L, mid);\n\t\tinit(2*p+1, mid+1, R);\n\n\t\tfor(int i = L; i <= R; i++){\n\t\t\tg[n+p].push_back(mp(i, 0));\n\t\t\t// g[i].push_back(mp(n+p, 0));\n\t\t}\n\t}\n\npublic:\n\tSegtree(int size = 0) : n(size), st(4*(size+5), 0){\n\t\tinit(1, 1, n);\n\t}\n\n\tvector<int> get(int i, int j){\n\t\tans.clear();\n\t\tget(1, 1, n, i, j);\n\t\treturn ans;\n\t}\n};\n\nclass Segtree2{\n\tvector<int> st;\n\tint n;\n\n\tvector<int> ans;\n\n\tvoid get(int p, int L, int R, int i, int j){\n\t\tif(j < L || i > R) return;\n\t\tif(i <= L && R <= j){\n\t\t\t// CONSIDERA\n\t\t\tans.push_back(5*n+p);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tget(2*p, L, mid, i, j);\n\t\tget(2*p+1, mid+1, R, i, j);\n\t}\n\n\tvoid init(int p, int L, int R){\n\t\tif(L == R){\n\t\t\tg[L].push_back(mp(5*n+p,0));\n\t\t\t// g[5*n+p].push_back(mp(L,0));\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tinit(2*p, L, mid);\n\t\tinit(2*p+1, mid+1, R);\n\n\t\tfor(int i = L; i <= R; i++){\n\t\t\t// g[5*n+p].push_back(mp(i, 0));\n\t\t\tg[i].push_back(mp(5*n+p, 0));\n\t\t}\n\t}\n\npublic:\n\tSegtree2(int size = 0) : n(size), st(4*(size+5), 0){\n\t\tinit(1, 1, n);\n\t}\n\n\tvector<int> get(int i, int j){\n\t\tans.clear();\n\t\tget(1, 1, n, i, j);\n\t\treturn ans;\n\t}\n};\n\n\nvoid dijsktra(int s){\n\n\tfor(int i = 0; i < 600005; i++)\n\t\tdist[i] = oo;\n\n\tpriority_queue<pair<long long, int> > q;\n\tdist[s] = 0;\n\tq.push(mp(0LL, s));\n\n\twhile(!q.empty()){\n\t\tlong long d = -q.top().ff;\n\t\tint u = q.top().ss; q.pop();\n\n\t\tfor(int i = 0; i < (int)g[u].size(); i++){\n\t\t\tint v = g[u][i].ff;\n\t\t\tlong long w = d + g[u][i].ss;\n\n\t\t\tif(dist[v] > w){\n\t\t\t\tdist[v] = w;\n\t\t\t\tq.push(mp(-w, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, q, s;\n\n\tscanf(\"%d %d %d\", &n, &q, &s);\n\n\tSegtree st(n);\n\tSegtree2 st2(n);\n\n\tint t, u, v, l, r;\n\tlong long w;\n\tfor(int i = 0; i < q; i++){\n\t\tscanf(\"%d\", &t);\n\t\tif(t == 1){\n\t\t\tscanf(\"%d %d %lld\", &u, &v, &w);\n\t\t\tg[u].push_back(mp(v, w));\n\t\t}\n\t\telse if(t == 2){\n\t\t\tscanf(\"%d %d %d %lld\", &v, &l, &r, &w);\n\t\t\tvector<int> tmp = st.get(l, r);\n\t\t\tfor(int j = 0; j < (int)tmp.size(); j++){\n\t\t\t\tg[v].push_back(mp(tmp[j], w));\n\t\t\t}\n\t\t}\n\t\telse if(t == 3){\n\t\t\tscanf(\"%d %d %d %lld\", &v, &l, &r, &w);\n\t\t\tvector<int> tmp = st2.get(l, r);\n\t\t\tfor(int j = 0; j < (int)tmp.size(); j++){\n\t\t\t\tg[tmp[j]].push_back(mp(v, w));\n\t\t\t}\n\t\t}\n\t}\n\n\tdijsktra(s);\n\n\tfor(int i = 1; i <= n; i++)\n\t\tprintf(\"%lld \", dist[i] == oo ? -1 : dist[i]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\n\n#define oo (100000000000000000)\n\n#define ff first\n#define ss second\n#define mp make_pair\n\nusing namespace std;\n\nconst int limit = 2000006;\n\nvector<pair<int, long long> > g[limit]; // vx, cost\n\nlong long dist[limit];\n\nclass Segtree{\n\tvector<int> st;\n\tint n;\n\n\tvector<int> ans;\n\n\tvoid get(int p, int L, int R, int i, int j){\n\t\tif(j < L || i > R) return;\n\t\tif(i <= L && R <= j){\n\t\t\t// CONSIDERA\n\t\t\tans.push_back(n+p);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tget(2*p, L, mid, i, j);\n\t\tget(2*p+1, mid+1, R, i, j);\n\t}\n\n\tvoid init(int p, int L, int R){\n\t\tif(L == R){\n\t\t\t// g[L].push_back(mp(n+p,0));\n\t\t\tg[n+p].push_back(mp(L,0));\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tinit(2*p, L, mid);\n\t\tinit(2*p+1, mid+1, R);\n\n\t\tfor(int i = L; i <= R; i++){\n\t\t\tg[n+p].push_back(mp(i, 0));\n\t\t\t// g[i].push_back(mp(n+p, 0));\n\t\t}\n\t}\n\npublic:\n\tSegtree(int size = 0) : n(size), st(4*(size+5), 0){\n\t\tinit(1, 1, n);\n\t}\n\n\tvector<int> get(int i, int j){\n\t\tans.clear();\n\t\tget(1, 1, n, i, j);\n\t\treturn ans;\n\t}\n};\n\nclass Segtree2{\n\tvector<int> st;\n\tint n;\n\n\tvector<int> ans;\n\n\tvoid get(int p, int L, int R, int i, int j){\n\t\tif(j < L || i > R) return;\n\t\tif(i <= L && R <= j){\n\t\t\t// CONSIDERA\n\t\t\tans.push_back(8*n+p);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tget(2*p, L, mid, i, j);\n\t\tget(2*p+1, mid+1, R, i, j);\n\t}\n\n\tvoid init(int p, int L, int R){\n\t\tif(L == R){\n\t\t\tg[L].push_back(mp(8*n+p,0));\n\t\t\t// g[8*n+p].push_back(mp(L,0));\n\t\t\treturn;\n\t\t}\n\t\tint mid = (L+R)/2;\n\t\tinit(2*p, L, mid);\n\t\tinit(2*p+1, mid+1, R);\n\n\t\tfor(int i = L; i <= R; i++){\n\t\t\t// g[8*n+p].push_back(mp(i, 0));\n\t\t\tg[i].push_back(mp(8*n+p, 0));\n\t\t}\n\t}\n\npublic:\n\tSegtree2(int size = 0) : n(size), st(4*(size+5), 0){\n\t\tinit(1, 1, n);\n\t}\n\n\tvector<int> get(int i, int j){\n\t\tans.clear();\n\t\tget(1, 1, n, i, j);\n\t\treturn ans;\n\t}\n};\n\n\nvoid dijsktra(int s){\n\n\tfor(int i = 0; i < limit; i++)\n\t\tdist[i] = oo;\n\n\tpriority_queue<pair<long long, int> > q;\n\tdist[s] = 0;\n\tq.push(mp(0LL, s));\n\n\twhile(!q.empty()){\n\t\tlong long d = -q.top().ff;\n\t\tint u = q.top().ss; q.pop();\n\n\t\tfor(int i = 0; i < (int)g[u].size(); i++){\n\t\t\tint v = g[u][i].ff;\n\t\t\tlong long w = d + g[u][i].ss;\n\n\t\t\tif(dist[v] > w){\n\t\t\t\tdist[v] = w;\n\t\t\t\tq.push(mp(-w, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, q, s;\n\n\tscanf(\"%d %d %d\", &n, &q, &s);\n\n\tSegtree st(n);\n\tSegtree2 st2(n);\n\n\tint t, u, v, l, r;\n\tlong long w;\n\tfor(int i = 0; i < q; i++){\n\t\tscanf(\"%d\", &t);\n\t\tif(t == 1){\n\t\t\tscanf(\"%d %d %lld\", &u, &v, &w);\n\t\t\tg[u].push_back(mp(v, w));\n\t\t}\n\t\telse if(t == 2){\n\t\t\tscanf(\"%d %d %d %lld\", &v, &l, &r, &w);\n\t\t\tvector<int> tmp = st.get(l, r);\n\t\t\tfor(int j = 0; j < (int)tmp.size(); j++){\n\t\t\t\tg[v].push_back(mp(tmp[j], w));\n\t\t\t}\n\t\t}\n\t\telse if(t == 3){\n\t\t\tscanf(\"%d %d %d %lld\", &v, &l, &r, &w);\n\t\t\tvector<int> tmp = st2.get(l, r);\n\t\t\tfor(int j = 0; j < (int)tmp.size(); j++){\n\t\t\t\tg[tmp[j]].push_back(mp(v, w));\n\t\t\t}\n\t\t}\n\t}\n\n\tdijsktra(s);\n\n\tfor(int i = 1; i <= n; i++)\n\t\tprintf(\"%lld \", dist[i] == oo ? -1 : dist[i]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define FIO                ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define DEBUG(x)           cout << '>' << #x << ':' << x << endl;\n#define rep(i,a,b)         for(int i=a;i<b;i++)\n#define repe(i,a,b)        for(int i=a;i<=b;i++)\n#define rrep(i,a,b)        for(int i=b;i>=a;i--)\n#define PI                 acos(-1.0)\n#define all(a)             a.begin(),a.end()\n#define rall(a)            a.rbegin(),a.rend()\n#define Unique(a)          sort(all(a)),a.erase(unique(all(a)),a.end())\n#define sz(s)              (int)s.size()\n#define fi                 first\n#define se                 second\n#define lb                 lower_bound\n#define up                 upper_bound \n#define pb                 push_back \n#define ppb                pop_back \n#define pf                 push_front \n#define ppf                pop_front \n#define ins(a)             insert(a)\n#define max2(a,b)          max(a,b)\n#define max3(a,b,c)        max(a,max(b,c))\n#define max4(a,b,c,d)      max(a,max3(b,c,d))\n#define min2(a,b)          min(a,b)\n#define min3(a,b,c)        min(a,min(b,c))\n#define min4(a,b,c,d)      min(a,min3(b,c,d))\n \n \nint main()\n{\n    FIO;\n    #ifndef ONLINE_JUDGE\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    int n,k,a,b;\n    cin>>n>>k>>a>>b;\n    char tt[3]=\"GB\";\n   // int cnt=0;\n   string temp=\"\";\n    if(a<b){\n    \tswap(a,b);\n    \tswap(tt[0],tt[1]);\n    }\n    if(a>(b+1)*k){\n    \tcout<<\"NO\"<<endl;\n    \treturn 0;\n    }\n  \n    if(a==b){\n    \tfor(int i=1;i<=a;i++){\n            temp+=\"GB\";\n    \t\tcout<<\"GB\";\n    \t}\n \n    }else{\n    \twhile(a>b){\n    \t\tint rr=min(k,a-b+1);\n    \t\tfor(int i=1;i<=rr && a;i++){\n              //  cout<<\"\\n 63 line \"<<endl;\n    \t\t\tcout<<tt[0];\n    \t\t\t--a;\n               // cout<<\"\\na: \"<<a<<\" \"<<b<<endl;\n    \t\t\t\n    \t\t}\n \n    \t\tif(b){\n              //  cout<<\"\\n 70 line \"<<endl;\n                cout<<tt[1],--b;\n            }\n            if(a>0 && a!=b && a-b<k){\n                while(a>b && a>0){ \n               //     cout<<\"\\n 75 line \"<<endl;\n                    cout<<tt[0];\n                    --a;\n                }\n            }\n \n    \t\tif(a==b)break;\n    \t\t\n \n    \t}\n    \tfor(int i=1;i<=a;i++){\n    \t\t\n    \t\tcout<<tt[0]<<tt[1];\n    \t}\n\n     \n    }\n \n \n   \t\n    #ifdef ONLINE_JUDGE\n    cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n    #endif\n   return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define FIO                ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define DEBUG(x)           cout << '>' << #x << ':' << x << endl;\n#define rep(i,a,b)         for(int i=a;i<b;i++)\n#define repe(i,a,b)        for(int i=a;i<=b;i++)\n#define rrep(i,a,b)        for(int i=b;i>=a;i--)\n#define PI                 acos(-1.0)\n#define all(a)             a.begin(),a.end()\n#define rall(a)            a.rbegin(),a.rend()\n#define Unique(a)          sort(all(a)),a.erase(unique(all(a)),a.end())\n#define sz(s)              (int)s.size()\n#define fi                 first\n#define se                 second\n#define lb                 lower_bound\n#define up                 upper_bound \n#define pb                 push_back \n#define ppb                pop_back \n#define pf                 push_front \n#define ppf                pop_front \n#define ins(a)             insert(a)\n#define max2(a,b)          max(a,b)\n#define max3(a,b,c)        max(a,max(b,c))\n#define max4(a,b,c,d)      max(a,max3(b,c,d))\n#define min2(a,b)          min(a,b)\n#define min3(a,b,c)        min(a,min(b,c))\n#define min4(a,b,c,d)      min(a,min3(b,c,d))\n \n \nint main()\n{\n    FIO;\n    #ifndef ONLINE_JUDGE\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    ll n,k,a,b;\n    cin>>n>>k>>a>>b;\n    char tt[3]=\"GB\";\n   // int cnt=0;\n   string temp=\"\";\n    if(a<b){\n    \tswap(a,b);\n    \tswap(tt[0],tt[1]);\n    }\n    if(a>(b+1)*k){\n    \tcout<<\"NO\"<<endl;\n    \treturn 0;\n    }\n  \n    if(a==b){\n    \tfor(int i=1;i<=a;i++){\n            temp+=\"GB\";\n    \t\tcout<<\"GB\";\n    \t}\n \n    }else{\n    \twhile(a>b){\n    \t\tint rr=min(k,a-b+1);\n    \t\tfor(int i=1;i<=rr && a;i++){\n              //  cout<<\"\\n 63 line \"<<endl;\n    \t\t\tcout<<tt[0];\n    \t\t\t--a;\n               // cout<<\"\\na: \"<<a<<\" \"<<b<<endl;\n    \t\t\t\n    \t\t}\n \n    \t\tif(b){\n              //  cout<<\"\\n 70 line \"<<endl;\n                cout<<tt[1],--b;\n            }\n            if(a>0 && a!=b && a-b<k){\n                while(a>b && a>0){ \n               //     cout<<\"\\n 75 line \"<<endl;\n                    cout<<tt[0];\n                    --a;\n                }\n            }\n \n    \t\tif(a==b)break;\n    \t\t\n \n    \t}\n    \tfor(int i=1;i<=a;i++){\n    \t\t\n    \t\tcout<<tt[0]<<tt[1];\n    \t}\n\n     \n    }\n \n \n   \t\n    #ifdef ONLINE_JUDGE\n    cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n    #endif\n   return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#pragma GCC optimize(2)\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include<bitset>\n#include<map>\n#include<bitset>\n#include<time.h>\n#include<set>\n#include <random>\n#include<bitset>\n#include<string>\n#define pb push_back\n#define ll long long\n#define sf scanf\n#define pf printf\n#define maxx 1000050\n#define maxn 5005\n#define dbg(x) cout<<#x<<\" = \"<<x<<endl;\n#define mod (ll)1000000007\n#define mm 20\n#define debug 0\n#define INF 1e18\n#define eps 1e-10\n#define pll pair<ll,ll>\n#define For(i,a,b) for(int i=(a);i<(b);i++)\n#define all(a) a.begin(),b.end()\nusing namespace std;\nll n, m, t, k;\nll a[maxn];\nint main() {\n    ios::sync_with_stdio(0);\n    cin >> n;\n    For(i, 0, n) {\n        cin >> a[i];\n    }\n    bool sud = 0;\n    ll ans = -INF;\n    For(p, -31, 32) {\n        ll p1 = 0, p2 = -INF;\n        For(i, 0, n) {\n            if (a[i] > p) {\n                p2 = -INF;\n                p1 = 0;\n            }\n            else if (a[i] == p) {\n                sud = 1;\n                p2 = max(p2+a[i],p1);\n                p1 = 0;\n            }\n            else {\n                p1+=a[i];\n                p2+=a[i];\n            }\n            if (p1 < 0)p1 = 0;\n            ans = max(ans, p2);\n        }\n    }\n    if(sud==0)while(1);\n    cout << ans;\n}\n/*\n15\n-25 3 25 29 15 -4 24 14 18 4 24 20 6 25 -23\n*/\n\n",
        "fixed_code": "#pragma GCC optimize(2)\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include<bitset>\n#include<map>\n#include<bitset>\n#include<time.h>\n#include<set>\n#include <random>\n#include<bitset>\n#include<string>\n#define pb push_back\n#define ll long long\n#define sf scanf\n#define pf printf\n#define maxx 1000050\n#define maxn 1000005\n#define dbg(x) cout<<#x<<\" = \"<<x<<endl;\n#define mod (ll)1000000007\n#define mm 20\n#define debug 0\n#define INF 1e18\n#define eps 1e-10\n#define pll pair<ll,ll>\n#define For(i,a,b) for(int i=(a);i<(b);i++)\n#define all(a) a.begin(),b.end()\nusing namespace std;\nll n, m, t, k;\nll a[maxn];\nint main() {\n    ios::sync_with_stdio(0);\n    cin >> n;\n    For(i, 0, n) {\n        cin >> a[i];\n    }\n    bool sud = 0;\n    ll ans = -INF;\n    For(p, -31, 32) {\n        ll p1 = 0, p2 = -INF;\n        For(i, 0, n) {\n            if (a[i] > p) {\n                p2 = -INF;\n                p1 = 0;\n            }\n            else if (a[i] == p) {\n                sud = 1;\n                p2 = max(p2+a[i],p1);\n                p1 = 0;\n            }\n            else {\n                p1+=a[i];\n                p2+=a[i];\n            }\n            if (p1 < 0)p1 = 0;\n            ans = max(ans, p2);\n        }\n    }\n    if(sud==0)while(1);\n    cout << ans;\n}\n/*\n15\n-25 3 25 29 15 -4 24 14 18 4 24 20 6 25 -23\n*/\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&l,&r);\n    if(n <= 2)\n    {\n        printf(\"%lld\\n\", n<=0 ? 0ll : n<=1 ? r-l+1ll : (r-l+1ll)*(r-l));\n        return 0;\n    }\n    for(int i=1; pow(i,n-1); i++)\n        for(int j=1; pow(j,n-1); j++)\n            if(__gcd(i,j) == 1)\n                ans += max(0,int(floor(r/pow(j,n-1))) - int(ceil(l/pow(i,n-1))) + 1);\n                \n    printf(\"%d\\n\", ans*2);\n    return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,l,r,ans;\n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&l,&r);\n    if(n <= 2)\n    {\n        printf(\"%lld\\n\", n<=0 ? 0ll : n<=1 ? r-l+1ll : (r-l+1ll)*(r-l));\n        return 0;\n    }\n    for(int i=1; pow(i,n-1)<=r; i++)\n        for(int j=i+1; pow(j,n-1)<=r; j++)\n            if(__gcd(i,j) == 1)\n                ans += max(0,int(floor(r/pow(j,n-1))) - int(ceil(l/pow(i,n-1))) + 1);\n                \n    printf(\"%d\\n\", ans*2);\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import bisect\nn,m = map(int,raw_input().split())\nb = map(int,raw_input().split())\ng = map(int,raw_input().split())\nans = m*sum(b)\nb.sort()\nd = {}\nfor i in b:\n\td[i] = m-1\ng.sort(None,None,True)\nimp = 0\nfor i in g:\n\tif i<b[n-1]:\n\t\timp = 1\n\t\tbreak\nif imp :\n\tprint -1\nelse:\n\tx = n-1\n\tfor i in g:\n\t\tif i == b[x]:\n\t\t\tpass\n\t\telse:\n\t\t\tans+=(i-b[x])\n\t\t\td[b[x]]-=1\n\t\t\tif d[b[x]] == 0:\n\t\t\t\tx-=1\n\tprint ans",
        "fixed_code": "R = lambda: map(int, input().split())\nn,m = R()\na = list(R())\nb = list(R())\na.sort()\nb.sort()\nt = sum(a)*m + sum(b) - a[-1]*m\n\nif a[-1] >  b[0]:\n    print(-1)\nelif a[-1] == b[0]:\n    print(t)\nelse:\n    print(t+a[-1]-a[-2])",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[100002];\nlong long int cont[100002];\nint main()\n{\n    long long int n,c,i;\n    scanf(\"%lld\",&n);\n\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%lld\",&c);\n        cont[c]++;\n    }\n    dp[0]=0;\n    dp[1]=cont[1];\n\n    for(i=2;i<=n;i++)\n    {\n        dp[i]=max(dp[i-1],dp[i-2]+cont[i]*i);\n    }\n    printf(\"%lld\",dp[n]);\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[100002];\nlong long int cont[100002];\nint main()\n{\n    long long int n,c,i;\n    scanf(\"%lld\",&n);\n\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%lld\",&c);\n        cont[c]++;\n    }\n    dp[0]=0;\n    dp[1]=cont[1];\n\n    for(i=2;i<=100002;i++)\n    {\n        dp[i]=max(dp[i-1],dp[i-2]+cont[i]*i);\n    }\n    printf(\"%lld\",dp[100002]);\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#include<unordered_map>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nFILE *stream;\nll n, m, b, Mod, a[505], dp[2][505][505];\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t//freopen_s(&stream, \"input.txt\", \"r\", stdin);\n\t//freopen_s(&stream, \"output.txt\", \"w\", stdout);\n\n\tcin >> n >> m >> b >> Mod;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int k = b; k >= 0; k--) {\n\t\t    for (int j = m; j >= 0; j--) {\n\t\t\t\tif (j == m)\n\t\t\t\t\tdp[i & 1][j][k] = 1;\n\t\t\t\telse if (i == n - 1) {\n\t\t\t\t\tif (k + a[i] * (m - j) <= b)dp[i & 1][j][k] = 1;\n\t\t\t\t\telse dp[i & 1][j][k] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tll c1 = 0, c2 = 0;\n\t\t\t\t\tif (k + a[i] <= b)c1 = dp[i & 1][j + 1][k + a[i]];\n\t\t\t\t\tc2 = dp[(i + 1) & 1][j][k];\n\t\t\t\t\tdp[i & 1][j][k] = (c1 + c2) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][0][0];\n\n\treturn 0;\n}",
        "fixed_code": "﻿#include<bits/stdc++.h>\n#include<unordered_map>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nFILE *stream;\nll n, m, b, Mod, a[505], dp[2][505][505];\nll solve(int I, int written, int bugs) {\n\tif (bugs > b)return 0;\n\tif (written == m)return 1;\n\tif (I == n)return 0;\n\tll c1 = solve(I, written + 1, bugs + a[I]),\n\t\tc2 = solve(I + 1, written, bugs);\n\treturn (c1 + c2) % Mod;\n}\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t//freopen_s(&stream, \"input.txt\", \"r\", stdin);\n\t//freopen_s(&stream, \"output.txt\", \"w\", stdout);\n\n\tcin >> n >> m >> b >> Mod;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t//cout << solve(0, 0, 0) << endl;\n\tfor (int i = n; i >= 0; i--) {\n\t\tfor (int j = m; j >= 0; j--) {\n\t\t\tfor (int k = b; k >= 0; k--) {\n\t\t\t\tif (j == m)\n\t\t\t\t\tdp[i & 1][j][k] = 1;\n\t\t\t\telse if (i == n)\n\t\t\t\t\tdp[i & 1][j][k] = 0;\n\t\t\t\telse {\n\t\t\t\t\tll c = 0;\n\t\t\t\t\tif (k + a[i] <= b)c = dp[i & 1][j + 1][k + a[i]];\n\t\t\t\t\tdp[i & 1][j][k] = (c + dp[(i + 1) & 1][j][k]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][0][0];\n\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nint a[200005];\nint cnt[200005];\nvector<int> v;\nint ans;\n\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    for (int i=1;i<=n;++i) {\n        cin>>a[i];\n        if (i!=m) {\n            ++cnt[a[i]];\n            v.push_back(a[i]);\n        }\n    }\n    sort(v.begin(),v.end());\n    int last=v.size()-1;\n    int last2=0;\n    if (a[m]) ++ans;\n    if (cnt[0]) {\n        ++last2;\n        --cnt[0];\n        ++ans;\n    }\n    while (last>=0) {\n        if (cnt[last2+1]) {\n            --cnt[last2+1];\n            ++last2;\n            continue;\n        } else {\n            if (v[last]<=last2+1) break;\n            --last;\n            ++last2;\n            ++ans;\n            continue;\n        }\n    }\n    ans+=cnt[0];\n    cout<<ans;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nint a[200005];\nint cnt[200005];\nvector<int> v;\nint ans;\n\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    for (int i=1;i<=n;++i) {\n        cin>>a[i];\n        if (i!=m) {\n            if (!a[i]) a[i]=n+2;\n            ++cnt[a[i]];\n            v.push_back(a[i]);\n        }\n    }\n    sort(v.begin(),v.end());\n    int last=v.size()-1;\n    int last2=0;\n    if (a[m]) ++ans;\n    if (cnt[0]) {\n        ++last2;\n        --cnt[0];\n        ++ans;\n    }\n    while (last>=0) {\n        if (cnt[last2+1]) {\n            --cnt[last2+1];\n            ++last2;\n            continue;\n        } else {\n            if (v[last]<=last2+1) break;\n            --last;\n            ++last2;\n            ++ans;\n            continue;\n        }\n    }\n    ans+=cnt[0];\n    cout<<ans;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private void addPhotoRow() {\n    java.lang.String[] urls = new java.lang.String[]{ \"http://tupian.enterdesk.com/2012/0528/gha/9/120523112107-15.jpg\" , \"http://imgstore.cdn.sogou.com/app/a/100540002/541762.jpg\" , \"http://image.tianjimedia.com/uploadImages/2012/291/Q5V0024X6GQM.jpg\" , \"http://www.bz55.com/uploads/allimg/140729/138-140H9144A7.jpg\" , \"http://imgstore.cdn.sogou.com/app/a/100540002/717240.jpg\" , \"http://www.bz55.com/uploads/allimg/141005/138-141005115Q4.jpg\" , \"http://e.hiphotos.baidu.com/zhidao/pic/item/5ab5c9ea15ce36d3418e754838f33a87e850b1c4.jpg\" , \"http://d.3987.com/liuyan_140827/005.jpg\" , \"http://www.bz55.com/uploads/allimg/150402/139-150402152530.jpg\" };\n    int photoCardCount = 9;\n    java.lang.String headerName = getResources().getString(R.string.app_header_photo_name);\n    android.support.v17.leanback.widget.ArrayObjectAdapter listRowAdapter = new android.support.v17.leanback.widget.ArrayObjectAdapter(new com.jacky.catlauncher.presenter.CardPresenter());\n    for (int i = 0; i < photoCardCount; i++) {\n        listRowAdapter.add(urls[i]);\n    }\n    android.support.v17.leanback.widget.HeaderItem header = new android.support.v17.leanback.widget.HeaderItem(0, headerName);\n    rowsAdapter.add(new android.support.v17.leanback.widget.ListRow(header, listRowAdapter));\n}",
        "fixed_code": "private void addPhotoRow() {\n    java.lang.String[] urls = new java.lang.String[]{ \"http://tupian.enterdesk.com/2012/0528/gha/9/120523112107-15.jpg\" , \"http://imgstore.cdn.sogou.com/app/a/100540002/541762.jpg\" , \"http://image.tianjimedia.com/uploadImages/2012/291/Q5V0024X6GQM.jpg\" , \"http://www.bz55.com/uploads/allimg/140729/138-140H9144A7.jpg\" , \"http://imgstore.cdn.sogou.com/app/a/100540002/717240.jpg\" , \"http://www.bz55.com/uploads/allimg/141005/138-141005115Q4.jpg\" , \"http://e.hiphotos.baidu.com/zhidao/pic/item/5ab5c9ea15ce36d3418e754838f33a87e850b1c4.jpg\" , \"http://d.3987.com/liuyan_140827/005.jpg\" , \"http://www.bz55.com/uploads/allimg/150402/139-150402152530.jpg\" };\n    java.lang.String headerName = getResources().getString(R.string.app_header_photo_name);\n    android.support.v17.leanback.widget.ArrayObjectAdapter listRowAdapter = new android.support.v17.leanback.widget.ArrayObjectAdapter(new com.jacky.catlauncher.presenter.CardPresenter());\n    for (java.lang.String url : urls) {\n        listRowAdapter.add(url);\n    }\n    android.support.v17.leanback.widget.HeaderItem header = new android.support.v17.leanback.widget.HeaderItem(0, headerName);\n    rowsAdapter.add(new android.support.v17.leanback.widget.ListRow(header, listRowAdapter));\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int t,a,b,c,i,s;\n\n    cin>>t;\n\n    for(i=0;i<t;i++)\n    {\n        s=0;\n        cin>>a>>b>>c;\n\n        while((b==0 || (a==0 && c<2) || (c==0 && b<2))==0)\n        {\n            if(b>c && a>0)\n            {\n                b-=2;\n                a--;\n                s+=3;\n            }\n            else\n            {\n                b--;\n                c-=2;\n                s+=3;\n            }\n        }\n        cout<<s<<endl;\n    }\n\n\n\n    return 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\n\nusing namespace std;\nint fun(int a,int b,int c)\n{\n    int s=0;\n    while(a>0 && b>1)\n    {\n        a--;\n        b-=2;\n        s+=3;\n    }\n    while(b>0 && c>1)\n    {\n        b--;\n        c-=2;\n        s+=3;\n    }\n    return s;\n}\n\nint funs(int a,int b,int c)\n{\n    int s=0;\n    while(b>0 && c>1)\n    {\n        b--;\n        c-=2;\n        s+=3;\n    }\n    while(a>0 && b>1)\n    {\n        a--;\n        b-=2;\n        s+=3;\n    }\n    return s;\n}\n\nint main()\n{\n    int t,a,b,c,i,s,j,x;\n\n    cin>>t;\n    for(i=0;i<t;i++)\n    {\n\n        s=0;\n        cin>>a>>b>>c;\n\n        s=fun(a,b,c);\n        x=funs(a,b,c);\n        if(s>x)\n            cout<<s<<endl;\n        else\n            cout<<x<<endl;\n    }\n\n\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/******************************************************************************\n \nрассвет. \n \n*******************************************************************************/\n#include <bits/stdc++.h>\ntypedef long long int lli;\ntypedef unsigned long long int ulli;\ntypedef long double ld;\n#define rapgame ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define vi vector <int>\n#define vlli vector <lli>\n#define vulli vector <ulli>\n#define vchar vector <char>\n#define vstr vector <string>\n#define vb vector <bool>\n#define fst first\n#define sec second\n#define srt(a) sort(a.begin(),a.end())\n#define vpii vector <pair <int,int> >\n#define pii pair <int,int> \n#define vplli vector <pair <lli,lli> >\n#define vpulli vector <pair <ulli,ulli> >\n#define vvi vector <vector <int> >\n#define vvlli vector <vector <lli> >\n#define vvpii vector <vector <pair <int,int>> >\n#define fr(i,n) for (int i = 0; i < (n); ++i)\n#define frbig(i,n) for (lli i = 0; i < (n); ++i)\n#define fra(i,a,n) for (lli i = a; i < (n); ++i)\n#define run(c,s) for(auto c:s) \n#define read(n) int n; cin >> n;\n#define read2(x,y) int x,y; cin >> x >> y;\n#define read2ll(x,y) long long int x,y; cin >> x >> y;\n#define readll(n) lli n; cin >> n;\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n#define print_array(x) fr(i,x.size()) cout << x[i] << \" \";\nusing namespace std;\n \nconst lli MOD=1e9+7;\nconst lli MAXN=1e6+1;\nconst ld PI=acos(-1);\n\nint main(){\n    rapgame\n    read(t);\n    while(t--){\n        read(n);\n        lli t=0;\n        vi a(n),b(1024,0);\n        fr(i,n){\n            fra(j,1,n){\n                b[a[i]^a[j]]++;\n            }\n        }\n        srt(b);\n        reverse(b.begin(),b.end());\n        if(b[0]<n/2) cout << \"-1\\n\";\n        else{\n            lli ans=-1;\n            fr(i,1024){\n                if(a[i]<n/2){\n                    ans=a[i-1];\n                    break;\n                }\n            }\n            if(ans==-1) ans=a[1023];\n            cout << ans << '\\n';\n        }\n    }\n}",
        "fixed_code": "/******************************************************************************\n \nрассвет. \n \n*******************************************************************************/\n#include <bits/stdc++.h>\ntypedef long long int lli;\ntypedef unsigned long long int ulli;\ntypedef long double ld;\n#define rapgame ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define vi vector <int>\n#define vlli vector <lli>\n#define vulli vector <ulli>\n#define vchar vector <char>\n#define vstr vector <string>\n#define vb vector <bool>\n#define fst first\n#define sec second\n#define srt(a) sort(a.begin(),a.end())\n#define vpii vector <pair <int,int> >\n#define pii pair <int,int> \n#define vplli vector <pair <lli,lli> >\n#define vpulli vector <pair <ulli,ulli> >\n#define vvi vector <vector <int> >\n#define vvlli vector <vector <lli> >\n#define vvpii vector <vector <pair <int,int>> >\n#define fr(i,n) for (int i = 0; i < (n); ++i)\n#define frbig(i,n) for (lli i = 0; i < (n); ++i)\n#define fra(i,a,n) for (lli i = a; i < (n); ++i)\n#define run(c,s) for(auto c:s) \n#define read(n) int n; cin >> n;\n#define read2(x,y) int x,y; cin >> x >> y;\n#define read2ll(x,y) long long int x,y; cin >> x >> y;\n#define readll(n) lli n; cin >> n;\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n#define print_array(x) fr(i,x.size()) cout << x[i] << \" \";\nusing namespace std;\n \nconst lli MOD=1e9+7;\nconst lli MAXN=1e6+1;\nconst ld PI=acos(-1);\n\nint main(){\n    rapgame\n    read(t);\n    while(t--){\n        read(n);\n        vi a(n),b(1024,0);\n        int l;\n        bool nice=true,rap=false;\n        fr(i,n){ \n            cin >> a[i];\n            if(a[i]){\n                l=a[i];\n                if(rap) nice=false;\n                else rap=true;\n            }\n        }\n        if(!nice && n%2==0) rap=true;\n        else rap=false;\n        fr(i,n){\n            fra(j,i+1,n){\n                int k=a[i]^a[j];\n                if(k>0) b[k]++;\n            }\n        }\n        int ans=1e9;\n        fr(i,1024){\n            if(b[i]==n/2){\n                ans=min(i,ans);\n            }\n        }\n        if(ans==1e9 && !nice) cout << \"-1\\n\";\n        else if(n%2==1) cout << \"-1\\n\";\n        else if(nice) cout << l << '\\n';\n        else cout << ans << '\\n';\n    }\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconst int maxn = 5555;\n\nint main(int argc, char const *argv[]) {\n    int n;\n    cin >> n;\n    vector<int> carr;\n    vector<vector<int> > table(n);\n    vector<pair<int,int> > pos(maxn);\n    vector<pair<pair<int,int> ,pair<int,int> > > result;\n\n    for(int i = 0; i < n; i++) {\n        int c;\n        cin >> c;\n        carr.push_back(c);\n    }\n\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < carr[i]; j++) {\n            int v;\n            cin >> v;\n            table[i].push_back(v);\n            pos[v] = make_pair(i,j);\n        }\n    }\n\n    int cur = 1;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < carr[i]; j++) {\n            if(table[i][j] == cur) {\n                cur++; continue;\n            }\n\n            int x, y;\n            x = pos[cur].first;\n            y = pos[cur].second;\n            swap(table[i][j], table[x][y]);\n            result.push_back(make_pair(make_pair(i,j), make_pair(x,y)));\n            cur++;\n        }\n    }\n\n    cout << result.size() << endl;\n    for(int i = 0; i < result.size(); i++) {\n        cout << result[i].first.first+1 << \" \" << result[i].first.second+1\n             << \" \"\n             << result[i].second.first+1 << \" \" << result[i].second.second+1\n             << endl;\n    }\n    return 0;\n}",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconst int maxn = 5555;\n\nint main(int argc, char const *argv[]) {\n    int n;\n    cin >> n;\n    vector<int> carr;\n    vector<vector<int> > table(n);\n    vector<pair<int,int> > pos(maxn);\n    vector<pair<pair<int,int> ,pair<int,int> > > result;\n\n    for(int i = 0; i < n; i++) {\n        int c;\n        cin >> c;\n        carr.push_back(c);\n    }\n\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < carr[i]; j++) {\n            int v;\n            cin >> v;\n            table[i].push_back(v);\n            pos[v] = make_pair(i,j);\n        }\n    }\n\n    int cur = 1;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < carr[i]; j++) {\n            if(table[i][j] == cur) {\n                cur++; continue;\n            }\n\n            int x, y;\n            x = pos[cur].first;\n            y = pos[cur].second;\n            pos[table[i][j]] = make_pair(x,y);\n            swap(table[i][j], table[x][y]);\n            result.push_back(make_pair(make_pair(i,j), make_pair(x,y)));\n            cur++;\n        }\n    }\n\n    cout << result.size() << endl;\n    for(int i = 0; i < result.size(); i++) {\n        cout << result[i].first.first+1 << \" \" << result[i].first.second+1\n             << \" \"\n             << result[i].second.first+1 << \" \" << result[i].second.second+1\n             << endl;\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nmap<string,ll>mp;\n\nint main()\n{\n    string s;\n    ll i,j,n,m;\n    cin>>s;\n    ll cnt=0;\n    ll len=s.size();\n    ll temp=0;\n    do{\n            temp=0;\n        for(i=0;i<len;i++){\n            temp=temp*10+s[i]-'0';\n            temp%=7;\n        }\n        //cout<<s<<\" \"<<temp<<endl;\n        if(temp==0){\n            cout<<s<<endl;\n            return 0;\n        }\n    }while(next_permutation(s.begin(),s.end()));\n\n\n    cout<<cnt<<endl;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nmap<string,ll>mp;\n\nint main()\n{\n    string s;\n    string shajib;\n    ll i,j,n,m;\n    cin>>s;\n    ll cnt=0;\n    ll len=s.size();\n    ll temp=0;\n    while(true){\n            temp=0;\n        for(i=0;i<len;i++){\n            temp=temp*10+s[i]-'0';\n            temp%=7;\n        }\n        //cout<<s<<\" \"<<temp<<endl;\n        if(temp==0){\n            cout<<s<<endl;\n            return 0;\n        }\n        next_permutation(s.begin(),s.end());\n    }\n\n\n    cout<<cnt<<endl;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private void modelPropertiesToRows(java.util.Map<java.lang.String, io.swagger.models.properties.Property> properties, io.swagger.models.Swagger swagger, java.lang.String parentPath, java.util.List<org.swagger2html.Swagger2Html.ModelRow> rows) {\n    if (properties == null) {\n        return ;\n    }\n    for (java.util.Map.Entry<java.lang.String, io.swagger.models.properties.Property> entry : properties.entrySet()) {\n        java.lang.String ognlPath = (parentPath == null) ? entry.getKey() : (parentPath + \".\") + (entry.getKey());\n        io.swagger.models.properties.Property property = entry.getValue();\n        java.lang.String type = propertyTypeString(property);\n        if (property instanceof io.swagger.models.properties.ArrayProperty) {\n            ognlPath = ognlPath + \"[]\";\n            org.swagger2html.Swagger2Html.ModelRow row = new org.swagger2html.Swagger2Html.ModelRow();\n            row.setOgnlPath(ognlPath);\n            row.setProperty(property);\n            row.setTypeStr(type);\n            rows.add(row);\n            io.swagger.models.properties.Property itemProperty = ((io.swagger.models.properties.ArrayProperty) (property)).getItems();\n            if (isPropertyRefType(swagger, itemProperty)) {\n                io.swagger.models.Model model = swagger.getDefinitions().get(propertyTypeString(itemProperty));\n                java.util.Map<java.lang.String, io.swagger.models.properties.Property> childProperties = model.getProperties();\n                modelPropertiesToRows(childProperties, swagger, ognlPath, rows);\n                continue;\n            }\n        }\n        org.swagger2html.Swagger2Html.ModelRow row = new org.swagger2html.Swagger2Html.ModelRow();\n        row.setOgnlPath(ognlPath);\n        row.setProperty(property);\n        row.setTypeStr(type);\n        rows.add(row);\n        if ((isPropertyRefType(swagger, property)) && (type != null)) {\n            io.swagger.models.Model model = swagger.getDefinitions().get(type);\n            java.util.Map<java.lang.String, io.swagger.models.properties.Property> childProperties = model.getProperties();\n            modelPropertiesToRows(childProperties, swagger, ognlPath, rows);\n        }\n        continue;\n    }\n}",
        "fixed_code": "private void modelPropertiesToRows(java.util.Map<java.lang.String, io.swagger.models.properties.Property> properties, io.swagger.models.Swagger swagger, java.lang.String parentPath, java.util.List<org.swagger2html.Swagger2Html.ModelRow> rows) {\n    if (properties == null) {\n        return ;\n    }\n    for (java.util.Map.Entry<java.lang.String, io.swagger.models.properties.Property> entry : properties.entrySet()) {\n        java.lang.String ognlPath = (parentPath == null) ? entry.getKey() : (parentPath + \".\") + (entry.getKey());\n        io.swagger.models.properties.Property property = entry.getValue();\n        java.lang.String type = propertyTypeString(property);\n        if (property instanceof io.swagger.models.properties.ArrayProperty) {\n            ognlPath = ognlPath + \"[]\";\n            org.swagger2html.Swagger2Html.ModelRow row = new org.swagger2html.Swagger2Html.ModelRow();\n            row.setOgnlPath(ognlPath);\n            row.setProperty(property);\n            row.setTypeStr(type);\n            rows.add(row);\n            io.swagger.models.properties.Property itemProperty = ((io.swagger.models.properties.ArrayProperty) (property)).getItems();\n            if (isPropertyRefType(swagger, itemProperty)) {\n                io.swagger.models.Model model = swagger.getDefinitions().get(propertyTypeString(itemProperty));\n                java.util.Map<java.lang.String, io.swagger.models.properties.Property> childProperties = model.getProperties();\n                modelPropertiesToRows(childProperties, swagger, ognlPath, rows);\n            }\n            continue;\n        }\n        org.swagger2html.Swagger2Html.ModelRow row = new org.swagger2html.Swagger2Html.ModelRow();\n        row.setOgnlPath(ognlPath);\n        row.setProperty(property);\n        row.setTypeStr(type);\n        rows.add(row);\n        if ((isPropertyRefType(swagger, property)) && (type != null)) {\n            io.swagger.models.Model model = swagger.getDefinitions().get(type);\n            java.util.Map<java.lang.String, io.swagger.models.properties.Property> childProperties = model.getProperties();\n            modelPropertiesToRows(childProperties, swagger, ognlPath, rows);\n        }\n        continue;\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "protected void onPostExecute(android.net.Uri uri) {\n    if (uri != null) {\n        addMedia(uri);\n    }else {\n        android.widget.Toast.makeText(this, getString(R.string.error_downloading_image), Toast.LENGTH_SHORT).show();\n    }\n}",
        "fixed_code": "@java.lang.Override\npublic void run() {\n    boolean hasLocalChanges = (mPost.isLocallyChanged()) || (mPost.isLocalDraft());\n    boolean isFirstTimePublish = isFirstTimePublish();\n    boolean postUpdateSuccessful = updatePostObject();\n    if (!postUpdateSuccessful) {\n        return ;\n    }\n    boolean hasChanges = org.wordpress.android.ui.posts.PostUtils.postHasEdits(mOriginalPost, mPost);\n    boolean isPublishable = org.wordpress.android.ui.posts.PostUtils.isPublishable(mPost);\n    boolean hasUnpublishedLocalDraftChanges = (((org.wordpress.android.fluxc.model.post.PostStatus.fromPost(mPost)) == (org.wordpress.android.fluxc.model.post.PostStatus.DRAFT)) && isPublishable) && hasLocalChanges;\n    boolean shouldSave = (hasChanges || hasUnpublishedLocalDraftChanges) && (isPublishable || (!(isNewPost())));\n    saveResult(shouldSave, false);\n    if (shouldSave) {\n        if (isNewPost()) {\n            mPost.setStatus(PostStatus.DRAFT.toString());\n            if ((mEditPostSettingsFragment) != null) {\n                runOnUiThread(new java.lang.Runnable() {\n                    @java.lang.Override\n                    public void run() {\n                        mEditPostSettingsFragment.updateStatusSpinner();\n                    }\n                });\n            }\n        }\n        if (((((org.wordpress.android.fluxc.model.post.PostStatus.fromPost(mPost)) == (org.wordpress.android.fluxc.model.post.PostStatus.DRAFT)) && isPublishable) && (!(hasUnfinishedMedia()))) && (org.wordpress.android.util.NetworkUtils.isNetworkAvailable(getBaseContext()))) {\n            savePostOnlineAndFinishAsync(isFirstTimePublish);\n        }else {\n            savePostLocallyAndFinishAsync();\n        }\n    }else {\n        if ((!isPublishable) && (isNewPost())) {\n            mDispatcher.dispatch(org.wordpress.android.fluxc.generated.PostActionBuilder.newRemovePostAction(mPost));\n        }\n        finish();\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.*;\npublic class Stonecount\n{\n\tpublic static void main(String args[]) throws IOException\n\t{\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n\tint n = Integer.parseInt(br.readLine());\n\t\n\tlong count[] = new long[n+1];\n\tcount[0]=0;\n\tString s = br.readLine();\n\tString arr[] = s.split(\" \");\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\n\t\t\n\t\tcount[i+1]=count[i]+Long.parseLong(arr[i]);\n\n\t}\n\t\n\tlong counts[] = new long[n+1];\n\t\n\tArrays.sort(arr);\n\tcounts[0] = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tcounts[i] = counts[i-1]+Long.parseLong(arr[i-1]);\n\t\t\n\t}\n\tint m = Integer.parseInt(br.readLine());\n\twhile(m-->0)\n\t{\t\n\t\tString in[] = br.readLine().split(\" \");\n\t\tint t= Integer.parseInt(in[0]);\n\t\tint l = Integer.parseInt(in[1]);\n\t\tint r = Integer.parseInt(in[2]);\n\t\tif(t==1)\n\t\t\tSystem.out.println(count[r]-count[l-1]);\n\t\telse\n\t\t\tSystem.out.println(counts[r]-counts[l-1]);\n\t}\n\t}\n}",
        "fixed_code": "import java.io.*;\nimport java.util.*;\npublic class Stonecount\n{\n\tpublic static void main(String args[]) throws IOException\n\t{\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n\tint n = Integer.parseInt(br.readLine());\n\t\n\tlong count[] = new long[n+1];\n\tcount[0]=0;\n\tStringTokenizer st = new StringTokenizer(br.readLine());\n\tint arr[] = new int[n];\n\t\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\n\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\n\t\tcount[i+1]=count[i]+arr[i];\n\n\t}\n\tRandom shuffle= new Random();\n\tfor(int i=n-1;i>0;i--)\n\t{\n\t\tint j = shuffle.nextInt(i+1);\n\t\tint t = arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=t;\n\t}\n\tlong counts[] = new long[n+1];\n\t\n\tArrays.sort(arr);\n\tcounts[0] = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tcounts[i] = counts[i-1]+arr[i-1];\n\t\t\n\t}\n\tint m = Integer.parseInt(br.readLine());\n\tPrintWriter pw = new PrintWriter(System.out);\n\twhile(m-->0)\n\t{\t\n\t\tStringTokenizer in = new StringTokenizer(br.readLine());\n\t\tint t= Integer.parseInt(in.nextToken());\n\t\tint l = Integer.parseInt(in.nextToken());\n\t\tint r = Integer.parseInt(in.nextToken());\n\t\tif(t==1)\n\t\t\tpw.println(count[r]-count[l-1]);\n\t\telse\n\t\t\tpw.println(counts[r]-counts[l-1]);\n\t}\n\tpw.close();\n\t}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nconst ll MAX = 1e6;\r\nvector<int> primes;\r\nvoid Sieve()\r\n{\r\n    int n = MAX;\r\n    int nNew = sqrt(n);\r\n\r\n    int marked[n / 2 + 500] = {0};\r\n\r\n    for (int i = 1; i <= (nNew - 1) / 2; i++)\r\n        for (int j = (i * (i + 1)) << 1; j <= n / 2; j = j + 2 * i + 1)\r\n            marked[j] = 1;\r\n\r\n    primes.push_back(2);\r\n\r\n    for (int i = 1; i <= n / 2; i++)\r\n        if (marked[i] == 0)\r\n            primes.push_back(2 * i + 1);\r\n}\r\n\r\nvoid solve()\r\n{\r\n\r\n    ll n;\r\n    cin >> n;\r\n    char c;\r\n    cin >> c;\r\n    string s;\r\n    cin >> s;\r\n\r\n    int cnt = 0;\r\n\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (c == s[i])\r\n        {\r\n            cnt++;\r\n        }\r\n    }\r\n\r\n    if (cnt == n)\r\n    {\r\n\r\n        cout << \"0\"\r\n             << \"\\n\";\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < n and primes[i] <= n; i++)\r\n    {\r\n        if (s[primes[i] - 1] == c)\r\n        {\r\n            cout << 1 << \"\\n\";\r\n            cout << primes[i] << \"\\n\";\r\n            return;\r\n        }\r\n    }\r\n    cout << 2 << \"\\n\";\r\n    int k = 0;\r\n    for (int i = 0; i < n and primes[i] <= n; i++)\r\n    {\r\n        cout << primes[i] << \" \";\r\n        k++;\r\n        if (k == 2)\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    cout << \"\\n\";\r\n}\r\nint main()\r\n{\r\n    int tc;\r\n    cin >> tc;\r\n    Sieve();\r\n    while (tc--)\r\n    {\r\n\r\n        solve();\r\n    }\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nvoid solve()\r\n{\r\n    ll n;\r\n    cin >> n;\r\n\r\n    char ch;\r\n    cin >> ch;\r\n\r\n    string s;\r\n    cin >> s;\r\n\r\n    bool find_one_other = false;\r\n    for (ll i = 0; i < s.size(); i++)\r\n    {\r\n        if (s[i] != ch)\r\n        {\r\n            find_one_other = true;\r\n        }\r\n    }\r\n    if (!find_one_other)\r\n    {\r\n        cout << 0 << endl;\r\n        return;\r\n    }\r\n\r\n    for (ll i = n - 1; i >= n / 2; i--)\r\n    {\r\n        if (s[i] == ch)\r\n        {\r\n            cout << 1 << endl;\r\n            cout << i + 1 << endl;\r\n            return;\r\n        }\r\n    }\r\n\r\n    cout << 2 << endl;\r\n    cout << n - 1 << \" \" << n << endl;\r\n    return;\r\n}\r\nint main()\r\n{\r\n    int tc;\r\n    cin >> tc;\r\n\r\n    while (tc--)\r\n    {\r\n\r\n        solve();\r\n    }\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\r\nusing namespace std;\r\nint a[100001],t,f;\r\nint main(){\r\n    cin>>t;\r\n    while(t--){\r\n        int n;\r\n        cin>>n;\r\n        for(int i=1;i<=n;i++)cin>>a[i];\r\n        f=0;\r\n        int sum=1;\r\n        for(int i=2;i<=n;i++){\r\n            if(!a[i]&&!a[i-1]){cout<<-1<<endl;f=1;break;}\r\n            if(a[i]&&a[i-1])sum+=5;\r\n            if(a[i-1]==0&&a[i]==1)sum++;\r\n        }\r\n        if(f!=1)cout<<sum<<endl;\r\n    }\r\n}",
        "fixed_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--)\r\n    {\r\n\t\tint n;\r\n\t\tcin>>n;\r\n\t\tint a[n+1];\r\n\t\tfor(int i=1;i<=n;i++)cin>>a[i];\r\n\t\tint x=1;\r\n\t\tif(a[1]==1)x++;\r\n\t\tfor(int i=2;i<=n;i++)\r\n        {\r\n\t\t\tif(a[i]==1&&a[i-1]==1)x+=5;\r\n            else if(a[i]==1)x+=1;\r\n            else if(a[i-1]==0){x=-1;break;}\r\n\t\t} \r\n\t\tcout<<x<<endl; \r\n\t}\r\n\treturn 0;\r\n} ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    int t;\r\n    cin >>t;\r\n    for(int i=0;i<t;i++)\r\n    {\r\n        int n,k;\r\n        cin >> n >> k;\r\n\r\n        if(k==3 && n==4)\r\n        {\r\n            cout << -1 << endl;\r\n        }\r\n        else if(k==0)\r\n        {\r\n            for(int j=0;j<n/2;j++)\r\n            {\r\n                cout << j << \" \" << n-1-j << endl;\r\n            }\r\n        }\r\n        else if(k!=n-2 && k!=n-1)\r\n        {\r\n            cout << \"0\" << \" \" << n-1-k << endl;\r\n            if(k<n/2)\r\n            {\r\n                for(int l=1;l<k;l++)\r\n                {\r\n                    cout << l << \" \" << n-1-l << endl;\r\n                }\r\n                cout << k << \" \" << n-1 << endl;\r\n                for(int m=k+1;m<n/2;m++)\r\n                {\r\n                    cout << m << \" \" << n-1-m << endl;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for(int l=1;l<n-1-k;l++)\r\n                {\r\n                    cout << l << \" \" << n-1-l << endl;\r\n                }\r\n                cout << k << \" \" << n-1 << endl;\r\n                for(int m=n-k;m<n/2;m++)\r\n                {\r\n                    cout << m << \" \" << n-1-m << endl;\r\n                }\r\n            }\r\n            \r\n        }\r\n        else if(k==n-2)\r\n        {\r\n            cout << \"0\" << \" \" << \"1\" <<endl;\r\n            cout << k  << \" \" << n-1 << endl;\r\n            for(int l=2;l<n/2;l++)\r\n            {\r\n                cout << l << \" \" << n-1-l << endl;\r\n            }\r\n        }\r\n        else if(k==n-1)\r\n        {\r\n            int num=((log10(n))/(log10(2)));\r\n            for(int j=0;j<num;j++)\r\n            {\r\n                cout << (int)pow(2,(float)j) << \" \" << n-1-(int)pow(2,(float)(j-1)) <<  endl;\r\n            }\r\n            cout << \"0\" << \" \" << n-1-(int)pow(2,(float)(num-1)) << endl;\r\n            for(int l=1;l<n/2;l++)\r\n            {\r\n                int temp=(int)((log10(l))/(log10(2)));\r\n                int temp1=(int)((log10(n-1-l))/(log10(2)));\r\n                if(l!=(int)pow(2,(float)temp) && (n-1-l)!=(int)pow(2,(float)temp1))\r\n                {\r\n                    cout << l << \" \" << n-1-l << endl;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n    return 0;\r\n}",
        "fixed_code": "#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\n\r\nint number(int n)\r\n{\r\n    int res=0;\r\n    while(n!=0)\r\n    {\r\n        n=n/2;\r\n        res++;\r\n    }\r\n    return res-1;\r\n}\r\n\r\nint pow_2(int n)\r\n{\r\n    int res=1;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        res *=2;\r\n    }\r\n    return res;\r\n}\r\nint main()\r\n{\r\n    int t;\r\n    cin >>t;\r\n    for(int i=0;i<t;i++)\r\n    {\r\n        int n,k;\r\n        cin >> n >> k;\r\n\r\n        if(k==3 && n==4)\r\n        {\r\n            cout << -1 << endl;\r\n        }\r\n        else if(k==0)\r\n        {\r\n            for(int j=0;j<n/2;j++)\r\n            {\r\n                cout << j << \" \" << n-1-j << endl;\r\n            }\r\n        }\r\n        else if(k!=n-2 && k!=n-1)\r\n        {\r\n            cout << \"0\" << \" \" << n-1-k << endl;\r\n            if(k<n/2)\r\n            {\r\n                for(int l=1;l<k;l++)\r\n                {\r\n                    cout << l << \" \" << n-1-l << endl;\r\n                }\r\n                cout << k << \" \" << n-1 << endl;\r\n                for(int m=k+1;m<n/2;m++)\r\n                {\r\n                    cout << m << \" \" << n-1-m << endl;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for(int l=1;l<n-1-k;l++)\r\n                {\r\n                    cout << l << \" \" << n-1-l << endl;\r\n                }\r\n                cout << k << \" \" << n-1 << endl;\r\n                for(int m=n-k;m<n/2;m++)\r\n                {\r\n                    cout << m << \" \" << n-1-m << endl;\r\n                }\r\n            }\r\n            \r\n        }\r\n        else if(k==n-2)\r\n        {\r\n            cout << \"0\" << \" \" << \"1\" <<endl;\r\n            cout << k  << \" \" << n-1 << endl;\r\n            for(int l=2;l<n/2;l++)\r\n            {\r\n                cout << l << \" \" << n-1-l << endl;\r\n            }\r\n        }\r\n        else if(k==n-1)\r\n        {\r\n            int num=number(n);\r\n            cout << \"1\" << \" \" << n-1 << endl;\r\n            for(int j=1;j<num;j++)\r\n            {\r\n                cout << pow_2(j) << \" \" << n-1-pow_2(j-1) << endl;\r\n            }\r\n            cout << \"0\" << \" \" << n-1-pow_2(num-1) << endl;\r\n            for(int l=1;l<n/2;l++)\r\n            {\r\n                int temp=number(l);\r\n                int temp1=number(n-1-l);\r\n                if(l!=pow_2(temp) && (n-1-l)!=pow_2(temp1))\r\n                {\r\n                    cout << l << \" \" << n-1-l << endl;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t Scanner sc=new Scanner(System.in);\n\t double d=sc.nextDouble();\n\t double h=sc.nextDouble();\n\t double v=sc.nextDouble();\n\t double e=sc.nextDouble();\n\t \n\t double dist=h;\n\t double dist1=4*v/Math.PI*d*d;\n\t double dist2=e;\n\t if(dist2>=dist1)\n\t  System.out.println(\"NO\");\n\t else\n\t {\n\t     double speed=dist1-dist2;\n\t     double time=dist/speed;\n\t     System.out.println(\"YES\");\n\t     System.out.println(time);\n\t }\n\t}\n}\n",
        "fixed_code": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t Scanner sc=new Scanner(System.in);\n\t double d=sc.nextDouble();\n\t double h=sc.nextDouble();\n\t double v=sc.nextDouble();\n\t double e=sc.nextDouble();\n\t \n\t double dist=h;\n\t double dist1=(4*v)/(Math.PI*d*d);\n\t double dist2=e;\n\t if(dist2>=dist1)\n\t  System.out.println(\"NO\");\n\t else\n\t {\n\t     double speed=dist1-dist2;\n\t     double time=dist/speed;\n\t     System.out.println(\"YES\");\n\t     System.out.println(time);\n\t }\n\t}\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std ;\nint a[20005] ;\n\nint main()\n{\n\t\n\tint n , sum1 = 0 , sum2 = 0 ;\t\t\t\t//sum1   数字1的次数\t\t\tsum2 数字2的次数 \n\tcin >> n ;\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t{\n\t\tcin >> a[i] ;\n\t\tif ( a[i] == 1 )\n\t\t{\n\t\t\tsum1++ ;\n\t\t}\n\t\telse if ( a[i] == 2 )\n\t\t{\n\t\t\tsum2++ ;\n\t\t}\n\t}\n\tif ( sum1 > sum2 )\n\t{\n\t\tif ( sum1 - sum2 < 3 )\n\t\t{\n\t\t\tcout << sum2 << endl ;\n\t\t}\n\t\telse if ( sum1 - sum2 >= 3 )\n\t\t{\n\t\t\tcout << sum2 + ( sum1 - sum2 ) / 3 << endl ;\n\t\t}\n\t}\n\telse if ( sum1 < sum2 )\n\t{\n\t\tif ( sum2 - sum1 < 3 )\n\t\t{\n\t\t\tcout << sum1 << endl ;\n\t\t}\n\t\telse if ( sum2 - sum1 >= 3 )\n\t\t{\n\t\t\tcout << sum1 + ( sum2 - sum1 ) / 3 << endl ;\n\t\t}\n\t}\n\telse if ( sum1 == sum2 )\n\t{\n\t\tcout << sum1 << endl ;\n\t}\n\t\n\t\n\treturn 0 ;\n\t\n} ",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std ;\nint a[200005] ;\n\nint main()\n{\n\t\n\tint n , sum1 = 0 , sum2 = 0 ;\t\t\t\t//sum1   数字1的次数\t\t\tsum2 数字2的次数 \n\tcin >> n ;\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t{\n\t\tcin >> a[i] ;\n\t\t\n\t}\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t{\n\t\tif ( a[i] == 1 )\n\t\t{\n\t\t\tsum1++ ;\n\t\t}\n\t\telse if ( a[i] == 2 )\n\t\t{\n\t\t\tsum2++ ;\n\t\t}\n\t}\n\tif ( sum1 > sum2 )\n\t{\n\t\tcout << sum2 + ( sum1 - sum2 ) / 3 << endl ;\n\t}\n\telse \n\t{\n\t\t\tcout << sum1 << endl ;\t\n\t}\n\t\n\treturn 0 ;\n\t\n} ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public void timerInterrupt() {\n    boolean interruptStatus = nachos.threads.Machine.interrupt().disable();\n    long currentTime = Machine.timer.getTime();\n    while ((!(waitQueue.isEmpty())) && ((waitQueue.peek().wakeTime) <= (time))) {\n        waitQueue.poll().ready();\n    } \n    nachos.threads.Machine.interrupt().restore(interruptStatus);\n    machos.threads.KThread.currentThread().yield();\n}",
        "fixed_code": "public void timerInterrupt() {\n    boolean interruptStatus = nachos.threads.Machine.interrupt().disable();\n    long currentTime = nachos.threads.Machine.timer().getTime();\n    while ((!(waitQueue.isEmpty())) && ((waitQueue.peek().wakeTime) <= currentTime)) {\n        waitQueue.poll().waitingThread.ready();\n    } \n    nachos.threads.Machine.interrupt().restore(interruptStatus);\n    nachos.threads.KThread.currentThread().yield();\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "for _ in range(int(input())):\r\n    i = 0\r\n    a = list(map(int,input().split()))\r\n    m = list(map(int,input().split()))\r\n    n = list(map(int,input().split()))\r\n    for i in range(0,a[2]-2):\r\n        for j in range(i+1,a[2]-1):\r\n            if m[j] != m[i] and n[j] != m[j]:\r\n                ans += 1\r\n    print(ans)",
        "fixed_code": "for _ in range(int(input())):\r\n    a,b,k = map(int,input().split())\r\n    m = list(map(int,input().split()))\r\n    n = list(map(int,input().split()))\r\n    p = [0]*a\r\n    q = [0]*b\r\n    for i in m:\r\n        p[i-1]+=1\r\n    for i in n:\r\n        q[i-1]+=1\r\n    ans = (k*(k-1))//2\r\n    for i in p:\r\n        ans -= (i*(i-1))//2\r\n    for i in q:\r\n        ans -= (i*(i-1))//2\r\n    print(ans)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define jaldi ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define kuch(a,n) for(int i=0;i<n;i++) cin>>a[i]\n#define Max(x,y,z) max(x,max(y,z))\n#define Min(x,y,z) min(x,min(y,z))\n#define pb push_back\n#define bs(v,x)\tbinary_search(v.begin(),v.end(),x)\n#define mci(b)\tcout<<b<<\"\\n\"\n#define bvb(n)\tlong long n;cin>>n;\n\ntypedef long long ll;\ntypedef vector<long long> vll ;\ntypedef long double ld;\nconst ll maxn = 1e10, mod = 1e9 + 7;\n\nll gcd(ll a,ll b) \n{\n\tif(a == 0)\n\t\treturn b;\n\treturn gcd(b%a, a);\n}\n\nll lcm(ll a, ll b)  \n{  \n    return (a*b)/gcd(a, b);  \n}\n\nint main()\n{\t\n\tjaldi;\n\tll n,m,x;cin>>n>>m;ll arr[n];\n\tif(n>m)\t\n\t{\n\t\t\tcout<<\"YES\"<<\"\\n\";return 0;\n\t}\n\t\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>x;\n\t\tarr[i]=x%m;\n\t}\n\tll dp1[m];\n\tfor(ll i=0;i<m;i++)\n\t{\n\t\tdp1[i]=0;\n\t}\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tdp1[arr[i]]=1;\n\t}\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tbool dc[m];memset(dc,false,m);\n\t\tfor(ll j=0;j<m;j++)\n\t\t{\n\t\t\tif(dp1[j]==1 && dp1[(j+arr[i])%m]==0)\n\t\t\t{\n\t\t\t\tdc[(j+arr[i])%m]=true;\n\t\t\t}\n\t\t}\n\t\tfor(ll k=0;k<m;k++)\n\t\t{\n\t\t\tif(dc[i])\n\t\t\t\tdp1[i]=1;\n\t\t}\n\n\t}\n\tif(dp1[0]==1)\n\t\t\tcout<<\"YES\"<<\"\\n\";\n\telse\tcout<<\"NO\"<<\"\\n\";\nreturn 0;\n}\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define jaldi ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define kuch(a,n) for(int i=0;i<n;i++) cin>>a[i]\n#define Max(x,y,z) max(x,max(y,z))\n#define Min(x,y,z) min(x,min(y,z))\n#define pb push_back\n#define bs(v,x)\tbinary_search(v.begin(),v.end(),x)\n#define mci(b)\tcout<<b<<\"\\n\"\n#define bvb(n)\tlong long n;cin>>n;\n\ntypedef long long ll;\ntypedef vector<long long> vll ;\ntypedef long double ld;\nconst ll maxn = 1e10, mod = 1e9 + 7;\n\nll gcd(ll a,ll b) \n{\n\tif(a == 0)\n\t\treturn b;\n\treturn gcd(b%a, a);\n}\n\nll lcm(ll a, ll b)  \n{  \n    return (a*b)/gcd(a, b);  \n}\n\nint main()\n{\t\n\tjaldi;\n\tll n,m,x;cin>>n>>m;ll arr[n];\n\tif(n>m)\t\n\t{\n\t\t\tcout<<\"YES\"<<\"\\n\";return 0;\n\t}\n\t\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>x;\n\t\tarr[i]=x%m;\n\t}\n\tll dp1[m];\n\tfor(ll i=0;i<m;i++)\n\t{\n\t\tdp1[i]=0;\n\t}\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tdp1[arr[i]]=1;\n\t}\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tbool dc[m];memset(dc,false,m);\n\t\tfor(ll j=0;j<m;j++)\n\t\t{\n\t\t\tif(dp1[j]==1 && dp1[(j+arr[i])%m]==0)\n\t\t\t{\n\t\t\t\tdc[(j+arr[i])%m]=true;\n\t\t\t}\n\t\t}\n\t\tfor(ll k=0;k<m;k++)\n\t\t{\n\t\t\tif(dc[k])\n\t\t\t\tdp1[k]=1;\n\t\t}\n\t}\n\n\tif(dp1[0]==1)\n\t\t\tcout<<\"YES\"<<\"\\n\";\n\telse\tcout<<\"NO\"<<\"\\n\";\nreturn 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws NumberFormatException, IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        String[] input = br.readLine().split(\" \");\r\n        int tests = Integer.parseInt(input[0]);\r\n        int[] a = new int[1001];\r\n        for (int i = 0; i < a.length; i++)\r\n            a[i] = Integer.MAX_VALUE;\r\n        a[1] = 0;\r\n        for (int i = 1; i < a.length; i++) {\r\n            for (int j = 1; j <= i; j++) {\r\n                int div = i / j;\r\n                if (div + i < a.length)\r\n                    a[div + i] = Math.min(a[i] + 1, a[div + i]);\r\n            }\r\n        }\r\n        for (int tc = 0; tc < tests; tc++) {\r\n            input = br.readLine().split(\" \");\r\n            int n = Integer.parseInt(input[0]);\r\n            int k = Integer.parseInt(input[1]);\r\n\r\n            int[] b = new int[n];\r\n            int[] c = new int[n];\r\n            input = br.readLine().split(\" \");\r\n            for (int i = 0; i < n; i++) {\r\n                b[i] = Integer.parseInt(input[i]);\r\n            }\r\n\r\n            input = br.readLine().split(\" \");\r\n            for (int i = 0; i < n; i++) {\r\n                c[i] = Integer.parseInt(input[i]);\r\n            }\r\n\r\n            int[][] dp = new int[n + 1][k + 1];\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j < k; j++) {\r\n                    if (j + a[b[i]] <= k)\r\n                        dp[i + 1][j + a[b[i]]] = Math.max(dp[i][j] + c[i], dp[i + 1][j + a[b[i]]]);\r\n                    dp[i + 1][j] = Math.max(dp[i][j], dp[i + 1][j]);\r\n                }\r\n            }\r\n\r\n            int max = 0;\r\n            for (int i = 0; i <= k; i++) {\r\n                // System.out.println(dp[n][i]);\r\n                max = Math.max(max, dp[n][i]);\r\n            }\r\n\r\n            System.out.println(max);\r\n\r\n        }\r\n    }\r\n}",
        "fixed_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws NumberFormatException, IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        String[] input = br.readLine().split(\" \");\r\n        int tests = Integer.parseInt(input[0]);\r\n        int[] a = new int[1001];\r\n        for (int i = 0; i < a.length; i++)\r\n            a[i] = Integer.MAX_VALUE;\r\n        a[1] = 0;\r\n        for (int i = 1; i < a.length; i++) {\r\n            for (int j = 1; j <= i; j++) {\r\n                int div = i / j;\r\n                if (div + i < a.length)\r\n                    a[div + i] = Math.min(a[i] + 1, a[div + i]);\r\n            }\r\n        }\r\n        for (int tc = 0; tc < tests; tc++) {\r\n            input = br.readLine().split(\" \");\r\n            int n = Integer.parseInt(input[0]);\r\n            int k = Integer.parseInt(input[1]);\r\n\r\n            int[] b = new int[n];\r\n            int[] c = new int[n];\r\n            input = br.readLine().split(\" \");\r\n            for (int i = 0; i < n; i++) {\r\n                b[i] = Integer.parseInt(input[i]);\r\n            }\r\n\r\n            input = br.readLine().split(\" \");\r\n            for (int i = 0; i < n; i++) {\r\n                c[i] = Integer.parseInt(input[i]);\r\n            }\r\n\r\n            int[][] dp = new int[2][k + 1];\r\n            int sum = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j <= k && j <= sum; j++) {\r\n                    if (j + a[b[i]] <= k)\r\n                        dp[1][j + a[b[i]]] = Math.max(dp[0][j] + c[i], dp[1][j + a[b[i]]]);\r\n                    dp[1][j] = Math.max(dp[0][j], dp[1][j]);\r\n                }\r\n                sum += a[b[i]];\r\n                int[] tmp = dp[0];\r\n                dp[0] = dp[1];\r\n                dp[1] = tmp;\r\n            }\r\n\r\n            int max = 0;\r\n            for (int i = 0; i <= k; i++) {\r\n                // System.out.println(dp[n][i]);\r\n                max = Math.max(max, dp[0][i]);\r\n            }\r\n\r\n            System.out.println(max);\r\n\r\n        }\r\n    }\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n \nusing namespace std;\n \nint main() {\n    \n    int n,x;\n    cin >> n;\n    \n    int neg[105];\n    int ineg = 0, ipos = 0;\n    int pos[105];\n    int zero[105];\n    int zeros = 0;\n    \n    while (n--) {\n        cin >> x;\n        if (x == 0) {\n            zeros++;\n            zero[zeros] = 0;\n        }\n        if (x < 0) {\n            neg[ineg] = x;\n            ineg++;\n        }\n        if (x > 0) {\n            pos[ipos] = x;\n            ipos++;\n        }\n    }\n    \n    if (ipos == 0) {\n        pos[0] = neg[ineg - 1];\n        pos[1] = neg[ineg - 2];\n        \n        ipos = 2;\n        ineg -= 2;\n    }\n    \n    if (ineg % 2 == 0) {\n        \n        zero[zeros] = neg[ineg - 1];\n        zeros++;\n        ineg--;\n    }\n    \n    cout << ineg << \" \";\n    for (int i = 0; i < ineg; i++) {\n        cout << neg[i] << \" \";\n    }\n    cout << endl;\n    \n    cout << ipos << \" \";\n    for (int i = 0; i < ipos; i++) {\n        cout << pos[i] << \" \";\n    }\n    cout << endl;\n    \n    cout << zeros << \" \";\n    for (int i = 0; i < zeros; i++) {\n        cout << zero[i] << \" \";\n    }\n    cout << endl;\n\n    \n    \n    \n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n \nusing namespace std;\n \nint main() {\n    \n    int n,x;\n    cin >> n;\n    \n    int neg[105];\n    int ineg = 0, ipos = 0;\n    int pos[105];\n    int zero[105];\n    int zeros = 0;\n    \n    while (n--) {\n        cin >> x;\n        if (x == 0) {\n            zero[zeros] = 0;\n            zeros++;\n        }\n        if (x < 0) {\n            neg[ineg] = x;\n            ineg++;\n        }\n        if (x > 0) {\n            pos[ipos] = x;\n            ipos++;\n        }\n    }\n    \n    if (ipos == 0) {\n        pos[0] = neg[ineg - 1];\n        pos[1] = neg[ineg - 2];\n        \n        ipos = 2;\n        ineg -= 2;\n    }\n    \n    if (ineg % 2 == 0) {\n        \n        zero[zeros] = neg[ineg - 1];\n        zeros++;\n        ineg--;\n    }\n    \n    cout << ineg << \" \";\n    for (int i = 0; i < ineg; i++) {\n        cout << neg[i] << \" \";\n    }\n    cout << endl;\n    \n    cout << ipos << \" \";\n    for (int i = 0; i < ipos; i++) {\n        cout << pos[i] << \" \";\n    }\n    cout << endl;\n    \n    cout << zeros << \" \";\n    for (int i = 0; i < zeros; i++) {\n        cout << zero[i] << \" \";\n    }\n    cout << endl;\n\n    \n    \n    \n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define int long long int \n#define TRY_HARD ios_base::sync_with_stdio(false);  cin.tie(NULL);  cout.tie(NULL);\nusing namespace std;\n\n\n//*********************************************************************************************************************************************************************************\n//TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD \n//**********************************************************************************************************************************************************************************\n\n\nsigned main()\n {\n\tTRY_HARD ;\n\tint n , min = INT_MAX ;\n\tcin >> n ;\n\tint a[n] ;\n\t\n\tfor ( int i = 0 ; i < n ; i++ )\n\t{\n\t    cin >> a[i] ;\n\t    int k = a[i] ;\n\t    int p , sum = 0 ;\n\t    for ( int j = 0 ; j < k ; j++ )\n\t    {\n\t        cin >> p ;\n\t        sum = sum + (p * 5) ;\n\t    }\n\t    sum = sum + ( k * 15 ) ;\n\t    if ( sum < min )\n\t    min = sum ;\n\t}\n\tcout << min ;\n\t\n        \n\t\n }",
        "fixed_code": "#include<bits/stdc++.h>\n#define int long long int \n#define TRY_HARD ios_base::sync_with_stdio(false);  cin.tie(NULL);  cout.tie(NULL);\nusing namespace std;\n\n\n//*********************************************************************************************************************************************************************************\n//TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD TRY_HARD \n//**********************************************************************************************************************************************************************************\n\n\nsigned main()\n {\n\tTRY_HARD ;\n\tint n , min = INT_MAX ;\n\tcin >> n ;\n\tint a[n] ;\n\tfor ( int i = 0 ; i < n ; i++ )\n\t{\n\t    cin >> a[i] ;\n\t}\n\tfor ( int i = 0 ; i < n ; i++ )\n\t{\n\t    \n\t    int k = a[i] ;\n\t    int p , sum = 0 ;\n\t    for ( int j = 0 ; j < k ; j++ )\n\t    {\n\t        cin >> p ;\n\t        sum = sum + (p * 5) ;\n\t    }\n\t    sum = sum + ( k * 15 ) ;\n\t    if ( sum < min )\n\t    min = sum ;\n\t}\n\tcout << min ;\n\t\n        \n\t\n }",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#include <vector>\n#include <utility>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n\tint n,m,k,cont,x,y;\n\tstring s;\n\tvector < vector<char> > G;\n\tvector < vector<int> > matriz;\n\tvector<int> muros;\n\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\n\tG.resize(n);\n\tmatriz.resize(n);\n\tgetline(cin,s);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tgetline(cin,s);\n\t\tfor (int j = 0; j < m; ++j)\n\t\t{\n\t\t\tG[i].push_back(s[j]);\n\t\t}\n\t}\n\t\n\tcont=0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < m; ++j)\n\t\t{\n\t\t\tif (G[i][j]=='*')\n\t\t\t{\n\t\t\t\tmatriz[i].push_back(-1);\n\t\t\t\tif (i>0)\n\t\t\t\t{\n\t\t\t\t\tif(matriz[i-1][j]!=-1)\n\t\t\t\t\t\tmuros[matriz[i-1][j]]++;\n\t\t\t\t}\n\t\t\t\tif (j>0)\n\t\t\t\t{\n\t\t\t\t\tif(matriz[i][j-1]!=-1)\n\t\t\t\t\t\tmuros[matriz[i][j-1]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(matriz[i-1][j]==-1 && matriz[i][j-1]==-1){\n\t\t\t\t\tmatriz[i].push_back(cont);\n\t\t\t\t\tmuros.push_back(2);\n\t\t\t\t\tcont++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(matriz[i-1][j]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmatriz[i].push_back(matriz[i-1][j]);\n\t\t\t\t\t\tmuros[matriz[i-1][j]]++;\n\t\t\t\t\t} \n\t\t\t\t\tif (matriz[i][j-1]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmatriz[i].push_back(matriz[i][j-1]);\n\t\t\t\t\t\tmuros[matriz[i][j-1]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tprintf(\"%d\\n\",muros[matriz[x-1][y-1]]);\n\t}\n\n\treturn 0;\n}\n\n\n// 1500413127500\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<long long> vi;\ntypedef vector<pair<long long,long long> > vii;\ntypedef pair<long long,long long> ii;\n#define mp(x,y) make_pair(x,y)\n#define INF 100000000000000\nvi visited;\nll componente;\nvector <vector <char> > mapa;\n\nvoid BFS(vector<vi > &graph,int s ){\nqueue <ll> q;\nq.push(s);\nvisited[s] = componente;\nwhile(!q.empty()){\n\tfor(ll i = 0; i < graph[q.front()].size();i++){\n\t\tll node = graph[q.front()][i];\n\t\tif(visited[node] == -1){\n\t\t\tvisited[node] = componente;\n\t\t\tq.push(node);\n\t\t}\n\t}\n\tq.pop();\n}\n}\n\n\nvoid visitados(int tam, int m,vector<vi> &graph){\n\tvisited.clear();\n\tvisited.resize(tam,-1);\n\tcomponente = 1;\n\tfor(int i = 0; i < tam; i++){\n\t\tif(visited[i] == -1 && mapa[i/m][i%m] == '.'){\n\t\t\tBFS(graph,i);\n\t\t\tcomponente++;\n\t\t}\n\t}\n}\n\n\nbool comprobar(int x, int y, int n, int m){\n\tif(x >= 0 && x < m && y >= 0 && y < n && mapa[y][x] == '.')return true;\n\telse return false;\n}\n\nbool comprobar2(int x, int y, int n, int m){\n\tif(x >= 0 && x < m && y >= 0 && y < n && mapa[y][x] == '*')return true;\n\telse return false;\n}\n\nint main(){\n\tlong long n, m, q,aux,a,b;\n\tchar c;\n\tscanf(\"%lld %lld %lld\",&n,&m,&q);\n\tgetchar();\n\tvector<vi> g(n*m,vi());\n\tvi sumas(n*m,0);\n\tmapa.resize(n,vector <char>(m));\n\tfor(ll i = 0; i < n; i++){\n\t\tfor(ll j = 0; j < m; j++){\n\t\t\tscanf(\"%c\",&c);\n\t\t\tmapa[i][j] = c;\t\n\t\t}\n\t\t\tgetchar();\n\t}\n\tfor(ll i = 0; i < n; i++){\n\t\tfor(ll j = 0; j < m; j++){\n\t\t\tif(mapa[i][j] == '.'){\n\t\t\t\tif(comprobar(j-1,i,n,m)){\n\t\t\t\t\tg[(i*m)+j-1 ].push_back( (i*m)+j );\n\t\t\t\t\tg[(i*m)+j ].push_back( (i*m)+j-1 );\n\t\t\t\t}\n\t\t\t\tif(comprobar(j+1,i,n,m)){\n\t\t\t\t\tg[(i*m)+j+1 ].push_back( (i*m)+j );\n\t\t\t\t\tg[(i*m)+j ].push_back( (i*m)+j+1 );\n\t\t\t\t}\n\t\t\t\tif(comprobar(j,i-1,n,m)){\n\t\t\t\t\tg[( (i-1) *m)+j ].push_back( (i*m)+j );\n\t\t\t\t\tg[(i*m)+j ].push_back( ( (i-1) *m)+j );\n\t\t\t\t}\n\t\t\t\tif(comprobar(j,i+1,n,m)){\n\t\t\t\t\tg[( (i+1) *m)+j ].push_back( (i*m)+j );\n\t\t\t\t\tg[(i*m)+j ].push_back( ( (i+1)  *m)+j );\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t}\n\tfor(ll i = 0; i < n; i++){\n\t\tfor(ll j = 0; j < m; j++){\n\t\t\tif(mapa[i][j] == '.'){\n\t\t\t\tif(comprobar2(j-1,i,n,m)){\n\t\t\t\t\tsumas[((i)*m)+j]++;\n\t\t\t\t}\n\t\t\t\tif(comprobar2(j+1,i,n,m)){\n\t\t\t\t\tsumas[((i)*m)+j]++;\n\t\t\t\t}\n\t\t\t\tif(comprobar2(j,i-1,n,m)){\n\t\t\t\t\tsumas[((i)*m)+j]++;\n\t\t\t\t}\n\t\t\t\tif(comprobar2(j,i+1,n,m)){\n\t\t\t\t\tsumas[((i)*m)+j]++;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t}\n\tvisitados(n*m,m,g);\n\tvi respuesta(componente,0);\n\tfor(int i = 0; i < n*m;i++){\n\t\trespuesta[visited[i]]+=sumas[i];\n\t}\n\tfor(int i = 0; i < q; i++){\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tprintf(\"%lld\\n\",respuesta[visited[(a*m)+b]] );\n\t}\n\n\treturn 0;\n}\n// 1500417631426\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"nocross.in\",\"r\",stdin)\n#define OUT freopen(\"nocross.out\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define LOG 19\n#define off 2\n\n#define mod 1000000007LL\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less< i64 >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\n#define INF 2000000000\n#define maxn 100005\n\n#define log 20\n\nvector <int> g[maxn] ;\nint dp[maxn][2] ;\n\nvoid dfs(int u)\n{\n    dp[u][0] = 1 ;\n\n    for( int v: g[u])\n    {\n        dfs(v) ;\n\n        int ev = 0 , od = 0 ;\n\n        ev = ( 1LL*dp[u][0]*(dp[v][0]+1) + 1LL*dp[u][1]*dp[v][1] )%mod ;\n        od = ( 1LL*dp[u][1]*(dp[v][0]+1) + 1LL*dp[u][0]*dp[v][1] )%mod ;\n        dp[u][0] = ev ; dp[u][1] = od ;\n    }\n\n//    printf(\"-- %d %d\\n\",dp[u][0],dp[u][1]) ;\n\n    dp[u][0] = (2*dp[u][0])%mod ;\n    dp[u][1] = (2*dp[u][1])%mod ;\n\n    int a[2] = {0,0} ;\n    for(int v : g[u])\n    {\n        int ev = (1LL*a[1]*dp[v][1])%mod , od = ( 1LL*a[0]*dp[v][1] + a[1] + dp[v][1] )%mod ;\n        a[0] = ev ; a[1] = od ;\n    }\n    int x = 1 ;\n    for(int v:g[u])\n    {\n        x = (1LL*x*(dp[v][0]+1))%mod ;\n    }\n\n    dp[u][0] = ((dp[u][0] -x)%mod + mod)%mod ;\n    dp[u][1] = ((dp[u][1] -a[1])%mod + mod)%mod ;\n\n    swap(dp[u][0],dp[u][1]) ;\n\n//    printf(\"%d : %d %d\\n\" , u , dp[u][0],dp[u][1]) ;\n}\n\nint main()\n{\n    int n ;\n    scanf(\"%d\",&n) ;\n\n    for(int i=2; i<=n ; i++)\n    {\n        int p ;\n        scanf(\"%d\",&p) ;\n        g[p].pb(i) ;\n    }\n\n    dfs(1) ;\n\n    printf(\"%d\\n\" , (dp[1][0]+dp[1][1])%mod ) ;\n\n    return 0 ;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"nocross.in\",\"r\",stdin)\n#define OUT freopen(\"nocross.out\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define LOG 19\n#define off 2\n\n#define mod 1000000007LL\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less< i64 >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\n#define INF 2000000000\n#define maxn 100005\n\n#define log 20\n\nvector <int> g[maxn] ;\nint dp[maxn][2] ;\n\nvoid dfs(int u)\n{\n    dp[u][0] = 1 ;\n\n    for( int v: g[u])\n    {\n        dfs(v) ;\n\n        int ev = 0 , od = 0 ;\n\n        ev = ( 1LL*dp[u][0]*(dp[v][0]+1) + 1LL*dp[u][1]*dp[v][1] )%mod ;\n        od = ( 1LL*dp[u][1]*(dp[v][0]+1) + 1LL*dp[u][0]*dp[v][1] )%mod ;\n        dp[u][0] = ev ; dp[u][1] = od ;\n    }\n\n  //  printf(\"-- %d %d\\n\",dp[u][0],dp[u][1]) ;\n\n    dp[u][0] = (2*dp[u][0])%mod ;\n    dp[u][1] = (2*dp[u][1])%mod ;\n\n    int a[2] = {0,0} ;\n    for(int v : g[u])\n    {\n        int ev = (1LL*a[1]*dp[v][1] + a[0])%mod , od = ( 1LL*a[0]*dp[v][1] + a[1] + dp[v][1] )%mod ;\n        a[0] = ev ; a[1] = od ;\n    }\n    int x = 1 ;\n    for(int v:g[u])\n    {\n        x = (1LL*x*(dp[v][0]+1))%mod ;\n    }\n\n    dp[u][0] = ((dp[u][0] -x)%mod + mod)%mod ;\n    dp[u][1] = ((dp[u][1] -a[1])%mod + mod)%mod ;\n\n    swap(dp[u][0],dp[u][1]) ;\n\n//    printf(\"%d : %d %d\\n\" , u , dp[u][0],dp[u][1]) ;\n}\n\nint main()\n{\n    int n ;\n    scanf(\"%d\",&n) ;\n\n    for(int i=2; i<=n ; i++)\n    {\n        int p ;\n        scanf(\"%d\",&p) ;\n        g[p].pb(i) ;\n    }\n\n    dfs(1) ;\n\n    printf(\"%d\\n\" , (dp[1][0]+dp[1][1])%mod ) ;\n\n    return 0 ;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define pll pair <ll , ll>\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n\n#define X first\n#define Y second\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n\nconst ll MAXN=1e5+10;\nconst ll MAX_LOG=20;\nconst ll INF=1e10+10;\nconst ll Mod=1e9+7;\n\nll w[MAXN][MAX_LOG];\nll dp[MAXN][MAX_LOG];\n\nll a[MAXN];\nll ps[MAXN];\nll pw2[MAXN];\n\nint main()\n{\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n , q;\n\tcin>>n>>q;\n\n\tfor(ll i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n\n    for(ll i=n;i>=1;i--)\n    {\n        ps[i]=ps[i+1]*2+(Mod+a[i]);\n        ps[i]%=Mod;\n    }\n\n\tpw2[0]=1;\n\n\tfor(ll i=1;i<MAXN;i++)\n    {\n        pw2[i]=pw2[i-1]*2;\n        pw2[i]%=Mod;\n    }\n\n\tfor(ll i=1;i<=n;i++)\n    {\n        if (a[i]<0)\n        {\n            dp[i][0]=i-1;\n        }\n\n        if (a[i]==0)\n        {\n            dp[i][0]=dp[i-1][0];\n        }\n\n        if (a[i]>0)\n        {\n            dp[i][0]=i-1;\n            ll x=a[i];\n\n            while (dp[i][0]>0)\n            {\n                if (x>INF)\n                {\n                    dp[i][0]=0;\n                    break;\n                }\n\n                if (2*x>=-a[dp[i][0]])\n                {\n                    x=2*x+a[dp[i][0]];\n                    dp[i][0]--;\n                }\n                else\n                {\n                    dp[i][0]--;\n                    break;\n                }\n            }\n        }\n\n        w[i][0]=ps[dp[i][0]+1]-((pw2[i-dp[i][0]]*ps[i+1])%Mod)+Mod;\n        w[i][0]%=Mod;\n    }\n\n    for(ll i=1;i<MAX_LOG;i++)\n    {\n        for(ll j=1;j<=n;j++)\n        {\n            dp[j][i]=dp[dp[j][i-1]][i-1];\n            w[j][i]=w[j][i-1]+w[dp[j][i-1]][i-1];\n            w[j][i]%=Mod;\n        }\n    }\n\n    for(ll i=1;i<=q;i++)\n    {\n        ll l , r;\n        cin>>l>>r;\n\n        ll res=0;\n\n        for(ll j=MAX_LOG;j>=0;j--)\n        {\n            if (dp[r][j]>=l)\n            {\n                res+=w[r][j];\n                res%=Mod;\n                r=dp[r][j];\n            }\n        }\n\n        res*=2;\n        res%=Mod;\n\n        res+=ps[l]-((pw2[r-l+1]*ps[r+1])%Mod)+Mod;\n        res%=Mod;\n\n        cout<<res<<endl;\n    }\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define pll pair <ll , ll>\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n\n#define X first\n#define Y second\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n\nconst ll MAXN=1e5+10;\nconst ll MAX_LOG=20;\nconst ll INF=1e9+10;\nconst ll Mod=1e9+7;\n\nll w[MAXN][MAX_LOG];\nll dp[MAXN][MAX_LOG];\n\nll a[MAXN];\nll ps[MAXN];\nll pw2[MAXN];\n\nint main()\n{\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n , q;\n\tcin>>n>>q;\n\n\tfor(ll i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n\n    for(ll i=n;i>=1;i--)\n    {\n        ps[i]=ps[i+1]*2+(Mod+a[i]);\n        ps[i]%=Mod;\n    }\n\n\tpw2[0]=1;\n\n\tfor(ll i=1;i<MAXN;i++)\n    {\n        pw2[i]=pw2[i-1]*2;\n        pw2[i]%=Mod;\n    }\n\n\tfor(ll i=1;i<=n;i++)\n    {\n        if (a[i]<0)\n        {\n            dp[i][0]=i-1;\n        }\n\n        if (a[i]>=0)\n        {\n            dp[i][0]=i-1;\n            ll x=a[i];\n\n            while (dp[i][0]>0)\n            {\n                if (x==0)\n                {\n                    dp[i][0]=dp[dp[i][0]][0];\n                    break;\n                }\n\n                if (x>INF)\n                {\n                    dp[i][0]=0;\n                    break;\n                }\n\n                if (2*x>=-a[dp[i][0]])\n                {\n                    x=2*x+a[dp[i][0]];\n                    dp[i][0]--;\n                }\n                else\n                {\n                    dp[i][0]--;\n                    break;\n                }\n            }\n        }\n\n        w[i][0]=ps[dp[i][0]+1]-((pw2[i-dp[i][0]]*ps[i+1])%Mod)+Mod;\n        w[i][0]%=Mod;\n    }\n\n    for(ll i=1;i<MAX_LOG;i++)\n    {\n        for(ll j=1;j<=n;j++)\n        {\n            dp[j][i]=dp[dp[j][i-1]][i-1];\n            w[j][i]=w[j][i-1]+w[dp[j][i-1]][i-1];\n            w[j][i]%=Mod;\n        }\n    }\n\n    for(ll i=1;i<=q;i++)\n    {\n        ll l , r;\n        cin>>l>>r;\n\n        ll res=0;\n\n        for(ll j=MAX_LOG-1;j>=0;j--)\n        {\n            if (dp[r][j]>=l)\n            {\n                res+=w[r][j];\n                res%=Mod;\n                r=dp[r][j];\n            }\n        }\n\n        res*=2;\n        res%=Mod;\n\n        res+=ps[l]-((pw2[r-l+1]*ps[r+1])%Mod)+Mod;\n        res%=Mod;\n\n        cout<<res<<endl;\n    }\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@org.testng.annotations.Test(priority = 66, enabled = false)\npublic void ChngCommPrefAddressEditSuccess() {\n    try {\n        java.util.Map<java.lang.String, java.lang.String> Data = readxml.getUserData(\"TestData.xml\", \"user-to-update-comm-pref\");\n        java.lang.String userId = Data.get(\"UserName\");\n        java.lang.String Pwd = Data.get(\"password\");\n        java.lang.String firstName1 = Data.get(\"firstname\");\n        java.lang.String firstName2 = Data.get(\"firstnameagain\");\n        java.lang.String lastName = Data.get(\"lastname\");\n        java.lang.String address1 = Data.get(\"address1\");\n        java.lang.String address2 = Data.get(\"address2\");\n        java.lang.String city = Data.get(\"city\");\n        java.lang.String state = Data.get(\"state\");\n        java.lang.String zip = Data.get(\"zipcode\");\n        cubHome = new com.test.regression.cub.pages.CubHome(_driver);\n        org.testng.asserts.SoftAssert sa = new org.testng.asserts.SoftAssert();\n        log.info(\"Cub Home page is launched\");\n        cubHome.clickSignInLink();\n        cubHome.enterLoginDetails(userId, Pwd);\n        cubHome.clickSignInButton();\n        java.lang.Thread.sleep(5000);\n        cp = new com.test.regression.cub.pages.CommuPrefPage(_driver);\n        cp.clickOnMyAccountUnderMyTools(_driver);\n        cp.clickEditCommunicationPref();\n        cp.cpCheckDirectMail(_driver);\n        cp.cpClickLinkToUpdateMailingAddress();\n        cp.cpEnterAddress(firstName1, lastName, address1, address2, city, state, zip);\n        cp.cpClickSaveButtonInEditAddress();\n        cp.clickEditLinkInQAS();\n        cp.cpEnterAddress(firstName2, lastName, address1, address2, city, state, zip);\n        cp.cpClickSaveButtonInEditAddress();\n        cp.clickUseThisAddressButton();\n        cp.cpClickSaveButtonInEditAddress();\n        java.lang.String FN = cp.cpGetFirstName();\n        java.lang.Thread.sleep(20000);\n        java.lang.String userData = cp.getUserData();\n        java.util.List<java.lang.String> completeUserData = java.util.Arrays.asList(userData.split(\"\\n\"));\n        java.lang.String temp = completeUserData.get(0);\n        java.util.List<java.lang.String> nameData = java.util.Arrays.asList(temp.split(\"\\\\s\"));\n        java.lang.String FirstNameData = nameData.get(0);\n        java.lang.System.out.println((\"Fetching First Name information from Communication Pref section\\n FirstName:\" + FirstNameData));\n        sa.assertEquals(FN, firstName2, \"\\n Address not updated in Communication Pref section\");\n        sa.assertEquals(FirstNameData, firstName2, \"\\n Address not updated in Contact Info Section\");\n        sa.assertEquals(FN, FirstNameData, \"\\n Address in Communication Pref section is not matching with address in Cont Info Section\");\n        sa.assertAll();\n        java.lang.System.out.println(\"Address updated successfully in Communication Pref and Contact information Sections\");\n        log.info(\"Address updated  successfully in Communication Pref and Contact information Sections\");\n    } catch (java.lang.InterruptedException ie) {\n        log.info(ie.getMessage());\n        org.testng.Assert.fail(\"Caught Interrupted Exception\");\n    } catch (java.io.IOException ioe) {\n        log.info(ioe.getMessage());\n        org.testng.Assert.fail(\"Caught IOException Exception\");\n    } catch (javax.xml.xpath.XPathExpressionException xee) {\n        log.info(xee.getMessage());\n        org.testng.Assert.fail(\"Caught XPathExpressionException Exception\");\n    } catch (javax.xml.parsers.ParserConfigurationException pce) {\n        log.info(pce.getMessage());\n        org.testng.Assert.fail(\"Caught ParserConfigurationException Exception\");\n    } catch (org.xml.sax.SAXException saxe) {\n        log.info(saxe.getMessage());\n        org.testng.Assert.fail(\"Caught SAXException Exception\");\n    } catch (java.lang.Exception e) {\n        log.info(e.getMessage());\n        org.testng.Assert.fail(e.getLocalizedMessage());\n    }\n}",
        "fixed_code": "@org.testng.annotations.Test(priority = 66, enabled = true)\npublic void ChngCommPrefAddressEditSuccess() {\n    try {\n        java.util.Map<java.lang.String, java.lang.String> Data = readxml.getUserData(\"TestData.xml\", \"user-to-update-comm-pref\");\n        java.lang.String userId = Data.get(\"UserName\");\n        java.lang.String Pwd = Data.get(\"password\");\n        java.lang.String firstName1 = Data.get(\"firstname\");\n        java.lang.String firstName2 = Data.get(\"firstnameagain\");\n        java.lang.String lastName = Data.get(\"lastname\");\n        java.lang.String address1 = Data.get(\"address1\");\n        java.lang.String address2 = Data.get(\"address2\");\n        java.lang.String city = Data.get(\"city\");\n        java.lang.String state = Data.get(\"state\");\n        java.lang.String zip = Data.get(\"zipcode\");\n        cubHome = new com.test.regression.cub.pages.CubHome(_driver);\n        org.testng.asserts.SoftAssert sa = new org.testng.asserts.SoftAssert();\n        log.info(\"Cub Home page is launched\");\n        cubHome.clickSignInLink();\n        cubHome.enterLoginDetails(userId, Pwd);\n        cubHome.clickSignInButton();\n        java.lang.Thread.sleep(5000);\n        cp = new com.test.regression.cub.pages.CommuPrefPage(_driver);\n        cp.clickOnMyAccountUnderMyTools(_driver);\n        cp.clickEditCommunicationPref();\n        cp.cpCheckDirectMail(_driver);\n        cp.cpClickLinkToUpdateMailingAddress();\n        cp.cpEnterAddress(firstName1, lastName, address1, address2, city, state, zip);\n        cp.cpClickSaveButtonInEditAddress();\n        cp.clickEditLinkInQAS();\n        cp.cpEnterAddress(firstName2, lastName, address1, address2, city, state, zip);\n        cp.cpClickSaveButtonInEditAddress();\n        cp.clickUseThisAddressButton();\n        cp.cpClickSaveButtonInEditAddress();\n        java.lang.String FN = cp.cpGetFirstName();\n        java.lang.Thread.sleep(20000);\n        java.lang.String userData = cp.getUserData();\n        java.util.List<java.lang.String> completeUserData = java.util.Arrays.asList(userData.split(\"\\n\"));\n        java.lang.String temp = completeUserData.get(0);\n        java.util.List<java.lang.String> nameData = java.util.Arrays.asList(temp.split(\"\\\\s\"));\n        java.lang.String FirstNameData = nameData.get(0);\n        java.lang.System.out.println((\"Fetching First Name information from Communication Pref section\\n FirstName:\" + FirstNameData));\n        sa.assertEquals(FN, firstName2, \"\\n Address not updated in Communication Pref section\");\n        sa.assertEquals(FirstNameData, firstName2, \"\\n Address not updated in Contact Info Section\");\n        sa.assertEquals(FN, FirstNameData, \"\\n Address in Communication Pref section is not matching with address in Cont Info Section\");\n        sa.assertAll();\n        java.lang.System.out.println(\"Address updated successfully in Communication Pref and Contact information Sections\");\n        log.info(\"Address updated  successfully in Communication Pref and Contact information Sections\");\n    } catch (java.lang.InterruptedException ie) {\n        log.info(ie.getMessage());\n        org.testng.Assert.fail(\"Caught Interrupted Exception\");\n    } catch (java.io.IOException ioe) {\n        log.info(ioe.getMessage());\n        org.testng.Assert.fail(\"Caught IOException Exception\");\n    } catch (javax.xml.xpath.XPathExpressionException xee) {\n        log.info(xee.getMessage());\n        org.testng.Assert.fail(\"Caught XPathExpressionException Exception\");\n    } catch (javax.xml.parsers.ParserConfigurationException pce) {\n        log.info(pce.getMessage());\n        org.testng.Assert.fail(\"Caught ParserConfigurationException Exception\");\n    } catch (org.xml.sax.SAXException saxe) {\n        log.info(saxe.getMessage());\n        org.testng.Assert.fail(\"Caught SAXException Exception\");\n    } catch (java.lang.Exception e) {\n        log.info(e.getMessage());\n        org.testng.Assert.fail(e.getLocalizedMessage());\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\t\n\tFILE *stream;\n\tfreopen_s(&stream, \"input.txt\", \"r\", stdin);\n\tfreopen_s(&stream, \"output.txt\", \"w\", stdout);\n#endif\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n);\n\tfor (size_t i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint l = 0;\n\tint r = n - 1;\n\tint last = 0;\n\tstring result = \"\";\n\n\twhile (l <= r) {\n\t\tif (last < a[l] && last < a[r]) {\n\t\t\tif (a[l] < a[r]) {\n\t\t\t\tresult += 'L';\n\t\t\t\tlast = a[l];\n\t\t\t\t++l;\n\t\t\t}\n\t\t\telse if (a[l] > a[r]) {\n\t\t\t\tresult += 'R';\n\t\t\t\tlast = a[r];\n\t\t\t\t--r;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (a[l] > last) {\n\t\t\t\tresult += 'L';\n\t\t\t\tlast = a[l];\n\t\t\t\t++l;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a[r] > last) {\n\t\t\t\tresult += 'R';\n\t\t\t\tlast = a[r];\n\t\t\t\t--r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} \n\t}\n\n\tlast = a[l];\n\t++l;\n\tint left_length = 0;\n\twhile (a[l] > last) {\n\t\tlast = a[l];\n\t\t++left_length;\n\t\t++l;\n\t}\n\n\tlast = a[r];\n\t--r;\n\tint right_length = 0;\n\twhile (a[r] > last) {\n\t\tlast = a[r];\n\t\t++right_length;\n\t\t--r;\n\t}\n\tresult += right_length > left_length\n\t\t? string(right_length + 1, 'R')\n\t\t: string(left_length + 1, 'L');\n\n\tcout << result.size() << endl << result;\n\n\treturn 0;\n}",
        "fixed_code": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\t\n\tFILE *stream;\n\tfreopen_s(&stream, \"input.txt\", \"r\", stdin);\n\tfreopen_s(&stream, \"output.txt\", \"w\", stdout);\n#endif\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n);\n\tfor (size_t i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint l = 0;\n\tint r = n - 1;\n\tint last = 0;\n\tstring result = \"\";\n\n\twhile (l <= r) {\n\t\tif (last < a[l] && last < a[r]) {\n\t\t\tif (a[l] < a[r]) {\n\t\t\t\tresult += 'L';\n\t\t\t\tlast = a[l];\n\t\t\t\t++l;\n\t\t\t}\n\t\t\telse if (a[l] > a[r]) {\n\t\t\t\tresult += 'R';\n\t\t\t\tlast = a[r];\n\t\t\t\t--r;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\telse if (a[l] > last) {\n\t\t\tresult += 'L';\n\t\t\tlast = a[l];\n\t\t\t++l;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a[r] > last) {\n\t\t\tresult += 'R';\n\t\t\tlast = a[r];\n\t\t\t--r;\n\t\t\tcontinue;\n\t\t}\n\t\telse break;\n\t}\n\n\tint left_length = 0;\n\tint sub_last = last;\n\twhile (l < a.size() && a[l] > sub_last) {\n\t\tsub_last = a[l];\n\t\t++left_length;\n\t\t++l;\n\t}\n\n\tint right_length = 0;\n\tsub_last = last;\n\twhile (r < a.size() && a[r] > sub_last) {\n\t\tsub_last = a[r];\n\t\t++right_length;\n\t\t--r;\n\t}\n\tresult += right_length > left_length\n\t\t? string(right_length, 'R')\n\t\t: string(left_length, 'L');\n\n\tcout << result.size() << endl << result;\n\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * @author atulanand\r\n */\r\npublic class Solution {\r\n\r\n  private static int total = 0;\r\n\r\n  private static int solve(int[] parent, char[] color) {\r\n    total = 0;\r\n    Map<Integer, List<Integer>> graph = new HashMap<>();\r\n    for (int i = 0; i < parent.length; i++) {\r\n      int curr = (i + 2);\r\n      int par = parent[i];\r\n      List<Integer> children = graph.getOrDefault(par, new ArrayList<>());\r\n      children.add(curr);\r\n      graph.put(par, children);\r\n    }\r\n    int[] res = rec(graph, color, 1);\r\n    return total;\r\n  }\r\n  \r\n  private static int[] rec(Map<Integer, List<Integer>> graph, char[] color, int root) {\r\n    if (!graph.containsKey(root)) {\r\n      int[] res = new int[2];\r\n      if (color[root - 1] == 'W') {\r\n        res[0] = 1;\r\n      }\r\n      if (color[root - 1] == 'B') {\r\n        res[1] = 1;\r\n      }\r\n      return res;\r\n    }\r\n    List<Integer> children = graph.get(root);\r\n    int[] left = new int[2];\r\n    left = rec(graph, color, children.get(0));\r\n    int[] right = new int[2];\r\n    if (children.size() > 1) {\r\n      right = rec(graph, color, children.get(1));\r\n    }\r\n    int W = left[0] + right[0] + (color[root - 1] == 'W' ? 1 : 0);\r\n    int B = left[1] + right[1] + (color[root - 1] == 'B' ? 1 : 0);\r\n    if (W == B) {\r\n      total++;\r\n    }\r\n    return new int[]{W, B};\r\n  }\r\n  \r\n  public static void main(String[] args) throws IOException {\r\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n    int t = inputInt(br);\r\n    StringBuilder sb = new StringBuilder();\r\n    while (t-- > 0) {\r\n      int[] spec = inputIntArray(br);\r\n      int[] arr = inputIntArray(br);\r\n      char[] color = inputString(br).toCharArray();\r\n      sb.append(solve(arr, color)).append(\"\\n\");\r\n    }\r\n    System.out.println(sb);\r\n  }\r\n  \r\n  public static char[][] inputCharGrid(BufferedReader br, int rows) throws IOException {\r\n    char[][] grid = new char[rows][];\r\n    for (int i = 0; i < grid.length; i++) {\r\n      grid[i] = inputString(br).toCharArray();\r\n    }\r\n    return grid;\r\n  }\r\n  \r\n  public static int[][] inputIntGrid(BufferedReader br, int rows) throws IOException {\r\n    int[][] grid = new int[rows][];\r\n    for (int i = 0; i < grid.length; i++) {\r\n      grid[i] = inputIntArray(br);\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  public static String inputString(BufferedReader br) throws IOException {\r\n    return br.readLine().trim();\r\n  }\r\n\r\n  public static int inputInt(BufferedReader br) throws IOException {\r\n    return Integer.parseInt(inputString(br));\r\n  }\r\n\r\n  public static long inputLong(BufferedReader br) throws IOException {\r\n    return Long.parseLong(inputString(br));\r\n  }\r\n\r\n  public static int[] inputIntArray(BufferedReader br) throws IOException {\r\n    String[] spec = inputString(br).split(\" \");\r\n    int[] arr = new int[spec.length];\r\n    for (int i = 0; i < spec.length; i++)\r\n      arr[i] = Integer.parseInt(spec[i]);\r\n    return arr;\r\n  }\r\n}",
        "fixed_code": "import java.io.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * @author atulanand\r\n */\r\npublic class Solution {\r\n\r\n  private static int total = 0;\r\n\r\n  private static int solve(int[] parent, char[] color) {\r\n    total = 0;\r\n    Map<Integer, List<Integer>> graph = new HashMap<>();\r\n    for (int i = 0; i < parent.length; i++) {\r\n      int curr = (i + 2);\r\n      int par = parent[i];\r\n      List<Integer> children = graph.getOrDefault(par, new ArrayList<>());\r\n      children.add(curr);\r\n      graph.put(par, children);\r\n    }\r\n    int[] res = rec(graph, color, 1);\r\n    return total;\r\n  }\r\n  \r\n  private static int[] rec(Map<Integer, List<Integer>> graph, char[] color, int root) {\r\n    if (!graph.containsKey(root)) {\r\n      int[] res = new int[2];\r\n      if (color[root - 1] == 'W') {\r\n        res[0] = 1;\r\n      }\r\n      if (color[root - 1] == 'B') {\r\n        res[1] = 1;\r\n      }\r\n      return res;\r\n    }\r\n    List<Integer> children = graph.get(root);\r\n    int[] left = new int[2];\r\n    for (int child : children) {\r\n      int[] x = rec(graph, color, child);\r\n      left[0] += x[0];\r\n      left[1] += x[1];\r\n    }\r\n    int W = left[0] + (color[root - 1] == 'W' ? 1 : 0);\r\n    int B = left[1] + (color[root - 1] == 'B' ? 1 : 0);\r\n    if (W == B) {\r\n      total++;\r\n    }\r\n    return new int[]{W, B};\r\n  }\r\n  \r\n  public static void main(String[] args) throws IOException {\r\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n    int t = inputInt(br);\r\n    StringBuilder sb = new StringBuilder();\r\n    while (t-- > 0) {\r\n      int[] spec = inputIntArray(br);\r\n      int[] arr = inputIntArray(br);\r\n      char[] color = inputString(br).toCharArray();\r\n      sb.append(solve(arr, color)).append(\"\\n\");\r\n    }\r\n    System.out.println(sb);\r\n  }\r\n  \r\n  public static char[][] inputCharGrid(BufferedReader br, int rows) throws IOException {\r\n    char[][] grid = new char[rows][];\r\n    for (int i = 0; i < grid.length; i++) {\r\n      grid[i] = inputString(br).toCharArray();\r\n    }\r\n    return grid;\r\n  }\r\n  \r\n  public static int[][] inputIntGrid(BufferedReader br, int rows) throws IOException {\r\n    int[][] grid = new int[rows][];\r\n    for (int i = 0; i < grid.length; i++) {\r\n      grid[i] = inputIntArray(br);\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  public static String inputString(BufferedReader br) throws IOException {\r\n    return br.readLine().trim();\r\n  }\r\n\r\n  public static int inputInt(BufferedReader br) throws IOException {\r\n    return Integer.parseInt(inputString(br));\r\n  }\r\n\r\n  public static long inputLong(BufferedReader br) throws IOException {\r\n    return Long.parseLong(inputString(br));\r\n  }\r\n\r\n  public static int[] inputIntArray(BufferedReader br) throws IOException {\r\n    String[] spec = inputString(br).split(\" \");\r\n    int[] arr = new int[spec.length];\r\n    for (int i = 0; i < spec.length; i++)\r\n      arr[i] = Integer.parseInt(spec[i]);\r\n    return arr;\r\n  }\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "/*\n  ID: oodt\n  PROG:\n  LANG:C++\n*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int p = 1000000007;\nconst int maxx=100005;\nint n,m,k;\nchar a[maxx];\nint ans = 0,cnt = 0,pos = 0;\nint l = 0,r = 0;\n\nLL qk_pow(LL a, LL b, LL p) {\n    LL res = 1;\n    while(b) {\n        if(b&1) res = (res * a) % p;\n        a = (a*a) % p;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n#ifdef LOCAL\n    freopen(\"/Users/ecooodt/Desktop/c++ and acm/special--专题/1-数论/rsa/cf327c.txt\",\"r\",stdin);\n#endif\n    scanf(\"%s%d\",a,&k);\n//    printf(\"%s,%d\",a,k);\n    n = strlen(a);\n    LL ans = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if(a[i] == '5' || a[i] == '0')\n        {\n            for(int j = 0; j < k; j++)\n            {\n                ans = (ans + qk_pow(2,i+j*n,p)) % p;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n",
        "fixed_code": "/*\n  ID: oodt\n  PROG:\n  LANG:C++\n*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int p = 1000000007;\nconst int maxx=100005;\nint n,m,k;\nchar a[maxx];\nint ans = 0,cnt = 0,pos = 0;\nint l = 0,r = 0;\n\nLL qk_pow(LL a, LL b, LL p) {\n    LL res = 1;\n    while(b) {\n        if(b&1) res = (res * a) % p;\n        a = (a*a) % p;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n#ifdef LOCAL\n    freopen(\"/Users/ecooodt/Desktop/c++ and acm/special--专题/1-数论/rsa/cf327c.txt\",\"r\",stdin);\n#endif\n    scanf(\"%s%d\",a,&k);\n//    printf(\"%s,%d\",a,k);\n    l = strlen(a);\n    int ans = 0;\n    LL d = qk_pow(2,l,p);\n    LL y,z,x;\n    for(int i = 0; i < l; i++)\n    {\n        if(a[i] == '5' || a[i] == '0')\n        {\n            x = qk_pow(2,i,p);\n            cnt += x,cnt %= p;\n            //   printf(\"%lld\\n\",ans);\n        }\n    }\n    y = qk_pow(d,k,p);\n    y = ((1 - y) % p + p) % p;\n    z = ((1-d)% p + p) % p;\n//    printf(\"%d\\n\",z);\n    z = qk_pow(z,p-2,p);\n    ans = (cnt * ((y * z) % p)) % p;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define double long double\n#define int long long\n#define vec vector\n#define pb push_back\n#define unset unordered_set\n#define ii pair<int, int>\n#define X first\n#define Y second\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define FORE(i, a, b) for(int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for(int i = (a); i >= (b); i--)\n#define bitcount(n) __builtin_popcountll(n)\ntemplate <typename T,typename U>\nstd::pair<T,U> operator+(const std::pair<T,U> & l,const std::pair<T,U> & r) {\n  return {l.first+r.first,l.second+r.second};\n} \ntypedef void (*callback_function)(void); // type for conciseness\nconst long long ZERO = 0LL;\nconst long long INF64 = 1e18;\nconst int INF32 = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1.0L);\nconst double EPS = static_cast<double>(1e-9);\ntypedef long long ll;\n\ninline int Pow(int a, int k) {\n  int s = 1; \n  for(; k; k >>= 1) {\n    k & 1 ? s = 1LL * s * a % MOD : 0;\n    a = 1LL * a * a % MOD;\n  }\n  return s;\n}\n\n#define iii pair<ii, int>\n\n// Init variables here\nconst int N = 1e3 + 7;\nint n, m;\nstring a[N];\nstring b[N];\nvec<iii> stars;\n\nvoid input() {\n  //freopen(\"??.in\", \"r\", stdin);\n  //freopen(\"??.out\", \"w\", stdout);\n  cin >> n >> m;\n  FORE(i, 1, n) {cin >> a[i];}\n}\n\nvoid output() {\n  FORE(i, 1, n) FORE(j, 1, m) {\n    if (a[i][j] != b[i][j]) {\n      cout << -1 << endl; return;\n    }\n  }\n  cout << stars.size() << endl;\n  for (auto &trip : stars) {\n    cout << trip.X.X << ' ' << trip.X.Y << ' ' << trip.Y << endl;\n  }\n}\n\n// dir[i][j] = number of stars in the direction dir of cell (i - 1, j - 1) \n// (including the one in cell (i - 1, j - 1)\nint U[N][N], D[N][N], L[N][N], R[N][N];\n\nvoid preprocess() {\n  FORE(i, 1, n) {b[i] = string(m, '.');}\n  FORE(i, 1, n) FORE(j, 1, m) {\n    if (a[i][j] == '*') {\n      U[i][j] = U[i - 1][j] + 1;\n      L[i][j] = L[i][j - 1] + 1;\n    }\n  }\n  FORD(i, n, 1) FORD(j, m, 1) {\n    if (a[i][j] == '*') {\n      D[i][j] = D[i + 1][j] + 1;\n      R[i][j] = R[i][j + 1] + 1;\n    }\n  }\n}\n\nvoid debug() {\n  if (true) {\n    cerr << endl;\n    FORE(i, 1, n) {\n      FORE(j, 1, m) {\n        cerr << b[i][j];\n      }\n      cerr << endl;\n    }\n    cerr << endl;\n  }\n  for (auto &trip : stars) {\n    cerr << trip.X.X << ' ' << trip.X.Y << ' ' << trip.Y << endl;\n  }\n}\n\nint h[N][N], v[N][N];\n\nvoid solve() {\n  preprocess();\n  FORE(i, 1, n) FORE(j, 1, m) {\n    if (a[i][j] == '*') {\n      int sz = min(min(U[i][j], D[i][j]), min(L[i][j], R[i][j])) - 1;\n      if (sz) {\n        stars.push_back(iii(ii(i, j), sz));\n        h[i][j - sz]++;\n        h[i][j + sz + 1]--;\n        v[i - sz][j]++;\n        v[i + sz + 1][j]--;\n      }\n    }\n  }\n  FORE(i, 1, n) FORE(j, 1, m) {\n    h[i][j] += h[i][j - 1];\n    v[i][j] += v[i - 1][j];\n    if (h[i][j] > 0 or v[i][j] > 0) {b[i][j] = '*';}\n    //debug();\n  }\n  //debug();\n  // read the question correctly (is y a vowel?)\n  // look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)\n}\n\n#undef int\nint main() {\n#define int long long\n  ios_base::sync_with_stdio(false);\n  cin.tie();\n  //auto beginProgram = chrono::steady_clock::now();\n\n  //int t; cin >> t;\n  //while (t--) \n  {\n    input();\n    solve();\n    output();\n  }\n\n  //auto endProgram = chrono::steady_clock::now();\n\n  return 0;\n}\n\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define double long double\n//#define int long long\n#define vec vector\n#define pb push_back\n#define unset unordered_set\n#define ii pair<int, int>\n#define X first\n#define Y second\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define FORE(i, a, b) for(int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for(int i = (a); i >= (b); i--)\n#define bitcount(n) __builtin_popcountll(n)\ntemplate <typename T,typename U>\nstd::pair<T,U> operator+(const std::pair<T,U> & l,const std::pair<T,U> & r) {\n  return {l.first+r.first,l.second+r.second};\n} \ntypedef void (*callback_function)(void); // type for conciseness\nconst long long ZERO = 0LL;\nconst long long INF64 = 1e18;\nconst int INF32 = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1.0L);\nconst double EPS = static_cast<double>(1e-9);\ntypedef long long ll;\n\ninline int Pow(int a, int k) {\n  int s = 1; \n  for(; k; k >>= 1) {\n    k & 1 ? s = 1LL * s * a % MOD : 0;\n    a = 1LL * a * a % MOD;\n  }\n  return s;\n}\n\n#define iii pair<ii, int>\n\n// Init variables here\nconst int N = 1e3 + 7;\nint n, m;\nstring a[N];\nstring b[N];\nvec<iii> stars;\n\nvoid input() {\n  //freopen(\"??.in\", \"r\", stdin);\n  //freopen(\"??.out\", \"w\", stdout);\n  cin >> n >> m;\n  FORE(i, 1, n) {cin >> a[i]; a[i] = \".\" + a[i];}\n}\n\nvoid output() {\n  FORE(i, 1, n) FORE(j, 1, m) {\n    if (a[i][j] != b[i][j]) {\n      cout << -1 << endl; return;\n    }\n  }\n  cout << stars.size() << endl;\n  for (auto &trip : stars) {\n    cout << trip.X.X << ' ' << trip.X.Y << ' ' << trip.Y << endl;\n  }\n}\n\n// dir[i][j] = number of stars in the direction dir of cell (i - 1, j - 1) \n// (including the one in cell (i - 1, j - 1)\nint U[N][N], D[N][N], L[N][N], R[N][N];\n\nvoid preprocess() {\n  FORE(i, 1, n) {b[i] = string(m + 1, '.');}\n  FORE(i, 1, n) FORE(j, 1, m) {\n    if (a[i][j] == '*') {\n      U[i][j] = U[i - 1][j] + 1;\n      L[i][j] = L[i][j - 1] + 1;\n    }\n  }\n  FORD(i, n, 1) FORD(j, m, 1) {\n    if (a[i][j] == '*') {\n      D[i][j] = D[i + 1][j] + 1;\n      R[i][j] = R[i][j + 1] + 1;\n    }\n  }\n}\n\nvoid debug() {\n  if (true) {\n    cerr << endl;\n    FORE(i, 1, n) {\n      FORE(j, 1, m) {\n        cerr << b[i][j];\n      }\n      cerr << endl;\n    }\n    cerr << endl;\n  }\n  for (auto &trip : stars) {\n    cerr << trip.X.X << ' ' << trip.X.Y << ' ' << trip.Y << endl;\n  }\n}\n\nint h[N][N], v[N][N];\n\nvoid solve() {\n  preprocess();\n  FORE(i, 1, n) FORE(j, 1, m) {\n    if (a[i][j] == '*') {\n      int sz = min(min(U[i][j], D[i][j]), min(L[i][j], R[i][j])) - 1;\n      if (sz) {\n        stars.push_back(iii(ii(i, j), sz));\n        h[i][j - sz]++;\n        h[i][j + sz + 1]--;\n        v[i - sz][j]++;\n        v[i + sz + 1][j]--;\n      }\n    }\n  }\n  FORE(i, 1, n) FORE(j, 1, m) {\n    h[i][j] += h[i][j - 1];\n    v[i][j] += v[i - 1][j];\n    if (h[i][j] > 0 or v[i][j] > 0) {b[i][j] = '*';}\n    //debug();\n  }\n  //debug();\n  // read the question correctly (is y a vowel?)\n  // look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)\n}\n\n#undef int\nint main() {\n#define int long long\n  ios_base::sync_with_stdio(false);\n  cin.tie();\n  //auto beginProgram = chrono::steady_clock::now();\n\n  //int t; cin >> t;\n  //while (t--) \n  {\n    input();\n    solve();\n    output();\n  }\n\n  //auto endProgram = chrono::steady_clock::now();\n\n  return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "function(){\n      res.end();\n      stream.destroy();\n    }",
        "fixed_code": "function(){\n      stream.destroy();\n    }",
        "source": "FixJs_55551.json"
    },
    {
        "source_code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nint sz, ssz;\nchar op[10];\nint win[2004],sell[2004],buy[5004];\n\nconst int maxlen=2010,cps=10;\n\nstruct bigint\n{\n        int length,num[maxlen];\n        void init();\n        void init(char *s);\n        void print();\n        void fixlen();\n        int& operator [](int index){\n                return num[index];\n        }\n        const int& operator[](int index)const{\n                return num[index];\n        }\n};\n\nvoid bigint::init(){\n        length=1; memset(num,0,sizeof(num));\n}\n\nvoid bigint::init(char *s){\n        int l=strlen(s); length=0;\n        memset(num,0,sizeof(num));\n        for(int i=l-1;i>=0;)\n                if(i>=0)num[length++]+=(s[i--]-'0');\n        if(!length)length=1;\n}\n\nvoid bigint::print(){\n        printf(\"%d\",num[length-1]);\n        for(int i=length-1;i;i--)printf(\"%d\",num[i-1]);//??????è????o?????1\n}\n\nvoid bigint::fixlen(){\n        length=maxlen;\n        while( num[length-1]==0 && (length-1) )length--;\n}\n\nbigint operator+(bigint x,int y){\n        int i=0; x[i]+=y;\n        while(x[i]>=cps){\n                x[i+1]+=x[i]/cps;\n                x[i]%=cps;\n        }\n        x.fixlen(); \n        return x;\n}\n\nbigint operator+(bigint x,bigint y){\n        int l=max(x.length,y.length),t=0;\n        for(int i=0;i<l;i++) {\n                x[i]+=y[i]+t;\n                t=x[i]/cps,x[i]%=cps;\n        }\n        while(t) {\n                x[l++]=t%cps;\n                t/=cps;\n        }\n        x.length=l; \n        return x;\n}\n\nbigint operator-(bigint x,int y){\n        int l=x.length,t; x[0]-=y;\n        for(int i=0;i<l;i++) if(x[i]<0) {\n                t=(-x[i])/cps+1;\n                x[i]+=cps*t,x[i+1]-=t;\n        }\n        x.fixlen(); \n        return x;\n}\n\nbigint operator-(bigint x,bigint y){\n        int l=x.length;\n        for(int i=0;i<l;i++){\n                x[i]-=y[i];\n                if(x[i]<0) x[i]+=cps,x[i+1]--;\n        }\n        x.fixlen(); \n        return x;\n}\n\nbigint operator*(bigint x,int y){\n        int t=0,p=x.length;\n        for(int i=0;i<p;i++){\n                x[i]=x[i]*y+t;\n                t=x[i]/cps,x[i]%=cps;\n        }\n        while(t) {\n                x[p++]=t%cps;\n                t/=cps;\n        }\n        x.length=p; \n        return x;\n}\n\nbigint operator*(bigint x,bigint y){\n        int lx=x.length,ly=y.length,t;\n        bigint ans; ans.init();\n        for(int i=0;i<lx;i++)\n                for(int j=0;j<ly;j++) {\n                        t=i+j; ans[t]+=x[i]*y[j];\n                        while(ans[t]>=cps) {\n                                ans[t+1]+=ans[t]/cps;\n                                ans[t]%=cps;\n                        }\n                }\n        ans.fixlen(); \n        return ans;\n}\n\nbigint operator/(bigint x,int y){\n        int i,t=0,p=x.length;\n        for(i=p-1;i>=0;i--) {\n                t=t*cps+x[i];\n                x[i]=t/y,t%=y;\n        }\n    x.fixlen(); \n    return x;\n}\n\nint operator%(bigint x,int y) {\n        int i,t=0,p=x.length;\n        for(i=p-1;i>=0;i--) {\n                t=t*cps+x[i];\n                t%=y;\n        }\n        return t;\n}\n\nbool operator<=(bigint x,bigint y){\n        if(x.length!=y.length)return x.length<y.length;\n        for(int i=x.length-1;i>=0;i--)\n                if(x[i]!=y[i])return x[i]<y[i];\n        return 1;\n}\n\nbool operator<(bigint x,bigint y){\n        if(x.length!=y.length)return x.length<y.length;\n        for(int i=x.length-1;i>=0;i--)\n                if(x[i]!=y[i])return x[i]<y[i];\n        return 0;\n}\n\nbigint operator/(bigint x,bigint y){\n        int lx=x.length,ly=y.length;\n        bigint p; p.init();\n        for(int i=lx-1;i>=0;i--){\n                p=p*cps+x[i];x[i]=0;\n                for(int j=13;j>=0;j--)\n                        if(y*(1<<j)<=p)\n                        {\n                                p=(p-y*(1<<j));\n                                x[i]+=(1<<j);\n                        }\n        }\n        x.fixlen();\n        return x;\n//      return p;//mod\n}\n\nbigint operator%(bigint x,bigint y){\n        int lx=x.length,ly=y.length;\n        bigint p; p.init();\n        for(int i=lx-1;i>=0;i--){\n                p=p*cps+x[i];x[i]=0;\n                for(int j=13;j>=0;j--)\n                        if(y*(1<<j)<=p)\n                        {\n                                p=(p-y*(1<<j));\n                                x[i]+=(1<<j);\n                        }\n        }\n//      x.fixlen();return x;\n        return p;//mod\n}\n\nbigint ans;\nvoid money(int p)\n{\n    bigint tmp, two;\n    tmp.init(\"1\");two.init(\"2\");\n    \n    while(p)\n    {\n        if(p&1) tmp=tmp*two;\n        two=two*two;\n        p=p>>1;\n    } \n    ans=ans+tmp; \n}\n\nint main()\n{\n    int n,i,j;\n    scanf(\"%d\", &n);\n    memset(win, -1, sizeof(win));\n    memset(sell, -1, sizeof(sell));\n    memset(buy, -1, sizeof(buy));\n    \n    ans.init();\n    for(i=0; i<n; ++i)\n    {\n        scanf(\"%s %d\", op, &sz);\n        if('s'==op[0] && -1!=win[sz]) sell[sz]=i,buy[i]=sz;\n        else if('w'==op[0] && -1==sell[sz]) win[sz]=i;\n    }\n    \n    for(i=2000; i>-1; --i) \n    {\n        if(sell[i]!=-1)\n        {\n            for(j=i-1; j>-1; --j)\n                if(sell[j]!=-1 && ((sell[j]>win[i] && sell[j]<sell[i]) || (win[j]>win[i] && win[j]<sell[i]) || (sell[j]>sell[i] && win[j]<win[i])))\n                    sell[j]=win[j]=-1; \n            money(i);\n        }             \n    }\n    \n    ans.print();\n  \n    return 0;    \n}\n",
        "fixed_code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int maxlen=700,cps=10;\n\nstruct bigint\n{\n        int length,num[maxlen];\n        void init();\n        void init(char *s);\n        void print();\n        void fixlen();\n        int& operator [](int index){\n                return num[index];\n        }\n        const int& operator[](int index)const{\n                return num[index];\n        }\n};\n\nvoid bigint::init(){\n        length=1; memset(num,0,sizeof(num));\n}\n\nvoid bigint::init(char *s){\n        int l=strlen(s); length=0;\n        memset(num,0,sizeof(num));\n        for(int i=l-1;i>=0;)\n                if(i>=0)num[length++]+=(s[i--]-'0');\n        if(!length)length=1;\n}\n\nvoid bigint::print(){\n        printf(\"%d\",num[length-1]);\n        for(int i=length-1;i;i--)printf(\"%d\",num[i-1]);//??????è????o?????1\n}\n\nvoid bigint::fixlen(){\n        length=maxlen;\n        while( num[length-1]==0 && (length-1) )length--;\n}\n\nbigint operator+(bigint x,int y){\n        int i=0; x[i]+=y;\n        while(x[i]>=cps){\n                x[i+1]+=x[i]/cps;\n                x[i]%=cps;\n        }\n        x.fixlen(); \n        return x;\n}\n\nbigint operator+(bigint x,bigint y){\n        int l=max(x.length,y.length),t=0;\n        for(int i=0;i<l;i++) {\n                x[i]+=y[i]+t;\n                t=x[i]/cps,x[i]%=cps;\n        }\n        while(t) {\n                x[l++]=t%cps;\n                t/=cps;\n        }\n        x.length=l; \n        return x;\n}\n\nbigint operator*(bigint x,int y){\n        int t=0,p=x.length;\n        for(int i=0;i<p;i++){\n                x[i]=x[i]*y+t;\n                t=x[i]/cps,x[i]%=cps;\n        }\n        while(t) {\n                x[p++]=t%cps;\n                t/=cps;\n        }\n        x.length=p; \n        return x;\n}\n\nbigint operator*(bigint x,bigint y){\n        int lx=x.length,ly=y.length,t;\n        bigint ans; ans.init();\n        for(int i=0;i<lx;i++)\n                for(int j=0;j<ly;j++) {\n                        t=i+j; ans[t]+=x[i]*y[j];\n                        while(ans[t]>=cps) {\n                                ans[t+1]+=ans[t]/cps;\n                                ans[t]%=cps;\n                        }\n                }\n        ans.fixlen(); \n        return ans;\n}\n\nbool operator<(bigint x,bigint y){\n        if(x.length!=y.length)return x.length<y.length;\n        for(int i=x.length-1;i>=0;i--)\n                if(x[i]!=y[i])return x[i]<y[i];\n        return 0;\n}\n\nbigint pow(int p)\n{\n    bigint res;res.init(\"1\");\n    bigint tmp;tmp.init(\"2\");\n    while(p)\n    {\n        if(p&1) res=res*tmp;\n        tmp=tmp*tmp;\n        p>>=1;        \n    }\n    return res;       \n}\n\nint win[2004];\nbigint tmp,*ans[5001];\n\nint main()\n{\n    int n,i,sz;\n    char op[9];\n    \n    memset(ans, 0, sizeof(ans));\n    memset(win, -1, sizeof(win));\n    ans[0]=new bigint;(*ans[0]).init();\n    scanf(\"%d\", &n);\n    for(i=1; i<=n; ++i)\n    {\n        ans[i]=ans[i-1];     \n        scanf(\"%s %d\", op, &sz);\n        if('s'==op[0] && -1!=win[sz])\n        {\n            tmp=*ans[win[sz]]+pow(sz);\n            if((*ans[i])<tmp) ans[i]=new bigint, (*ans[i])=tmp;   \n        }\n        else if('w'==op[0]) win[sz]=i;\n    }\n    (*ans[n]).print();\n    return 0;    \n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public void saveResults(java.lang.String result) throws java.io.IOException {\n    try {\n        java.lang.String filename = \"log.txt\";\n        java.lang.String path = \"/storage/emulated/0/Documents\";\n        java.io.File filePath = new java.io.File(path, filename);\n        if (filePath.createNewFile()) {\n            java.io.FileOutputStream fileOutputStream = new java.io.FileOutputStream(filePath);\n            fileOutputStream.flush();\n            fileOutputStream.write(result.getBytes());\n            fileOutputStream.close();\n            java.lang.String showText = java.lang.String.format(\"File saved at %s/%s\", path, filename);\n            android.widget.Toast.makeText(getApplicationContext(), showText, Toast.LENGTH_LONG).show();\n        }\n    } catch (java.lang.Exception e) {\n        java.lang.String setText = \"Can't write to local file\";\n        mainText.setText(setText);\n        android.util.Log.d(\"SAVE\", \"EXCEPTION\", e);\n    }\n}",
        "fixed_code": "public void saveResults(java.lang.String result) throws java.io.IOException {\n    try {\n        java.lang.String filename = \"log.txt\";\n        java.lang.String path = \"/storage/emulated/0/Documents\";\n        java.io.File filePath = new java.io.File(path, filename);\n        filePath.createNewFile();\n        java.io.FileOutputStream fileOutputStream = new java.io.FileOutputStream(filePath);\n        fileOutputStream.flush();\n        fileOutputStream.write(result.getBytes());\n        fileOutputStream.close();\n        java.lang.String showText = java.lang.String.format(\"File saved at %s/%s\", path, filename);\n        android.widget.Toast.makeText(getApplicationContext(), showText, Toast.LENGTH_LONG).show();\n    } catch (java.lang.Exception e) {\n        java.lang.String setText = \"Can't write to local file\";\n        mainText.setText(setText);\n        android.util.Log.d(\"SAVE\", \"EXCEPTION\", e);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) throws Exception {\n            int queries = inp.nextInt();\n            for (int i = 0; i < queries; i++) {\n                int length = inp.nextInt();\n                int moves = inp.nextInt();\n                String[] list = inp.reader.readLine().split(\"\");\n\n                int goTo = Integer.MAX_VALUE;\n                for(int s = 0; s < list.length; s++){\n                    if(list[s].equals(\"1\")){\n                        goTo = s;\n                        break;\n                    }\n                }\n\n                int printIndex = 0;\n                for (int x = list.length-1; x >= 0; x--) {\n                    if(list[x].equals(\"0\") && moves >= (x-goTo) && x > goTo) {\n                        String temp = list[x];\n                        list[x] = list[goTo];\n                        list[goTo] = temp;\n\n                        moves -= Math.abs(x-goTo);\n                        goTo++;\n                        \n                        System.out.print(list[printIndex]);\n                    } else if (list[x].equals(\"0\") && moves < (x-goTo) && x > goTo){\n                        String temp = list[x];\n                        list[x] = list[x-moves];\n                        list[x-moves] = temp;\n                        System.out.print(list[printIndex]);\n                    } else {\n                        System.out.print(list[printIndex]);\n                    }\n                    printIndex++;\n                }\n                System.out.println();\n            }\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}",
        "fixed_code": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) throws Exception {\n            int queries = inp.nextInt();\n            for (int i = 0; i < queries; i++) {\n                long length = inp.nextLong();\n                long moves = inp.nextLong();\n                String[] list = inp.reader.readLine().split(\"\");\n\n                int goTo = Integer.MAX_VALUE;\n                for(int s = 0; s < list.length; s++) {\n                    if (list[s].equals(\"1\")) {\n                        goTo = s;\n                        break;\n                    }\n                }\n\n                for (int x = 0; x < length; x++) {\n                    if(list[x].equals(\"0\") && moves >= (x-goTo) && x > goTo) {\n                        out.print(list[x]);\n\n                        String temp = list[x];\n                        list[x] = list[goTo];\n                        list[goTo] = temp;\n\n                        moves -= Math.abs(x-goTo);\n                        goTo++;\n                    } else if (list[x].equals(\"0\") && moves < (x-goTo) && x > goTo){\n                        String temp = list[x];\n                        list[x] = list[x-(int)moves];\n                        list[x-(int)moves] = temp;\n                        break;\n                    } else if(list[x].equals(\"0\")) out.print(\"0\");\n                }\n                for(int r = (goTo); r < length; r++) out.print(list[r]);\n                out.println();\n            }\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "import java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Scanner;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\n\r\nimport javax.management.RuntimeErrorException;\r\n \r\n\r\n\r\n\r\npublic class CodeforcesQuestions {\r\n \r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\t\r\n\t\tScanner s=new Scanner(System.in);\r\n\t\t\r\n\t\tint t1=s.nextInt();\r\n\t\t\r\n\t\twhile(t1-->0)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tint n=s.nextInt();\r\n\t\t\t\r\n\t\t\t// if(n<14 && n>=10)\r\n\t\t\t//{\r\n\t\t\t//\tSystem.out.println(\"14\");\r\n\t\t\t//}\r\n\t\t\t//else\r\n\t\t\t//{\r\n\t\t\t\tint x=n%7;\r\n\t\t\t\tif(x==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tSystem.out.println(n);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tString s1=Integer.toString(n);\r\n\t\t\t\tString s2=Integer.toString(n-x);\r\n\t\t\t\tString s3=Integer.toString(n+7-x);\r\n\t\t\t\t\r\n\t\t\t\tif(s2.length()==s3.length() && s2.length()==s1.length() &&  s3.length()==s1.length())\r\n\t\t\t\t{\r\n\t\t\t\t\tint count2=0;\r\n\t\t\t\t\tint count3=0;\r\n\t\t\t\t\tfor(int i=0;i<s2.length();i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(s1.charAt(i)!=s2.charAt(i))\r\n\t\t\t\t\t\t\tcount2++;\r\n\t\t\t\t\t\tif(s1.charAt(i)!=s1.charAt(i))\r\n\t\t\t\t\t\t\tcount3++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(count2<count3)\r\n\t\t\t\t\t\tSystem.out.println(s2);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tSystem.out.println(s3);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t//System.out.println(s1.length());\r\n\t\t\t\t//System.out.println(s2.length());\r\n\t\t\t\telse if(s2.length()==s1.length())\r\n\t\t\t\t         System.out.println(n-x);\r\n\t\t\t\telse\r\n\t\t\t\t\tSystem.out.println(n+7-x);\r\n\r\n\t\t\t//}\r\n\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\r\n\t}\r\n\t\r\n}",
        "fixed_code": "\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Scanner;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\n\r\nimport javax.management.RuntimeErrorException;\r\n \r\n\r\n\r\n\r\npublic class CodeforcesQuestions {\r\n \r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\t\r\n\t\tScanner s=new Scanner(System.in);\r\n\t\t\r\n\t\tint t1=s.nextInt();\r\n\t\t\r\n\t\twhile(t1-->0)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tint n=s.nextInt();\r\n\t\t\t\r\n\t\t\t// if(n<14 && n>=10)\r\n\t\t\t//{\r\n\t\t\t//\tSystem.out.println(\"14\");\r\n\t\t\t//}\r\n\t\t\t//else\r\n\t\t\t//{\r\n\t\t\t\tint x=n%7;\r\n\t\t\t\tif(x==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tSystem.out.println(n);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tString s1=Integer.toString(n);\r\n\t\t\t\tString s2=Integer.toString(n-x);\r\n\t\t\t\tString s3=Integer.toString(n+7-x);\r\n\t\t\t\t\r\n\t\t\t\tif(s2.length()==s3.length() && s2.length()==s1.length() &&  s3.length()==s1.length())\r\n\t\t\t\t{\r\n\t\t\t\t\tint count2=0;\r\n\t\t\t\t\tint count3=0;\r\n\t\t\t\t\tfor(int i=0;i<s2.length();i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(s1.charAt(i)!=s2.charAt(i))\r\n\t\t\t\t\t\t\tcount2++;\r\n\t\t\t\t\t\tif(s1.charAt(i)!=s3.charAt(i))\r\n\t\t\t\t\t\t\tcount3++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(count2<count3)\r\n\t\t\t\t\t\tSystem.out.println(s2);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tSystem.out.println(s3);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t//System.out.println(s1.length());\r\n\t\t\t\t//System.out.println(s2.length());\r\n\t\t\t\telse if(s2.length()==s1.length())\r\n\t\t\t\t         System.out.println(n-x);\r\n\t\t\t\telse\r\n\t\t\t\t\tSystem.out.println(n+7-x);\r\n\r\n\t\t\t//}\r\n\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\r\n\t}\r\n\t\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "import java.util.*;\r\nimport java.io.*;\r\nimport static java.lang.System.out;\r\n\r\npublic class C1607\r\n{\r\n\r\n    static int mod=(int)(1e9+7);\r\n    static long MOD=(long)(1e9+7);\r\n    static FastReader in=new FastReader();\r\n    static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\r\n        \r\n    public static void main(String args[])\r\n    {  \r\n\r\n        int tc=1;\r\n     \r\n        tc=in.nextInt();\r\n        tcloop: while(tc-->0)\r\n        {\r\n            \r\n            int n=in.nextInt();\r\n            long arr[] = in.readLongArray(n);\r\n            if(n==1){\r\n                pr.println(arr[0]);\r\n                continue tcloop;\r\n            }\r\n\r\n            sort(arr);\r\n     \r\n            long sum=0;\r\n            int last=0;\r\n            for(int i=1;i<n;i++){\r\n                //pr.println(arr[i]-sum+\" \"+arr[i-1]);\r\n                if(arr[i]-sum-arr[i-1]>=arr[i-1]){\r\n                    long temp=sum;\r\n                    sum+=arr[i-1];\r\n                    arr[i]-=temp+arr[i-1];\r\n                    last=i;\r\n                    \r\n\r\n                    \r\n                    \r\n                }\r\n                else \r\n                    break;\r\n            }\r\n            pr.println(arr[last]);\r\n            \r\n\r\n            \r\n        }\r\n        pr.flush();\r\n        \r\n    }\r\n\r\n\tstatic long gcd(long a,long b)\r\n\t{\r\n\t\tif(a==0)return b;\r\n\t\treturn gcd(b%a,a);\r\n\t}\r\n\r\n    static class Pair implements Comparable<Pair>\r\n    {\r\n        int a,b;\r\n        Pair(int a,int b)\r\n        {\r\n            this.a=a;\r\n            this.b=b;\r\n\r\n        }\r\n\r\n        @Override\r\n        public int compareTo(Pair o)\r\n        {\r\n            return Integer.compare(a,o.a);\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    static void sort(long[] a) {\r\n\t\tArrayList<Long> l = new ArrayList<>();\r\n\t\tfor (long i : a)\r\n\t\t\tl.add(i);\r\n\t\tCollections.sort(l);\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t\ta[i] = l.get(i);\r\n\t}\r\n    \r\n    \r\n\tstatic void sort(int[] a) {\r\n\t\tArrayList<Integer> l = new ArrayList<>();\r\n\t\tfor (int i : a)\r\n\t\t\tl.add(i);\r\n\t\tCollections.sort(l);\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t\ta[i] = l.get(i);\r\n    }\r\n\r\n    \r\n    static class FastReader\r\n    { \r\n        BufferedReader br; \r\n        StringTokenizer st; \r\n\r\n        public FastReader() \r\n        { \r\n            br = new BufferedReader(new InputStreamReader(System.in)); \r\n        } \r\n\r\n        String next() \r\n        { \r\n            while (st == null || !st.hasMoreElements()) \r\n            { \r\n                try\r\n                { \r\n                    st = new StringTokenizer(br.readLine()); \r\n                } \r\n                catch (IOException  e) \r\n                { \r\n                    e.printStackTrace(); \r\n                } \r\n            } \r\n            return st.nextToken(); \r\n        } \r\n\r\n        int nextInt() \r\n        { \r\n            return Integer.parseInt(next()); \r\n        } \r\n\r\n        long nextLong() \r\n        { \r\n            return Long.parseLong(next()); \r\n        } \r\n\r\n        double nextDouble() \r\n        { \r\n            return Double.parseDouble(next()); \r\n        } \r\n        \r\n        int[] readIntArray(int n)\r\n        {\r\n\t\tint a[]=new int[n];\r\n\t\tfor(int i=0;i<n;i++)a[i]=nextInt();\r\n\t\treturn a;\r\n\t}\r\n\t\t\r\n\tlong[] readLongArray(int n)\r\n\t{\r\n\t\tlong a[]=new long[n];\r\n\t\tfor(int i=0;i<n;i++)a[i]=nextLong();\r\n\t\treturn a;\r\n\t}\r\n\t\r\n        String nextLine() \r\n        { \r\n            String str = \"\"; \r\n            try\r\n            { \r\n                str = br.readLine(); \r\n            } \r\n            catch (IOException e) \r\n            { \r\n                e.printStackTrace(); \r\n            } \r\n            return str; \r\n        } \r\n    } \r\n}\r\n\r\n\r\n\r\n",
        "fixed_code": "import java.util.*;\r\nimport java.io.*;\r\nimport static java.lang.System.out;\r\n\r\npublic class C1607\r\n{\r\n\r\n    static int mod=(int)(1e9+7);\r\n    static long MOD=(long)(1e9+7);\r\n    static FastReader in=new FastReader();\r\n    static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\r\n        \r\n    public static void main(String args[])\r\n    {  \r\n\r\n        int tc=1;\r\n     \r\n        tc=in.nextInt();\r\n        tcloop: while(tc-->0)\r\n        {\r\n            \r\n            int n=in.nextInt();\r\n            long arr[] = in.readLongArray(n);\r\n            if(n==1){\r\n                pr.println(arr[0]);\r\n                continue tcloop;\r\n            }\r\n\r\n            sort(arr);\r\n     \r\n            long sum=0;\r\n    \r\n            long max=arr[0];\r\n            for(int i=1;i<n;i++){\r\n                //pr.println(arr[i]-sum+\" \"+arr[i-1]);\r\n               \r\n                long temp=sum;\r\n                sum+=arr[i-1];\r\n                arr[i]-=temp+arr[i-1];\r\n                max = Math.max(arr[i],max);\r\n                    \r\n\r\n          \r\n            }\r\n            pr.println(max);\r\n            \r\n\r\n            \r\n        }\r\n        pr.flush();\r\n        \r\n    }\r\n\r\n\tstatic long gcd(long a,long b)\r\n\t{\r\n\t\tif(a==0)return b;\r\n\t\treturn gcd(b%a,a);\r\n\t}\r\n\r\n    static class Pair implements Comparable<Pair>\r\n    {\r\n        int a,b;\r\n        Pair(int a,int b)\r\n        {\r\n            this.a=a;\r\n            this.b=b;\r\n\r\n        }\r\n\r\n        @Override\r\n        public int compareTo(Pair o)\r\n        {\r\n            return Integer.compare(a,o.a);\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    static void sort(long[] a) {\r\n\t\tArrayList<Long> l = new ArrayList<>();\r\n\t\tfor (long i : a)\r\n\t\t\tl.add(i);\r\n\t\tCollections.sort(l);\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t\ta[i] = l.get(i);\r\n\t}\r\n    \r\n    \r\n\tstatic void sort(int[] a) {\r\n\t\tArrayList<Integer> l = new ArrayList<>();\r\n\t\tfor (int i : a)\r\n\t\t\tl.add(i);\r\n\t\tCollections.sort(l);\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t\ta[i] = l.get(i);\r\n    }\r\n\r\n    \r\n    static class FastReader\r\n    { \r\n        BufferedReader br; \r\n        StringTokenizer st; \r\n\r\n        public FastReader() \r\n        { \r\n            br = new BufferedReader(new InputStreamReader(System.in)); \r\n        } \r\n\r\n        String next() \r\n        { \r\n            while (st == null || !st.hasMoreElements()) \r\n            { \r\n                try\r\n                { \r\n                    st = new StringTokenizer(br.readLine()); \r\n                } \r\n                catch (IOException  e) \r\n                { \r\n                    e.printStackTrace(); \r\n                } \r\n            } \r\n            return st.nextToken(); \r\n        } \r\n\r\n        int nextInt() \r\n        { \r\n            return Integer.parseInt(next()); \r\n        } \r\n\r\n        long nextLong() \r\n        { \r\n            return Long.parseLong(next()); \r\n        } \r\n\r\n        double nextDouble() \r\n        { \r\n            return Double.parseDouble(next()); \r\n        } \r\n        \r\n        int[] readIntArray(int n)\r\n        {\r\n\t\tint a[]=new int[n];\r\n\t\tfor(int i=0;i<n;i++)a[i]=nextInt();\r\n\t\treturn a;\r\n\t}\r\n\t\t\r\n\tlong[] readLongArray(int n)\r\n\t{\r\n\t\tlong a[]=new long[n];\r\n\t\tfor(int i=0;i<n;i++)a[i]=nextLong();\r\n\t\treturn a;\r\n\t}\r\n\t\r\n        String nextLine() \r\n        { \r\n            String str = \"\"; \r\n            try\r\n            { \r\n                str = br.readLine(); \r\n            } \r\n            catch (IOException e) \r\n            { \r\n                e.printStackTrace(); \r\n            } \r\n            return str; \r\n        } \r\n    } \r\n}\r\n\r\n\r\n\r\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "function (event) {\n\t\tif (event.target.id == 'turntable-player' && !this._playerPaused) {\n\t\t\tconsole.info('Player event: ended.');\n\t\t\tthis.end();\n\t\t}\n\t\telse {\n\t\t\tvar \n\t\t\t\tr = /turntable-player-transition/i,\n\t\t\t\ts = event.target.id\n\t\t\t;\n\t\t\tif (r.test(s)) {\n\t\t\t\tthis._inTransition = false;\n\t\t\t\tif (event.target.id == 'turntable-player-transition-start')\n\t\t\t\t\tthis.play(true);\n\t\t\t\telse if (event.target.id == 'turntable-player-transition-stop')\n\t\t\t\t\tthis.end(true);\n\t\t\t}\n\t\t}\n\t}",
        "fixed_code": "function (event) {\n\t\tconsole.info('Audio player \"' + event.target.id + '\" event: loadedData.');\n\n\t\tif (event.target.id == 'turntable-player') {\n\t\t\tthis.enableRemote('playerLoaded');\n\n\t\t\tif (this.options.mode != 'automatic') {\n\t\t\t\tthis.updateTrackInfos();\n\t\t\t\tthis.updateInfos();\n\t\t\t\tthis.updatePlayerPosition();\n\t\t\t}\n\n\t\t\tif (this.options.mode == 'automatic' && (!this._playerPaused || this._inTransition))\n\t\t\t\tthis.restart();\n\t\t}\n\t}",
        "source": "FixJs_55551.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define MAX 300000\nusing namespace std;\nint ara[MAX+1],index[MAX+1],temp[MAX+1];\nint main()\n{\n    IOS;\n    int i,n,q,x,t=0,sum=0,type,sentence=1;\n    cin>>n>>q;\n    while(q--){\n        cin>>type>>x;\n        if(type==1){\n            index[++t]=x;\n            ara[x]++;\n            sum++;\n        }\n        else if(type==2){\n            sum-=ara[x];\n            temp[x]=t;\n            ara[x]=0;\n        }\n        else if(type==3){\n            for(i=sentence;i<=x;i++){\n                if(i>temp[index[i]]&&index[i]){\n                    ara[index[i]]--;\n                    sum--;\n                    index[i]=0;\n                }\n            }\n            sentence=x;\n        }\n        cout<<sum<<endl;\n    }\n    return 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\n#define MAX 300005\nusing namespace std;\nint mp[MAX],r[MAX],curr[MAX];\nint main(){\n    int n,q,t,x,cnt = 0,ans = 0;\n    cin>>n>>q;\n    set<pair<int,pair<int,int> > >s;\n    for(int i=1; i<=q; i++){\n        cin>>t>>x;\n        if(t == 1){\n            ++cnt; ++ans;\n            curr[x]++; mp[x]++;\n            s.insert({cnt,{x,curr[x]}});\n        }\n        else if(t == 2){\n            r[x]+=mp[x]; ans-=mp[x];\n            mp[x] = 0;\n        }\n        else{\n            while(s.size()){\n                auto it = s.begin();\n                if((*it).first > x) break;\n                int z = (*it).second.second;\n                int y = (*it).second.first;\n                if(z > r[y]){\n                    r[y]++; mp[y]--;\n                    ans--;\n                }\n                s.erase(it);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef double ld;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst ld eps=1e-8;\nconst int N=1e5+10;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nbool eq(ld a,ld b) {\n\treturn fabsl(a-b)<eps;\n}\n\nstruct point {\n\tld x,y,z;\n\tpoint(ld x=0,ld y=0,ld z=0):x(x),y(y),z(z) {}\n\tpoint operator+(const point &A) const {\n\t\treturn point(x+A.x,y+A.y,z+A.z);\n\t}\n\tpoint operator-(const point &A) const {\n\t\treturn point(x-A.x,y-A.y,z-A.z);\n\t}\n\tpoint operator*(ld v) const {\n\t\treturn point(x*v,y*v,z*v);\n\t}\n\tpoint operator/(ld v) const {\n\t\treturn point(x/v,y/v,z/v);\n\t}\n\tld operator*(const point &A) const {\n\t\treturn x*A.x+y*A.y+z*A.z;\n\t}\n\tpoint operator%(const point &A) const {\n\t\treturn point(y*A.z-z*A.y,z*A.x-x*A.z,x*A.y-y*A.x);\n\t}\n\tld len() const {\n\t\treturn sqrtl(x*x+y*y+z*z);\n\t}\n\tvoid read() {\n\t\tx=gi();y=gi();z=gi();\n\t}\n\tvoid print() {\n\t\tcerr<<x<<' '<<y<<' '<<z<<'\\n';\n\t}\n} p1[N],p2[N];\n\nstruct line {\n\tpoint st,v;\n\tline() {}\n\tline(point st,point v):st(st),v(v) {}\n} s;\n\nstruct flat {\n\tpoint st,nor;\n\tflat(point a,point b,point c) {\n\t\tst=a;nor=(b-a)%(c-a);\n\t}\n};\n\nint n,m;\n\npoint sec(line a,line b) {\n\tld p=((b.st-a.st)%a.v).len()/(a.v%b.v).len();\n\treturn b.st+b.v*p;\n}\n\nld dist(point a,flat b) {\n\treturn (a-b.st)*b.nor/b.nor.len();\n}\n\npoint sec(line a,flat b) {\n\tpoint p=a.st,q=a.st+a.v;\n\tld d1=dist(p,b),d2=dist(q,b);\n\treturn p+(q-p)*d1/(d1-d2);\n}\n\nline sec(flat a,flat b) {\n\tline tmp(a.st,a.nor%point(23333,66666,47777));\n\tpoint p=sec(tmp,b);\n\treturn line(p,a.nor%b.nor);\n}\n\nbool cmp(point a,point b) {\n\treturn (b-a)*s.v>0;\n}\n\nint cal(vector<point> a,vector<point> b) {\n\t/*for(auto x:a) x.print();\n\tcerr<<endl<<endl;\n\tfor(auto x:b) x.print();\n\tcerr<<endl<<endl;*/\n\tsort(a.begin(),a.end(),cmp);sort(b.begin(),b.end(),cmp);\n\tint ret=0;\n\tfor(int i=0,j=0;i<sz(a)||j<sz(b);) {\n\t\tif(i<sz(a)&&(j==sz(b)||cmp(a[i],b[j]))) ++i;\n\t\telse ret+=i&1,++j;\n\t}\n\t//cerr<<ret<<' ';\n\treturn ret;\n}\n\nint main() {\n\tsrand(1919810);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) p1[i].read();\n\tcin>>m;\n\tfor(int i=1;i<=m;i++) p2[i].read();\n\tflat f1(p1[1],p1[2],p1[3]),f2(p2[1],p2[2],p2[3]);\n\tif(eq((f1.nor%f2.nor).len(),0)) return cout<<\"NO\",0;\n\tint pos=1;\n\tfor(int i=1;i<=n;i++) if(!eq(f1.nor*(p2[i]-f1.st),0)) { pos=i;break; }\n\trotate(p2+1,p2+pos,p2+n+1);\n\t//cerr<<pos<<endl;\n\tpos=1;\n\tfor(int i=1;i<=m;i++) if(!eq(f2.nor*(p1[i]-f2.st),0)) { pos=i;break; }\n\trotate(p1+1,p1+pos,p1+m+1);\n\ts=sec(f1,f2);p1[n+1]=p1[1];p2[m+1]=p2[1];\n\t//s.st.print();s.v.print();\n\tld pre=f1.nor*(p2[1]-f1.st);\n\tvector<point> vec1,vec2[2];\n\t//求多边形2的边与平面1的交点\n\tfor(int i=2;i<=m+1;i++) {\n\t\tld now=f1.nor*(p2[i]-f1.st);\n\t\tif(pre*now<-eps) {\n\t\t\tpre=now,vec1.pb(sec(s,line(p2[i-1],p2[i]-p2[i-1])));\n\t\t\t//cerr<<i<<' ';\n\t\t\t//p2[i-1].print();(p2[i]-p2[i-1]).print();\n\t\t}\n\t}\n\t//for(auto x:vec1) x.print();\n\t//exit(0);\n\tpre=f2.nor*(p1[1]-f2.st);int fl=0;\n\tfor(int i=2;i<=n+1;i++) {\n\t\tld now=f2.nor*(p1[i]-f2.st);\n\t\tif(pre*now<-eps) pre=now,vec2[fl^=1].pb(sec(s,line(p1[i-1],p1[i]-p1[i-1])));\n\t}\n\t//for(auto x:vec2[1]) x.print();\n\t//exit(0);\n\tcout<<(cal(vec1,vec2[0])==cal(vec1,vec2[1])?\"NO\\n\":\"YES\\n\");\n\treturn 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef double ld;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst ld eps=1e-8;\nconst int N=1e5+10;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nbool eq(ld a,ld b) {\n\treturn fabsl(a-b)<eps;\n}\n\nstruct point {\n\tld x,y,z;\n\tpoint(ld x=0,ld y=0,ld z=0):x(x),y(y),z(z) {}\n\tpoint operator+(const point &A) const {\n\t\treturn point(x+A.x,y+A.y,z+A.z);\n\t}\n\tpoint operator-(const point &A) const {\n\t\treturn point(x-A.x,y-A.y,z-A.z);\n\t}\n\tpoint operator*(ld v) const {\n\t\treturn point(x*v,y*v,z*v);\n\t}\n\tpoint operator/(ld v) const {\n\t\treturn point(x/v,y/v,z/v);\n\t}\n\tld operator*(const point &A) const {\n\t\treturn x*A.x+y*A.y+z*A.z;\n\t}\n\tpoint operator%(const point &A) const {\n\t\treturn point(y*A.z-z*A.y,z*A.x-x*A.z,x*A.y-y*A.x);\n\t}\n\tld len() const {\n\t\treturn sqrtl(x*x+y*y+z*z);\n\t}\n\tvoid read() {\n\t\tx=gi();y=gi();z=gi();\n\t}\n\tvoid print() {\n\t\tcerr<<x<<' '<<y<<' '<<z<<'\\n';\n\t}\n} p1[N],p2[N];\n\nstruct line {\n\tpoint st,v;\n\tline() {}\n\tline(point st,point v):st(st),v(v) {}\n} s;\n\nstruct flat {\n\tpoint st,nor;\n\tflat(point a,point b,point c) {\n\t\tst=a;nor=(b-a)%(c-a);\n\t}\n};\n\nint n,m;\n\npoint sec(line a,line b) {\n\tld p=((b.st-a.st)%a.v).len()/(a.v%b.v).len();\n\treturn b.st+b.v*p;\n}\n\nld dist(point a,flat b) {\n\treturn (a-b.st)*b.nor/b.nor.len();\n}\n\npoint sec(line a,flat b) {\n\tpoint p=a.st,q=a.st+a.v;\n\tld d1=dist(p,b),d2=dist(q,b);\n\treturn p+(q-p)*d1/(d1-d2);\n}\n\nline sec(flat a,flat b) {\n\tline tmp(a.st,a.nor%point(23333,66666,47777));\n\tpoint p=sec(tmp,b);\n\treturn line(p,a.nor%b.nor);\n}\n\nbool cmp(point a,point b) {\n\treturn (b-a)*s.v>0;\n}\n\nint cal(vector<point> a,vector<point> b) {\n\t/*for(auto x:a) x.print();\n\tcerr<<endl<<endl;\n\tfor(auto x:b) x.print();\n\tcerr<<endl<<endl;*/\n\tsort(a.begin(),a.end(),cmp);sort(b.begin(),b.end(),cmp);\n\tint ret=0;\n\tfor(int i=0,j=0;i<sz(a)||j<sz(b);) {\n\t\tif(i<sz(a)&&(j==sz(b)||cmp(a[i],b[j]))) ++i;\n\t\telse ret+=i&1,++j;\n\t}\n\t//cerr<<ret<<' ';\n\treturn ret;\n}\n\nint main() {\n\tsrand(1919810);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) p1[i].read();\n\tcin>>m;\n\tfor(int i=1;i<=m;i++) p2[i].read();\n\tflat f1(p1[1],p1[2],p1[3]),f2(p2[1],p2[2],p2[3]);\n\tif(eq((f1.nor%f2.nor).len(),0)) return cout<<\"NO\",0;\n\tint pos=1;\n\tfor(int i=1;i<=n;i++) if(!eq(f1.nor*(p2[i]-f1.st),0)) { pos=i;break; }\n\trotate(p2+1,p2+pos,p2+m+1);\n\t//cerr<<pos<<endl;\n\tpos=1;\n\tfor(int i=1;i<=m;i++) if(!eq(f2.nor*(p1[i]-f2.st),0)) { pos=i;break; }\n\trotate(p1+1,p1+pos,p1+n+1);\n\ts=sec(f1,f2);p1[n+1]=p1[1];p2[m+1]=p2[1];\n\t//s.st.print();s.v.print();\n\tld pre=f1.nor*(p2[1]-f1.st);\n\tvector<point> vec1,vec2[2];\n\t//求多边形2的边与平面1的交点\n\tfor(int i=2;i<=m+1;i++) {\n\t\tld now=f1.nor*(p2[i]-f1.st);\n\t\tif(pre*now<-eps) {\n\t\t\tpre=now,vec1.pb(sec(s,line(p2[i-1],p2[i]-p2[i-1])));\n\t\t\t//cerr<<i<<' ';\n\t\t\t//p2[i-1].print();(p2[i]-p2[i-1]).print();\n\t\t}\n\t}\n\t//for(auto x:vec1) x.print();\n\t//exit(0);\n\tpre=f2.nor*(p1[1]-f2.st);int fl=0;\n\tfor(int i=2;i<=n+1;i++) {\n\t\tld now=f2.nor*(p1[i]-f2.st);\n\t\tif(pre*now<-eps) pre=now,vec2[fl^=1].pb(sec(s,line(p1[i-1],p1[i]-p1[i-1])));\n\t}\n\t//for(auto x:vec2[1]) x.print();\n\t//exit(0);\n\tcout<<(cal(vec1,vec2[0])==cal(vec1,vec2[1])?\"NO\\n\":\"YES\\n\");\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public java.lang.String[] toStringArray() {\n    return new java.lang.String[]{ java.lang.String.valueOf(eventID) , java.lang.String.valueOf(calendarID) , java.lang.String.valueOf(day) , java.lang.String.valueOf(month) , java.lang.String.valueOf(year) , owner , title , location , date , startTime , endTime , duration };\n}",
        "fixed_code": "public java.lang.String[] toStringArray() {\n    return new java.lang.String[]{ owner , title , location , date , startTime , endTime , duration };\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void afterNavigateTo(java.lang.String url, org.openqa.selenium.WebDriver driver) {\n}",
        "fixed_code": "@java.lang.Override\npublic void afterClickOn(org.openqa.selenium.WebElement arg0, org.openqa.selenium.WebDriver arg1) {\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "//package raif;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n// What's the smallest input?\n// Check * for int/long overflow.\n// Check / for accidental rounding.\n// Are you using doubles? Can you avoid it?\n// Never compare after taking mod.\n// Mod the final result.\n// Initialize globals in solve() unless they are independent of the problem input.\n// Check for local/global name conflicts (n?).\n// Check initial values for max/min (not Integer.MIN_VALUE for long).\npublic class D {\n    static Random rand;\n    static boolean MULTIPLE_CASES = false;\n    static boolean CONSTRUCTIVE = true;\n    static long MOD = (long) 1e9 + 7;\n    static long BIG = (long) 2e9;\n\n    static class Target {\n        int r, c;\n\n        public Target(int r, int c) {\n            this.r = r+1;\n            this.c = c+1;\n        }\n\n        @Override\n        public String toString() {\n            return r + \" \" + c;\n        }\n    }\n\n    public static void solve(Reader in, PrintWriter out) {\n        int n = in.nextInt();\n        int[] arr = in.nextInts(n);\n\n        Stack<Integer> ones = new Stack<>();\n        Stack<Integer> twosAndThrees = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            if (arr[i] == 1) {\n                ones.add(i);\n            } else if (arr[i] == 2 || arr[i] == 3) {\n                twosAndThrees.add(i);\n            }\n        }\n\n        List<Target> ans = new ArrayList<>();\n\n        boolean ok = true;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == 0) continue;\n            ans.add(new Target(i, i));\n\n            if (arr[i] == 3) {\n                // would be nice to find a 2 or 3\n                while (!twosAndThrees.isEmpty() && twosAndThrees.peek() <= i) twosAndThrees.pop();\n\n                if (!twosAndThrees.isEmpty()) {\n                    int nextCol = twosAndThrees.pop();\n                    ans.add(new Target(i, nextCol));\n                    continue;\n                }\n            }\n\n            if (arr[i] == 2 || arr[i] == 3) {\n                // need to find a 1\n                while (!ones.isEmpty() && ones.peek() <= i) ones.pop();\n                if (ones.isEmpty()) {\n                    ok = false;\n                    break;\n                }\n                int nextCol = ones.pop();\n                ans.add(new Target(i, nextCol));\n                arr[nextCol] = 0; // we don't want to add a target here later on\n            }\n        }\n\n        if (ok) {\n            out.println(ans.size());\n            for (Target t : ans) {\n                out.println(t);\n            }\n        } else {\n            out.println(-1);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Reader in = null;\n        PrintWriter out = null;\n        for (String arg : args) {\n            if (arg.startsWith(\"input\")) {\n                in = new Reader(arg);\n            } else if (arg.startsWith(\"output\")) {\n                out = new PrintWriter(new FileWriter(arg));\n            }\n        }\n        if (in == null) in = new Reader();\n        if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        if (MULTIPLE_CASES) {\n            int tests = in.nextInt();\n            for (int t = 0; t < tests; t++) {\n                solve(in, out);\n            }\n        } else {\n            solve(in, out);\n        }\n\n        out.flush();\n    }\n\n    static class Tester {\n        public static void main(String[] args) throws IOException {\n            Validator validator = new Validator();\n\n            File currentDir = new File(\".\");\n            long before;\n            long after;\n            for (File inputFile : Arrays.stream(currentDir.listFiles())\n                    .sorted(Comparator.comparing(File::getName))\n                    .collect(Collectors.toList())) {\n                if (!inputFile.getName().startsWith(\"input\")\n                        || inputFile.getName().contains(\"sight\")\n                        || inputFile.getName().contains(\"big\")) continue;\n                System.out.println(\"Test file: \" + inputFile.getName());\n\n                before = System.nanoTime();\n                String outputFileName = \"output\" + inputFile.getName().substring(5);\n                D.main(new String[]{inputFile.getName(), outputFileName});\n                after = System.nanoTime();\n\n                File outputFile = new File(outputFileName);\n                if (!outputFile.exists()) {\n                    throw new IllegalStateException(\"Missing output file \" + outputFile);\n                }\n\n                // TODO if verifier is implemented, remove this\n                if (CONSTRUCTIVE) {\n                    System.out.println(\"INPUT:\");\n                    printFile(inputFile);\n                    System.out.printf(\"\\nOUTPUT: (%d milliseconds)\\n\", (after - before) / 1000000L);\n                    printFile(outputFile);\n                    continue;\n                }\n\n                if (validator.validate(inputFile, outputFile)) {\n                    System.out.printf(\"OK (%d milliseconds)\\n\", (after - before) / 1000000L);\n                } else {\n                    System.out.println(\"FAILED\");\n                    System.out.println(\"\\nInput: \");\n                    printFile(inputFile);\n                    System.out.println(\"\\nIncorrect Output: \");\n                    printFile(outputFile);\n                    return;\n                }\n            }\n            System.out.println(\"\\n-----------------\\n\");\n\n            File sightTestInput = new File(\"input-sight\");\n            if (sightTestInput.exists()) {\n                System.out.println(\"Running sight test... Input:\");\n                printFile(sightTestInput);\n                before = System.nanoTime();\n                System.out.println(\"\\nOutput: \");\n                D.main(new String[]{\"input-sight\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n                System.out.println(\"\\n-----------------\\n\");\n            }\n\n            File bigTestInput = new File(\"input-big\");\n            if (bigTestInput.exists()) {\n                System.out.println(\"Running big test...\");\n                before = System.nanoTime();\n                D.main(new String[] {\"input-big\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n            }\n        }\n\n        static void printFile(File file) throws FileNotFoundException {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            reader.lines().forEach(System.out::println);\n        }\n    }\n\n    static class Validator {\n        boolean validate(File inputFile, File outputFile) throws IOException {\n            File expectedOutputFile = new File(\"expected-output\" + inputFile.getName().substring(5));\n            if (CONSTRUCTIVE || !expectedOutputFile.exists()) {\n                return validateManual(inputFile, outputFile);\n            }\n            return areSame(outputFile, expectedOutputFile);\n        }\n\n        private boolean validateManual(File inputFile, File outputFile) throws IOException {\n            if (CONSTRUCTIVE) {\n                // Validate output against input\n                Reader inputReader = new Reader(inputFile.getName());\n                Reader outputReader = new Reader(outputFile.getName());\n\n                // TODO implement manual validation\n\n                throw new IllegalStateException(\"Missing expected output file\");\n            } else {\n                File naiveOutput = new File(\"naive-\" + outputFile.getName());\n                Naive.main(new String[]{inputFile.getName(), naiveOutput.getName()});\n\n                return areSame(outputFile, naiveOutput);\n            }\n        }\n\n        private boolean areSame(File file1, File file2) throws IOException {\n            BufferedReader reader1 = new BufferedReader(new FileReader(file1));\n            BufferedReader reader2 = new BufferedReader(new FileReader(file2));\n\n            String line1;\n            while ((line1 = reader1.readLine()) != null) {\n                String line2 = reader2.readLine();\n                if (line2 == null) line2 = \"\"; // ok if one has an extra newline\n                if (!line1.trim().equals(line2.trim())) {\n                    return false;\n                }\n            }\n            String line2;\n            while ((line2 = reader2.readLine()) != null) {\n                if (!line2.trim().isEmpty()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Naive {\n        public static void solveNaive(Reader in, PrintWriter out) {\n            throw new IllegalStateException(\"missing expected output file\");\n        }\n\n        public static void main(String[] args) throws IOException {\n            Reader in = null;\n            PrintWriter out = null;\n            for (String arg : args) {\n                if (arg.startsWith(\"input\")) {\n                    in = new Reader(arg);\n                } else if (arg.startsWith(\"naive-output\")) {\n                    out = new PrintWriter(new FileWriter(arg));\n                }\n            }\n            if (in == null) in = new Reader();\n            if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n            int tests = in.nextInt();\n            for (int t = 0; t < tests; t++) {\n                solveNaive(in, out);\n            }\n\n            out.flush();\n            out.close();\n        }\n    }\n\n    static long pair(int x, int y) {\n        return x * BIG + y;\n    }\n\n    static int x(long pair) {\n        return (int) (pair / BIG);\n    }\n\n    static int y(long pair) {\n        return (int) (pair % BIG);\n    }\n\n    static void ruffleSort(int[] a) {\n        if (rand == null) rand = new Random();\n        int n=a.length;\n        for (int i=0; i<n; i++) {\n            int oi=rand.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void insist(boolean bool) {\n        if (!bool) throw new IllegalStateException();\n    }\n\n    static class Reader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public Reader() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public Reader(String fileName) throws FileNotFoundException {\n            reader = new BufferedReader(new FileReader(fileName));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextInts(int n) {\n            int[] out = new int[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = nextInt();\n            }\n            return out;\n        }\n\n        public long[] nextLongs(int n) {\n            long[] out = new long[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = nextLong();\n            }\n            return out;\n        }\n    }\n}\n",
        "fixed_code": "//package raif;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n// What's the smallest input?\n// Check * for int/long overflow.\n// Check / for accidental rounding.\n// Are you using doubles? Can you avoid it?\n// Never compare after taking mod.\n// Mod the final result.\n// Initialize globals in solve() unless they are independent of the problem input.\n// Check for local/global name conflicts (n?).\n// Check initial values for max/min (not Integer.MIN_VALUE for long).\npublic class D {\n    static Random rand;\n    static boolean MULTIPLE_CASES = false;\n    static boolean CONSTRUCTIVE = true;\n    static long MOD = (long) 1e9 + 7;\n    static long BIG = (long) 2e9;\n\n    static class Target {\n        int r, c;\n\n        public Target(int r, int c) {\n            this.r = r+1;\n            this.c = c+1;\n        }\n\n        @Override\n        public String toString() {\n            return r + \" \" + c;\n        }\n    }\n\n    public static void solve(Reader in, PrintWriter out) {\n        int n = in.nextInt();\n        int[] arr = in.nextInts(n);\n\n        Stack<Integer> ones = new Stack<>();\n        Stack<Integer> twosAndThrees = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            if (arr[i] == 1) {\n                ones.add(i);\n            } else if (arr[i] == 2 || arr[i] == 3) {\n                twosAndThrees.add(i);\n            }\n        }\n\n        List<Target> ans = new ArrayList<>();\n\n        boolean ok = true;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == 0) continue;\n            ans.add(new Target(i, i));\n\n            if (arr[i] == 3) {\n                // would be nice to find a 2 or 3\n                while (!twosAndThrees.isEmpty() && twosAndThrees.peek() <= i) twosAndThrees.pop();\n\n                if (!twosAndThrees.isEmpty()) {\n                    int nextCol = twosAndThrees.pop();\n                    ans.add(new Target(i, nextCol));\n                    continue;\n                }\n            }\n\n            if (arr[i] == 2 || arr[i] == 3) {\n                // need to find a 1\n                while (!ones.isEmpty() && ones.peek() <= i) ones.pop();\n                if (ones.isEmpty()) {\n                    ok = false;\n                    break;\n                }\n                int nextCol = ones.pop();\n                ans.add(new Target(i, nextCol));\n                if (arr[i] == 2) arr[nextCol] = 0; // we don't want to add a target here later on\n            }\n        }\n\n        if (ok) {\n            out.println(ans.size());\n            for (Target t : ans) {\n                out.println(t);\n            }\n        } else {\n            out.println(-1);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Reader in = null;\n        PrintWriter out = null;\n        for (String arg : args) {\n            if (arg.startsWith(\"input\")) {\n                in = new Reader(arg);\n            } else if (arg.startsWith(\"output\")) {\n                out = new PrintWriter(new FileWriter(arg));\n            }\n        }\n        if (in == null) in = new Reader();\n        if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        if (MULTIPLE_CASES) {\n            int tests = in.nextInt();\n            for (int t = 0; t < tests; t++) {\n                solve(in, out);\n            }\n        } else {\n            solve(in, out);\n        }\n\n        out.flush();\n    }\n\n    static class Tester {\n        public static void main(String[] args) throws IOException {\n            Validator validator = new Validator();\n\n            File currentDir = new File(\".\");\n            long before;\n            long after;\n            for (File inputFile : Arrays.stream(currentDir.listFiles())\n                    .sorted(Comparator.comparing(File::getName))\n                    .collect(Collectors.toList())) {\n                if (!inputFile.getName().startsWith(\"input\")\n                        || inputFile.getName().contains(\"sight\")\n                        || inputFile.getName().contains(\"big\")) continue;\n                System.out.println(\"Test file: \" + inputFile.getName());\n\n                before = System.nanoTime();\n                String outputFileName = \"output\" + inputFile.getName().substring(5);\n                D.main(new String[]{inputFile.getName(), outputFileName});\n                after = System.nanoTime();\n\n                File outputFile = new File(outputFileName);\n                if (!outputFile.exists()) {\n                    throw new IllegalStateException(\"Missing output file \" + outputFile);\n                }\n\n                // TODO if verifier is implemented, remove this\n                if (CONSTRUCTIVE) {\n                    System.out.println(\"INPUT:\");\n                    printFile(inputFile);\n                    System.out.printf(\"\\nOUTPUT: (%d milliseconds)\\n\", (after - before) / 1000000L);\n                    printFile(outputFile);\n                    continue;\n                }\n\n                if (validator.validate(inputFile, outputFile)) {\n                    System.out.printf(\"OK (%d milliseconds)\\n\", (after - before) / 1000000L);\n                } else {\n                    System.out.println(\"FAILED\");\n                    System.out.println(\"\\nInput: \");\n                    printFile(inputFile);\n                    System.out.println(\"\\nIncorrect Output: \");\n                    printFile(outputFile);\n                    return;\n                }\n            }\n            System.out.println(\"\\n-----------------\\n\");\n\n            File sightTestInput = new File(\"input-sight\");\n            if (sightTestInput.exists()) {\n                System.out.println(\"Running sight test... Input:\");\n                printFile(sightTestInput);\n                before = System.nanoTime();\n                System.out.println(\"\\nOutput: \");\n                D.main(new String[]{\"input-sight\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n                System.out.println(\"\\n-----------------\\n\");\n            }\n\n            File bigTestInput = new File(\"input-big\");\n            if (bigTestInput.exists()) {\n                System.out.println(\"Running big test...\");\n                before = System.nanoTime();\n                D.main(new String[] {\"input-big\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n            }\n        }\n\n        static void printFile(File file) throws FileNotFoundException {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            reader.lines().forEach(System.out::println);\n        }\n    }\n\n    static class Validator {\n        boolean validate(File inputFile, File outputFile) throws IOException {\n            File expectedOutputFile = new File(\"expected-output\" + inputFile.getName().substring(5));\n            if (CONSTRUCTIVE || !expectedOutputFile.exists()) {\n                return validateManual(inputFile, outputFile);\n            }\n            return areSame(outputFile, expectedOutputFile);\n        }\n\n        private boolean validateManual(File inputFile, File outputFile) throws IOException {\n            if (CONSTRUCTIVE) {\n                // Validate output against input\n                Reader inputReader = new Reader(inputFile.getName());\n                Reader outputReader = new Reader(outputFile.getName());\n\n                // TODO implement manual validation\n\n                throw new IllegalStateException(\"Missing expected output file\");\n            } else {\n                File naiveOutput = new File(\"naive-\" + outputFile.getName());\n                Naive.main(new String[]{inputFile.getName(), naiveOutput.getName()});\n\n                return areSame(outputFile, naiveOutput);\n            }\n        }\n\n        private boolean areSame(File file1, File file2) throws IOException {\n            BufferedReader reader1 = new BufferedReader(new FileReader(file1));\n            BufferedReader reader2 = new BufferedReader(new FileReader(file2));\n\n            String line1;\n            while ((line1 = reader1.readLine()) != null) {\n                String line2 = reader2.readLine();\n                if (line2 == null) line2 = \"\"; // ok if one has an extra newline\n                if (!line1.trim().equals(line2.trim())) {\n                    return false;\n                }\n            }\n            String line2;\n            while ((line2 = reader2.readLine()) != null) {\n                if (!line2.trim().isEmpty()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Naive {\n        public static void solveNaive(Reader in, PrintWriter out) {\n            throw new IllegalStateException(\"missing expected output file\");\n        }\n\n        public static void main(String[] args) throws IOException {\n            Reader in = null;\n            PrintWriter out = null;\n            for (String arg : args) {\n                if (arg.startsWith(\"input\")) {\n                    in = new Reader(arg);\n                } else if (arg.startsWith(\"naive-output\")) {\n                    out = new PrintWriter(new FileWriter(arg));\n                }\n            }\n            if (in == null) in = new Reader();\n            if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n            int tests = in.nextInt();\n            for (int t = 0; t < tests; t++) {\n                solveNaive(in, out);\n            }\n\n            out.flush();\n            out.close();\n        }\n    }\n\n    static long pair(int x, int y) {\n        return x * BIG + y;\n    }\n\n    static int x(long pair) {\n        return (int) (pair / BIG);\n    }\n\n    static int y(long pair) {\n        return (int) (pair % BIG);\n    }\n\n    static void ruffleSort(int[] a) {\n        if (rand == null) rand = new Random();\n        int n=a.length;\n        for (int i=0; i<n; i++) {\n            int oi=rand.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void insist(boolean bool) {\n        if (!bool) throw new IllegalStateException();\n    }\n\n    static class Reader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public Reader() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public Reader(String fileName) throws FileNotFoundException {\n            reader = new BufferedReader(new FileReader(fileName));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextInts(int n) {\n            int[] out = new int[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = nextInt();\n            }\n            return out;\n        }\n\n        public long[] nextLongs(int n) {\n            long[] out = new long[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = nextLong();\n            }\n            return out;\n        }\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "package codeforces_round_805;\n\nimport java.util.*;\n\n//brute force\n\npublic class P2 {\n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);\n\n        int t;\n        t = scan.nextInt();\n\n        for (int test = 0; test < t; test++) {\n            String str = scan.next();\n            String memstr = \"\";\n            int mem = 0;\n            int memcount = 0;\n            int days = 1;\n            int check = 0;\n\n            while (memcount < str.length()) {\n                if (mem == 0) {\n                    memstr += str.charAt(memcount);\n                    ++mem;\n                } else {\n                    for (int i = 0; i < memstr.length(); i++) {\n                        if (str.charAt(memcount) == memstr.charAt(i)) {\n                            check = 1;\n                            break;\n                        }\n                    }\n                    if (check == 1) {\n                        check = 0;\n                    } else {\n                        if (mem == 3) {\n                            ++days;\n                            memstr = \"\";\n                            mem = 0;\n                            check = 0;\n                            --memcount;\n                        } else {\n                            memstr += str.charAt(memcount);\n                            ++mem;\n                        }\n\n                    }\n                }\n                ++memcount;\n            }\n\n            System.out.println(days);\n        }\n        scan.close();\n    }\n}\n",
        "fixed_code": "// package codeforces_round_805;\n\nimport java.util.*;\n\n//same code as accepted by others in my case but gives tle :|\n\npublic class P2 {\n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);\n\n        int t;\n        t = scan.nextInt();\n\n        for (int test = 0; test < t; test++) {\n            String str = scan.next();\n            String memstr = \"\";\n            int mem = 0;\n            int memcount = 0;\n            int days = 1;\n            int check = 0;\n\n            while (memcount < str.length()) {\n                if (mem == 0) {\n                    memstr += str.charAt(memcount);\n                    ++mem;\n                } else {\n                    for (int i = 0; i < memstr.length(); i++) {\n                        if (str.charAt(memcount) == memstr.charAt(i)) {\n                            check = 1;\n                            break;\n                        }\n                    }\n                    if (check == 1) {\n                        check = 0;\n                    } else {\n                        if (mem == 3) {\n                            ++days;\n                            memstr = \"\";\n                            mem = 0;\n                            check = 0;\n                            --memcount;\n                        } else {\n                            memstr += str.charAt(memcount);\n                            ++mem;\n                        }\n\n                    }\n                }\n                ++memcount;\n            }\n\n            System.out.println(days);\n        }\n        // scan.close();\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <queue>\r\n#include <string>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <tuple>\r\n#define debug(...) fprintf(stderr,__VA_ARGS__)\r\n#define all(x) x.begin(),x.end()\r\n#define rep(i, j, n) for (int i=j;i<int(n);++i)\r\ntypedef long long ll;\r\nusing namespace std;\r\ntypedef pair<ll, ll> P;\r\ntypedef pair<ll, int> P1;\r\nconst int maxN = 10000 + 5;\r\npriority_queue<P1> que;\r\nvector<P> city;\r\nint n;\r\nll ans = 0;\r\n\r\nint main()\r\n{\r\n    cin >> n;\r\n    for (int i = 0; i < n; i ++) {\r\n        ll a, c;\r\n        scanf(\"%lld %lld\", &a, &c);\r\n        city.push_back(P(a, c));\r\n        ans += c;\r\n    }\r\n    sort(city.begin(), city.end());\r\n    que.push(P1(0, 0));\r\n    vector<bool> vis(n, false);\r\n    // vector<int> fa(n, 0);\r\n    while(que.size()) {\r\n        ll d; int i;\r\n        tie(d, i) = que.top(); que.pop();\r\n        if (vis[i]) continue;\r\n        vis[i] = true;\r\n        if (i == n - 1) {\r\n            ans -= d;\r\n            break;\r\n        }\r\n        if (i > 0) {\r\n            que.push({d, i - 1});\r\n        }\r\n        int j = lower_bound(city.begin(), city.end(), P(city[i].first + city[i].second, LLONG_MAX)) - city.begin() - 1;\r\n        que.push({d, j});\r\n        if (j + 1 < n) {\r\n            que.push({d - city[j+1].first + city[i].first + city[i].second, j + 1});\r\n        }\r\n    }\r\n    printf(\"%lld\\n\", ans);\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\n#define debug(...) fprintf(stderr,__VA_ARGS__)\r\n#define all(x) x.begin(),x.end()\r\n#define rep(i, j, n) for (int i=j;i<int(n);++i)\r\ntypedef long long ll;\r\nusing namespace std;\r\ntypedef pair<ll, ll> P;\r\ntypedef pair<ll, int> P1;\r\nconst int maxN = 10000 + 5;\r\npriority_queue<P1> que;\r\nvector<P> city;\r\nint n;\r\nll ans = 0;\r\n\r\nint main()\r\n{\r\n    cin >> n;\r\n    for (int i = 0; i < n; i ++) {\r\n        ll a, c;\r\n        scanf(\"%lld %lld\", &a, &c);\r\n        city.push_back(P(a, c));\r\n        ans += c;\r\n    }\r\n    sort(city.begin(), city.end());\r\n    que.push(P1(0, 0));\r\n    vector<bool> vis(n, false);\r\n    // vector<int> fa(n, 0);\r\n    while(que.size()) {\r\n        ll d; int i;\r\n        tie(d, i) = que.top(); que.pop();\r\n        if (vis[i]) continue;\r\n        vis[i] = true;\r\n        if (i == n - 1) {\r\n            ans -= d;\r\n            break;\r\n        }\r\n        if (i > 0) {\r\n            que.push({d, i - 1});\r\n        }\r\n        int j = lower_bound(city.begin(), city.end(), P(city[i].first + city[i].second, LLONG_MAX)) - city.begin() - 1;\r\n        que.push({d, j});\r\n        if (j + 1 < n) {\r\n            que.push({d - city[j+1].first + city[i].first + city[i].second, j + 1});\r\n        }\r\n    }\r\n    printf(\"%lld\\n\", ans);\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tint a;\n\tcin >> a;\n\tfor (int i = 0;i < a;i++)\n\t{\n\t\tint b;\n\t\tcin >> b;\n\t\tcout << pow(2, (b - 1)) << endl;\n\t}\n\n\treturn 0;\n}",
        "fixed_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tint a;\n\tcin >> a;\n\tfor (int i = 0;i < a;i++)\n\t{\n\t\tint b;\n\t\tcin >> b;\n\t\tcout << b << endl;\n\t}\n\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define f first\n#define s second\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\n#define pi acos(-1.0)\n#define EPS 1e-9\n#define mem(n,x) memset(n,x,sizeof(n))\ntypedef long long ll;\n\nusing namespace std;\n\nint v[100005],n;\n\nbool check(int x){\n\tfor(int i=0;i<n;i++){\n\t\tif(!v[i])continue;\n\t\tint cnt=0;\n\t\tbool ok=true;\n\t\tfor(int j=i;;j+=x){\n\t\t\tif(j+x>=n){\n\t\t\t\tj=(j+x)%n;\n\t\t\t\tif(!v[j] || cnt<2)ok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif(!v[j]){ok=false;break;}\n\t\t}\n\t\tif(ok)return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",v+i);\n\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i)continue;\n\t\tif(check(i) || check(n/i)){cout<<\"YES\\n\";return 0;}\n\t}\n\tcout<<\"NO\\n\";\n\treturn 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define f first\n#define s second\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\n#define pi acos(-1.0)\n#define EPS 1e-9\n#define mem(n,x) memset(n,x,sizeof(n))\ntypedef long long ll;\n\nusing namespace std;\n\nint v[100005],n;\n\nbool check(int x){\n\tfor(int i=0;i<n;i++){\n\t\tif(!v[i])continue;\n\t\tint cnt=0;\n\t\tbool ok=true;\n\t\tfor(int j=i;;j+=x){\n\t\t\tcnt++;\n\t\t\tif(!v[j]){ok=false;break;}\n\t\t\tif(j+x>=n){\n\t\t\t\tj=(j+x)%n;\n\t\t\t\tif(!v[j] || cnt<3)ok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",v+i);\n\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i)continue;\n\t\tif(check(i) || check(n/i)){cout<<\"YES\\n\";return 0;}\n\t}\n\tcout<<\"NO\\n\";\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nvoid _qsort(int arr[],int l,int h){\n    int m,key,t,ll,hh;\n\tif(l>=h)return;\nelse{\n     m=rand()%(h-l)+l;\n\t t=arr[m];\n\t arr[m]=arr[l];\n\t arr[l]=t;\n\t key=arr[l];\n     while(ll<hh){\n                  while(ll<hh&&arr[hh]>key) hh--;\n                  if(ll<hh)\n                  {\n                                            arr[ll]=arr[hh];\n                                            ll++;\n                                                }\n                  while(ll<hh&&arr[ll]<key) ll++;\n                  if(ll<hh)\n                  {\n                                            arr[hh]=arr[ll];\n                                            hh--;\n                                                }\n                  }\n     }\n\tarr[ll]=key;\n\t_qsort(arr,l,ll-1);\n\t_qsort(arr,ll+1,h);\n}\n\nint main(){\n    int n,k,a[10002],i,sum,count,j,h,temp;\n    scanf(\"%d%d\",&n,&k);\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&a[i]);\n    for(i=0;i<n;i++){\n        if(a[i]>0)\n            break;\n    }\n    count=i;\n    if(count>=k){\n        for(i=0;i<k;i++)\n            a[i]=a[i]*(-1);\n    }\n    else{\n        k-=count;\n        for(i=0;i<count;i++)\n            a[i]=a[i]*(-1);\n        _qsort(a,0,n);\n        /*for(j=0;j<n;j++){\n            for(h=j+i;h<n;h++){\n                if(a[j]<a[h]){\n                    temp=a[j];\n                    a[j]=a[h];\n                    a[h]=temp;\n                }\n            }\n        }*/\n        if(k%2)\n            a[0]=a[0]*(-1);\n    }\n\n    /*for(i=0;i<k;i++){\n        if(a[i]>=0) break;\n        else{\n            a[i]=a[i]*(-1);\n        }\n    }*/\n    sum=0;\n    for(i=0;i<n;i++){\n        sum=sum+a[i];\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}\n \t \t\t\t   \t  \t  \t\t\t \t \t \t\t\t",
        "fixed_code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nvoid qsort1(int *a,int l,int h){\n    int key,aa,ll=l,hh=h;\n    if(l>=h)return;\n    aa=rand()%(h-l)+l;\n    key=a[aa];\n    a[aa]=a[ll];\n    a[ll]=key;\n    while(ll<hh){\n        while(ll<hh&&a[hh]>=key)\n            hh--;\n        if(ll<hh){\n            a[ll++]=a[hh];\n        }\n        while(ll<hh&&a[ll]<=key)\n            ll++;\n        if(ll<hh){\n            a[hh--]=a[ll];\n        }\n    }\n    a[ll]=key;\n    qsort1(a,l,ll-1);\n    qsort1(a,ll+1,h);\n}\nint a[100010],b[100010],c[100010];\nint main(){\n    int n,m,s,ss,i,k,t,ia,ib,sum1,sum2,sum;\n    while(~scanf(\"%d %d\",&n,&m)){\n        for(i=0;i<n;i++){\n            scanf(\"%d\",&a[i]);\n            if(a[i]<0&&m){\n                a[i]=-a[i];\n                m--;\n            }\n        }\n        if(m%2){\n            qsort1(a,0,n-1);\n            a[0]=-a[0];\n        }\n        sum=0;\n        for(i=0;i<n;i++)\n        sum+=a[i];\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}\n   \t \t\t\t \t\t\t\t\t\t \t\t\t\t  \t \t\t",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 5e3+1;\nconst int MOD = 1e9+7;\nchar vec[MAX_N];\nlong long dp[MAX_N][MAX_N];\nvoid add(int pos,int x,long long num)\n{\n    for(;x<MAX_N;x+=(x&-x))\n    {\n        dp[pos][x]=dp[pos][x]+num;\n        if(dp[pos][x]>=MOD) dp[pos][x]-=MOD;\n    }\n}\nlong long sum(int pos,int x)\n{\n    long long ans = 0;\n    for(;x>0;x-=(x&-x))\n    {\n        ans =ans+dp[pos][x];\n        if(ans>=MOD) ans-=MOD;\n    }\n    return ans;\n}\nint main()\n{\n    int N,M,T;\n    while(cin>>N)\n    {\n        memset(dp,0,sizeof(dp));\n        for(int i=1;i<=N;i++)\n        {\n            cin>>vec[i];\n        }\n        dp[1][1] = 1;\n        for(int i=1;i<=N;i++)\n        {\n            //cout<<\"............\"<<vec[i]<<endl;\n            for(int j=1;j<=i;j++)\n            {\n                long long t = sum(i,j);\n                //cout<<i<<\".....\"<<j<<\"????\"<<t<<endl;\n                if(vec[i] == 'f')\n                {\n                    add(i+1,j+1,t);\n                    add(i+1,j+2,-t);\n                }\n                else\n                {\n                    add(i+1,1,t);\n                    add(i+1,j+1,-t);\n                }\n            }\n        }\n        long long ans = 0;\n        for(int i=1;i<=N;i++) ans = (ans+sum(N,i))%MOD;\n        cout<<(ans+MOD)%MOD<<endl;\n    }\n    return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 5e3+9;\nconst int MOD = 1e9+7;\nchar vec[MAX_N];\nlong long dp[MAX_N][MAX_N];\nvoid add(int pos,int x,long long num)\n{\n    if(num<0) num+=MOD;\n    for(;x<MAX_N;x+=(x&-x))\n    {\n        dp[pos][x]=dp[pos][x]+num;\n        if(dp[pos][x]>=MOD) dp[pos][x]-=MOD;\n    }\n}\nlong long sum(int pos,int x)\n{\n    long long ans = 0;\n    for(;x>0;x-=(x&-x))\n    {\n        ans=ans+dp[pos][x];\n        if(ans>=MOD) ans-=MOD;\n    }\n    return ans;\n}\nint main()\n{\n    int N,M,T;\n    while(cin>>N)\n    {\n        memset(dp,0,sizeof(dp));\n        for(int i=1;i<=N;i++)\n        {\n            cin>>vec[i];\n        }\n        dp[1][1] = 1;\n        for(int i=1;i<=N;i++)\n        {\n            //cout<<\"............\"<<vec[i]<<endl;\n            for(int j=1;j<=i;j++)\n            {\n                long long t = sum(i,j);\n                //cout<<i<<\".....\"<<j<<\"????\"<<t<<endl;\n                if(vec[i] == 'f')\n                {\n                    add(i+1,j+1,t);\n                    add(i+1,j+2,-t);\n                }\n                else\n                {\n                    add(i+1,1,t);\n                    add(i+1,j+1,-t);\n                }\n            }\n        }\n        long long ans = 0;\n        for(int i=1;i<=N;i++) ans = (ans+sum(N,i))%MOD;\n        cout<<(ans+MOD)%MOD<<endl;\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public void sendGroupVoiceMessageWithExtras(org.json.JSONArray data, final org.apache.cordova.CallbackContext callback) {\n    try {\n        long groupId = data.getLong(0);\n        java.lang.String voiceUrlStr = data.getString(1);\n        java.lang.String json = data.getString(2);\n        cn.jpush.im.android.api.model.Conversation conversation = cn.jpush.im.android.api.JMessageClient.getGroupConversation(groupId);\n        if (conversation == null) {\n            conversation = cn.jpush.im.android.api.model.Conversation.createGroupConversation(groupId);\n        }\n        if (conversation == null) {\n            callback.error(\"无法创建对话\");\n            return ;\n        }\n        requestPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE);\n        java.net.URL url = new java.net.URL(voiceUrlStr);\n        java.lang.String voicePath = url.getPath();\n        java.io.File file = new java.io.File(voicePath);\n        android.media.MediaPlayer mediaPlayer = android.media.MediaPlayer.create(this.cordova.getActivity(), android.net.Uri.parse(voicePath));\n        int duration = mediaPlayer.getDuration();\n        cn.jpush.im.android.api.content.VoiceContent content = new cn.jpush.im.android.api.content.VoiceContent(file, duration);\n        if (!(android.text.TextUtils.isEmpty(json))) {\n            content.setExtras(getExtras(json));\n        }\n        final cn.jpush.im.android.api.model.Message msg = cn.jpush.im.android.api.JMessageClient.createGroupVoiceMessage(groupId, file, duration);\n        msg.setOnSendCompleteCallback(new cn.jpush.im.api.BasicCallback() {\n            @java.lang.Override\n            public void gotResult(int status, java.lang.String desc) {\n                if (status == 0) {\n                    callback.success(mGson.toJson(msg));\n                }else {\n                    callback.error(((status + \": \") + desc));\n                }\n            }\n        });\n        cn.jpush.im.android.api.JMessageClient.sendMessage(msg);\n        mediaPlayer.release();\n    } catch (org.json.JSONException e) {\n        e.printStackTrace();\n        callback.error(\"json data error\");\n    } catch (java.net.MalformedURLException e) {\n        e.printStackTrace();\n        callback.error(\"file url error\");\n    } catch (java.io.FileNotFoundException e) {\n        e.printStackTrace();\n        callback.error(\"file not found.\");\n    }\n}",
        "fixed_code": "public void sendGroupCustomMessage(org.json.JSONArray data, final org.apache.cordova.CallbackContext callback) {\n    try {\n        long groupId = data.getLong(0);\n        cn.jpush.im.android.api.model.Conversation con = cn.jpush.im.android.api.JMessageClient.getGroupConversation(groupId);\n        if (con == null) {\n            con = cn.jpush.im.android.api.model.Conversation.createGroupConversation(groupId);\n        }\n        if (con == null) {\n            callback.error(\"无法建立对话\");\n            return ;\n        }\n        java.lang.String jsonStr = data.getString(1);\n        org.json.JSONObject customValues = new org.json.JSONObject(jsonStr);\n        java.util.Iterator<? extends java.lang.String> keys = customValues.keys();\n        java.lang.String key;\n        java.lang.String value;\n        java.util.Map<java.lang.String, java.lang.String> valuesMap = new java.util.HashMap<java.lang.String, java.lang.String>();\n        while (keys.hasNext()) {\n            key = keys.next();\n            value = customValues.getString(key);\n            valuesMap.put(key, value);\n        } \n        final cn.jpush.im.android.api.model.Message msg = cn.jpush.im.android.api.JMessageClient.createGroupCustomMessage(groupId, valuesMap);\n        msg.setOnSendCompleteCallback(new cn.jpush.im.api.BasicCallback() {\n            @java.lang.Override\n            public void gotResult(int status, java.lang.String desc) {\n                if (status == 0) {\n                    callback.success(mGson.toJson(msg));\n                }else {\n                    callback.error(((status + \": \") + desc));\n                }\n            }\n        });\n        cn.jpush.im.android.api.JMessageClient.sendMessage(msg);\n    } catch (org.json.JSONException e) {\n        e.printStackTrace();\n        callback.error(\"error reading id json.\");\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<string>\n//#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<vector>\n#include<map>\n#include<functional>\n    \n#define fst first\n#define sc second\n#define pb push_back\n#define mem(a,b) memset(a,b,sizeof(a))\n#define lson l,mid,root<<1\n#define rson mid+1,r,root<<1|1\n#define lc root<<1\n#define rc root<<1|1\n#define lowbit(x) ((x)&(-x)) \n\nusing namespace std;\n\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\ntypedef pair<ll,ll> PLL;\n\nconst db eps = 1e-6;\nconst int mod = 100003;\nconst int maxn = 2e5+100;\nconst int maxm = 2e5+100;\nconst ll inf = 0x3f3f3f3f3f3f3f3f;\nconst db pi = acos(-1.0);\nstruct cube{\n    int num;\n    int h;\n}cu[maxn];\nint vis[maxn];\nint id[maxn];\nbool cmp(cube a, cube b){\n    return a.h<b.h;\n}\nint nh[maxn];\nint main() {\n    int n;ll m;\n    mem(vis, 0);\n    scanf(\"%d %lld\", &n, &m);\n    int vol = 0;\n    for(int i = 1; i <= n; i++){\n        int c;\n        scanf(\"%d\", &c);\n        if(vis[c]){\n            cu[id[c]].num++;\n        }\n        else{\n            id[c]=vol;\n            cu[vol].num=1;\n            cu[vol].h=c;\n            vis[c]=1;\n            id[c]=vol++;\n        }\n    }\n    sort(cu, cu+vol,cmp);\n    ll tmp = n;\n    int lst = 0;\n    for(int i = 0; i < vol; i++){\n        id[cu[i].h]=i;\n    }\n    for(int i = 1; i < cu[0].h; i++)nh[i]=n;\n    for(int i = cu[0].h; i <= cu[vol-1].h; i++){\n        if(vis[i]){\n            tmp-=lst;\n            lst = cu[id[i]].num;\n        }\n        nh[i]=tmp;\n        //printf(\"%d %d\\n\", i, nh[i]);\n\n    }\n    tmp = 0;\n    int ans = 0;\n    for(int i = cu[vol-1].h; i >= 0; i--){\n        if(nh[i]==n)break;\n        if(tmp+nh[i]>m){\n            tmp=nh[i];\n            ans++;\n        }\n        else tmp+=nh[i];\n        //printf(\"%d\\n\", tmp);\n    }\n    if(tmp>0)ans++;\n    printf(\"%d\", ans);\n    return 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<string>\n//#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<vector>\n#include<map>\n#include<functional>\n    \n#define fst first\n#define sc second\n#define pb push_back\n#define mem(a,b) memset(a,b,sizeof(a))\n#define lson l,mid,root<<1\n#define rson mid+1,r,root<<1|1\n#define lc root<<1\n#define rc root<<1|1\n#define lowbit(x) ((x)&(-x)) \n\nusing namespace std;\n\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\ntypedef pair<ll,ll> PLL;\n\nconst db eps = 1e-6;\nconst int mod = 100003;\nconst int maxn = 2e5+100;\nconst int maxm = 2e5+100;\nconst ll inf = 0x3f3f3f3f3f3f3f3f;\nconst db pi = acos(-1.0);\nstruct cube{\n    int num;\n    int h;\n}cu[maxn];\nint vis[maxn];\nint id[maxn];\nbool cmp(cube a, cube b){\n    return a.h<b.h;\n}\nint nh[maxn];\nint main() {\n    int n;ll m;\n    mem(vis, 0);\n    scanf(\"%d %lld\", &n, &m);\n    int vol = 0;\n    for(int i = 1; i <= n; i++){\n        int c;\n        scanf(\"%d\", &c);\n        nh[0]++;nh[c]--;\n        if(vis[c]){\n            cu[id[c]].num++;\n        }\n        else{\n            id[c]=vol;\n            cu[vol].num=1;\n            cu[vol].h=c;\n            vis[c]=1;\n            id[c]=vol++;\n        }\n    }\n    sort(cu, cu+vol,cmp);\n    ll tmp = n;\n    int lst = 0;\n    for(int i = 0; i < vol; i++){\n        id[cu[i].h]=i;\n    }\n    /*for(int i = 1; i < cu[0].h; i++)nh[i]=n;\n    for(int i = cu[0].h; i <= cu[vol-1].h; i++){\n        if(vis[i]){\n            tmp-=lst;\n            lst = cu[id[i]].num;\n        }\n        nh[i]=tmp;\n        //printf(\"%d %d\\n\", i, nh[i]);\n\n    }*/\n    for(int i = 1; i <= cu[vol-1].h; i++){\n        nh[i]+=nh[i-1];\n    }\n    tmp = 0;\n    int ans = 0;\n    for(int i = cu[vol-1].h; i >= 0; i--){\n        if(nh[i]==n)break;\n        if(tmp+nh[i]>m){\n            tmp=nh[i];\n            ans++;\n        }\n        else tmp+=nh[i];\n        //printf(\"%d\\n\", tmp);\n    }\n    if(tmp>0)ans++;\n    printf(\"%d\", ans);\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long int a[1000000];\nint main()\n{\n    int n;\n    long long k;\n    cin>>n>>k;\n    int i,j;\n    for(i=0;i<n;i++)\n    cin>>a[i];\n    vector<long long int> b[11];\n   long long int ans=0;\n    for(i=0;i<n;i++)\n    {\n   int len=int(floor(log10(a[i])+1));\n   b[len].push_back(a[i]%k);\n    }\n    for(i=0;i<=10;i++)\n    sort(b[i].begin(),b[i].end());\n    for(i=0;i<n;i++)\n    {\n        for(j=1;j<=10;j++)\n        {\n           long long int rem=(a[i]*(long long(pow(10,j))))%k;\n          long long   int crem=(k-rem)%k;\n        int l=lower_bound(b[j].begin(),b[j].end(),crem)-b[j].begin();\n              int u=upper_bound(b[j].begin(),b[j].end(),crem)-b[j].begin();\n        ans=ans+u-l;\n        if((rem+a[i]%k)%k==0&&int(floor(log10(a[i])+1))==j)\n        ans--;\n            \n        }\n    }\n    \n    cout<<ans<<\"\\n\";\n    return 0;\n    \n}",
        "fixed_code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long int a[1000000];\nint main()\n{\n    int n;\n    long long k;\n    cin>>n>>k;\n    int i,j;\n    for(i=0;i<n;i++)\n    cin>>a[i];\n    vector<long long int> b[11];\n   long long int ans=0;\n    for(i=0;i<n;i++)\n    {\n   int len=int(floor(log10(a[i])+1));\n   b[len].push_back(a[i]%k);\n    }\n    for(i=0;i<=10;i++)\n    sort(b[i].begin(),b[i].end());\n    for(i=0;i<n;i++)\n    {\n        for(j=1;j<=10;j++)\n        {\n           long long int rem=((a[i]%k)*((long long(pow(10,j)))%k))%k;\n          long long   int crem=(k-rem)%k;\n        int l=lower_bound(b[j].begin(),b[j].end(),crem)-b[j].begin();\n              int u=upper_bound(b[j].begin(),b[j].end(),crem)-b[j].begin();\n        ans=ans+u-l;\n        if((rem+a[i]%k)%k==0&&int(floor(log10(a[i])+1))==j)\n        ans--;\n            \n        }\n    }\n    \n    cout<<ans<<\"\\n\";\n    return 0;\n    \n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<cmath>\r\n#include<algorithm>\r\n#include<string>\r\n#include<vector>\r\n#include<queue>\r\n#include<map>\r\n#include<set>\r\n#include<bitset>\r\n#include<math.h>\r\n#include<iomanip>\r\n#include<utility>\r\n#include<stack>\r\n#include<list>\r\nusing namespace std;\r\n\r\n#define num 100005\r\n#define ll long long\r\n#define inf 0x3f3f3f3f\r\n\r\nint t, n,m, ans;\r\nint a[num];\r\n\r\nvoid solve()\r\n{\r\n    ans = 0;\r\n    cin >> n >> m;\r\n    int maxx = 0;\r\n    for (int i = 1;i <= n;i++)\r\n    {\r\n        cin >> a[i];\r\n    }\r\n    sort(a + 1, a + 1 + n);\r\n    while (m > 0)\r\n    {\r\n        ans++;\r\n        if (ans & 1)\r\n            m -= a[n];\r\n        else\r\n            m -= a[n - 1];\r\n    }\r\n    cout << ans << '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0), cout.tie(0);\r\n    cin >> t;\r\n    while (t--)\r\n        solve();\r\n    return 0;\r\n}\r\n",
        "fixed_code": "#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<cmath>\r\n#include<algorithm>\r\n#include<string>\r\n#include<vector>\r\n#include<queue>\r\n#include<map>\r\n#include<set>\r\n#include<bitset>\r\n#include<math.h>\r\n#include<iomanip>\r\n#include<utility>\r\n#include<stack>\r\n#include<list>\r\nusing namespace std;\r\n\r\n#define num 100005\r\n#define ll long long\r\n#define inf 0x3f3f3f3f\r\n\r\nint t, n, m, ans;\r\nint a[num];\r\n\r\nvoid solve()\r\n{\r\n    ans = 0;\r\n    cin >> n >> m;\r\n    int maxx1 = 0;\r\n    int maxx2 = 0;\r\n    for (int i = 1;i <= n;i++)\r\n        cin >> a[i];\r\n    sort(a + 1, a + 1 + n);\r\n    maxx1 = a[n];\r\n    maxx2 = a[n - 1];\r\n    int sum = maxx1 + maxx2;\r\n    if (m % sum == 0) ans = m / sum * 2;\r\n    else\r\n    {\r\n        ans = m / sum * 2;\r\n        m %= sum;\r\n        m -= maxx1;\r\n        ans++;\r\n        if (m > 0)\r\n        {\r\n            m -= maxx2;\r\n            ans++;\r\n        }\r\n    }\r\n    cout << ans << '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0), cout.tie(0);\r\n    cin >> t;\r\n    while (t--)\r\n        solve();\r\n    return 0;\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public void setCoefficents() {\n    java.lang.String kalKey = \"\";\n    double kalCount = 0;\n    double kalmanCoeff = 0;\n    double newCoeff = 0;\n    for (int i = 0; i < (OscarGenieDriver.awardList.length); i++) {\n        for (int j = 0; j < (OscarGenieDriver.orgList.length); j++) {\n            kalKey = ((OscarGenieDriver.orgList[j]) + \" \") + (OscarGenieDriver.awardList[i]);\n            try {\n                kalCount = orgCount.get(kalKey);\n                kalmanCoeff = kalmanMap.get(kalKey);\n                kalmanCoeff = kalmanCoeff / kalCount;\n                kalmanMap.put(kalKey, kalmanCoeff);\n            } catch (java.lang.NullPointerException e) {\n            }\n        }\n    }\n}",
        "fixed_code": "public void setAllCalculationscoef(int year) {\n    double getcoef = 0;\n    double kalmancoef = 0;\n    java.util.HashMap<java.lang.String, Calculations> coefByOrg = new java.util.HashMap<java.lang.String, Calculations>();\n    java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, Calculations>> coefByAward = new java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, Calculations>>();\n    coefByAward = calculationByYear.get(year);\n    java.util.HashMap<java.lang.String, Nomination> nominations = new java.util.HashMap<java.lang.String, Nomination>();\n    java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, Nomination>> nominationsByAward = new java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, Nomination>>();\n    coefByAward = calculationByYear.get(year);\n    nominationsByAward = nomineesByYear.get(year);\n    for (int i = 0; i < (OscarGenieDriver.awardList.length); i++) {\n        coefByOrg = coefByAward.get(OscarGenieDriver.awardList[i]);\n        nominations = nominationsByAward.get(OscarGenieDriver.awardList[i]);\n        for (int j = 0; j < (OscarGenieDriver.orgList.length); j++) {\n            kalKey = ((OscarGenieDriver.orgList[j]) + \" \") + (OscarGenieDriver.awardList[i]);\n            Calculations c = new Calculations(\"\", \"\", 0);\n            Nomination n = new Nomination(\"\", 0, \"\");\n            try {\n                c = coefByOrg.get(OscarGenieDriver.orgList[j]);\n                kalmancoef = kalmanMap.get(kalKey);\n                kalmancoef = kalmancoef + (c.getCoefficient());\n                c.setCoefficient(kalmancoef);\n                coefByOrg.put(OscarGenieDriver.orgList[j], c);\n                try {\n                    name = c.getName();\n                    n = nominations.get(name);\n                    n.setCoefficient(kalmancoef);\n                } catch (java.lang.NullPointerException e) {\n                }\n            } catch (java.lang.NullPointerException e) {\n            }\n            coefByAward.put(OscarGenieDriver.awardList[i], coefByOrg);\n        }\n        calculationByYear.put(year, coefByAward);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define FOR(i,L,R) for(int i = L; (L <= R? i <= R : i >= R); (L <= R? i += 1 : i -= 1))\n#define int long long\n\nconst int N = 5e5 + 2, inf = 1e18;\nconst int BUCKETS = (int)(sqrt(N)) + 2;\n\nint n, q, a[N], lazy[BUCKETS];\nmap<int,vector<int>> values[BUCKETS];\n\nint bucket_id(int id) {\n    return id/BUCKETS;\n}\n\nvoid preprocess() {\n    FOR(i,0,n-1) {\n        int bId = bucket_id(i);\n        values[bId][a[i]].push_back(i);\n    }\n    FOR(i,0,BUCKETS-1) {\n        for(auto &it : values[i]) {\n            sort(it.second.begin(), it.second.end());\n        }\n    }\n}\n\nvoid full_update_bucket(int bId, int L, int R, int add) {\n    // auto& mp = values[bId];\n    map<int,vector<int>> next;\n    for(auto it : values[bId]) {\n        int val = it.first;\n        for(int pos : it.second) {\n            if(pos >= L && pos <= R) {\n                next[val + add].push_back(pos);\n            }else {\n                next[val].push_back(pos);\n            }\n        }\n    }\n    values[bId].clear();\n    for(auto &it : next) {\n        sort(it.second.begin(), it.second.end());\n    }\n    values[bId] = next;\n}\n\nvoid lazy_update_bucket(int id, int add) {\n    lazy[id] += add;\n}\n\nvoid update(int L, int R, int val) {\n    int leftmost = bucket_id(L), rightmost = bucket_id(R);\n\n    if(leftmost == rightmost) {\n        full_update_bucket(leftmost, L, R, val);\n    }else {\n        // full_update_bucket(leftmost, L, R, val);\n        // FOR(i,leftmost + 1, rightmost - 1) {\n        //     lazy_update_bucket(i, val);\n        // }\n        // full_update_bucket(rightmost, L, R, val);\n\n        FOR(i,leftmost, rightmost) {\n            full_update_bucket(i, L, R, val);\n        }\n    }\n}\n\nint query(int val) {\n    int L = inf, R = -inf;\n    FOR(i,0,BUCKETS-1) {\n        int chk = val - lazy[i];\n        if(values[i].count(chk)) {\n            for(int &pos : values[i][chk]) {    //not optimal\n                L = min(L, pos);\n                R = max(R, pos);\n            }\n        }\n    }\n    if(L == inf) return -1;\n    return R - L;\n}\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    cin >> n >> q;\n    FOR(i,0,n-1) {\n        cin >> a[i];\n    }\n    preprocess();\n    FOR(i,1,q) {\n        int type;   cin >> type;\n        if(type == 1) {\n            int L, R, add;\n            cin >> L >> R >> add;\n            --L, --R;\n            update(L, R, add);\n        }else {\n            int val;\n            cin >> val;\n            cout << query(val) << '\\n';\n        }\n    }\n}\n",
        "fixed_code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define FOR(i,L,R) for(int i = L; (L <= R? i <= R : i >= R); (L <= R? i += 1 : i -= 1))\n#define int long long\n\nconst int N = 5e5 + 5, inf = 1e18;\nconst int BUCKET = 474;\n\nint n, q, lazy[N];\npair<int,int> values[N];\n\n\n/*---------------------------------------DEBUG-----------------------------------------------*/\nvoid __print(int x) {\n    cerr << x;\n}\nvoid __print(float x) {\n    cerr << x;\n}\nvoid __print(double x) {\n    cerr << x;\n}\nvoid __print(long double x) {\n    cerr << x;\n}\nvoid __print(char x) {\n    cerr << '\\'' << x << '\\'';\n}\nvoid __print(const char *x) {\n    cerr << '\\\"' << x << '\\\"';\n}\nvoid __print(const string &x) {\n    cerr << '\\\"' << x << '\\\"';\n}\nvoid __print(bool x) {\n    cerr << (x ? \"true\" : \"false\");\n}\n\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n    cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';\n}\ntemplate<typename T>\nvoid __print(const T &x) {\n    int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";\n}\nvoid _print() {\n    cerr << \"]\\n\";\n}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n    __print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);\n}\n#ifndef ONLINE_JUDGE\n#define see(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define see(x...)\n#endif\n/*---------------------------------------DEBUG-----------------------------------------------*/\n\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    cin >> n >> q;\n    FOR(i,1,n) {\n        cin >> values[i].first;\n        values[i].second = i;\n    }\n    for(int i = 1; i <= n; i += BUCKET) {\n        sort(values + i, values + min(n, i + BUCKET - 1) + 1);\n        //keep each bucket in sorted order\n    }\n    while(q--)\n    {\n        int tc;\n        cin >> tc;\n        if(tc == 1)\n        {\n            int L, R, add;\n            cin >> L >> R >> add;\n            for(int i = 1, which = 0; i <= n; ++which, i += BUCKET) {\n                int from = i;\n                int to = min(n, i + BUCKET - 1);\n                //[from, to] : both inclusive\n                if(to < L || R < from) continue;\n                if(L <= from && to <= R) {\n                    // update lazy\n                    lazy[which] += add;\n                    continue;\n                }\n                // full update bucket\n                FOR(id,from,to) {\n                    int index = values[id].second;\n                    //only update indexes in given range [L, R]\n                    if(L <= index && index <= R) {\n                        values[id].first += add;\n                    }\n                }\n                //sorting to keep bucket reusable later\n                //[from, to] = [from, to + 1) for addresses\n                sort(values + from, values + to + 1);\n            }\n        }\n        else \n        {\n            int val;\n            cin >> val;\n            int leftmost = inf, rightmost = -inf;\n\n            for(int i = 1, which = 0; i <= n; i += BUCKET, ++which) {\n                // a[i] + lazy[which] = val\n                // to_find = val - lazy[which]\n                int to_find = val - lazy[which];\n                int L = 0, R = 0;\n\n                int lo = i, hi = min(n, i + BUCKET - 1);\n\n                while(lo <= hi) {\n                    int mid = (lo + hi) / 2;\n                    if(values[mid].first >= to_find) {\n                        L = mid;\n                        hi = mid - 1;\n                    }else lo = mid + 1;\n                }\n                lo = i, hi = min(n, i + BUCKET - 1);\n                while(lo <= hi) {\n                    int mid = (lo + hi) / 2;\n                    if(values[mid].first <= to_find) {\n                        R = mid;\n                        lo = mid + 1;\n                    }else hi = mid - 1;\n                }\n\n                if(values[L].first != to_find || values[R].first != to_find)\n                    continue;\n                if(L <= R) {\n                    leftmost = min(leftmost, values[L].second);\n                    rightmost = max(rightmost, values[R].second);\n                }\n            }\n\n            int ans = rightmost -leftmost;\n            if(leftmost == inf) \n                ans = -1;\n            cout << ans << '\\n';\n        }\n    }\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <string>\r\nusing namespace std;\r\nconst int N = 2010;\r\nint a[N],n;\r\nint main()\r\n{\r\n    int t;\r\n    cin>>t;\r\n    while(t--)\r\n    {\r\n        memset(a, 0, sizeof a);\r\n        cin>>n;\r\n        int z=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            cin>>a[i];\r\n        }\r\n        if(n%2==0) puts(\"YES\");\r\n        else\r\n        {\r\n            int flag=0;\r\n            for(int i=1;i<n;i++)\r\n            {\r\n                if(a[i]<a[i-1])\r\n                {\r\n                    flag=1;\r\n                    break;\r\n                }\r\n            }\r\n            if(flag) puts(\"YES\");\r\n            else puts(\"NO\");\r\n        }\r\n    }\r\n}",
        "fixed_code": "#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <string>\r\nusing namespace std;\r\nconst int N = 1e5+10;\r\nint a[N],n;\r\nint main()\r\n{\r\n    int t;\r\n    cin>>t;\r\n    while(t--)\r\n    {\r\n        memset(a, 0, sizeof a);\r\n        cin>>n;\r\n        int z=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            cin>>a[i];\r\n        }\r\n        if(n%2==0) puts(\"YES\");\r\n        else\r\n        {\r\n            int flag=0;\r\n            for(int i=1;i<n;i++)\r\n            {\r\n                if(a[i]<=a[i-1])\r\n                {\r\n                    flag=1;\r\n                    break;\r\n                }\r\n            }\r\n            if(flag) puts(\"YES\");\r\n            else puts(\"NO\");\r\n        }\r\n    }\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/* @nazarbek.altybay */\n\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <queue>\n\n#define pii pair<int, int>\n\n#define pb push_back\n#define mp make_pair\n\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\nconst int INF = (int) 1e9 + 7;\nconst int MAXN = (int) 1e6 + 7;\n\nvector<int> plist;\nbool bad[MAXN];\n\nll x, k;\nvector<ll> ans;\nvector<ll> divisors;\nvector<pair<ll, int>> factor;\n\nvoid genDivisors(int ptr = 0, ll cur = 1) {\n  if (ptr == factor.size()) {\n    divisors.pb(cur);\n  } else {\n    genDivisors(ptr + 1, cur);\n    for (int i = 0; i < factor[ptr].s; i++) {\n      cur *= factor[ptr].f;\n      genDivisors(ptr + 1, cur);\n    }\n  }\n}\n\nvoid generate(ll n, ll step) {\n  if (ans.size() > 100000)\n    return;\n  if (n == 1) {\n    ans.pb(1);\n    return;\n  }\n  if (step == 0) {\n    ans.pb(n);\n    return;\n  }\n  factor.clear();\n  for (auto it : plist) {\n    if (1ll * it * it > n)\n      break;\n    if (n % it == 0) {\n      int deg = 0;\n      while (n % it == 0) {\n        n /= it;\n        deg++;\n      }\n      factor.pb(mp(it, deg));\n    }\n  }\n  if (n > 1)\n    factor.pb(mp(n, 1));\n  divisors.clear();\n  genDivisors();\n  sort(divisors.begin(), divisors.end());\n  for (auto it : divisors) {\n    generate(it, step - 1);\n  }\n}\n\nint main() {\n  #ifdef LOCAL\n  freopen(\"in\", \"r\", stdin);\n  #endif\n\n  bad[0] = bad[1] = true;\n  for (int i = 2; i * i < MAXN; i++) {\n    if (!bad[i]) {\n      for (int j = i * i; j < MAXN; j += i)\n        bad[j] = true;\n    }\n  }\n  for (int i = 2; i < MAXN; i++) {\n    if (!bad[i]) {\n      plist.pb(i);\n    }\n  }\n\n  cin >> x >> k;\n  generate(x, k);\n  if (ans.size() > 100000)\n    ans.resize(100000);\n  for (auto it : ans)\n    cout << it << ' ';\n\n  return 0;\n}",
        "fixed_code": "/* @nazarbek.altybay */\n\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <queue>\n\n#define pii pair<int, int>\n\n#define pb push_back\n#define mp make_pair\n\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\nconst int INF = (int) 1e9 + 7;\nconst int MAXN = (int) 1e6 + 7;\n\nvector<int> plist;\nbool bad[MAXN];\n\nll x, k;\nvector<ll> ans;\nvector<ll> divisors;\nvector<pair<ll, int>> factor;\n\nvoid genDivisors(int ptr = 0, ll cur = 1) {\n  if (ptr == factor.size()) {\n    divisors.pb(cur);\n  } else {\n    genDivisors(ptr + 1, cur);\n    for (int i = 0; i < factor[ptr].s; i++) {\n      cur *= factor[ptr].f;\n      genDivisors(ptr + 1, cur);\n    }\n  }\n}\n\nvoid generate(ll n, ll step) {\n  if (ans.size() > 100000)\n    return;\n  if (n == 1) {\n    ans.pb(1);\n    return;\n  }\n  if (step == 0) {\n    ans.pb(n);\n    return;\n  }\n  factor.clear();\n  bool prime = true;\n  for (auto it : plist) {\n    if (1ll * it * it > n)\n      break;\n    if (n % it == 0) {\n      int deg = 0;\n      while (n % it == 0) {\n        n /= it;\n        deg++;\n      }\n      prime = false;\n      factor.pb(mp(it, deg));\n    }\n  }\n  if (n > 1)\n    factor.pb(mp(n, 1));\n  if (prime) {\n    for (ll i = 0; i < step && ans.size() < 100000; i++) {\n      ans.pb(1);\n    }\n    ans.pb(n);\n    return;\n  }\n  divisors.clear();\n  genDivisors();\n  sort(divisors.begin(), divisors.end());\n  for (auto it : divisors) {\n    generate(it, step - 1);\n  }\n}\n\nint main() {\n  #ifdef LOCAL\n  freopen(\"in\", \"r\", stdin);\n  #endif\n\n  bad[0] = bad[1] = true;\n  for (int i = 2; i * i < MAXN; i++) {\n    if (!bad[i]) {\n      for (int j = i * i; j < MAXN; j += i)\n        bad[j] = true;\n    }\n  }\n  for (int i = 2; i < MAXN; i++) {\n    if (!bad[i]) {\n      plist.pb(i);\n    }\n  }\n\n  cin >> x >> k;\n  generate(x, k);\n  if (ans.size() > 100000)\n    ans.resize(100000);\n  for (auto it : ans)\n    cout << it << ' ';\n\n  return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//This code is written by प्रविण शंखपाळ \r\n\r\n//package wizard;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Ginny_Weasley {\r\n\r\n\tstatic long mod = (long) 1e9 + 7;\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n//\t\ttry {\r\n\r\n\t\tFastReader fr = new FastReader();\r\n\t\tPrintWriter pt = new PrintWriter(System.out);\r\n\r\n\t\tint t = 1;\r\n\r\n\t\twhile (t > 0) {\r\n\r\n\t\t\tint n = fr.nextInt(), q = fr.nextInt();\r\n\t\t\tString str = fr.next();\r\n\r\n\t\t\tlong dp[] = new long[n + 1];\r\n\r\n\t\t\tdp[0] = 0;\r\n\r\n\t\t\tfor (int i = 1; i <= str.length(); i++) {\r\n\t\t\t\tdp[i] = dp[i - 1] + ((str.charAt(i - 1) - 'a') + 1);\r\n\t\t\t}\r\n\r\n\t\t\tfor (long i : dp) {\r\n\t\t\t\tpt.print(i + \" \");\r\n\t\t\t}\r\n\t\t\tpt.println();\r\n\r\n\t\t\twhile (q > 0) {\r\n\r\n\t\t\t\tint l = fr.nextInt(), r = fr.nextInt();\r\n\t\t\t\tl--;\r\n\r\n\t\t\t\tpt.println(dp[r] - dp[l]);\r\n\r\n\t\t\t\tq--;\r\n\t\t\t}\r\n\r\n\t\t\tt--;\r\n\t\t}\r\n\r\n\t\tpt.close();\r\n\r\n//\t\t} catch (\r\n//\r\n//\t\tException e) {\r\n//\t\t\treturn;\r\n//\t\t}\r\n\t}\r\n\r\n\tstatic int lower_bound(long[] arr, int begin, int end, long tar) {\r\n\t\twhile (begin < end) {\r\n\t\t\tint mid = begin + (end - begin) / 2;\r\n\t\t\tif (arr[mid] < tar)\r\n\t\t\t\tbegin = mid + 1;\r\n\t\t\telse if (arr[mid] >= tar)\r\n\t\t\t\tend = mid;\r\n\t\t}\r\n\t\treturn begin;\r\n//\t\tlower bound gives largest index of a number smaller than (if target is not present) or equal to target(if target is present) \r\n//      for complete array use begin = 0 and end = n\r\n\t}\r\n\r\n\tstatic int upper_bound(long[] arr, int begin, int end, long tar) {\r\n\t\twhile (begin < end) {\r\n\t\t\tint mid = begin + (end - begin) / 2;\r\n\t\t\tif (arr[mid] <= tar)\r\n\t\t\t\tbegin = mid + 1;\r\n\t\t\telse if (arr[mid] > tar)\r\n\t\t\t\tend = mid;\r\n\t\t}\r\n\r\n\t\treturn begin;\r\n//\t\tupper bound gives smallest index of a number strictly greater than target\r\n//\t    for complete array use begin = 0 and end = n\r\n\t}\r\n\r\n\tstatic class Triple implements Comparable<Triple> {\r\n\t\tint a, b, c;\r\n\r\n\t\tTriple(int a, int b, int c) {\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.c = c;\r\n\t\t}\r\n\r\n\t\tpublic int compareTo(Triple o) {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\tif (this.a != o.a)\r\n\t\t\t\treturn Long.compare(this.a, o.a);\r\n\t\t\telse\r\n\t\t\t\treturn Long.compare(this.b, o.b);\r\n\t\t\t// return 0;\r\n\t\t}\r\n\r\n\t\tpublic boolean equals(Object o) {\r\n\t\t\tif (o instanceof Pair) {\r\n\t\t\t\tPair p = (Pair) o;\r\n\t\t\t\treturn p.a == a && p.b == b;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class Pairx<Pairx> {\r\n\r\n\t\tint a;\r\n\t\tString b;\r\n\r\n\t\tPairx(int a, String b) {\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.b = b;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic void merge(long arr[], int l, int m, int r) {\r\n\r\n\t\tint n1 = m - l + 1;\r\n\t\tint n2 = r - m;\r\n\r\n\t\tlong L[] = new long[n1];\r\n\t\tlong R[] = new long[n2];\r\n\r\n\t\tfor (int i = 0; i < n1; ++i)\r\n\t\t\tL[i] = arr[l + i];\r\n\t\tfor (int j = 0; j < n2; ++j)\r\n\t\t\tR[j] = arr[m + 1 + j];\r\n\r\n\t\tint i = 0, j = 0;\r\n\r\n\t\tint k = l;\r\n\t\twhile (i < n1 && j < n2) {\r\n\t\t\tif (L[i] <= R[j]) {\r\n\t\t\t\tarr[k] = L[i];\r\n\t\t\t\ti++;\r\n\t\t\t} else {\r\n\t\t\t\tarr[k] = R[j];\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t\tk++;\r\n\t\t}\r\n\r\n\t\twhile (i < n1) {\r\n\t\t\tarr[k] = L[i];\r\n\t\t\ti++;\r\n\t\t\tk++;\r\n\t\t}\r\n\r\n\t\twhile (j < n2) {\r\n\t\t\tarr[k] = R[j];\r\n\t\t\tj++;\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void sort(long arr[], int l, int r) {\r\n\t\tif (l < r) {\r\n\r\n\t\t\tint m = l + (r - l) / 2;\r\n\r\n\t\t\tsort(arr, l, m);\r\n\t\t\tsort(arr, m + 1, r);\r\n\r\n\t\t\tmerge(arr, l, m, r);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic class Pair implements Comparable<Pair> {\r\n\t\tint a, b;\r\n\r\n\t\tPair(int a, int b) {\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.b = b;\r\n\t\t}\r\n\r\n\t\tpublic int compareTo(Pair o) {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\tif (this.a != o.a)\r\n\t\t\t\treturn Long.compare(this.a, o.a);\r\n\t\t\telse\r\n\t\t\t\treturn Long.compare(this.b, o.b);\r\n\t\t\t// return 0;\r\n\t\t}\r\n\r\n\t\tpublic boolean equals(Object o) {\r\n\t\t\tif (o instanceof Pair) {\r\n\t\t\t\tPair p = (Pair) o;\r\n\t\t\t\treturn p.a == a && p.b == b;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic int binarySearch(long arr[], int first, int last, long key) {\r\n\t\tint mid = (first + last) / 2;\r\n\t\twhile (first <= last) {\r\n\t\t\tif (arr[mid] < key) {\r\n\t\t\t\tfirst = mid + 1;\r\n\t\t\t} else if (arr[mid] == key) {\r\n\t\t\t\treturn mid;\r\n\t\t\t} else {\r\n\t\t\t\tlast = mid - 1;\r\n\t\t\t}\r\n\t\t\tmid = (first + last) / 2;\r\n\t\t}\r\n//\t\treturn -1;\r\n\t\treturn mid;\r\n//\t\treturn mid if want to find key greater than or less than arr[mid] if exact value is not given\r\n\t}\r\n\r\n\tstatic class FastReader {\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\tpublic FastReader() {\r\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t}\r\n\r\n\t\tString next() {\r\n\t\t\twhile (st == null || !st.hasMoreElements()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tint nextInt() {\r\n\t\t\treturn Integer.parseInt(next());\r\n\t\t}\r\n\r\n\t\tlong nextLong() {\r\n\t\t\treturn Long.parseLong(next());\r\n\t\t}\r\n\r\n\t\tdouble nextDouble() {\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tString nextLine() {\r\n\t\t\tString str = \"\";\r\n\t\t\ttry {\r\n\t\t\t\tstr = br.readLine();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t}\r\n\t}\r\n}",
        "fixed_code": "//This code is written by प्रविण शंखपाळ \r\n\r\n//package wizard;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Ginny_Weasley {\r\n\r\n\tstatic long mod = (long) 1e9 + 7;\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n//\t\ttry {\r\n\r\n\t\tFastReader fr = new FastReader();\r\n\t\tPrintWriter pt = new PrintWriter(System.out);\r\n\r\n\t\tint t = 1;\r\n\r\n\t\twhile (t > 0) {\r\n\r\n\t\t\tint n = fr.nextInt(), q = fr.nextInt();\r\n\t\t\tString str = fr.next();\r\n\r\n\t\t\tlong dp[] = new long[n + 1];\r\n\r\n\t\t\tdp[0] = 0;\r\n\r\n\t\t\tfor (int i = 1; i <= str.length(); i++) {\r\n\t\t\t\tdp[i] = dp[i - 1] + ((str.charAt(i - 1) - 'a') + 1);\r\n\t\t\t}\r\n\r\n\t\t\twhile (q > 0) {\r\n\r\n\t\t\t\tint l = fr.nextInt(), r = fr.nextInt();\r\n\t\t\t\tl--;\r\n\r\n\t\t\t\tpt.println(dp[r] - dp[l]);\r\n\r\n\t\t\t\tq--;\r\n\t\t\t}\r\n\r\n\t\t\tt--;\r\n\t\t}\r\n\r\n\t\tpt.close();\r\n\r\n//\t\t} catch (\r\n//\r\n//\t\tException e) {\r\n//\t\t\treturn;\r\n//\t\t}\r\n\t}\r\n\r\n\tstatic int lower_bound(long[] arr, int begin, int end, long tar) {\r\n\t\twhile (begin < end) {\r\n\t\t\tint mid = begin + (end - begin) / 2;\r\n\t\t\tif (arr[mid] < tar)\r\n\t\t\t\tbegin = mid + 1;\r\n\t\t\telse if (arr[mid] >= tar)\r\n\t\t\t\tend = mid;\r\n\t\t}\r\n\t\treturn begin;\r\n//\t\tlower bound gives largest index of a number smaller than (if target is not present) or equal to target(if target is present) \r\n//      for complete array use begin = 0 and end = n\r\n\t}\r\n\r\n\tstatic int upper_bound(long[] arr, int begin, int end, long tar) {\r\n\t\twhile (begin < end) {\r\n\t\t\tint mid = begin + (end - begin) / 2;\r\n\t\t\tif (arr[mid] <= tar)\r\n\t\t\t\tbegin = mid + 1;\r\n\t\t\telse if (arr[mid] > tar)\r\n\t\t\t\tend = mid;\r\n\t\t}\r\n\r\n\t\treturn begin;\r\n//\t\tupper bound gives smallest index of a number strictly greater than target\r\n//\t    for complete array use begin = 0 and end = n\r\n\t}\r\n\r\n\tstatic class Triple implements Comparable<Triple> {\r\n\t\tint a, b, c;\r\n\r\n\t\tTriple(int a, int b, int c) {\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.c = c;\r\n\t\t}\r\n\r\n\t\tpublic int compareTo(Triple o) {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\tif (this.a != o.a)\r\n\t\t\t\treturn Long.compare(this.a, o.a);\r\n\t\t\telse\r\n\t\t\t\treturn Long.compare(this.b, o.b);\r\n\t\t\t// return 0;\r\n\t\t}\r\n\r\n\t\tpublic boolean equals(Object o) {\r\n\t\t\tif (o instanceof Pair) {\r\n\t\t\t\tPair p = (Pair) o;\r\n\t\t\t\treturn p.a == a && p.b == b;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class Pairx<Pairx> {\r\n\r\n\t\tint a;\r\n\t\tString b;\r\n\r\n\t\tPairx(int a, String b) {\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.b = b;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic void merge(long arr[], int l, int m, int r) {\r\n\r\n\t\tint n1 = m - l + 1;\r\n\t\tint n2 = r - m;\r\n\r\n\t\tlong L[] = new long[n1];\r\n\t\tlong R[] = new long[n2];\r\n\r\n\t\tfor (int i = 0; i < n1; ++i)\r\n\t\t\tL[i] = arr[l + i];\r\n\t\tfor (int j = 0; j < n2; ++j)\r\n\t\t\tR[j] = arr[m + 1 + j];\r\n\r\n\t\tint i = 0, j = 0;\r\n\r\n\t\tint k = l;\r\n\t\twhile (i < n1 && j < n2) {\r\n\t\t\tif (L[i] <= R[j]) {\r\n\t\t\t\tarr[k] = L[i];\r\n\t\t\t\ti++;\r\n\t\t\t} else {\r\n\t\t\t\tarr[k] = R[j];\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t\tk++;\r\n\t\t}\r\n\r\n\t\twhile (i < n1) {\r\n\t\t\tarr[k] = L[i];\r\n\t\t\ti++;\r\n\t\t\tk++;\r\n\t\t}\r\n\r\n\t\twhile (j < n2) {\r\n\t\t\tarr[k] = R[j];\r\n\t\t\tj++;\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void sort(long arr[], int l, int r) {\r\n\t\tif (l < r) {\r\n\r\n\t\t\tint m = l + (r - l) / 2;\r\n\r\n\t\t\tsort(arr, l, m);\r\n\t\t\tsort(arr, m + 1, r);\r\n\r\n\t\t\tmerge(arr, l, m, r);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic class Pair implements Comparable<Pair> {\r\n\t\tint a, b;\r\n\r\n\t\tPair(int a, int b) {\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.b = b;\r\n\t\t}\r\n\r\n\t\tpublic int compareTo(Pair o) {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\tif (this.a != o.a)\r\n\t\t\t\treturn Long.compare(this.a, o.a);\r\n\t\t\telse\r\n\t\t\t\treturn Long.compare(this.b, o.b);\r\n\t\t\t// return 0;\r\n\t\t}\r\n\r\n\t\tpublic boolean equals(Object o) {\r\n\t\t\tif (o instanceof Pair) {\r\n\t\t\t\tPair p = (Pair) o;\r\n\t\t\t\treturn p.a == a && p.b == b;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic int binarySearch(long arr[], int first, int last, long key) {\r\n\t\tint mid = (first + last) / 2;\r\n\t\twhile (first <= last) {\r\n\t\t\tif (arr[mid] < key) {\r\n\t\t\t\tfirst = mid + 1;\r\n\t\t\t} else if (arr[mid] == key) {\r\n\t\t\t\treturn mid;\r\n\t\t\t} else {\r\n\t\t\t\tlast = mid - 1;\r\n\t\t\t}\r\n\t\t\tmid = (first + last) / 2;\r\n\t\t}\r\n//\t\treturn -1;\r\n\t\treturn mid;\r\n//\t\treturn mid if want to find key greater than or less than arr[mid] if exact value is not given\r\n\t}\r\n\r\n\tstatic class FastReader {\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\tpublic FastReader() {\r\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t}\r\n\r\n\t\tString next() {\r\n\t\t\twhile (st == null || !st.hasMoreElements()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tint nextInt() {\r\n\t\t\treturn Integer.parseInt(next());\r\n\t\t}\r\n\r\n\t\tlong nextLong() {\r\n\t\t\treturn Long.parseLong(next());\r\n\t\t}\r\n\r\n\t\tdouble nextDouble() {\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tString nextLine() {\r\n\t\t\tString str = \"\";\r\n\t\t\ttry {\r\n\t\t\t\tstr = br.readLine();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t}\r\n\t}\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "//#include<bits/stdc++.h>\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <sstream>\n#include <math.h>\n#include <cstring>\n\n\n#define endl '\\n'\n#define ll long long\n#define fo(i,n) for(i=0;i<n;i++)\n#define rep(i,n) for(i=n-1;i>=0;i--)\n#define mod 1000000007\n\nint gcd(int a,int b){return b==0?a:gcd(b,a%b);}\nint lcm(int a,int b){return ((a*b)/gcd(a,b));}\n\n\n\nusing namespace std;\nll a[5005][5005];\nint main()\n{\n    ll i,j,k,l,m,s,r,n;\n    cin >> n >> m >> k;\n\n    for(i=0;i<k;i++)\n    {\n        cin >> s >> l >> r;\n        if(s==1)\n        {\n            for(j=1;j<=m;j++)\n            {\n                a[l][j]=r;\n            }\n        }\n        else\n        {\n            for(j=1;j<=n;j++)\n            {\n                a[j][l]=r;\n            }\n        }\n\n    }\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=m;j++)\n        {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n",
        "fixed_code": "//#include<bits/stdc++.h>\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <sstream>\n#include <math.h>\n#include <cstring>\n#include <set>\n\n\n\n#define endl '\\n'\n#define ll long long\n#define fo(i,n) for(i=0;i<n;i++)\n#define rep(i,n) for(i=n-1;i>=0;i--)\n/*#define mod 1000000007\n\nusing namespace std;\n\nint a[100005];\n\nint main()\n{\n    int i,j,k,l,m,n,ans=0;\n    cin >> n;\n    for(i=1;i<=n;i++)\n    {\n        cin >> a[i];\n    }\n    for(i=1;i<=n;i++)\n    {\n        ans+=abs(a[i]-a[i-1]);\n        ans+=2;\n\n    }\n    cout << ans-1;\n\n}*/\n\n\nusing namespace std;\n\nll lx[5005],rx[5005];\n\nint main()\n{\n    ll i,j,k,l,m,n,t,bl,rc[5005],lc[5005];\n    cin >> n >> m >> k;\n    for(i=1;i<=k;i++)\n    {\n        cin >> t >> l >> bl;\n        if(t==1)\n        {\n            rx[l]=i;\n\n            rc[l]=bl;\n        }\n        else\n        {\n            lx[l]=i;\n            lc[l]=bl;\n        }\n    }\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=m;j++)\n        {\n            if(lx[j]>rx[i])\n                cout << lc[j] << \" \";\n            else\n                cout << rc[i] << \" \";\n        }\n        cout << endl;\n    }\n\n\n\n}\n\n\n\n\n\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@org.springframework.web.bind.annotation.RequestMapping(value = \"/add\", method = org.springframework.web.bind.annotation.RequestMethod.GET)\npublic org.springframework.web.servlet.ModelAndView addUserPage() {\n    org.springframework.web.servlet.ModelAndView modelAndView = new org.springframework.web.servlet.ModelAndView(\"add-user-form\");\n    modelAndView.addObject(\"user\", new com.model.User());\n    return modelAndView;\n}",
        "fixed_code": "@org.springframework.web.bind.annotation.RequestMapping(value = \"/add\", method = org.springframework.web.bind.annotation.RequestMethod.GET)\npublic org.springframework.web.servlet.ModelAndView addUserPage() {\n    org.springframework.web.servlet.ModelAndView modelAndView = new org.springframework.web.servlet.ModelAndView(\"add-user-form\");\n    modelAndView.addObject(\"user\", new com.model.User());\n    isInitedList = false;\n    return modelAndView;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "// Nov 24, 2020\nimport java.util.*;\nimport java.io.*;\n\npublic class D {\n\tstatic class FastReader {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tprivate FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[] nextIntArrayOne(int n) {\n\t\t\tint[] a = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFastReader s = new FastReader();\n\t\tStringBuilder str = new StringBuilder();\n\n\t\tint t = s.nextInt();\n\n\t\twhile (t-- > 0) {\n\t\t\tlong n = s.nextLong();\n\t\t\tArrayList<Long> primeDivisors = primesDivs(n);\n\t\t\t\n\t\t\tTreeMap<Long,Long> map = new TreeMap<>();\n\t\t\t\n\t\t\tfor(long p : primeDivisors) {\n\t\t\t\tif(map.containsKey(p)) {\n\t\t\t\t\tmap.put(p, map.get(p) + 1);\n\t\t\t\t}else {\n\t\t\t\t\tmap.put(p,1l);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong maxOcc = -1, whose = -1;\n\t\t\t\n\t\t\tfor(Map.Entry<Long, Long> entry : map.entrySet()) {\n\t\t\t\t\n\t\t\t\tif(entry.getValue() > maxOcc) {\n\t\t\t\t\tmaxOcc = entry.getValue();\n\t\t\t\t\twhose = entry.getKey();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(maxOcc == 1) {\n\t\t\t\tstr.append(\"1\\n\");\n\t\t\t\tstr.append(n +\"\\n\");\n\t\t\t}else {\n\t\t\t\tstr.append(maxOcc +\"\\n\");\n\t\t\t\t\n\t\t\t\tfor(int i = 1; i <= maxOcc - 1; i++) {\n\t\t\t\t\tstr.append(whose +\" \");\n\t\t\t\t}\n\t\t\t\tlong c = whose;\n\t\t\t\tfor(long p : primeDivisors) {\n\t\t\t\t\tif(p != whose) {\n\t\t\t\t\t\tc *= p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr.append(c + \"\\n\");\n\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tSystem.out.println(str);\n\t}\n\n\tprivate static ArrayList<Long> primesDivs(long n) {\n\t\tArrayList<Long> divs = new ArrayList<>();\n\t\t\n\t\tlong temp = n;\n\t\tboolean put = true;\n\t\twhile(temp % 2 == 0) {\n\t\t\tdivs.add(2l);\n\t\t\ttemp /= 2;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfor(long i = 3; i * i <= n; i+= 2) {\n\t\t\t\n\t\t\twhile(temp % i == 0) {\n\t\t\t\n\t\t\t\t\tdivs.add(i);\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\ttemp /= i;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tif(temp > 1) {\n\t\t\tdivs.add(n);\n\t\t}\n\t\treturn divs;\n\t}\n\n}\n",
        "fixed_code": "// Nov 24, 2020\nimport java.util.*;\nimport java.io.*;\n\npublic class D {\n\tstatic class FastReader {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tprivate FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[] nextIntArrayOne(int n) {\n\t\t\tint[] a = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFastReader s = new FastReader();\n\t\tStringBuilder str = new StringBuilder();\n\n\t\tint t = s.nextInt();\n\n\t\twhile (t-- > 0) {\n\t\t\tlong n = s.nextLong();\n\t\t\tArrayList<Long> primeDivisors = primesDivs(n);\n\t\t\t\n\t\t\tTreeMap<Long,Long> map = new TreeMap<>();\n\t\t\t\n\t\t\tfor(long p : primeDivisors) {\n\t\t\t\tif(map.containsKey(p)) {\n\t\t\t\t\tmap.put(p, map.get(p) + 1);\n\t\t\t\t}else {\n\t\t\t\t\tmap.put(p,1l);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong maxOcc = -1, whose = -1;\n\t\t\t\n\t\t\tfor(Map.Entry<Long, Long> entry : map.entrySet()) {\n\t\t\t\t\n\t\t\t\tif(entry.getValue() > maxOcc) {\n\t\t\t\t\tmaxOcc = entry.getValue();\n\t\t\t\t\twhose = entry.getKey();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(maxOcc == 1) {\n\t\t\t\tstr.append(\"1\\n\");\n\t\t\t\tstr.append(n +\"\\n\");\n\t\t\t}else {\n\t\t\t\tstr.append(maxOcc +\"\\n\");\n\t\t\t\t\n\t\t\t\tfor(int i = 1; i <= maxOcc - 1; i++) {\n\t\t\t\t\tstr.append(whose +\" \");\n\t\t\t\t}\n\t\t\t\tlong c = whose;\n\t\t\t\tfor(long p : primeDivisors) {\n\t\t\t\t\tif(p != whose) {\n\t\t\t\t\t\tc *= p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr.append(c + \"\\n\");\n\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tSystem.out.println(str);\n\t}\n\n\tprivate static ArrayList<Long> primesDivs(long n) {\n\t\tArrayList<Long> divs = new ArrayList<>();\n\t\t\n\t\tlong temp = n;\n\t\tboolean put = true;\n\t\twhile(temp % 2 == 0) {\n\t\t\tdivs.add(2l);\n\t\t\ttemp /= 2;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfor(long i = 3; i * i <= n; i+= 2) {\n\t\t\t\n\t\t\twhile(temp % i == 0) {\n\t\t\t\n\t\t\t\t\tdivs.add(i);\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\ttemp /= i;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tif(temp > 1) {\n\t\t\tdivs.add(temp);\n\t\t}\n\t\treturn divs;\n\t}\n\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "private void processDiseases() throws java.lang.Exception {\n    logger.info(\"loading disease terms\");\n    java.lang.String diseaseTermQuery = \"select t.term_key, t.term, t.primary_id, a.marker_key, \" + ((((\"  a.genotype_key, a.organism_key, a.hdp_annotation_key \" + \"from term t \") + \"left outer join hdp_annotation a on (t.term_key = a.term_key) \") + \"where t.vocab_name = 'OMIM' \") + \"  and t.is_obsolete = 0\");\n    java.sql.ResultSet rs = ex.executeProto(diseaseTermQuery, cursorLimit);\n    logger.debug((\"  - finished disease query in \" + (ex.getTimestamp())));\n    java.util.Collection<org.apache.solr.common.SolrInputDocument> docs = new java.util.ArrayList<org.apache.solr.common.SolrInputDocument>();\n    while (rs.next()) {\n        uniqueKey += 1;\n        java.lang.Integer termKey = rs.getInt(\"term_key\");\n        java.lang.String term = rs.getString(\"term\");\n        java.lang.String termId = rs.getString(\"primary_id\");\n        java.lang.Integer markerKey = rs.getInt(\"marker_key\");\n        java.lang.Integer organismKey = rs.getInt(\"organism_key\");\n        java.lang.Integer annotationKey = rs.getInt(\"hdp_annotation_key\");\n        org.jax.mgi.shr.DistinctSolrInputDocument doc = new org.jax.mgi.shr.DistinctSolrInputDocument();\n        doc.addField(DiseasePortalFields.UNIQUE_KEY, uniqueKey);\n        doc.addField(DiseasePortalFields.TERM, term);\n        doc.addField(DiseasePortalFields.TERM_ID, termId);\n        doc.addField(DiseasePortalFields.TERM_TYPE, omim);\n        org.jax.mgi.indexer.BSU bsu = null;\n        if (organismKey == 1) {\n            bsu = this.getMouseBsu(getGenocluster(rs.getInt(\"genotype_key\")), getGridClusterKey(markerKey));\n        }else\n            if (organismKey == 2) {\n                bsu = getHumanBsu(markerKey, termKey);\n            }\n        \n        if (bsu != null) {\n            doc.addField(DiseasePortalFields.GRID_KEY, bsu.bsuKey);\n        }\n        if ((markerKey == null) || (isHuman(markerKey))) {\n            addHpoData(doc, termKey);\n        }\n        int termSort = getTermSequenceNum(term);\n        doc.addField(DiseasePortalFields.BY_TERM_NAME, termSort);\n        addAllFromLookup(doc, DiseasePortalFields.TERM_SYNONYM, termId, termSynonymMap);\n        addAll(doc, DiseasePortalFields.TERM_ALT_ID, getAlternateTermIds(termId));\n        if (headersPerTerm.containsKey(termId)) {\n            addAllFromLookup(doc, DiseasePortalFields.TERM_HEADER, termId, headersPerTerm);\n        }else {\n            doc.addField(DiseasePortalFields.TERM_HEADER, term);\n        }\n        doc.addField(DiseasePortalFields.DISEASE_REF_COUNT, getDiseaseReferenceCount(termId));\n        doc.addField(DiseasePortalFields.DISEASE_MODEL_COUNTS, getDiseaseModelCount(termId));\n        addAll(doc, DiseasePortalFields.MP_TERM_FOR_DISEASE_TEXT, getRelatedPhenotypes(annotationKey, true, false));\n        addAll(doc, DiseasePortalFields.MP_TERM_FOR_DISEASE_ID, getRelatedPhenotypes(annotationKey, false, true));\n        addAll(doc, DiseasePortalFields.OMIM_TERM_FOR_DISEASE_TEXT, getRelatedDiseases(annotationKey, true, false));\n        addAll(doc, DiseasePortalFields.OMIM_TERM_FOR_DISEASE_ID, getRelatedDiseases(annotationKey, false, true));\n        if (markerKey != null) {\n            java.util.Set<java.lang.String> featureTypes = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> markerSynonyms = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologNomen = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologSymbols = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologSynonyms = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologIds = new java.util.HashSet<java.lang.String>();\n            java.lang.String markerSymbol = getMarkerSymbol(markerKey);\n            java.lang.Integer gridClusterKey = getGridClusterKey(markerKey);\n            doc.addField(DiseasePortalFields.MARKER_KEY, markerKey);\n            addIfNotNull(doc, DiseasePortalFields.MARKER_SYMBOL, markerSymbol);\n            addIfNotNull(doc, DiseasePortalFields.MARKER_NAME, getMarkerName(markerKey));\n            addIfNotNull(doc, DiseasePortalFields.MARKER_MGI_ID, getMarkerID(markerKey));\n            if (markerSynonymMap.containsKey(markerKey.toString())) {\n                markerSynonyms.addAll(markerSynonymMap.get(markerKey.toString()));\n            }\n            addAll(doc, DiseasePortalFields.MARKER_ID, getMarkerIds(markerKey));\n            if (gridClusterKey != null) {\n                java.lang.String gckString = gridClusterKey.toString();\n                doc.addField(DiseasePortalFields.GRID_CLUSTER_KEY, gckString);\n                if (featureTypeMap.containsKey(gckString)) {\n                    featureTypes.addAll(featureTypeMap.get(gckString));\n                }\n            }else {\n                java.util.Set<java.lang.String> mFeatureTypes = getMarkerFeatureTypes(markerKey);\n                if (mFeatureTypes != null) {\n                    featureTypes.addAll(mFeatureTypes);\n                }\n            }\n            this.addMarkerCoordinates(doc, markerKey, true);\n            java.util.Set<java.lang.String> markerKeys = getMarkersByDisease(termId);\n            if (markerKeys != null) {\n                for (java.lang.String stringMarkerKey : markerKeys) {\n                    java.lang.Integer mkey = java.lang.Integer.parseInt(stringMarkerKey);\n                    java.lang.String msymbol = getMarkerSymbol(mkey);\n                    if (isHuman(mkey)) {\n                        doc.addField(DiseasePortalFields.TERM_HUMANSYMBOL, msymbol);\n                    }else {\n                        doc.addField(DiseasePortalFields.TERM_MOUSESYMBOL, msymbol);\n                    }\n                }\n            }\n            java.util.Set<java.lang.Integer> orthologousMarkerKeys = getMarkerOrthologs(markerKey);\n            if (orthologousMarkerKeys != null) {\n                for (java.lang.Integer orthoMarkerKey : orthologousMarkerKeys) {\n                    java.lang.String orthoSymbol = getMarkerSymbol(orthoMarkerKey);\n                    java.lang.String orthoName = getMarkerName(orthoMarkerKey);\n                    java.util.Set<java.lang.String> orthoIds = getMarkerIds(orthoMarkerKey);\n                    java.util.Set<java.lang.String> orthoSynonyms = getMarkerSynonyms(orthoMarkerKey);\n                    if (orthoSymbol != null) {\n                        orthologSymbols.add(orthoSymbol);\n                    }\n                    if (orthoName != null) {\n                        orthologNomen.add(orthoName);\n                    }\n                    if (orthoSynonyms != null) {\n                        orthologSynonyms.addAll(orthoSynonyms);\n                    }\n                    if (orthoIds != null) {\n                        orthologIds.addAll(orthoIds);\n                    }\n                }\n            }\n            if ((featureTypes.size()) > 0) {\n                addAll(doc, DiseasePortalFields.FILTERABLE_FEATURE_TYPES, featureTypes);\n            }\n            if ((markerSynonyms.size()) > 0) {\n                addAll(doc, DiseasePortalFields.MARKER_SYNONYM, markerSynonyms);\n                addAll(doc, DiseasePortalFields.MARKER_SYNONYM_SINGLE_TOKEN, getMarkerSingleTokenSynonyms(markerKey));\n            }\n            if ((orthologNomen.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_NOMEN, orthologNomen);\n            }\n            if ((orthologSymbols.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_SYMBOL, orthologSymbols);\n            }\n            if ((orthologSynonyms.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_SYNONYM, orthologSynonyms);\n            }\n            if ((orthologIds.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_ID, orthologIds);\n            }\n            addExpressedComponents(doc, markerKey);\n        }\n        docs.add(doc);\n        if ((docs.size()) >= (solrBatchSize)) {\n            writeDocs(docs);\n            docs = new java.util.ArrayList<org.apache.solr.common.SolrInputDocument>();\n        }\n    } \n    writeDocs(docs);\n    commit();\n    rs.close();\n    logger.info(((\"done processing \" + (uniqueKey)) + \" disease terms\"));\n}",
        "fixed_code": "private void processDiseases() throws java.lang.Exception {\n    logger.info(\"loading disease terms\");\n    java.lang.String diseaseTermQuery = \"select t.term_key, t.term, t.primary_id, a.marker_key, \" + ((((\"  a.genotype_key, a.organism_key, a.hdp_annotation_key \" + \"from term t \") + \"left outer join hdp_annotation a on (t.term_key = a.term_key) \") + \"where t.vocab_name = 'OMIM' \") + \"  and t.is_obsolete = 0\");\n    java.sql.ResultSet rs = ex.executeProto(diseaseTermQuery, cursorLimit);\n    logger.debug((\"  - finished disease query in \" + (ex.getTimestamp())));\n    java.util.Collection<org.apache.solr.common.SolrInputDocument> docs = new java.util.ArrayList<org.apache.solr.common.SolrInputDocument>();\n    while (rs.next()) {\n        uniqueKey += 1;\n        java.lang.Integer termKey = rs.getInt(\"term_key\");\n        java.lang.String term = rs.getString(\"term\");\n        java.lang.String termId = rs.getString(\"primary_id\");\n        java.lang.Integer markerKey = rs.getInt(\"marker_key\");\n        java.lang.Integer organismKey = rs.getInt(\"organism_key\");\n        java.lang.Integer annotationKey = rs.getInt(\"hdp_annotation_key\");\n        org.jax.mgi.shr.DistinctSolrInputDocument doc = new org.jax.mgi.shr.DistinctSolrInputDocument();\n        doc.addField(DiseasePortalFields.UNIQUE_KEY, uniqueKey);\n        doc.addField(DiseasePortalFields.TERM, term);\n        doc.addField(DiseasePortalFields.TERM_ID, termId);\n        doc.addField(DiseasePortalFields.TERM_TYPE, omim);\n        org.jax.mgi.indexer.BSU bsu = null;\n        if (organismKey == 1) {\n            bsu = this.getMouseBsu(getGenocluster(rs.getInt(\"genotype_key\")), getGridClusterKey(markerKey));\n        }else\n            if (organismKey == 2) {\n                bsu = getHumanBsu(markerKey, termKey);\n            }\n        \n        if (bsu != null) {\n            doc.addField(DiseasePortalFields.GRID_KEY, bsu.bsuKey);\n        }\n        if ((markerKey == null) || (isHuman(markerKey))) {\n            addHpoData(doc, termKey);\n        }\n        int termSort = getTermSequenceNum(term);\n        doc.addField(DiseasePortalFields.BY_TERM_NAME, termSort);\n        addAllFromLookup(doc, DiseasePortalFields.TERM_SYNONYM, termId, termSynonymMap);\n        addAll(doc, DiseasePortalFields.TERM_ALT_ID, getAlternateTermIds(termId));\n        if (headersPerTerm.containsKey(termId)) {\n            addAllFromLookup(doc, DiseasePortalFields.TERM_HEADER, termId, headersPerTerm);\n        }else {\n            doc.addField(DiseasePortalFields.TERM_HEADER, term);\n        }\n        doc.addField(DiseasePortalFields.DISEASE_REF_COUNT, getDiseaseReferenceCount(termId));\n        doc.addField(DiseasePortalFields.DISEASE_MODEL_COUNTS, getDiseaseModelCount(termId));\n        addAll(doc, DiseasePortalFields.MP_TERM_FOR_DISEASE_TEXT, getRelatedPhenotypes(annotationKey, true, false));\n        addAll(doc, DiseasePortalFields.MP_TERM_FOR_DISEASE_ID, getRelatedPhenotypes(annotationKey, false, true));\n        addAll(doc, DiseasePortalFields.OMIM_TERM_FOR_DISEASE_TEXT, getRelatedDiseases(annotationKey, true, false));\n        addAll(doc, DiseasePortalFields.OMIM_TERM_FOR_DISEASE_ID, getRelatedDiseases(annotationKey, false, true));\n        if (markerKey != null) {\n            java.util.Set<java.lang.String> featureTypes = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> markerSynonyms = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologNomen = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologSymbols = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologSynonyms = new java.util.HashSet<java.lang.String>();\n            java.util.Set<java.lang.String> orthologIds = new java.util.HashSet<java.lang.String>();\n            java.lang.String markerSymbol = getMarkerSymbol(markerKey);\n            java.lang.Integer gridClusterKey = getGridClusterKey(markerKey);\n            doc.addField(DiseasePortalFields.MARKER_KEY, markerKey);\n            addIfNotNull(doc, DiseasePortalFields.MARKER_SYMBOL, markerSymbol);\n            addIfNotNull(doc, DiseasePortalFields.MARKER_NAME, getMarkerName(markerKey));\n            addIfNotNull(doc, DiseasePortalFields.MARKER_MGI_ID, getMarkerID(markerKey));\n            if (markerSynonymMap.containsKey(markerKey.toString())) {\n                markerSynonyms.addAll(markerSynonymMap.get(markerKey.toString()));\n            }\n            addAll(doc, DiseasePortalFields.MARKER_ID, getMarkerIds(markerKey));\n            if (gridClusterKey != null) {\n                java.lang.String gckString = gridClusterKey.toString();\n                doc.addField(DiseasePortalFields.GRID_CLUSTER_KEY, gckString);\n                if (featureTypeMap.containsKey(gckString)) {\n                    featureTypes.addAll(featureTypeMap.get(gckString));\n                }\n            }else {\n                java.util.Set<java.lang.String> mFeatureTypes = getMarkerFeatureTypes(markerKey);\n                if (mFeatureTypes != null) {\n                    featureTypes.addAll(mFeatureTypes);\n                }\n            }\n            this.addMarkerCoordinates(doc, markerKey, true);\n            java.util.Set<java.lang.String> markerKeys = getMarkersByDisease(termId);\n            if (markerKeys != null) {\n                for (java.lang.String stringMarkerKey : markerKeys) {\n                    java.lang.Integer mkey = java.lang.Integer.parseInt(stringMarkerKey);\n                    java.lang.String msymbol = getMarkerSymbol(mkey);\n                    if (isHuman(mkey)) {\n                        doc.addField(DiseasePortalFields.TERM_HUMANSYMBOL, msymbol);\n                    }else {\n                        doc.addField(DiseasePortalFields.TERM_MOUSESYMBOL, msymbol);\n                    }\n                }\n            }\n            java.util.Set<java.lang.Integer> orthologousMarkerKeys = getMarkerOrthologs(markerKey);\n            if (orthologousMarkerKeys != null) {\n                for (java.lang.Integer orthoMarkerKey : orthologousMarkerKeys) {\n                    java.lang.String orthoSymbol = getMarkerSymbol(orthoMarkerKey);\n                    java.lang.String orthoName = getMarkerName(orthoMarkerKey);\n                    java.util.Set<java.lang.String> orthoIds = getMarkerIds(orthoMarkerKey);\n                    java.util.Set<java.lang.String> orthoSynonyms = getMarkerSynonyms(orthoMarkerKey);\n                    if (orthoSymbol != null) {\n                        orthologSymbols.add(orthoSymbol);\n                    }\n                    if (orthoName != null) {\n                        orthologNomen.add(orthoName);\n                    }\n                    if (orthoSynonyms != null) {\n                        orthologSynonyms.addAll(orthoSynonyms);\n                    }\n                    if (orthoIds != null) {\n                        orthologIds.addAll(orthoIds);\n                    }\n                }\n            }\n            if ((featureTypes.size()) > 0) {\n                addAll(doc, DiseasePortalFields.FILTERABLE_FEATURE_TYPES, featureTypes);\n            }\n            if ((markerSynonyms.size()) > 0) {\n                addAll(doc, DiseasePortalFields.MARKER_SYNONYM, markerSynonyms);\n                addAll(doc, DiseasePortalFields.MARKER_SYNONYM_SINGLE_TOKEN, getMarkerSingleTokenSynonyms(markerKey, true));\n            }\n            if ((orthologNomen.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_NOMEN, orthologNomen);\n            }\n            if ((orthologSymbols.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_SYMBOL, orthologSymbols);\n            }\n            if ((orthologSynonyms.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_SYNONYM, orthologSynonyms);\n            }\n            if ((orthologIds.size()) > 0) {\n                addAll(doc, DiseasePortalFields.ORTHOLOG_ID, orthologIds);\n            }\n            addExpressedComponents(doc, markerKey);\n        }\n        docs.add(doc);\n        if ((docs.size()) >= (solrBatchSize)) {\n            writeDocs(docs);\n            docs = new java.util.ArrayList<org.apache.solr.common.SolrInputDocument>();\n        }\n    } \n    writeDocs(docs);\n    commit();\n    rs.close();\n    logger.info(((\"done processing \" + (uniqueKey)) + \" disease terms\"));\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Euler {\n\t\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tPrintWriter o = new PrintWriter(System.out);\n\t\t\n\t\tint n = in.nextInt();\n\t\tlong[] ar = new long[n];\n\t\tfor (int i = 0; i < n; i++) ar[i] = in.nextLong();\n\t\t\n\t\tArrays.sort(ar);\n\t\t\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += ar[i] - 1;\n\t\t}\n\t\t\n\t\tfor (int i = 2; i < 1e5; i++) {\n\t\t\tlong cr = 0;\n\t\t\tlong x = 1;\n\t\t\t\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcr += Math.abs(x - ar[0]);\n\t\t\t\tx *= i;\n\t\t\t\tif (cr > ans) break;\n\t\t\t}\n\t\t\tans = Math.min(cr, ans);\n\t\t}\n\t\to.println(ans);\n\t\t\n\t\t\n\t\t\n\t\to.close();\n        o.flush();\n        return;\n        \n\t}\n\t\n\t\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n \n}\n",
        "fixed_code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Euler {\n\t\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tPrintWriter o = new PrintWriter(System.out);\n\t\t\n\t\tint n = in.nextInt();\n\t\tlong[] ar = new long[n];\n\t\tfor (int i = 0; i < n; i++) ar[i] = in.nextLong();\n\t\t\n\t\tArrays.sort(ar);\n\t\t\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += ar[i] - 1;\n\t\t}\n\t\t\n\t\tfor (int i = 2; i < 1e5; i++) {\n\t\t\tlong cr = 0;\n\t\t\tlong x = 1;\n\t\t\t\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcr += Math.abs(x - ar[j]);\n\t\t\t\tx *= i;\n\t\t\t\tif (cr > ans) break;\n\t\t\t}\n\t\t\tans = Math.min(cr, ans);\n\t\t}\n\t\to.println(ans);\n\t\t\n\t\t\n\t\t\n\t\to.close();\n        o.flush();\n        return;\n        \n\t}\n\t\n\t\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n \n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "@org.junit.Test\npublic void testBRCorner() {\n    clueGame.BoardCell cell = board.getCellAt(3, 3);\n    java.util.LinkedList<clueGame.BoardCell> testList = board.getAdjList(cell);\n    assertTrue(testList.contains(board.getCellAt(2, 3)));\n    assertEquals(1, testList.size());\n}",
        "fixed_code": "@org.junit.Test\npublic void testBRCorner() {\n    clueGame.BoardCell cell = board.getCellAt(25, 12);\n    java.util.LinkedList<clueGame.BoardCell> testList = board.getAdjList(cell);\n    assertTrue(testList.contains(board.getCellAt(24, 12)));\n    assertTrue(testList.contains(board.getCellAt(25, 11)));\n    assertEquals(1, testList.size());\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\n#define ll long long\r\n#define ls u<<1\r\n#define rs u<<1|1\r\n#define mm(x) memset(x,0,sizeof(x))\r\n#define debug(x) cout << #x << \":\" << x << '\\n'\r\nusing namespace std;\r\nint read()\r\n{\r\n    int a=0;int f=0;char p=getchar();\r\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\r\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\r\n    return f?-a:a;\r\n}\r\nconst int INF=998244353;\r\nint T;\r\nint n,m;\r\nchar s[1000050];\r\nll val[1000050];\r\nint t[1000050],top;\r\nint head[1000050];\r\nint nex[1000050];\r\nint ver[1000050];\r\nint tot;\r\n\r\nint fa[1000050];\r\nint son[1000050];\r\nint pos[1000050];\r\nset<int >v[1000050];\r\nbool vis[1000050];\r\nint rnk[1000050];\r\nstruct TR\r\n{\r\n\tll sum[2000050];\r\n\tvoid modify(int u,int l,int r,int POS,ll VAL)\r\n\t{\r\n\t\tsum[u]+=VAL;\r\n\t\tif(l==r)\treturn ;\r\n\t\tint mid=(l+r)>>1;\r\n\t\tif(POS<=mid)\tmodify(ls,l,mid,POS,VAL);\r\n\t\telse\tmodify(rs,mid+1,r,POS,VAL);\r\n\t}\r\n\tll query(int u,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\treturn sum[u];\r\n\t\tll sum=0;\tint mid=(l+r)>>1;\r\n\t\tif(L<=mid)\tsum+=query(ls,l,mid,L,R);\r\n\t\tif(R>mid)\tsum+=query(rs,mid+1,r,L,R);\r\n\t\treturn sum;\r\n\t}\r\n}T1,T2;\r\nvoid add(int x,int y)\r\n{\r\n\t++tot;\r\n\tnex[tot]=head[x];\r\n\thead[x]=tot;\r\n\tver[tot]=y;\r\n\tfa[y]=x;\r\n\tv[x].insert(y);\r\n}\r\nll C(int n,int m=2)\r\n{\r\n\tif(n==0)\treturn 0;\r\n\treturn (ll)n*(n-1)/2;\r\n}\r\nvoid dfs(int u)\r\n{\r\n\tset<int >::iterator it;\r\n\tfor(it=v[u].begin();it!=v[u].end();it++)\r\n\t{\r\n\t\tint v=*it;\r\n\t\tson[u]++;\r\n\t\tdfs(v);\r\n\t}\r\n\tval[u]=C(son[u])+1;\r\n\tif(u)\tT1.modify(1,1,n,u,val[u]);\r\n}\r\nvoid del(int u)\r\n{\r\n\tvis[u]=true;\r\n\tset<int >::iterator it;\r\n\tfor(it=v[u].begin();it!=v[u].end();it++)\r\n\t{\r\n\t\tint v=*it;\r\n\t\tdel(v);\r\n\t}\r\n\tT1.modify(1,1,n,u,-val[u]);\r\n\tT2.modify(1,1,n,rnk[u],-1);\r\n}\r\nint main()\r\n{\r\n\tn=read();\tm=read();\tscanf(\"%s\",s+1);\r\n\tfor(int i=1;i<=n;++i)\r\n\t{\r\n\t\tif(s[i]=='(')\r\n\t\t{\r\n\t\t\tt[++top]=i;\r\n\t\t\tadd(t[top-1],t[top]);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpos[t[top]]=i;\r\n\t\t\tpos[i]=t[top];\r\n\t\t\tif(top)\ttop--;\r\n\t\t}\r\n\t}\r\n\tint l=0;\tint r=0;\r\n\twhile(l<=r)\r\n\t{\r\n\t\tint u=t[l];\tl++;\r\n\t\tset<int >::iterator it;\r\n\t\tfor(it=v[u].begin();it!=v[u].end();it++)\r\n\t\t{\r\n\t\t\tint v=*it;\r\n\t\t\tt[++r]=v;\r\n\t\t\trnk[v]=r;\r\n\t\t\tT2.modify(1,1,n,rnk[v],1);\r\n\t\t}\r\n\t}\r\n\tdfs(0);\r\n\twhile(m--)\r\n\t{\r\n\t\tint qwq=read();\r\n\t\tint l=read();\r\n\t\tint r=read();\r\n\t\tif(qwq==1)\r\n\t\t{\r\n\t\t\tint L=l;\tint R=pos[L];\r\n\t\t\twhile(true)\r\n\t\t\t{\r\n\t\t\t\tif(!vis[L])\r\n\t\t\t\t{\r\n\t\t\t\t\tdel(L);\r\n\t\t\t\t\tif(fa[L])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint FA=fa[L];\r\n\t\t\t\t\t\tv[FA].erase(L);\r\n\t\t\t\t\t\tson[FA]--;\r\n\t\t\t\t\t\tT1.modify(1,1,n,FA,-son[FA]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(R==r)\tbreak;\r\n\t\t\t\tL=R+1;\tR=pos[L];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tll ans=T1.query(1,1,n,l,r);\r\n\t\t\tint cnt=T2.query(1,1,n,rnk[l],rnk[pos[r]]);\r\n\t\t\tans+=C(cnt);\r\n\t\t\tprintf(\"%lld\\n\",ans);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n",
        "fixed_code": "#include<bits/stdc++.h>\r\n#define ll long long\r\n#define ls u<<1\r\n#define rs u<<1|1\r\n#define mm(x) memset(x,0,sizeof(x))\r\n#define debug(x) cout << #x << \":\" << x << '\\n'\r\nusing namespace std;\r\nint read()\r\n{\r\n    int a=0;int f=0;char p=getchar();\r\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\r\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\r\n    return f?-a:a;\r\n}\r\nconst int INF=998244353;\r\nint T;\r\nint n,m;\r\nchar s[1000050];\r\nll val[1000050];\r\nint t[1000050],top;\r\nint head[1000050];\r\nint nex[1000050];\r\nint ver[1000050];\r\nint tot;\r\n\r\nint fa[1000050];\r\nint son[1000050];\r\nint pos[1000050];\r\nset<int >v[1000050];\r\nbool vis[1000050];\r\nint rnk[1000050];\r\nstruct TR\r\n{\r\n\tll sum[2000050];\r\n\tvoid modify(int u,int l,int r,int POS,ll VAL)\r\n\t{\r\n\t\tsum[u]+=VAL;\r\n\t\tif(l==r)\treturn ;\r\n\t\tint mid=(l+r)>>1;\r\n\t\tif(POS<=mid)\tmodify(ls,l,mid,POS,VAL);\r\n\t\telse\tmodify(rs,mid+1,r,POS,VAL);\r\n\t}\r\n\tll query(int u,int l,int r,int L,int R)\r\n\t{\r\n\t\tif(L<=l&&r<=R)\treturn sum[u];\r\n\t\tll sum=0;\tint mid=(l+r)>>1;\r\n\t\tif(L<=mid)\tsum+=query(ls,l,mid,L,R);\r\n\t\tif(R>mid)\tsum+=query(rs,mid+1,r,L,R);\r\n\t\treturn sum;\r\n\t}\r\n}T1,T2;\r\nvoid add(int x,int y)\r\n{\r\n\t++tot;\r\n\tnex[tot]=head[x];\r\n\thead[x]=tot;\r\n\tver[tot]=y;\r\n\tfa[y]=x;\r\n\tv[x].insert(y);\r\n}\r\nll C(int n,int m=2)\r\n{\r\n\tif(n==0)\treturn 0;\r\n\treturn (ll)n*(n-1)/2;\r\n}\r\nvoid dfs(int u)\r\n{\r\n\tset<int >::iterator it;\r\n\tfor(it=v[u].begin();it!=v[u].end();it++)\r\n\t{\r\n\t\tint v=*it;\r\n\t\tson[u]++;\r\n\t\tdfs(v);\r\n\t}\r\n\tval[u]=C(son[u])+1;\r\n\tif(u)\tT1.modify(1,1,n,u,val[u]);\r\n}\r\nvoid del(int u)\r\n{\r\n\tvis[u]=true;\r\n\tset<int >::iterator it;\r\n\tfor(it=v[u].begin();it!=v[u].end();it++)\r\n\t{\r\n\t\tint v=*it;\r\n\t\tdel(v);\r\n\t}\r\n\tT1.modify(1,1,n,u,-val[u]);\r\n\tT2.modify(1,1,n,rnk[u],-1);\r\n}\r\nint main()\r\n{\r\n\tn=read();\tm=read();\tscanf(\"%s\",s+1);\r\n\tfor(int i=1;i<=n;++i)\r\n\t{\r\n\t\tif(s[i]=='(')\r\n\t\t{\r\n\t\t\tt[++top]=i;\r\n\t\t\tadd(t[top-1],t[top]);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpos[t[top]]=i;\r\n\t\t\tpos[i]=t[top];\r\n\t\t\tif(top)\ttop--;\r\n\t\t}\r\n\t}\r\n\tint l=0;\tint r=0;\r\n\twhile(l<=r)\r\n\t{\r\n\t\tint u=t[l];\tl++;\r\n\t\tset<int >::iterator it;\r\n\t\tfor(it=v[u].begin();it!=v[u].end();it++)\r\n\t\t{\r\n\t\t\tint v=*it;\r\n\t\t\tt[++r]=v;\r\n\t\t\trnk[v]=r;\r\n\t\t\tT2.modify(1,1,n,rnk[v],1);\r\n\t\t}\r\n\t}\r\n\tdfs(0);\r\n\twhile(m--)\r\n\t{\r\n\t\tint qwq=read();\r\n\t\tint l=read();\r\n\t\tint r=read();\r\n\t\tif(qwq==1)\r\n\t\t{\r\n\t\t\tint L=l;\tint R=pos[L];\r\n\t\t\twhile(true)\r\n\t\t\t{\r\n\t\t\t\tif(!vis[L])\r\n\t\t\t\t{\r\n\t\t\t\t\tdel(L);\r\n\t\t\t\t\tif(fa[L])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint FA=fa[L];\r\n\t\t\t\t\t\tv[FA].erase(L);\r\n\t\t\t\t\t\tson[FA]--;\r\n\t\t\t\t\t\tval[FA]=C(son[FA])+1;\r\n\t\t\t\t\t\tT1.modify(1,1,n,FA,-son[FA]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(R==r)\tbreak;\r\n\t\t\t\tL=R+1;\tR=pos[L];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tll ans=T1.query(1,1,n,l,r);\r\n\t\t\tint cnt=T2.query(1,1,n,rnk[l],rnk[pos[r]]);\r\n\t\t\tans+=C(cnt);\r\n\t\t\tprintf(\"%lld\\n\",ans);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\n/*\n\tExecution time on G4G:\n\n\tCorrectness:\n\n\tTime complexity:\n\n\tSpace complexity:\n\n*/\n\nint fenwick_sum(std::vector<int> B, int i){\n\tint sum {};\n\twhile(i != 0){\n\t\tsum += B[i];\n\t\ti -= i & -i;\n\t}\n\treturn sum;\n}\n\nvoid fenwick_update(std::vector<int> &B, int i, int v){\n\twhile(i < B.size()){\n\t\tB[i] += v;\n\t\ti += i & -i;\n\t}\n}\n\n\nint main() {\n\tint n {};\n\tint x {};\n\tstd::vector<int> vec;\n    std::unordered_map<int, int> map;\n\n\t//collect data\n    cin >> n;\n    vec.reserve(n);\n\tmap.reserve(n);\n\tfor (int i {}; i < n; ++i) {\n\t\tscanf(\"%d\", &x);\n\t\tvec.push_back(x);\n\t}\n\n\t//create prefix counter array\n\t//P[i] = f(1, i, a_i)\n\n\tstd::vector<int> P;\n\tfor(auto it = vec.begin(); it <vec.end(); ++it){\n\t\tP.push_back(++map[*it]);\n\t}\n\tmap.clear();\n\n\t//create suffix counter array\n\t//S[j] = f(j, n, a_j)\n\tstd::vector<int> S(n);\n\tfor(auto it = vec.rbegin(); it <vec.rend(); ++it)\n\t\tS.push_back(++map[*it]);\n\n\t//scans P backward, for each possible i\n\t//counts the possible js.\n\tstd::vector<int> BIT(vec.size()+1);\n\tint result {};\n\tfor(int  i=n-1; i>=0; --i){\n\t\tresult += fenwick_sum(BIT, P[i]-1);\n\t\tfenwick_update(BIT, S[S.size() - i], 1);\n\t}\n\tcout<<result;\n\n\n\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\n/*\n\tExecution time on G4G:\n\n\tCorrectness:\n\n\tTime complexity:\n\n\tSpace complexity:\n\n*/\n\ntemplate<class T> T fenwick_sum(std::vector<T>& B, int i){\n\tT sum {};\n\twhile(i != 0){\n\t\tsum += B[i];\n\t\ti -= i & -i;\n\t}\n\treturn sum;\n}\n\ntemplate<class T> void fenwick_update(std::vector<T> &B, int i, int v){\n\twhile(i < B.size()){\n\t\tB[i] += v;\n\t\ti += i & -i;\n\t}\n}\n\n\nint main() {\n\tsize_t n {};\n\tuint64_t x {};\n\tstd::vector<int> vec;\n    std::unordered_map<int, int> map;\n\n\t//collect data\n    cin >> n;\n    vec.reserve(n);\n\tmap.reserve(n);\n\tfor (size_t i {}; i < n; ++i) {\n\t\tscanf(\"%d\", &x);\n\t\tvec.push_back(x);\n\t}\n\n\t//create prefix counter array\n\t//P[i] = f(1, i, a_i)\n\tuint64_t max {};\n\tstd::vector<uint64_t> P;\n\tfor(auto it = vec.begin(); it <vec.end(); ++it){\n\t\tauto value = ++map[*it];\n\t\tP.push_back(value);\n\t\tmax = (max < value)?value:max;\n\t}\n\tmap.clear();\n\n\t//create suffix counter array\n\t//S[j] = f(j, n, a_j)\n\tstd::deque<uint64_t> S(n);\n\tfor(auto it = vec.rbegin(); it <vec.rend(); ++it)\n\t\tS.push_front(++map[*it]);\n\n\t//scans P backward, for each possible i\n\t//counts the possible js.\n\tstd::vector<uint64_t> BIT(max);\n\tuint64_t result {};\n\tfor(int  i=n-1; i>=0; --i){\n\t\tresult += fenwick_sum(BIT, P[i]-1);\n\t\tfenwick_update(BIT, S[i], 1);\n\t}\n\tcout<<result;\n\n\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    ll n;\n    string a, b;\n    cin >> n >> a >> b;\n\n    ll l = 0;\n    while( l < n && a[l] == b[l])\n        l++;\n\n    ll r = n-1;\n    while (r >= 0 && a[r] == b[r])\n        r--;\n    if(l == r){\n        cout << 2;\n    }else{\n        if(a[l] == b[r])\n            swap(a,b);\n        string as = string (a.begin()+l+1, a.begin()+r+1);\n        string bs = string (b.begin()+l, b.begin()+r);\n        if(as == bs){\n            if(l == r-1 && a[l] == b[l+1] && a[l+1] == b[l])\n                cout << 2;\n            else\n                cout << 1;\n        }else{\n            cout << 0;\n        }\n    }\n\n\n\n\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    ll n;\n    string a, b;\n    cin >> n >> a >> b;\n\n    ll l = 0;\n    while( l < n && a[l] == b[l])\n        l++;\n\n    ll r = n-1;\n    while (r >= 0 && a[r] == b[r])\n        r--;\n    if(l == r){\n        cout << 2;\n    }else{\n        ll cnt = 0;\n        string as = string (a.begin()+l+1, a.begin()+r+1);\n        string bs = string (b.begin()+l, b.begin()+r);\n        if(as == bs)\n            cnt++;\n        swap(a, b);\n        as = string (a.begin()+l+1, a.begin()+r+1);\n        bs = string (b.begin()+l, b.begin()+r);\n        if(as == bs)\n            cnt++;\n        cout << cnt;\n    }\n\n\n\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint w;\n\tint id;\n\n\tbool operator< (const Edge& a) const { \n\t\treturn (w>a.w);\n\t}\n};\n\nint root;\nvector<int> depths;\nvector< vector<int> > par;\nvector< vector<int> > prop;\nvector< vector<Edge> > adj;\nconst int NN = 18;\n\nusing ll = long long;\nvector<ll> scores;\nll min_score;\n\nint get_ancestor(int a, int depth) {\n\tint d = depths[a] - depth;\n\tint res = a;\n\tfor(int i=0; i<NN; ++i) if(d & (1<<i)){\n\t\tres = par[res][i];\n\t}\n\treturn res;\n}\n\nint lca(int a, int b) {\n\tif(depths[a]<depths[b])\n\t\tb = get_ancestor(b, depths[a]);\n\tif(depths[b]<depths[a])\n\t\ta = get_ancestor(a, depths[b]);\n\tif(a==b)\n\t\treturn a;\n\tint left = 0;\n\tint right = depths[a];\n\twhile(right>left+1) {\n\t\tint mid = (left+right)/2;\n\t\tint ca = get_ancestor(a, mid);\n\t\tint cb = get_ancestor(b, mid);\n\t\tif(ca!=cb) {\n\t\t\ta = ca;\n\t\t\tb = cb;\n\t\t\tright = mid;\n\t\t} else {\n\t\t\tleft = mid;\n\t\t}\n\t}\n\treturn left;\n}\n\nint weight(int a, int b) {\n\tint d = depths[a] - depths[b];\n\tint res = 0;\n\tfor(int i=0; i<NN; ++i) if(d & (1<<i)){\n\t\tres = max(res, prop[a][i]);\n\t\ta = par[a][i];\n\t}\t\n\treturn res;\n}\n\n\nvoid build_mst() {\n\t// init global\n\tint n = adj.size();\n\tdepths.assign(n, -1);\n\tpar.assign(n, vector<int>(NN, -1));\n\tprop.assign(n, vector<int>(NN, 0));\n\tvector<bool> visited(n, false);\n\t// init root\n\tpriority_queue<Edge> q;\n\tvisited[root] = true;\n\tdepths[root] = 0;\n\tfor(Edge& e: adj[root])\n\t\tq.push(e);\n\t// build tree\n\tmin_score = 0;\n\twhile(!q.empty()) {\n\t\tEdge e = q.top();\n\t\tq.pop();\n\t\tint cur = e.u;\n\t\tint next = e.v;\n\t\tif(visited[next]) continue;\n\t\tvisited[next] = true;\n\t\tdepths[next] = depths[cur] + 1;\n\t\tpar[next][0] = cur;\n\t\tprop[next][0] = e.w;\n\t\tmin_score += 1LL * e.w;\n\t\tfor(Edge& ee: adj[next])\n\t\t\tif(!visited[ee.v])\n\t\t\t\tq.push(ee);\n\t}\n\t// rec parent and prop updates\n\tvector<int> order(n);\n\tiota(order.begin(), order.end(), 0);\n\tsort(order.begin(), order.end(), [](const int a, const int b){return (depths[a]<depths[b]);});\n\tfor(int i=1; i<NN; ++i) {\n\t\tint shift = (1<<i);\n\t\tfor(int cur:order) {\n\t\t\tif(depths[cur]>=shift) {\n\t\t\t\tint next = par[cur][i-1];\n\t\t\t\tpar[cur][i] = par[next][i-1];\n\t\t\t\tprop[cur][i] = max(prop[cur][i-1], prop[next][i-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid go_on() {\n\tfor(vector<Edge>& ve: adj) \n\tfor(Edge& e: ve) \n\tif(scores[e.id]==0) {\n\t\tint a = e.u;\n\t\tint b = e.v;\n\t\tint l = lca(a, b);\n\t\tint la = weight(a, l);\n\t\tint lb = weight(b, l);\n\t\tint res = max(la, lb);\n\t\tscores[e.id] = min_score + 1LL * e.w - 1LL * res;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\tcout << fixed;\n\tint n, m;\n\tcin >> n >> m;\n\tscores.assign(m, 0);\n\tadj.assign(n, vector<Edge>());\n\tfor(int i=0; i<m; ++i) {\n\t\tint ui, vi, wi;\n\t\tcin >> ui >> vi >> wi;\n\t\t--ui; --vi;\n\t\tif(vi<ui) swap(ui, vi);\n\t\tadj[ui].push_back(Edge{ui, vi, wi, i});\n\t\tadj[vi].push_back(Edge{vi, ui, wi, i});\n\t}\n\troot = 0;\n\tbuild_mst();\n\tgo_on();\n\tfor(int i=0; i<m; ++i) {\n\t\tcout << scores[i] << '\\n';\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint u;\n\tint v;\n\tint w;\n\tint id;\n\n\tbool operator< (const Edge& a) const { \n\t\treturn (w>a.w);\n\t}\n};\n\nint root;\nvector<int> depths;\nvector< vector<int> > par;\nvector< vector<int> > prop;\nvector< vector<Edge> > adj;\nconst int NN = 18;\n\nusing ll = long long;\nvector<ll> scores;\nll min_score;\n\nint get_ancestor(int a, int depth) {\n\tint d = depths[a] - depth;\n\tint res = a;\n\tfor(int i=0; i<NN; ++i) if(d & (1<<i)){\n\t\tres = par[res][i];\n\t}\n\treturn res;\n}\n\nint lca(int a, int b) {\n\tif(depths[a]<depths[b])\n\t\tb = get_ancestor(b, depths[a]);\n\tif(depths[b]<depths[a])\n\t\ta = get_ancestor(a, depths[b]);\n\tif(a==b)\n\t\treturn a;\n\tint left = 0;\n\tint right = depths[a];\n\twhile(right>left+1) {\n\t\tint mid = (left+right)/2;\n\t\tint ca = get_ancestor(a, mid);\n\t\tint cb = get_ancestor(b, mid);\n\t\tif(ca!=cb) {\n\t\t\ta = ca;\n\t\t\tb = cb;\n\t\t\tright = mid;\n\t\t} else {\n\t\t\tleft = mid;\n\t\t}\n\t}\n\tint res = get_ancestor(a, left);\n\treturn res;\n}\n\nint weight(int a, int b) {\n\tint d = depths[a] - depths[b];\n\tint res = 0;\n\tfor(int i=0; i<NN; ++i) if(d & (1<<i)){\n\t\tres = max(res, prop[a][i]);\n\t\ta = par[a][i];\n\t}\t\n\treturn res;\n}\n\n\nvoid build_mst() {\n\t// init global\n\tint n = adj.size();\n\tdepths.assign(n, -1);\n\tpar.assign(n, vector<int>(NN, -1));\n\tprop.assign(n, vector<int>(NN, 0));\n\tvector<bool> visited(n, false);\n\t// init root\n\tpriority_queue<Edge> q;\n\tvisited[root] = true;\n\tdepths[root] = 0;\n\tfor(Edge& e: adj[root])\n\t\tq.push(e);\n\t// build tree\n\tmin_score = 0;\n\twhile(!q.empty()) {\n\t\tEdge e = q.top();\n\t\tq.pop();\n\t\tint cur = e.u;\n\t\tint next = e.v;\n\t\tif(visited[next]) continue;\n\t\tvisited[next] = true;\n\t\tdepths[next] = depths[cur] + 1;\n\t\tpar[next][0] = cur;\n\t\tprop[next][0] = e.w;\n\t\tmin_score += 1LL * e.w;\n\t\tfor(Edge& ee: adj[next])\n\t\t\tif(!visited[ee.v])\n\t\t\t\tq.push(ee);\n\t}\n\t// rec parent and prop updates\n\tvector<int> order(n);\n\tiota(order.begin(), order.end(), 0);\n\tsort(order.begin(), order.end(), [](const int a, const int b){return (depths[a]<depths[b]);});\n\tfor(int i=1; i<NN; ++i) {\n\t\tint shift = (1<<i);\n\t\tfor(int cur:order) {\n\t\t\tif(depths[cur]>=shift) {\n\t\t\t\tint next = par[cur][i-1];\n\t\t\t\tpar[cur][i] = par[next][i-1];\n\t\t\t\tprop[cur][i] = max(prop[cur][i-1], prop[next][i-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid go_on() {\n\tfor(vector<Edge>& ve: adj) \n\tfor(Edge& e: ve) \n\tif(scores[e.id]==0) {\n\t\tint a = e.u;\n\t\tint b = e.v;\n\t\tint l = lca(a, b);\n\t\tint la = weight(a, l);\n\t\tint lb = weight(b, l);\n\t\tint res = max(la, lb);\n\t\tscores[e.id] = min_score + 1LL * e.w - 1LL * res;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\tcout << fixed;\n\tint n, m;\n\tcin >> n >> m;\n\tscores.assign(m, 0);\n\tadj.assign(n, vector<Edge>());\n\tfor(int i=0; i<m; ++i) {\n\t\tint ui, vi, wi;\n\t\tcin >> ui >> vi >> wi;\n\t\t--ui; --vi;\n\t\tif(vi<ui) swap(ui, vi);\n\t\tadj[ui].push_back(Edge{ui, vi, wi, i});\n\t\tadj[vi].push_back(Edge{vi, ui, wi, i});\n\t}\n\troot = 0;\n\tbuild_mst();\n\tgo_on();\n\tfor(int i=0; i<m; ++i) {\n\t\tcout << scores[i] << '\\n';\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void onServiceStateChanged(android.telephony.ServiceState serviceState) {\n    if (!(mHasTelephony))\n        return ;\n    \n    final boolean inAirplaneMode = (serviceState.getState()) == (android.telephony.ServiceState.STATE_POWER_OFF);\n    mAirplaneState = (inAirplaneMode) ? com.android.internal.policy.impl.GlobalActions.ToggleAction.State.On : com.android.internal.policy.impl.GlobalActions.ToggleAction.State.Off;\n    mAirplaneModeOn.updateState(mAirplaneState);\n    mAdapter.notifyDataSetChanged();\n}",
        "fixed_code": "public void handleMessage(android.os.Message msg) {\n    switch (msg.what) {\n        case com.android.internal.policy.impl.GlobalActions.MESSAGE_DISMISS :\n            if ((mDialog) != null) {\n                mDialog.dismiss();\n                mDialog = null;\n            }\n            break;\n        case com.android.internal.policy.impl.GlobalActions.MESSAGE_REFRESH :\n            refreshSilentMode();\n            mAdapter.notifyDataSetChanged();\n            break;\n        case com.android.internal.policy.impl.GlobalActions.MESSAGE_SHOW :\n            handleShow();\n            break;\n        case com.android.internal.policy.impl.GlobalActions.MESSAGE_REFRESH_AIRPLANEMODE :\n            mAirplaneModeOn.updateState(mAirplaneState);\n            mAdapter.notifyDataSetChanged();\n            break;\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.util.Scanner;\n\n/**\n *\n * @author aso\n */\npublic class Problem33 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int con = in.nextInt();\n        int num[] = new int[con];\n        for (int u = 0; u < num.length; u++) {\n            num[u] = in.nextInt();\n\n        }\n        int n = 0;\n        if (num[0] == 1) {\n            for (int y = 0; y < num.length; y++) {\n                System.out.print(num[y] + \" \");\n\n            }\n            System.out.println();\n\n        } else {\n            for (int x = 0; x < num.length; x++) {\n\n                if (num[x] == 1) {\n                    n = x - 1;\n                }\n\n            }\n            for (int i = 0; i < num.length; i++) {\n                if (i == 0) {\n                    System.out.print(num[n] + \" \");\n                } else if (i == 1) {\n                    System.out.print(1 + \" \");\n                } else {\n                    System.out.print(num[i - 2] + \" \");\n                }\n\n            }\n            System.out.println();\n        }\n    }\n\n}\n\n",
        "fixed_code": "import java.util.Scanner;\n\n/**\n *\n * @author aso\n */\npublic class Problem33 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int con = in.nextInt();\n        int num[] = new int[con];\n        int res[] = new int[con];\n        for (int x = 0; x < num.length; x++) {\n            num[x] = in.nextInt();\n\n        }\n        for(int y=0;y<res.length;y++){\n            res[num[y]-1]=y+1;\n          \n        \n        }\n        for(int i=0;i<res.length;i++){\n                System.out.print(res[i]+\" \");\n\n        }\n        System.out.println();\n    }\n\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * Created by oknesif on 26.03.15.\n */\npublic class CodeforcesR297_t1 {\n\n    public static void main(String[] arrgs) throws IOException {\n        Scanner scanner = new Scanner(System.in);\n        int roomCount = scanner.nextInt();\n        String s = scanner.next();\n        int additionalKeys = 0;\n        HashMap<Character, Integer> hashMap = new HashMap<Character, Integer>();\n        for (int i = 0; i < roomCount - 1; i++) {\n            char key = s.charAt(i * 2);\n            char door = s.charAt(i * 2 + 1);\n            if (Character.toUpperCase(key) != door) {\n                addKey(hashMap, key);\n                if (hashMap.containsKey(Character.toLowerCase(door))) {\n                    int keyCount = hashMap.get(key);\n                    if (keyCount > 0) {\n                        hashMap.put(key, --keyCount);\n                    } else {\n                        additionalKeys++;\n                    }\n                } else {\n                    additionalKeys++;\n                }\n            }\n        }\n        System.out.println(additionalKeys);\n    }\n\n    private static void addKey(HashMap<Character, Integer> hashMap, Character key) {\n        int i = hashMap.containsKey(key) ? hashMap.get(key) : 0;\n        hashMap.put(key, i + 1);\n    }\n}\n",
        "fixed_code": "import java.io.IOException;\nimport java.util.Scanner;\n\n/**\n * Created by oknesif on 26.03.15.\n */\npublic class CodeforcesR297_t1_v2 {\n\n    public static void main(String[] arrgs) throws IOException {\n        Scanner scanner = new Scanner(System.in);\n        int roomCount = scanner.nextInt();\n        String s = scanner.next();\n        int additionalKeys = 0;\n        int[] keys = new int['z' - 'a' + 1];\n        for (int i = 0; i < roomCount - 1; i++) {\n            char key = s.charAt(i * 2);\n            char door = s.charAt(i * 2 + 1);\n            if (Character.toUpperCase(key) != door) {\n                keys[key - 'a']++;\n                if (keys[Character.toLowerCase(door) - 'a'] > 0) {\n                    keys[Character.toLowerCase(door) - 'a']--;\n                } else {\n                    additionalKeys++;\n                }\n            }\n        }\n        System.out.println(additionalKeys);\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=502019;\nint n,sz,loc[N],v[N],stk[N];\nstruct node{int loc,v;}a[N];\nstruct shuzhuangshuzu{\n\tint c[N];\n\tint lowbit(int x){return x & (-x);}\n\tint ask(int x){int res=0;for(;x;x-=lowbit(x))res+=c[x];return res;}\n\tvoid add(int x,int y){for(;x<=sz;x+=lowbit(x))c[x]+=y;}\n}tr1,tr2;\nint read(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nbool cmp(const node &x,const node &y){return x.loc<y.loc;}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)a[i].loc=read();\n\tfor(int i=1;i<=n;i++)stk[i]=a[i].v=read();\n\tsort(stk+1,stk+n+1);\n\tsz=unique(stk+1,stk+n+1)-(stk+1);\n\tfor(int i=1;i<=n;i++)\n\t\ta[i].v=lower_bound(stk+1,stk+sz+1,a[i].v)-stk;\n\tsort(a+1,a+n+1,cmp);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans+=tr1.ask(a[i].v)+a[i].loc*tr2.ask(a[i].v);\n\t\ttr1.add(a[i].v,-a[i].loc),tr2.add(a[i].v,1);\n\t} cout<<ans<<endl;\n\treturn 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define int long long\nconst int N=502019;\nint n,sz,loc[N],v[N],stk[N];\nstruct node{int loc,v;}a[N];\nstruct shuzhuangshuzu{\n\tint c[N];\n\tint lowbit(int x){return x & (-x);}\n\tint ask(int x){int res=0;for(;x;x-=lowbit(x))res+=c[x];return res;}\n\tvoid add(int x,int y){for(;x<=sz;x+=lowbit(x))c[x]+=y;}\n}tr1,tr2;\nint read(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nbool cmp(const node &x,const node &y){return x.loc<y.loc;}\n#undef int\nint main()\n{\n\t#define int long long\n\tn=read();\n\tfor(int i=1;i<=n;i++)a[i].loc=read();\n\tfor(int i=1;i<=n;i++)stk[i]=a[i].v=read();\n\tsort(stk+1,stk+n+1);\n\tsz=unique(stk+1,stk+n+1)-(stk+1);\n\tfor(int i=1;i<=n;i++)\n\t\ta[i].v=lower_bound(stk+1,stk+sz+1,a[i].v)-stk;\n\tsort(a+1,a+n+1,cmp);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tans+=tr1.ask(a[i].v)+a[i].loc*tr2.ask(a[i].v);\n\t\ttr1.add(a[i].v,-a[i].loc),tr2.add(a[i].v,1);\n\t} cout<<ans<<endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//هوالحق\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint F1(int l, int r){\n   if(l >= r) return l;\n   if(l == 0) return r;\n   int m = (r + l) / 2;\n   if(!m) return r;\n   cout << \"1 \" << m << \" \" << m+1 << endl;\n   string s; cin >> s;\n   if(s == \"TAK\") return F1(l, m);\n   return F1(m + 1, r);\n}\n\nint main() {\n   ios::sync_with_stdio(false), cin.tie(nullptr);\n   int n, k; cin >> n >> k;\n   int shams = F1(1, n), a = F1(1, shams - 1), b = F1(shams + 1, n);\n   if(a == 0 || a == shams) return cout << \"2 \" << shams << \" \" << b << endl, 0;\n   cout << \"1 \" << a << \" \" << b << endl;\n   string s; cin >> s;\n   if(s == \"TAK\") cout << \"2 \" << a << \" \" << shams;\n   else cout << \"2 \" << shams << \" \" << b;\n   return cout << endl, 0;\n}",
        "fixed_code": "//هوالحق\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint F1(int l, int r){\n   if(l >= r) return l;\n   if(l == 0) return r;\n   int m = (r + l) / 2;\n   if(!m) return r;\n   cout << \"1 \" << m << \" \" << m+1 << endl;\n   string s; cin >> s;\n   if(s == \"TAK\") return F1(l, m);\n   return F1(m + 1, r);\n}\n\nint main() {\n   ios::sync_with_stdio(false), cin.tie(nullptr);\n   int n, k; cin >> n >> k;\n   int shams = F1(1, n), a = F1(1, shams - 1), b = F1(shams + 1, n);\n   if(a == 0 || a == shams) return cout << \"2 \" << shams << \" \" << b << endl, 0;\n   if(b == shams || b > n) return cout << \"2 \" << a << \" \" << shams << endl, 0;\n   cout << \"1 \" << a << \" \" << b << endl;\n   string s; cin >> s;\n   if(s == \"TAK\") cout << \"2 \" << a << \" \" << shams;\n   else cout << \"2 \" << shams << \" \" << b;\n   return cout << endl, 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <stdio.h>\ntypedef long long ll;\nconst int N = 4e5+10;\nll a[N], pre[N] = {0}, sum = 0;\nint main()\n{\n\tint n, m;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lld\", a+i);\n\t\tsum += a[i];\n\t}\n\tm = n / 2;\n\tint now = 1, tot = 1;\n\tdo\n\t{\n\t\tpre[tot] = pre[tot-1] + a[now];\n\t\tnow += m;\n\t\tif(now > n) now -= n;\n\t\ttot++;\n\t}while(now != 1);\n\t\n\tdo\n\t{\n\t\tpre[tot] = pre[tot-1] + a[now];\n\t\tnow += m;\n\t\tif(now > n) now -= n;\n\t\ttot++;\n\t}while(now != 1);\n\t\n\tll minn = 1e18;\n\tfor(int i = m; i <= n + m - 1; i++)\n\t{\n\t\tif(minn > pre[i] - pre[i-m])\n\t\t\tminn = pre[i] - pre[i-m];\n\t}\n\t\n\tprintf(\"%lld\\n\", sum - minn);\n}",
        "fixed_code": "#include <stdio.h>\ntypedef long long ll;\nconst int N = 4e5+10;\nll a[N], pre[N] = {0}, sum = 0;\nint main()\n{\n\tint n, m;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lld\", a+i);\n\t\tsum += a[i];\n\t}\n\tif(n == 1)\n\t{\n\t\tprintf(\"%lld\\n\", a[1]); return 0;\n\t}\n\tm = n / 2;\n\tint now = 1, tot = 1;\n\tdo\n\t{\n\t\tpre[tot] = pre[tot-1] + a[now];\n\t\tnow += 2;\n\t\tif(now > n) now -= n;\n\t\ttot++;\n\t}while(now != 1);\n\t\n\tdo\n\t{\n\t\tpre[tot] = pre[tot-1] + a[now];\n\t\tnow += 2;\n\t\tif(now > n) now -= n;\n\t\ttot++;\n\t}while(now != 1);\n\t\n\tll minn = 1e18;\n\tfor(int i = m; i <= n + m - 1; i++)\n\t{\n\t\tif(minn > pre[i] - pre[i-m])\n\t\t\tminn = pre[i] - pre[i-m];\n\t}\n\t\n\tprintf(\"%lld\\n\", sum - minn);\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> G[100010];\nvector<pair<int, int> > v;\nint n, m;\nbool vis[100010];\n\nint dfs(int x){\n    int cnt = 0;\n    vis[x] = true;\n    for(int i = 0; i < G[x].size(); i++){\n        if(!vis[G[x][i]])\n            cnt = max(cnt, dfs(G[x][i]));\n    }\n    return cnt + 1;\n}\n\nbool check(int num){\n    for(int i = 1; i <= n; i++)G[i].clear();\n    memset(vis, 0, sizeof(vis));\n    for(int i = 0; i < num; i++){\n        G[v[i].first].push_back(v[i].second);\n        vis[v[i].second] = 1;\n    }\n    for(int i = 1; i <= n; i++){\n        if(!vis[i] and dfs(i) >= n)return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> n >> m;\n    for(int i = 0; i < m; i++){\n        int x, y;\n        cin >> x >> y;\n        v.push_back(make_pair(x, y));\n    }\n    if(!check(m)){\n        puts(\"-1\");\n        return 0;\n    }\n    int hi = m, lo = 1;\n    while(abs(hi - lo) > 1){\n        int mid = ( hi + lo )/ 2;\n        if(check(mid))hi = mid;\n        else lo = mid;\n    }\n    cout << hi << endl;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> G[100010];\nvector<pair<int, int> > v;\nint n, m, dp[100010];\nbool vis[100010];\n \nint dfs(int x){\n    if(dp[x] >= 0)return dp[x];\n    int cnt = 0;\n    for(int i = 0; i < G[x].size(); i++){\n        cnt = max(cnt, dfs(G[x][i]));\n    }\n    return dp[x] = cnt + 1;\n}\n \nbool check(int num){\n    for(int i = 1; i <= n; i++)G[i].clear();\n    memset(vis, 0, sizeof(vis));\n    memset(dp, -1, sizeof(dp));\n    for(int i = 0; i < num; i++){\n        G[v[i].first].push_back(v[i].second);\n        vis[v[i].second] = 1;\n    }\n    for(int i = 1; i <= n; i++){\n        if(!vis[i]){\n            if(dfs(i) >= n)\n                return true;\n            else\n                return false;\n        }\n    }\n    return false;\n}\n \nint main(){\n    cin >> n >> m;\n    for(int i = 0; i < m; i++){\n        int x, y;\n        cin >> x >> y;\n        v.push_back(make_pair(x, y));\n    }\n    if(!check(m)){\n        puts(\"-1\");\n        return 0;\n    }\n    int hi = m, lo = 1;\n    while(abs(hi - lo) > 1){\n        int mid = ( hi + lo )/ 2;\n        if(check(mid))hi = mid;\n        else lo = mid;\n    }\n    cout << hi << endl;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private  static void solver(InputReader sc, PrintWriter out) {\n\n        int n = sc.nextInt();\n        boolean ans[] = new boolean[n];\n        for(int i=0;i<n;i++){\n            long x = sc.nextInt();\n            ans[i] = meth(x);\n        }\n        for(boolean xx : ans){\n            if(xx)\n                out.println(\"YES\");\n            else\n                out.println(\"NO\");\n        }\n    }\n    private static boolean meth(long x){\n        int sq = (int)Math.sqrt(x);\n        int count=0;\n        for(int i=2;i<=sq;i++){\n            if(x%i==0){\n                if(i==(x/i))\n                    count++;\n                else\n                    count+=2;\n            }\n            if(count==2)\n                return false;\n        }\n      //  System.out.println(count);\n        return count==1;\n    }\n    public static void main(String[] args) throws Exception{\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        solver(in,out);\n        out.close();\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public void readLongArr(int n){\n            long arr[] = new long[n];\n            for(int i=0;i<n;i++){\n                arr[i] = nextLong();\n            }\n        }\n        public void readIntArr(int n){\n            int arr[] = new int[n];\n            for(int i=0; i<n; i++){\n                arr[i] = nextInt();\n            }\n        }\n    }\n}",
        "fixed_code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static Set<Long> hs = new HashSet<>();\n    static {\n        int n = 1000000;\n        boolean prime[] = new boolean[n+1];\n        Arrays.fill(prime,true);\n        for(int p=2; p*p<=n; p++){\n            if(prime[p]){\n                for(int i= p*p; i<=n; i+=p){\n                    prime[i] = false;\n                }\n            }\n        }\n        for(int i=2; i<=n; i++){\n            if(prime[i]){\n                long z = (long)Math.pow(i,2) ;\n                hs.add(z);\n            }\n        }\n\n    }\n    private static void solver(InputReader sc, PrintWriter out) throws Exception {\n            int in = sc.nextInt();\n            for(int i=0; i<in; i++){\n                long x = sc.nextLong();\n                if(hs.contains(x))\n                    out.println(\"YES\");\n                else\n                    out.println(\"NO\");\n            }\n    }\n    private static int gcd (int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return gcd (b, a % b);\n    }\n    private static long helper(long x){\n        long ans = (x * (x-1))/2;\n        return ans;\n    }\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        solver(in,out);\n        out.close();\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int[] readIntArray(int n){\n            int arr[] = new int[n];\n            for(int i=0;i<n;i++) arr[i] = nextInt();\n            return arr;\n        }\n    }\n}\nclass Pair{\n    long x;\n    long y;\n    Pair(long x, long y){\n        this.x  =x ;\n        this.y =y;\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nconst int N = 3005;\n\nint n, k, l = 1e9, r = -1e9, x, dis[N];\nbool is[N], vis[N];\n\nint main () {\n  scanf (\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; ++i) {\n    scanf (\"%d\", &x);\n    is[x] = 1;\n    if (x < l) l = x;\n    if (x > r) r = x;\n  }\n  if (k > r || k < l) return puts (\"-1\"), 0;\n  memset (dis, 0x3f, sizeof dis);\n  for (int i = 0; i <= 1000; ++i) if (is[i]) dis[1000 + i - n] = 1;\n  while (!vis[1000]) {\n    int u = -1;\n    for (int i = 0; i <= 2000; ++i) if (!vis[i] && (u == -1 || dis[i] < dis[u])) u = i;\n    vis[u] = 1;\n    for (int i = 0; i <= 1000; ++i) if (u + i - n >= 0 && u + i - n <= 2000 && is[i] && dis[u + i - n] > dis[u] + 1) dis[u + i - n] = dis[u] + 1;\n  }\n  return printf (\"%d\\n\", dis[1000]), 0;\n}\n",
        "fixed_code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nconst int N = 3005;\n\nint n, k, l = 1e9, r = -1e9, x, dis[N];\nbool is[N], vis[N];\n\nint main () {\n  scanf (\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; ++i) {\n    scanf (\"%d\", &x);\n    is[x] = 1;\n    if (x < l) l = x;\n    if (x > r) r = x;\n  }\n  if (n > r || n < l) return puts (\"-1\"), 0;\n  memset (dis, 0x3f, sizeof dis);\n  for (int i = 0; i <= 1000; ++i) if (is[i]) dis[1000 + i - n] = 1;\n  while (!vis[1000]) {\n    int u = -1;\n    for (int i = 0; i <= 2000; ++i) if (!vis[i] && (u == -1 || dis[i] < dis[u])) u = i;\n    vis[u] = 1;\n    for (int i = 0; i <= 1000; ++i) if (u + i - n >= 0 && u + i - n <= 2000 && is[i] && dis[u + i - n] > dis[u] + 1) dis[u + i - n] = dis[u] + 1;\n  }\n  return printf (\"%d\\n\", dis[1000]), 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private dooyit.logic.commands.Command getInvalidCmd() {\n    return dooyit.logic.commands.CommandUtils.createInvalidCommand(\"Invalid Delete Command!\");\n}",
        "fixed_code": "private dooyit.logic.commands.Command getInvalidCmd() {\n    return dooyit.logic.commands.CommandUtils.createInvalidCommand(\"Invalid Mark Command!\");\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "function(name, config)\n    {\n      if (!config) {\n        var config = {};\n      }\n\n      // Normalize include to array\n      if (config.include && !(qx.Bootstrap.getClass(config.include) === \"Array\")) {\n        config.include = [config.include];\n      }\n\n      // Normalize implement to array\n      if (config.implement && !(qx.Bootstrap.getClass(config.implement) === \"Array\")) {\n        config.implement = [config.implement];\n      }\n\n      // Normalize type\n      var implicitType = false;\n      if (!config.hasOwnProperty(\"extend\") && !config.type) {\n        config.type = \"static\";\n        implicitType = true;\n      }\n\n      // Validate incoming data\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        try {\n          this.__validateConfig(name, config);\n        } catch(ex) {\n          if (implicitType) {\n            ex.message = 'Assumed static class because no \"extend\" key was found. ' + ex.message;\n          }\n          throw ex;\n        }\n      }\n\n      // Create the class\n      var clazz = this.__createClass(name, config.type, config.extend, config.statics, config.construct, config.destruct, config.include);\n\n      // Members, properties, events and mixins are only allowed for non-static classes\n      if (config.extend)\n      {\n        // Attach properties\n        if (config.properties) {\n          this.__addProperties(clazz, config.properties, true);\n        }\n\n        // Attach members\n        if (config.members) {\n          this.__addMembers(clazz, config.members, true, true, false);\n        }\n\n        // Process events\n        if (config.events) {\n          this.__addEvents(clazz, config.events, true);\n        }\n\n        // Include mixins\n        // Must be the last here to detect conflicts\n        if (config.include)\n        {\n          for (var i=0, l=config.include.length; i<l; i++) {\n            this.__addMixin(clazz, config.include[i], false);\n          }\n        }\n      }\n\n      // Process environment\n      if (config.environment)\n      {\n        for (var key in config.environment) {\n          qx.core.Environment.add(key, config.environment[key]);\n        }\n      }\n\n      // Interface support for non-static classes\n      if (config.implement)\n      {\n        for (var i=0, l=config.implement.length; i<l; i++) {\n          this.__addInterface(clazz, config.implement[i]);\n        }\n      }\n\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        this.__validateAbstractInterfaces(clazz);\n      }\n\n\n      // Process defer\n      if (config.defer)\n      {\n        config.defer.self = clazz;\n        config.defer(clazz, clazz.prototype,\n        {\n          add : function(name, config)\n          {\n            // build pseudo properties map\n            var properties = {};\n            properties[name] = config;\n\n            // execute generic property handler\n            qx.Class.__addProperties(clazz, properties, true);\n          }\n        });\n      }\n\n      return clazz;\n    }",
        "fixed_code": "function(name, config)\n    {\n      if (!config) {\n        config = {};\n      }\n\n      // Normalize include to array\n      if (config.include && !(qx.Bootstrap.getClass(config.include) === \"Array\")) {\n        config.include = [config.include];\n      }\n\n      // Normalize implement to array\n      if (config.implement && !(qx.Bootstrap.getClass(config.implement) === \"Array\")) {\n        config.implement = [config.implement];\n      }\n\n      // Normalize type\n      var implicitType = false;\n      if (!config.hasOwnProperty(\"extend\") && !config.type) {\n        config.type = \"static\";\n        implicitType = true;\n      }\n\n      // Validate incoming data\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        try {\n          this.__validateConfig(name, config);\n        } catch(ex) {\n          if (implicitType) {\n            ex.message = 'Assumed static class because no \"extend\" key was found. ' + ex.message;\n          }\n          throw ex;\n        }\n      }\n\n      // Create the class\n      var clazz = this.__createClass(name, config.type, config.extend, config.statics, config.construct, config.destruct, config.include);\n\n      // Members, properties, events and mixins are only allowed for non-static classes\n      if (config.extend)\n      {\n        // Attach properties\n        if (config.properties) {\n          this.__addProperties(clazz, config.properties, true);\n        }\n\n        // Attach members\n        if (config.members) {\n          this.__addMembers(clazz, config.members, true, true, false);\n        }\n\n        // Process events\n        if (config.events) {\n          this.__addEvents(clazz, config.events, true);\n        }\n\n        // Include mixins\n        // Must be the last here to detect conflicts\n        if (config.include)\n        {\n          for (var i=0, l=config.include.length; i<l; i++) {\n            this.__addMixin(clazz, config.include[i], false);\n          }\n        }\n      }\n\n      // Process environment\n      if (config.environment)\n      {\n        for (var key in config.environment) {\n          qx.core.Environment.add(key, config.environment[key]);\n        }\n      }\n\n      // Interface support for non-static classes\n      if (config.implement)\n      {\n        for (var i=0, l=config.implement.length; i<l; i++) {\n          this.__addInterface(clazz, config.implement[i]);\n        }\n      }\n\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        this.__validateAbstractInterfaces(clazz);\n      }\n\n\n      // Process defer\n      if (config.defer)\n      {\n        config.defer.self = clazz;\n        config.defer(clazz, clazz.prototype,\n        {\n          add : function(name, config)\n          {\n            // build pseudo properties map\n            var properties = {};\n            properties[name] = config;\n\n            // execute generic property handler\n            qx.Class.__addProperties(clazz, properties, true);\n          }\n        });\n      }\n\n      return clazz;\n    }",
        "source": "FixJs_55551.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\r\n#define sz(a) int((a).size())\r\n\r\nconst int MOD = int(1e9) + 7;\r\n\r\nint norm(int a) {\r\n\twhile (a >= MOD)\r\n\t\ta -= MOD;\r\n\twhile (a < 0)\r\n\t\ta += MOD;\r\n\treturn a;\r\n}\r\nint mul(int a, int b) {\r\n\treturn int(a * 1ll * b % MOD);\r\n}\r\nint binPow(int a, int k) {\r\n\tint ans = 1;\r\n\twhile (k > 0) {\r\n\t\tif (k & 1)\r\n\t\t\tans = mul(ans, a);\r\n\t\ta = mul(a, a);\r\n\t\tk >>= 1;\r\n\t}\r\n\treturn ans;\r\n}\r\n\r\nconst int N = 200 * 1000 + 55;\r\nint f[N], inf[N];\r\n\r\nvoid precalc() {\r\n\tf[0] = inf[0] = 1;\r\n\tfore (i, 1, N) {\r\n\t\tf[i] = mul(f[i - 1], i);\r\n\t\tinf[i] = binPow(f[i], MOD - 2);\r\n\t}\r\n}\r\n\r\nint C(int n, int k) {\r\n\tif (k < 0 || n < k)\r\n\t\treturn 0;\r\n\treturn mul(f[n], mul(inf[n - k], inf[k]));\r\n}\r\n\r\nint n, l, r;\r\n\r\ninline bool read() {\r\n\tif(!(cin >> n >> l >> r))\r\n\t\treturn false;\r\n\treturn true;\r\n}\r\n\r\ninline void solve() {\r\n\tint half = n / 2;\r\n\tint st = min(1 - l, r - n);\r\n\t\r\n\tint ans = mul(st, C(n, half));\r\n\tif (n & 1)\r\n\t\tans = norm(ans + mul(st, C(n, half + 1)));\r\n\t\r\n\tfor (int k = st + 1; ; k++) {\r\n\t\tint lf = max(1, l + k);\r\n\t\tint rg = min(n, r - k);\r\n\t\t\r\n\t\tif (rg + 1 - lf < 0)\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tans = norm(ans + C(rg + 1 - lf, half - (lf - 1)));\r\n\t\tif (n & 1)\r\n\t\t\tans = norm(ans + C(rg + 1 - lf, half + 1 - (lf - 1)));\r\n\t}\r\n\t\r\n\tcout << ans << endl;\r\n}\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0), cout.tie(0);\r\n\tcout << fixed << setprecision(15);\r\n\tprecalc();\r\n\tint t; cin >> t;\r\n\twhile (t--) {\r\n\t\tread();\r\n\t\tsolve();\r\n\t}\r\n\treturn 0;\r\n}",
        "fixed_code": "#include<bits/stdc++.h>\r\n#define ll long long\r\nusing namespace std;\r\nint n,m,i,j,k,ans1,ans2;\r\nll a[1005][1005];\r\nll c[1005],x,y,s,t,temp;\r\nint main(){\r\n    scanf(\"%d%d\",&n,&m);\r\n    for (i=0;i<m;i++)\r\n    {\r\n        for (j=1;j<=n;j++)\r\n        {\r\n            scanf(\"%lld\",&a[i][j]);\r\n            c[i]+=a[i][j];\r\n        }\r\n    }\r\n    x=(c[m-1]-c[0])/(m-1);\r\n    for (i=1;i<m;i++)\r\n    {\r\n        if ((c[i]-c[0])!=x*i)\r\n        {\r\n            ans1=i;\r\n            y=c[i]-c[0]-x*i;\r\n            break;\r\n        }\r\n    }\r\n    for (i=1;i<m-1;i++)\r\n    {\r\n        if (i-1!=ans1&&i!=ans1&&i+1!=ans1)\r\n        {\r\n            x=0;\r\n            for (j=1;j<=n;j++)\r\n            {\r\n                x+=a[i-1][j]*a[i-1][j]+a[i+1][j]*a[i+1][j]-a[i][j]*a[i][j]*2;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    i=ans1;\r\n    t=s=0;\r\n    for (j=1;j<=n;j++)\r\n    {\r\n        s+=a[i-1][j]*a[i-1][j]+a[i+1][j]*a[i+1][j];\r\n        t+=a[i][j]*a[i][j]*2;\r\n    }\r\n    s-=x;\r\n    for (j=1;j<=n;j++)\r\n    {\r\n        temp=t-a[i][j]*a[i][j]*2+(a[i][j]-y)*(a[i][j]-y)*2;\r\n        if (temp==s)\r\n        {\r\n            ans2=a[i][j]-y;\r\n            break;\r\n        }\r\n    }\r\n    cout<<ans1<<' '<<ans2<<endl;\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<stdio.h>\n#include<assert.h>\n#include<string.h>\n#include<time.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string>\n#include<sstream>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#pragma comment(linker, \"/STACK:16777216\")\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sqr(x) (x) * (x)\n#define sz(x) (int)(x).size()\n#define LL long long\n#define bit __builtin_popcountll\nusing namespace std;\ntypedef pair<int, int> pii;\nint n,m,used[222];\nLL d[222][222];\nLL calc()\n{\n\tmemset(d,0,sizeof(d));\n\td[0][0] = 1;\n\tfor(int i = 1; i <= n + m - 1; i++)\n\t\tfor(int j = 0; j <= n + m - 1; j++)\n\t\t\tif (used[i - 1])\n\t\t\t{\n\t\t\t\tif (j - used[i - 1] >= 0) d[i][j] = d[i - 1][j - used[i - 1]];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (j - 1 >= 0) d[i][j] = d[i - 1][j - 1];\n\t\t\t\td[i][j] += d[i - 1][j + 1];\n\t\t\t}\n\treturn d[n + m - 1][0];\n}\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tint t;\n\tLL k;\n\tcin>>n>>m>>k;\n\tvector<pii> p(n * m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tcin>>t;\n\t\t\tp[t - 1] = mp(i,j);\n\t\t}\n\tfor(int i = 0; i < n * m; i++)\n\t{\n\t\tint x = p[i].first;\n\t\tint y = p[i].second;\n\t\tif (used[x + y]) continue;\n\t\tused[x + y] = 1;\n\t\tLL val = calc();\n\t\tif (val < k)\n\t\t{\n\t\t\tused[x + y] = -1;\n\t\t\tk -= val;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tassert(abs(used[i + j]) == 1);\n\t\t\tif (used[i + j] == 1) cout<<'('; else cout<<')';\n\t\t}\t\n\t\tcout<<endl;\t\n\t}\t\t\n\treturn 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<stdio.h>\n#include<assert.h>\n#include<string.h>\n#include<time.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string>\n#include<sstream>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#pragma comment(linker, \"/STACK:16777216\")\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sqr(x) (x) * (x)\n#define sz(x) (int)(x).size()\n#define LL long long\n#define bit __builtin_popcountll\nusing namespace std;\ntypedef pair<int, int> pii;\nconst LL INF = (LL)2e18;\nint n,m,used[222];\nLL d[222][222];\nLL calc()\n{\n\tmemset(d,0,sizeof(d));\n\td[0][0] = 1;\n\tfor(int i = 1; i <= n + m - 1; i++)\n\t\tfor(int j = 0; j <= n + m - 1; j++)\n\t\t\tif (used[i - 1])\n\t\t\t{\n\t\t\t\tif (j - used[i - 1] >= 0) d[i][j] = d[i - 1][j - used[i - 1]];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (j - 1 >= 0) d[i][j] = d[i - 1][j - 1];\n\t\t\t\td[i][j] += d[i - 1][j + 1];\n\t\t\t\tif (d[i][j] > INF) d[i][j] = INF;\n\t\t\t}\n\treturn d[n + m - 1][0];\n}\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tint t;\n\tLL k;\n\tcin>>n>>m>>k;\n\tvector<pii> p(n * m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tcin>>t;\n\t\t\tp[t - 1] = mp(i,j);\n\t\t}\n\tfor(int i = 0; i < n * m; i++)\n\t{\n\t\tint x = p[i].first;\n\t\tint y = p[i].second;\n\t\tif (used[x + y]) continue;\n\t\tused[x + y] = 1;\n\t\tLL val = calc();\n\t\tif (val < k)\n\t\t{\n\t\t\tused[x + y] = -1;\n\t\t\tk -= val;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tassert(abs(used[i + j]) == 1);\n\t\t\tif (used[i + j] == 1) cout<<'('; else cout<<')';\n\t\t}\t\n\t\tcout<<endl;\t\n\t}\t\t\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "n = int(raw_input())\narr = map(int,raw_input().split())\n\narr.sort()\ntotal = sum(arr)\n\nnice = []\ncount = 0\nfor i in range(n):\n    curr = total - arr[i]\n    if i == n-1:\n        if curr - arr[n-2] == arr[n-2]:\n            count += 1\n            nice.append(n-1)\n    else:\n        if curr - arr[n-1] == arr[n-1]:\n            count += 1\n            nice.append(i+1)\nprint count\nprint *nice",
        "fixed_code": "n = int(raw_input())\narr = map(int,raw_input().split())\nnew_arr = []\nfor i in range(n):\n    new_arr.append([arr[i],i+1])\nnew_arr.sort()\ntotal = sum(arr)\n\nnice = []\ncount = 0\nfor i in range(n):\n    curr = total - new_arr[i][0]\n    if i == n-1:\n        if curr - new_arr[n-2][0] == new_arr[n-2][0]:\n            count += 1\n            nice.append(new_arr[n-1][1])\n    else:\n        if curr - new_arr[n-1][0] == new_arr[n-1][0]:\n            count += 1\n            nice.append(new_arr[i][1])\nprint count\nfor i in nice:\n    print i,",
        "source": "Python_461356.json"
    },
    {
        "source_code": "@android.support.annotation.Nullable\nprivate android.support.v4.app.Fragment getGcmReceiverUIForeground(java.util.List<android.support.v4.app.Fragment> fragments, java.lang.String screenName) {\n    if (fragments == null)\n        return null;\n    \n    for (android.support.v4.app.Fragment fragment : fragments) {\n        if (((fragment != null) && (isVisible(fragment))) && (fragment instanceof rx_gcm.GcmReceiverUIForeground)) {\n            rx_gcm.GcmReceiverUIForeground gcmReceiverUIForeground = ((rx_gcm.GcmReceiverUIForeground) (fragment));\n            boolean isTargetScreen = gcmReceiverUIForeground.matchesTarget(screenName);\n            if (isTargetScreen) {\n                return fragment;\n            }else {\n                gcmReceiversUIForegroundNotTargetScreen.add(fragment);\n                continue;\n            }\n        }else\n            if ((fragment != null) && ((fragment.getChildFragmentManager()) != null)) {\n                java.util.List<android.support.v4.app.Fragment> childFragments = fragment.getChildFragmentManager().getFragments();\n                return getGcmReceiverUIForeground(childFragments, screenName);\n            }\n        \n    }\n    if (!(gcmReceiversUIForegroundNotTargetScreen.isEmpty()))\n        return gcmReceiversUIForegroundNotTargetScreen.get(0);\n    else\n        return null;\n    \n}",
        "fixed_code": "@android.support.annotation.Nullable\nprivate android.support.v4.app.Fragment getGcmReceiverUIForeground(java.util.List<android.support.v4.app.Fragment> fragments, java.lang.String screenName) {\n    if (fragments == null)\n        return null;\n    \n    for (android.support.v4.app.Fragment fragment : fragments) {\n        if (((fragment != null) && (isVisible(fragment))) && (fragment instanceof rx_gcm.GcmReceiverUIForeground)) {\n            rx_gcm.GcmReceiverUIForeground gcmReceiverUIForeground = ((rx_gcm.GcmReceiverUIForeground) (fragment));\n            boolean isTargetScreen = gcmReceiverUIForeground.matchesTarget(screenName);\n            if (isTargetScreen)\n                return fragment;\n            \n            gcmReceiversUIForegroundNotTargetScreen.add(fragment);\n            if ((fragment.getChildFragmentManager()) != null) {\n                android.support.v4.app.Fragment candidate = getGcmReceiverUIForegroundFromChild(fragment, screenName);\n                if (candidate != null)\n                    return candidate;\n                \n            }\n        }else\n            if (((fragment != null) && (isVisible(fragment))) && ((fragment.getChildFragmentManager()) != null)) {\n                android.support.v4.app.Fragment candidate = getGcmReceiverUIForegroundFromChild(fragment, screenName);\n                if (candidate != null)\n                    return candidate;\n                \n            }\n        \n    }\n    if (!(gcmReceiversUIForegroundNotTargetScreen.isEmpty()))\n        return gcmReceiversUIForegroundNotTargetScreen.get(0);\n    else\n        return null;\n    \n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import sys\r\nimport time\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nimport math\r\n\r\n\r\nM=10**9+7\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n \r\n \r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\ndef inputf(): \r\n    return sys.stdin.readline().rstrip(\"\\r\\n\")   \r\n \r\ndef get_ints(): \r\n    return list(map(int, inputf().split()))\r\n \r\n \r\ndef get_string(): \r\n    return list(map(str, inputf().split()))\r\n\r\n\r\n\r\n\r\n\r\nglobal maximum\r\n \r\n \r\ndef _lis(arr, n):\r\n \r\n    global maximum\r\n \r\n    if n == 1:\r\n        return 1\r\n \r\n    maxEndingHere = 1\r\n    for i in range(1, n):\r\n        res = _lis(arr, i)\r\n        if arr[i-1] < arr[n-1] and res+1 > maxEndingHere:\r\n            maxEndingHere = res + 1\r\n \r\n    maximum = max(maximum, maxEndingHere)\r\n \r\n    return maxEndingHere\r\n \r\n \r\ndef LIS(arr):\r\n \r\n    global maximum\r\n \r\n    n = len(arr)\r\n \r\n    maximum = 1\r\n \r\n    _lis(arr, n)\r\n \r\n    return maximum\r\n \r\n\r\ndef binary_search(data, elem):\r\n    \r\n    low = 0\r\n    high = len(data) - 1\r\n    while low <= high:\r\n      \r\n        middle = (low + high)//2\r\n        if data[middle] == elem:\r\n            return middle\r\n            \r\n        elif data[middle] > elem:\r\n\r\n            high = middle - 1\r\n        else:\r\n            low = middle + 1\r\n\r\n    return middle   \r\n\r\ndef upper_bound(my_list, key):\r\n    large = len(my_list) -1\r\n    small = 0\r\n\r\n    while (small <= large):\r\n        mid = (small + large) // 2\r\n        if my_list[mid] < key:\r\n            small = mid + 1\r\n        elif my_list[mid] > key:\r\n            large = mid - 1\r\n        else:\r\n            return mid\r\n    if my_list[mid]>key:\r\n        return mid\r\n    else:\r\n        return mid+1\r\n\r\n\r\ndef lower_bound(my_list, key):\r\n    large = len(my_list) -1\r\n    small = 0\r\n\r\n    while (small <= large):\r\n        mid = (small + large) // 2\r\n        if my_list[mid] < key:\r\n            small = mid + 1\r\n        elif my_list[mid] > key:\r\n            large = mid - 1\r\n        else:\r\n            return mid\r\n    if my_list[mid]<key:\r\n        return mid\r\n    else:\r\n        return mid-1\r\n\r\n\r\na=[]\r\ndef SieveOfEratosthenes(n):\r\n    \r\n\tprime = [True for i in range(n+1)]\r\n\tp = 2\r\n\twhile (p * p <= n):\r\n\r\n\t\tif (prime[p] == True):\r\n\r\n\t\t\tfor i in range(p * p, n+1, p):\r\n\t\t\t\tprime[i] = False\r\n\t\tp += 1\r\n\r\n\tfor p in range(2, n+1):\r\n\t\tif prime[p]:\r\n\t\t\ta.append(p)\r\n\r\ndef roman_number(x):\r\n    if x > 15999:\r\n        return\r\n    value = [5000, 4000, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\r\n    symbol = [\"F\", \"MF\", \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\r\n    roman = \"\"\r\n    i = 0\r\n    while x > 0:\r\n        div = x // value[i]\r\n        x = x % value[i]\r\n        while div:\r\n            roman += symbol[i]\r\n            div -= 1\r\n        i += 1\r\n    return roman\r\n\r\ndef maxSubArraySum(a,size):\r\n     \r\n    max_so_far = a[0]   \r\n    max_ending_here = 0\r\n     \r\n    for i in range(0, size):\r\n        max_ending_here = max_ending_here + a[i]\r\n        if max_ending_here < 0:\r\n            max_ending_here = 0\r\n         \r\n        elif (max_so_far < max_ending_here):   \r\n            max_so_far = max_ending_here\r\n             \r\n    return max_so_far\r\n\r\n    \r\ndef prefixSum(test_list):\r\n    res = [sum(test_list[ : i + 1]) for i in range(len(test_list))]\r\n    return res\r\n\r\n\r\n\r\ndef lcm(x, y):\r\n\r\n   if x > y:\r\n       greater = x\r\n   else:\r\n       greater = y\r\n\r\n   while(True):\r\n       if((greater % x == 0) and (greater % y == 0)):\r\n           lcm = greater\r\n           break\r\n       greater += 1\r\n\r\n   return lcm\r\n\r\na=[]\r\ndef primeFactors(n):\r\n     \r\n\r\n    while n % 2 == 0:\r\n        a.append(2)\r\n        n = n / 2\r\n         \r\n    for i in range(3,int(math.sqrt(n))+1,2):\r\n         \r\n        while n % i== 0:\r\n            a.append(i)\r\n            n = n / i\r\n             \r\n    if n > 2:\r\n        a.append(n)\r\nimport random\r\n \r\ndef is_Prime(n):\r\n    \"\"\"\r\n    Miller-Rabin primality test.\r\n \r\n    A return value of False means n is certainly not prime. A return value of\r\n    True means n is very likely a prime.\r\n    \"\"\"\r\n    if n!=int(n):\r\n        return False\r\n    n=int(n)\r\n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\r\n        return False\r\n \r\n    if n==2 or n==3 or n==5 or n==7:\r\n        return True\r\n    s = 0\r\n    d = n-1\r\n    while d%2==0:\r\n        d>>=1\r\n        s+=1\r\n    assert(2**s * d == n-1)\r\n \r\n    def trial_composite(a):\r\n        if pow(a, d, n) == 1:\r\n            return False\r\n        for i in range(s):\r\n            if pow(a, 2**i * d, n) == n-1:\r\n                return False\r\n        return True  \r\n \r\n    for i in range(8):\r\n        a = random.randrange(2, n)\r\n        if trial_composite(a):\r\n            return False\r\n \r\n    return True  \r\n\r\n\"\"\"\r\ndef find_shortest_path(graph, start, end, path):\r\n    path = path + [start]\r\n    if start == end:\r\n        return path\r\n    if start not in graph:\r\n        return None\r\n    shortest = None\r\n    for node in graph[start]:\r\n        if node not in path:\r\n            newpath = find_shortest_path(graph, node, end, path)\r\n            if newpath:\r\n                if not shortest or len(newpath) < len(shortest):\r\n                    shortest = newpath\r\n    return shortest\r\n\"\"\" \r\n\r\n\"\"\"\r\ndef dfs(root,nodeVal,nodeConnection,visited):\r\n    leftVal = nodeVal[root][0]\r\n    rightVal = nodeVal[root][1]\r\n    solution = []\r\n    if nodeConnection[root]:\r\n        visited.add(root)\r\n        for i in nodeConnection[root]:\r\n            if i not in visited:\r\n                solution.append(dfs(i,nodeVal,nodeConnection,visited))\r\n        leftMax = 0\r\n        rightMax = 0\r\n        for i in solution:\r\n            l, r = i\r\n            leftMax += max(abs(leftVal - l[0]) + l[1], abs(leftVal - r[0]) + r[1])\r\n            rightMax += max(abs(rightVal - l[0]) + l[1], abs(rightVal - r[0]) + r[1])\r\n        return ((leftVal, leftMax), (rightVal, rightMax))\r\n    else:\r\n        return ((leftVal, 0), (rightVal, 0))\r\n \r\n\"\"\"\r\n \r\n\"\"\"\r\ndef BFS(adj,src,dist,paths,n):\r\n    visited=[False]*n\r\n    dist[src]=0\r\n    paths[0]=1\r\n    q=[src]\r\n    visited[src]=True\r\n    while(q):\r\n        p=q.pop(0)\r\n        for j in adj[p]:\r\n            if not visited[j]:\r\n                q.append(j)\r\n                visited[j]=True\r\n            if dist[j]>dist[p]+1:\r\n                dist[j] = dist[p]+1\r\n                paths[j] = paths[p]\r\n            elif dist[j]==dist[p]+1:\r\n                paths[j] +=paths[p]\r\n    return paths\r\n \r\n\"\"\"\r\n\r\ntestcase=int(inputf())\r\n\r\nfor test in range(testcase):\r\n    n=int(inputf())\r\n    s=str(inputf())\r\n    \r\n    sob=0\r\n    soc=0\r\n    \r\n    start=s.find(\"a\")\r\n    check=False\r\n    current=start\r\n    res=10**9\r\n    for i in range(start+1,n):\r\n        if s[i]==\"b\":\r\n            sob+=1\r\n        if s[i]==\"c\":\r\n            soc+=1\r\n        if s[i]==\"a\":           \r\n            if sob<=1 and soc<=1:\r\n                res=min(res,i-current+1)                \r\n                check=True\r\n            current=i\r\n            sob=0\r\n            soc=0                    \r\n    if check==False:\r\n        print(-1)\r\n    else:\r\n        print(res)\r\n            \r\n\r\n",
        "fixed_code": "import sys\r\nimport time\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nimport math\r\n\r\n\r\nM=10**9+7\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n \r\n \r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\ndef inputf(): \r\n    return sys.stdin.readline().rstrip(\"\\r\\n\")   \r\n \r\ndef get_ints(): \r\n    return list(map(int, inputf().split()))\r\n \r\n \r\ndef get_string(): \r\n    return list(map(str, inputf().split()))\r\n\r\n\r\n\r\n\r\n\r\nglobal maximum\r\n \r\n \r\ndef _lis(arr, n):\r\n \r\n    global maximum\r\n \r\n    if n == 1:\r\n        return 1\r\n \r\n    maxEndingHere = 1\r\n    for i in range(1, n):\r\n        res = _lis(arr, i)\r\n        if arr[i-1] < arr[n-1] and res+1 > maxEndingHere:\r\n            maxEndingHere = res + 1\r\n \r\n    maximum = max(maximum, maxEndingHere)\r\n \r\n    return maxEndingHere\r\n \r\n \r\ndef LIS(arr):\r\n \r\n    global maximum\r\n \r\n    n = len(arr)\r\n \r\n    maximum = 1\r\n \r\n    _lis(arr, n)\r\n \r\n    return maximum\r\n \r\n\r\ndef binary_search(data, elem):\r\n    \r\n    low = 0\r\n    high = len(data) - 1\r\n    while low <= high:\r\n      \r\n        middle = (low + high)//2\r\n        if data[middle] == elem:\r\n            return middle\r\n            \r\n        elif data[middle] > elem:\r\n\r\n            high = middle - 1\r\n        else:\r\n            low = middle + 1\r\n\r\n    return middle   \r\n\r\ndef upper_bound(my_list, key):\r\n    large = len(my_list) -1\r\n    small = 0\r\n\r\n    while (small <= large):\r\n        mid = (small + large) // 2\r\n        if my_list[mid] < key:\r\n            small = mid + 1\r\n        elif my_list[mid] > key:\r\n            large = mid - 1\r\n        else:\r\n            return mid\r\n    if my_list[mid]>key:\r\n        return mid\r\n    else:\r\n        return mid+1\r\n\r\n\r\ndef lower_bound(my_list, key):\r\n    large = len(my_list) -1\r\n    small = 0\r\n\r\n    while (small <= large):\r\n        mid = (small + large) // 2\r\n        if my_list[mid] < key:\r\n            small = mid + 1\r\n        elif my_list[mid] > key:\r\n            large = mid - 1\r\n        else:\r\n            return mid\r\n    if my_list[mid]<key:\r\n        return mid\r\n    else:\r\n        return mid-1\r\n\r\n\r\na=[]\r\ndef SieveOfEratosthenes(n):\r\n    \r\n\tprime = [True for i in range(n+1)]\r\n\tp = 2\r\n\twhile (p * p <= n):\r\n\r\n\t\tif (prime[p] == True):\r\n\r\n\t\t\tfor i in range(p * p, n+1, p):\r\n\t\t\t\tprime[i] = False\r\n\t\tp += 1\r\n\r\n\tfor p in range(2, n+1):\r\n\t\tif prime[p]:\r\n\t\t\ta.append(p)\r\n\r\ndef roman_number(x):\r\n    if x > 15999:\r\n        return\r\n    value = [5000, 4000, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\r\n    symbol = [\"F\", \"MF\", \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\r\n    roman = \"\"\r\n    i = 0\r\n    while x > 0:\r\n        div = x // value[i]\r\n        x = x % value[i]\r\n        while div:\r\n            roman += symbol[i]\r\n            div -= 1\r\n        i += 1\r\n    return roman\r\n\r\ndef maxSubArraySum(a,size):\r\n     \r\n    max_so_far = a[0]   \r\n    max_ending_here = 0\r\n     \r\n    for i in range(0, size):\r\n        max_ending_here = max_ending_here + a[i]\r\n        if max_ending_here < 0:\r\n            max_ending_here = 0\r\n         \r\n        elif (max_so_far < max_ending_here):   \r\n            max_so_far = max_ending_here\r\n             \r\n    return max_so_far\r\n\r\n    \r\ndef prefixSum(test_list):\r\n    res = [sum(test_list[ : i + 1]) for i in range(len(test_list))]\r\n    return res\r\n\r\n\r\n\r\ndef lcm(x, y):\r\n\r\n   if x > y:\r\n       greater = x\r\n   else:\r\n       greater = y\r\n\r\n   while(True):\r\n       if((greater % x == 0) and (greater % y == 0)):\r\n           lcm = greater\r\n           break\r\n       greater += 1\r\n\r\n   return lcm\r\n\r\na=[]\r\ndef primeFactors(n):\r\n     \r\n\r\n    while n % 2 == 0:\r\n        a.append(2)\r\n        n = n / 2\r\n         \r\n    for i in range(3,int(math.sqrt(n))+1,2):\r\n         \r\n        while n % i== 0:\r\n            a.append(i)\r\n            n = n / i\r\n             \r\n    if n > 2:\r\n        a.append(n)\r\nimport random\r\n \r\ndef is_Prime(n):\r\n    \"\"\"\r\n    Miller-Rabin primality test.\r\n \r\n    A return value of False means n is certainly not prime. A return value of\r\n    True means n is very likely a prime.\r\n    \"\"\"\r\n    if n!=int(n):\r\n        return False\r\n    n=int(n)\r\n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\r\n        return False\r\n \r\n    if n==2 or n==3 or n==5 or n==7:\r\n        return True\r\n    s = 0\r\n    d = n-1\r\n    while d%2==0:\r\n        d>>=1\r\n        s+=1\r\n    assert(2**s * d == n-1)\r\n \r\n    def trial_composite(a):\r\n        if pow(a, d, n) == 1:\r\n            return False\r\n        for i in range(s):\r\n            if pow(a, 2**i * d, n) == n-1:\r\n                return False\r\n        return True  \r\n \r\n    for i in range(8):\r\n        a = random.randrange(2, n)\r\n        if trial_composite(a):\r\n            return False\r\n \r\n    return True  \r\n\r\n\"\"\"\r\ndef find_shortest_path(graph, start, end, path):\r\n    path = path + [start]\r\n    if start == end:\r\n        return path\r\n    if start not in graph:\r\n        return None\r\n    shortest = None\r\n    for node in graph[start]:\r\n        if node not in path:\r\n            newpath = find_shortest_path(graph, node, end, path)\r\n            if newpath:\r\n                if not shortest or len(newpath) < len(shortest):\r\n                    shortest = newpath\r\n    return shortest\r\n\"\"\" \r\n\r\n\"\"\"\r\ndef dfs(root,nodeVal,nodeConnection,visited):\r\n    leftVal = nodeVal[root][0]\r\n    rightVal = nodeVal[root][1]\r\n    solution = []\r\n    if nodeConnection[root]:\r\n        visited.add(root)\r\n        for i in nodeConnection[root]:\r\n            if i not in visited:\r\n                solution.append(dfs(i,nodeVal,nodeConnection,visited))\r\n        leftMax = 0\r\n        rightMax = 0\r\n        for i in solution:\r\n            l, r = i\r\n            leftMax += max(abs(leftVal - l[0]) + l[1], abs(leftVal - r[0]) + r[1])\r\n            rightMax += max(abs(rightVal - l[0]) + l[1], abs(rightVal - r[0]) + r[1])\r\n        return ((leftVal, leftMax), (rightVal, rightMax))\r\n    else:\r\n        return ((leftVal, 0), (rightVal, 0))\r\n \r\n\"\"\"\r\n \r\n\"\"\"\r\ndef BFS(adj,src,dist,paths,n):\r\n    visited=[False]*n\r\n    dist[src]=0\r\n    paths[0]=1\r\n    q=[src]\r\n    visited[src]=True\r\n    while(q):\r\n        p=q.pop(0)\r\n        for j in adj[p]:\r\n            if not visited[j]:\r\n                q.append(j)\r\n                visited[j]=True\r\n            if dist[j]>dist[p]+1:\r\n                dist[j] = dist[p]+1\r\n                paths[j] = paths[p]\r\n            elif dist[j]==dist[p]+1:\r\n                paths[j] +=paths[p]\r\n    return paths\r\n \r\n\"\"\"\r\n\r\ntestcase=int(inputf())\r\n\r\nfor test in range(testcase):\r\n    n=int(inputf())\r\n    s=str(inputf())\r\n\r\n    if s.find(\"aa\")!=-1:\r\n        print(2)\r\n    elif s.find(\"aba\")!=-1 or s.find(\"aca\")!=-1:\r\n        print(3)\r\n    elif s.find(\"abca\")!=-1 or s.find(\"acba\")!=-1:\r\n        print(4)\r\n    elif s.find(\"abbacca\")!=-1 or s.find(\"accabba\")!=-1:\r\n        print(7)\r\n    else:\r\n        print(-1)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct nod{\n\tint row;\n\tint col;\n} num[106];\nint com(int w)\n{\n\tint count = 1;\n\tfor(int i = w;i>2;i--)\n\t{\n\t\tcount *= i;\n\t}\n\treturn count;\n}\nint main()\n{\n\tint n,i,j;\n\tchar a;\n\tmemset(num,0,sizeof(num));\n\tscanf(\"%d\",&n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tfor(j = 0;j < n;j++)\n\t\t{\n\t\t\tcin>>a;\n\t\t\tif(a == 'C')\n\t\t\t{\n\t\t\t\tnum[j].col ++;\n\t\t\t\tnum[i].row ++;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tif(num[i].col >= 2)\n\t\t{\n\t\t\tif(num[i].col == 2)\n\t\t\tret++;\n\t\t\telse\n\t\t\tret += com(num[i].col);\n\t\t}\n\t\tif(num[i].row >= 2)\n\t\t{\n\t\t\tif(num[i].row == 2)\n\t\t\tret++;\n\t\t\telse\n\t\t\tret += com(num[i].row);\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\treturn 0;\n}",
        "fixed_code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct nod{\n\tint row;\n\tint col;\n} num[106];\nint com(int w,int k)\n{\n\tif(w == k||k == 0)\n\treturn 1;\n\telse\n\treturn com(w-1,k-1) + com(w-1,k);\n}\nint main()\n{\n\tint n,i,j;\n\tchar a;\n\tmemset(num,0,sizeof(num));\n\tscanf(\"%d\",&n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tfor(j = 0;j < n;j++)\n\t\t{\n\t\t\tcin>>a;\n\t\t\tif(a == 'C')\n\t\t\t{\n\t\t\t\tnum[j].col ++;\n\t\t\t\tnum[i].row ++;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tif(num[i].col >= 2)\n\t\t{\n\t\t\tif(num[i].col == 2)\n\t\t\tret++;\n\t\t\telse\n\t\t\tret += com(num[i].col,2);\n\t\t}\n\t\tif(num[i].row >= 2)\n\t\t{\n\t\t\tif(num[i].row == 2)\n\t\t\tret++;\n\t\t\telse\n\t\t\tret += com(num[i].row,2);\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define f first\n#define s second\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tint n, m;\n\tcin>>n>>m;\n\tint f[m+1];\n\tvector<vector<int>>v;\n\tv.resize(m+1);\n\tint sz[m+1];\n\tfor(int i=0; i<=m; i++){\n\t\tsz[i]=0;\n\t}\n\tint val[n+1];\n\tfor(int i=1; i<=n; i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tsz[x]++;\n\t\tval[i]=x;\n\t\tv[x].pb(i);\n\t}\n\tfor(int i=0; i<=m; i++){\n\t\tf[i]=i;\n\t}\n\tint num=0;\n\tfor(int i=1; i<n; i++){\n\t\tif(val[i]==val[i+1]){\n\t\t\tnum++;\n\t\t}\n\t}\n\tcout<<n-1-num<<endl;\n\tfor(int i=0; i<m-1; i++){\n\t\tint a, b;\n\t\tcin>>a>>b;\n\t\tint aa=f[a];\n\t\tint bb=f[b];\n\t\tif(v[aa].size()>v[bb].size()){\n\t\t\tfor(auto u:v[bb]){\n\t\t\t\tif(u==n){\n\t\t\t\t\tif(val[u-1]==aa){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u==1){\n\t\t\t\t\tif(val[2]==aa){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(val[u+1]==aa){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tif(val[u-1]==aa){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto u:v[bb]){\n\t\t\t\tval[u]=aa;\n\t\t\t\tv[aa].pb(u);\n\t\t\t}\n\t\t\tf[a]=aa;\n\t\t\tf[b]=aa;\n\t\t}\n\t\telse{\n\t\t\tfor(auto u:v[aa]){\n\t\t\t\tif(u==n){\n\t\t\t\t\tif(val[u-1]==bb){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(u==1){\n\t\t\t\t\tif(val[2]==bb){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(val[u+1]==bb){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tif(val[u-1]==bb){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto u:v[aa]){\n\t\t\t\tval[u]=bb;\n\t\t\t\tv[bb].pb(u);\n\t\t\t}\n\t\t\tf[a]=bb;\n\t\t\tf[b]=bb;\n\t\t}\n\t\tcout<<n-1-num<<endl;\n\t}\n\t\n\treturn 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define f first\n#define s second\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tint n, m;\n\tcin>>n>>m;\n\tint f[m+1];\n\tvector<vector<int>>v;\n\tv.resize(m+1);\n\tint sz[m+1];\n\tfor(int i=0; i<=m; i++){\n\t\tsz[i]=0;\n\t}\n\tint val[n+1];\n\tfor(int i=1; i<=n; i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tsz[x]++;\n\t\tval[i]=x;\n\t\tv[x].pb(i);\n\t}\n\tfor(int i=0; i<=m; i++){\n\t\tf[i]=i;\n\t}\n\tint num=0;\n\tfor(int i=1; i<n; i++){\n\t\tif(val[i]==val[i+1]){\n\t\t\tnum++;\n\t\t}\n\t}\n\tcout<<n-1-num<<endl;\n\tfor(int i=0; i<m-1; i++){\n\t\tint a, b;\n\t\tcin>>a>>b;\n\t\tint aa=f[a];\n\t\tint bb=f[b];\n\t\tif(v[aa].size()>v[bb].size()){\n\t\t\tfor(auto u:v[bb]){\n\t\t\t\tif(u==n){\n\t\t\t\t\tif(val[u-1]==aa){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(u==1){\n\t\t\t\t\tif(val[2]==aa){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(val[u+1]==aa){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tif(val[u-1]==aa){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto u:v[bb]){\n\t\t\t\tval[u]=aa;\n\t\t\t\tv[aa].pb(u);\n\t\t\t}\n\t\t\tf[a]=aa;\n\t\t\tf[b]=aa;\n\t\t}\n\t\telse{\n\t\t\tfor(auto u:v[aa]){\n\t\t\t\tif(u==n){\n\t\t\t\t\tif(val[u-1]==bb){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(u==1){\n\t\t\t\t\tif(val[2]==bb){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(val[u+1]==bb){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tif(val[u-1]==bb){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto u:v[aa]){\n\t\t\t\tval[u]=bb;\n\t\t\t\tv[bb].pb(u);\n\t\t\t}\n\t\t\tf[a]=bb;\n\t\t\tf[b]=bb;\n\t\t}\n\t\tcout<<n-1-num<<endl;\n\t}\n\t\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n\nbool comp(vector<int> &a, vector<int> &b)\n{\n\tif (a[0] > b[0])\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tint t;\n\tcin >> t;\n\tfor (int step = 0; step < t; step ++)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<vector<int>> ar(2 * n - 1, {0, 0, 0});\n\t\tint a, o;\n\t\tfor (int i = 0; i < 2 * n - 1; i ++)\n\t\t{\n\t\t\tcin >> a >> o;\n\t\t\tar[i] = {a, o, i + 1};\n\t\t}\n\t\tsort(ar.begin(), ar.end(), comp);\n\t\ta = 0;\n\t\to = 0;\n\t\tfor (int j = 0; j < ar.size(); j ++)\n\t\t{\n\t\t\ta += ar[j][0];\n\t\t\to += ar[j][1];\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int k = 0; k < ar.size(); k += 2)\n\t\t{\n\t\t\tsum += ar[k][1];\n\t\t}\n\t\tif (sum >= double(o) / 2)\n\t\t{\n\t\t\tcout << \"YES\" << endl;\n\t\t\tfor (int k = 0; k < ar.size(); k += 2)\n\t\t\t{\n\t\t\t\tcout << ar[k][2] << ' ';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"YES\" << endl;\n\t\t\tcout << ar[0][2] << ' ';\n\t\t\tfor (int k = 1; k < ar.size(); k += 2 )\n\t\t\t{\n\t\t\t\tcout << ar[k][2] << ' ';\n\t\t\t}\n\t\t}\n\t}\n\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n\nbool comp(vector<int> &a, vector<int> &b)\n{\n\tif (a[0] > b[0])\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tlong long int t;\n\tcin >> t;\n\tfor (int step = 0; step < t; step ++)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<vector<int>> ar(2 * n - 1, {0, 0, 0});\n\t\tint a, o;\n\t\tfor (int i = 0; i < 2 * n - 1; i ++)\n\t\t{\n\t\t\tcin >> a >> o;\n\t\t\tar[i] = {a, o, i + 1};\n\t\t}\n\t\tlong long int sa, so;\n\t\tsort(ar.begin(), ar.end(), comp);\n\t\tsa = 0;\n\t\tso = 0;\n\t\tfor (int j = 0; j < ar.size(); j ++)\n\t\t{\n\t\t\tsa += ar[j][0];\n\t\t\tso += ar[j][1];\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor (int k = 0; k < ar.size(); k += 2)\n\t\t{\n\t\t\tsum += ar[k][1];\n\t\t}\n\t\tif (sum >= double(so) / 2)\n\t\t{\n\t\t\tcout << \"YES\" << endl;\n\t\t\tfor (int k = 0; k < ar.size(); k += 2)\n\t\t\t{\n\t\t\t\tcout << ar[k][2] << ' ';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"YES\" << endl;\n\t\t\tcout << ar[0][2] << ' ';\n\t\t\tfor (int k = 1; k < ar.size(); k += 2 )\n\t\t\t{\n\t\t\t\tcout << ar[k][2] << ' ';\n\t\t\t}\n\t\t}\n\t}\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private static java.util.ArrayList<java.lang.String> getUniqueList(java.util.ArrayList<controllers.classification.AnonymizedSubData> subData) {\n    java.util.ArrayList<java.lang.String> models = controllers.classification.ID3.getModelList(subData);\n    java.util.SortedSet<java.lang.String> set = new java.util.TreeSet<java.lang.String>(models);\n    java.util.ArrayList<java.lang.String> uniqueList = new java.util.ArrayList();\n    for (java.lang.String uniqueValue : set) {\n        uniqueList.add(uniqueValue);\n    }\n    return uniqueList;\n}",
        "fixed_code": "private static java.util.ArrayList<java.lang.String> getUniqueList(java.util.ArrayList<controllers.classification.AnonymizedSubData> subData) {\n    java.util.ArrayList<java.lang.String> attributes = controllers.classification.ID3.getAttributeList(subData);\n    java.util.SortedSet<java.lang.String> set = new java.util.TreeSet<java.lang.String>(attributes);\n    java.util.ArrayList<java.lang.String> uniqueList = new java.util.ArrayList();\n    for (java.lang.String uniqueValue : set) {\n        uniqueList.add(uniqueValue);\n    }\n    return uniqueList;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <string>\r\n#include <map>\r\n#include <math.h>\r\n#include <set>\r\n#include <bitset>\r\n#include <sstream>\r\n#include<stack>\r\n#include<iomanip>\r\n#include<list>\r\n\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"no-stack-protector\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\r\n#pragma GCC optimize(\"fast-math\")\r\n\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nconst ll inf = 1e12;\r\n\r\nvoid imouto()\r\n{\r\n    ll n, cnt = 0;\r\n    cin >> n;\r\n    vector<ll> a(n), b(n);\r\n    for(auto &it : a) cin >> it;\r\n    for(auto &it : b) cin >> it;\r\n    bool dumb = 0;\r\n    for(int i = 0; i < n - 1; i++)\r\n    {\r\n        if(a[i] > b[i]) dumb = 1;\r\n        if(a[i] != b[i] && b[i] > b[i + 1] + 1) dumb = 1;\r\n    }\r\n    if(a[n - 1] != b[n - 1] && b[n - 1] > b[0] + 1) dumb = 1;\r\n    if(!dumb) cout << \"YES\\n\";\r\n    else cout << \"NO\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false);\r\n\t//cin.tie(nullptr);\r\n\t//cout.setf(ios::fixed);\r\n    //cout << setprecision(0);\r\n    ll t;\r\n    cin >> t;\r\n    while(t--) imouto();\r\n    //imouto();\r\n    return 0;\r\n}\r\n",
        "fixed_code": "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <string>\r\n#include <map>\r\n#include <math.h>\r\n#include <set>\r\n#include <bitset>\r\n#include <sstream>\r\n#include<stack>\r\n#include<iomanip>\r\n#include<list>\r\n\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"no-stack-protector\")\r\n#pragma GCC optimize(\"unroll-loops\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\r\n#pragma GCC optimize(\"fast-math\")\r\n\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nconst ll inf = 1e12;\r\n\r\nvoid imouto()\r\n{\r\n    ll n;\r\n    cin >> n;\r\n    vector<ll> a(n), b(n);\r\n    for(auto &it : a) cin >> it;\r\n    for(auto &it : b) cin >> it;\r\n    bool dumb = 0;\r\n    for(int i = 0; i <= n - 1; i++)\r\n    {\r\n        if(a[i] > b[i]) dumb = 1;\r\n        if(a[i] != b[i] && b[i] > b[(i + 1)%n] + 1) dumb = 1;\r\n    }\r\n    //if(a[n - 1] != b[n - 1] && b[n - 1] > b[0] + 1) dumb = 1;\r\n    if(!dumb) cout << \"YES\\n\";\r\n    else cout << \"NO\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    ios::sync_with_stdio(false);\r\n\t//cin.tie(nullptr);\r\n\t//cout.setf(ios::fixed);\r\n    //cout << setprecision(0);\r\n    ll t;\r\n    cin >> t;\r\n    while(t--) imouto();\r\n    //imouto();\r\n    return 0;\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long int\r\n#define ld long double\r\n#define fon for(i=0;i<n;i++)\r\n#define foj for(j=0;j<n;j++)\r\n#define f(i, x, n) for (i = x; i < n; i++)\r\n#define bf(i,z,n) for(ll i=z;i>=n;i--)\r\n#define PI 3.141592653589793\r\n#define maxa *max_element\r\n#define mina *min_element\r\n#define pb push_back\r\n#define fast ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\r\n#define cina(a,n) for(ll i=0;i<n;i++){cin>>a[i];}\r\n#define cin1 for(ll i=0;i<n;i++){cin>>a[i];}\r\n#define couta(a,n) for(ll i=0;i<n;i++){cout<<a[i]<<' ';}\r\nint main()\r\n{\r\nfast;\r\nll t;\r\ncin >> t;\r\nwhile(t--){\r\n    ll n,m;\r\n    cin >> n >>m;\r\n    if (m==n && (m%2!=0 || n%2!=0))cout <<\"Tonya\" <<endl;\r\n    else cout << \"Burenka\" << endl;\r\n}\r\nreturn 0;\r\n}\r\n",
        "fixed_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long int\r\n#define ld long double\r\n#define fon for(i=0;i<n;i++)\r\n#define foj for(j=0;j<n;j++)\r\n#define f(i, x, n) for (i = x; i < n; i++)\r\n#define bf(i,z,n) for(ll i=z;i>=n;i--)\r\n#define PI 3.141592653589793\r\n#define maxa *max_element\r\n#define mina *min_element\r\n#define pb push_back\r\n#define fast ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\r\n#define cina(a,n) for(ll i=0;i<n;i++){cin>>a[i];}\r\n#define cin1 for(ll i=0;i<n;i++){cin>>a[i];}\r\n#define couta(a,n) for(ll i=0;i<n;i++){cout<<a[i]<<' ';}\r\nint main()\r\n{\r\nfast;\r\nll t;\r\ncin >> t;\r\nwhile(t--){\r\n    ll n,m;\r\n    cin >> n >>m;\r\n    if(abs(n-m)%2==0)cout << \"Tonya\"  <<endl ; \r\n    else cout << \"Burenka\" <<endl;\r\n}\r\nreturn 0;\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic android.view.View onCreateInputView() {\n    super.onCreateInputView();\n    kv = ((android.inputmethodservice.KeyboardView) (getLayoutInflater().inflate(R.layout.keyboard, null)));\n    keyboard = new android.inputmethodservice.Keyboard(this, R.xml.qwerty);\n    kv.setKeyboard(keyboard);\n    kv.setOnKeyboardActionListener(this);\n    analyzer = new com.example.mobile.typinganalyzer.KeyboardAnalyzer(this.getApplicationContext());\n    android.util.Log.i(\"create\", \"creating keyboard\");\n    android.widget.Toast.makeText(this, \"creating keyboard\", Toast.LENGTH_SHORT).show();\n    return kv;\n}",
        "fixed_code": "@java.lang.Override\npublic android.view.View onCreateInputView() {\n    super.onCreateInputView();\n    kv = ((android.inputmethodservice.KeyboardView) (getLayoutInflater().inflate(R.layout.keyboard, null)));\n    keyboard = new android.inputmethodservice.Keyboard(this, R.xml.qwerty);\n    kv.setKeyboard(keyboard);\n    kv.setOnKeyboardActionListener(this);\n    analyzer = new com.example.mobile.typinganalyzer.KeyboardAnalyzer(this.getApplicationContext());\n    return kv;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n    int n;\n    cin>>n;\n    int ara[n];\n    for(int i=0;i<n;i++)cin>>ara[i];\n    int c=0;\n    sort(ara,ara+n,greater<int>());\n    for(int i=0;i<n;i++)\n    {\n       // cout<<ara[i]<<endl;\n\n        if(ara[i]-ara[i+1]==1)\n        {\n\n            c++;\n            break;\n\n        }\n\n\n    }\n    //cout<<c<<endl;\n    if(c==0)cout<<\"1\"<<endl;\n    else cout<<\"2\"<<endl;\n\n\n    }\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n    int n;\n    cin>>n;\n    int ara[n];\n    for(int i=0;i<n;i++)cin>>ara[i];\n    int c=0;\n    sort(ara,ara+n,greater<int>());\n    for(int i=0;i<n-1;i++)\n    {\n       // cout<<ara[i]<<endl;\n\n        if(ara[i]-ara[i+1]==1)\n        {\n\n            c++;\n            break;\n\n        }\n\n\n    }\n    //cout<<c<<endl;\n    if(c==0)cout<<\"1\"<<endl;\n    else cout<<\"2\"<<endl;\n\n\n    }\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint a,b,x;\n\tcin>>a>>b>>x;\n\tcout<<(a+b)/x<<\" \";\n\tif(b>=(x-a%x)&&a%x)\n\t\tcout<<(x-a%x)<<endl;\n\telse\n\t\tcout<<0<<endl;\n\treturn 0;\n}",
        "fixed_code": "#include<iostream>\nusing namespace std;\n#define ull long long\null x,y,n,m;\null ans=0;\null rez=0;\nint main(){\n    cin>>x>>y>>n;\n    ull sum=(x+y);\n    ull k=max(x%n,y%n);\n    if(x%n+y%n>=n)rez=n-k;\n    cout<<sum/n<<\" \"<<rez;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <map>\n#include <iostream>\n#include <iterator>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <vector>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define ls now << 1\n// #define rs now << 1 | 1\n// #define PB push_back\n// #define MP make_pair\n// #define double long double\n#define int long long\n// #define us unsigned\n// #define LL long long\n// #define double long double\nconst int N = 1e6;\n// const int M = ;\n#define re register\n// const int mod = 998244353;\n// const int inf = 0x7fffffff;\n// const double inf_double = 1e4;\n// const double eps = 1e-4;\n// inline char nc()\n// {\n//     static char buf[1000000], *p1 = buf, *p2 = buf;\n//     return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;\n// }\n// #define getchar nc\ninline int read()\n{\n    register int s = 0;\n    register bool neg = 0;\n    register char c = getchar();\n    for (; c < '0' || c > '9'; c = getchar())\n        neg |= (c == '-');\n    for (; c >= '0' && c <= '9'; s = s * 10 + (c ^ 48), c = getchar())\n        ;\n    return (neg ? -s : s);\n}\n\nint a, b, c, s[N + 10], bel[N + 10], p[N + 10], ans, Ans[N + 10];\nstruct node\n{\n    int l, r, id;\n    bool operator<(const node &t) const\n    {\n        return (bel[l] ^ bel[t.l]) ? bel[l] < bel[t.l] : r < t.r;\n    }\n} ask[N + 10];\n\ninline void add(int n)\n{\n    ans += p[n ^ c];\n    p[n]++;\n}\n\ninline void del(int n)\n{\n    p[n]--;\n    ans -= p[n ^ c];\n}\n\nsigned main()\n{\n    a = read();\n    b = read();\n    c = read();\n    int k = (int)(sqrt(a));\n    for (int i = 1; i <= a; i++)\n        bel[i] = (i - 1) / k + 1;\n    for (int i = 1; i <= a; i++)\n        s[i] = (read() ^ s[i - 1]);\n    for (int i = 1; i <= b; i++)\n    {\n        ask[i].l = read() - 1;\n        ask[i].r = read();\n        ask[i].id = i;\n    }\n    sort(ask + 1, ask + b + 1);\n    p[0] = 1;\n    int l = 0, r = 0;\n    for (int i = 1; i <= b; i++)\n    {\n        while (l < ask[i].l)\n            del(s[l++]);\n        while (l > ask[i].l)\n            add(s[--l]);\n        while (r < ask[i].r)\n            add(s[++r]);\n        while (r > ask[i].r)\n            del(s[r--]);\n        Ans[ask[i].id] = ans;\n    }\n    for (int i = 1; i <= b; i++)\n        printf(\"%lld\\n\", Ans[i]);\n    return 0;\n}",
        "fixed_code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <map>\n#include <iostream>\n#include <iterator>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <vector>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define ls now << 1\n// #define rs now << 1 | 1\n// #define PB push_back\n// #define MP make_pair\n// #define double long double\n#define int long long\n// #define us unsigned\n// #define LL long long\n// #define double long double\nconst int N = 2e6;\n// const int M = ;\n#define re register\n// const int mod = 998244353;\n// const int inf = 0x7fffffff;\n// const double inf_double = 1e4;\n// const double eps = 1e-4;\n// inline char nc()\n// {\n//     static char buf[1000000], *p1 = buf, *p2 = buf;\n//     return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;\n// }\n// #define getchar nc\ninline int read()\n{\n    register int s = 0;\n    register bool neg = 0;\n    register char c = getchar();\n    for (; c < '0' || c > '9'; c = getchar())\n        neg |= (c == '-');\n    for (; c >= '0' && c <= '9'; s = s * 10 + (c ^ 48), c = getchar())\n        ;\n    return (neg ? -s : s);\n}\n\nint a, b, c, s[N + 10], bel[N + 10], p[N + 10], ans, Ans[N + 10];\nstruct node\n{\n    int l, r, id;\n    bool operator<(const node &t) const\n    {\n        return (bel[l] ^ bel[t.l]) ? bel[l] < bel[t.l] : r < t.r;\n    }\n} ask[N + 10];\n\ninline void add(int n)\n{\n    ans += (long long)p[(n ^ c)];\n    p[n]++;\n}\n\ninline void del(int n)\n{\n    p[n]--;\n    ans -= (long long)p[(n ^ c)];\n}\n\nsigned main()\n{\n    a = read();\n    b = read();\n    c = read();\n    int k = (int)(sqrt(a));\n    for (int i = 1; i <= a; i++)\n        bel[i] = (i - 1) / k + 1;\n    for (int i = 1; i <= a; i++)\n        s[i] = (read() ^ s[i - 1]);\n    for (int i = 1; i <= b; i++)\n    {\n        ask[i].l = read() - 1;\n        ask[i].r = read();\n        ask[i].id = i;\n    }\n    sort(ask + 1, ask + b + 1);\n    p[0] = 1;\n    int l = 0, r = 0;\n    for (int i = 1; i <= b; i++)\n    {\n        for (; l < ask[i].l; l++)\n            del(s[l]);\n        for (; l > ask[i].l; l--)\n            add(s[l - 1]);\n        for (; r < ask[i].r; r++)\n            add(s[r + 1]);\n        for (; r > ask[i].r; r--)\n            del(s[r]);\n        Ans[ask[i].id] = ans;\n    }\n    for (int i = 1; i <= b; i++)\n        printf(\"%lld\\n\", Ans[i]);\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>  \nusing namespace std;  \nconst int maxn = 1005;  \nconst int maxm = 10;  \nint n,m,f[maxm][maxm][maxn][maxn],lg[maxn];  \nvoid Build_2D_Sparse_Table(int n, int m){  \n    int i, j, k1, k2;  \n  \n    for(i = 2; i < maxn; i++)  \n        lg[i] = 1 + lg[i/2];  \n  \n  \t//相当于第一次维护一维的，为第二次预备 \n    \n        for(k2 = 1; (1 << k2) <= m; k2++)  //第 2k2次方列 \n    \tfor(i = 1; i <= n; i++)  //第i行 \n            for(j = 1; j <= m - (1 << k2) + 1; j++)  //第j列 \n                f[0][k2][i][j] = max(f[0][k2 - 1][i][j], f[0][k2 - 1][i][j + (1 << (k2 - 1))]);  \n  \t//处理第一维的时候因为 \n    \n        for(i = 1; i <= n - (1 << k1) + 1; i++)  //枚举第i行 \n        for(k1 = 1; (1 << k1) <= n; k1++)  //枚举覆盖的第k1次方行 \n                for(j = 1; j <= m - (1 << k2) + 1; j++)  //枚举列 \n                for(k2 = 0; (1 << k2) <= m; k2++)  //枚举覆盖的第k2次方列 ，从0开始 \n                    f[k1][k2][i][j] = max(f[k1 - 1][k2][i][j], f[k1 - 1][k2][i + (1 << (k1 - 1))][j]);  \n}  \n  \nint Query(int x1, int y1, int x2, int y2){  \n    int k1 = lg[x2 - x1 + 1], k2 = lg[y2 - y1 + 1];  \n    x2 = x2 - (1 << k1) + 1;  \n    y2 = y2 - (1 << k2) + 1;  \n    return max(max(f[k1][k2][x1][y1],f[k1][k2][x1][y2]),max(f[k1][k2][x2][y1],f[k1][k2][x2][y2]));  \n}  \nint main()  \n{  \n    scanf(\"%d%d\",&n,&m);  \n    for(int i=1;i<=n;i++)  \n    {  \n        for(int j=1;j<=m;j++)  \n        {  \n            int x;scanf(\"%d\",&x);  \n            if(x){  \n                f[0][0][i][j]=min(f[0][0][i-1][j],min(f[0][0][i][j-1],f[0][0][i-1][j-1]))+1;  \n            }  \n        }  \n    }  \n    Build_2D_Sparse_Table(n,m);  \n    int q;scanf(\"%d\",&q);  \n    while(q--)  \n    {  \n        int x1,x2,y1,y2;  \n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);  \n        int l=0,r=min(x2-x1,y2-y1)+1,ans=0;  \n        while(l<=r)  //二分正方形长度 \n        {  \n            int mid=(l+r)/2;  \n            if(Query(x1+mid-1,y1+mid-1,x2,y2)>=mid)l=mid+1,ans=mid; //又一个二分姿势 \n            else r=mid-1;  \n        }  \n        cout<<ans<<endl;  \n    }  \n}  ",
        "fixed_code": "#include<bits/stdc++.h>  \nusing namespace std;  \nconst int maxn = 1005;  \nconst int maxm = 10;  \nint n,m,f[maxm][maxm][maxn][maxn],lg[maxn];  \nvoid Build_2D_Sparse_Table(int n, int m){  \n    int i, j, k1, k2;  \n  \n    for(i = 2; i < maxn; i++)  \n        lg[i] = 1 + lg[i/2];  \n  \n  \t//相当于第一次维护一维的，为第二次预备 \n    for(i = 1; i <= n; i++)  //第i行 \n        for(k2 = 1; (1 << k2) <= m; k2++)  //第 2k2次方列 \n            for(j = 1; j <= m - (1 << k2) + 1; j++)  //第j列 \n                f[0][k2][i][j] = max(f[0][k2 - 1][i][j], f[0][k2 - 1][i][j + (1 << (k2 - 1))]);  \n  \t//处理第一维的时候因为 \n    for(k1 = 1; (1 << k1) <= n; k1++)  //枚举覆盖的第k1次方行 \n        for(i = 1; i <= n - (1 << k1) + 1; i++)  //枚举第i行 \n            for(k2 = 0; (1 << k2) <= m; k2++)  //枚举覆盖的第k2次方列 ，从0开始 \n                for(j = 1; j <= m - (1 << k2) + 1; j++)  //枚举列 \n                    f[k1][k2][i][j] = max(f[k1 - 1][k2][i][j], f[k1 - 1][k2][i + (1 << (k1 - 1))][j]);  \n}  \n  \nint Query(int x1, int y1, int x2, int y2){  \n    int k1 = lg[x2 - x1 + 1], k2 = lg[y2 - y1 + 1];  \n    x2 = x2 - (1 << k1) + 1;  \n    y2 = y2 - (1 << k2) + 1;  \n    return max(max(f[k1][k2][x1][y1],f[k1][k2][x1][y2]),max(f[k1][k2][x2][y1],f[k1][k2][x2][y2]));  \n}  \nint main()  \n{  \n    scanf(\"%d%d\",&n,&m);  \n    for(int i=1;i<=n;i++)  \n    {  \n        for(int j=1;j<=m;j++)  \n        {  \n            int x;scanf(\"%d\",&x);  \n            if(x){  \n                f[0][0][i][j]=min(f[0][0][i-1][j],min(f[0][0][i][j-1],f[0][0][i-1][j-1]))+1;  \n            }  \n        }  \n    }  \n    Build_2D_Sparse_Table(n,m);  \n    int q;scanf(\"%d\",&q);  \n    while(q--)  \n    {  \n        int x1,x2,y1,y2;  \n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);  \n        int l=0,r=min(x2-x1,y2-y1)+1,ans=0;  \n        while(l<=r)  //二分正方形长度 \n        {  \n            int mid=(l+r)/2;  \n            if(Query(x1+mid-1,y1+mid-1,x2,y2)>=mid)l=mid+1,ans=mid; //又一个二分姿势 \n            else r=mid-1;  \n        }  \n        cout<<ans<<endl;  \n    }  \n}  ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "def nypb(m,n,l2):\r\n    ms=n-1\r\n    mv=[0]*(n)\r\n    for i in range(m):\r\n        cm=0\r\n        for j in range(n):\r\n            mv[j]=max(mv[j],l2[i][j])\r\n    ans=mv[0]\r\n    for x in range(len(mv)):\r\n        ans=min(ans,mv[x])\r\n    if m<=n-1:\r\n        return ans\r\n    cmm=max(l2[0])\r\n    for i in range(1,m):\r\n        cmm=max(cmm,max(l2[i]))\r\n    ans=min(ans,cmm)\r\n    return ans\r\nt=int(input())\r\nls=[]\r\nl=[]\r\n_=str(input())\r\nfor x in range(t):\r\n    s=str(input())\r\n    ls.append(s)\r\n    l1=[]\r\n    for y in range(int(s.split(' ',)[0])):\r\n        s1=str(input())\r\n        l1.append(s1)\r\n    l.append(l1)\r\n    if x==t-1:\r\n        break\r\n    _=str(input())\r\nla=[]\r\nfor i in range(len(l)):\r\n    m,n=int(ls[i].split(' ',)[0]),int(ls[i].split(' ',)[1])\r\n    l2=[]\r\n    for x in l[i]:\r\n        y=x.split(' ',)\r\n        l3=[]\r\n        for z in y:\r\n            l3.append(int(z))\r\n        l2.append(l3)\r\n    ans=nypb(m,n,l2)\r\n    la.append(ans)\r\nfor x in la:\r\n    print(x)",
        "fixed_code": "def nypb(m,n,l2):\r\n    ms=n-1\r\n    mv=[0]*(n)\r\n    for i in range(m):\r\n        cm=0\r\n        for j in range(n):\r\n            mv[j]=max(mv[j],l2[i][j])\r\n    ans=mv[0]\r\n    for x in range(len(mv)):\r\n        ans=min(ans,mv[x])\r\n    if m<=n-1:\r\n        return ans\r\n    cmm=0\r\n    mx1=[]\r\n    mx2=[]\r\n    for i in range(m):\r\n        l5=l2[i].copy()\r\n        l5.sort()\r\n        mx1.append(l5[-1])\r\n        mx2.append(l5[-2])\r\n    ans=min(ans,max(mx1),max(mx2))\r\n    return ans\r\nt=int(input())\r\nls=[]\r\nl=[]\r\n_=str(input())\r\nfor x in range(t):\r\n    s=str(input())\r\n    ls.append(s)\r\n    l1=[]\r\n    for y in range(int(s.split(' ',)[0])):\r\n        s1=str(input())\r\n        l1.append(s1)\r\n    l.append(l1)\r\n    if x==t-1:\r\n        break\r\n    _=str(input())\r\nla=[]\r\nfor i in range(len(l)):\r\n    m,n=int(ls[i].split(' ',)[0]),int(ls[i].split(' ',)[1])\r\n    l2=[]\r\n    for x in l[i]:\r\n        y=x.split(' ',)\r\n        l3=[]\r\n        for z in y:\r\n            l3.append(int(z))\r\n        l2.append(l3)\r\n    ans=nypb(m,n,l2)\r\n    la.append(ans)\r\nfor x in la:\r\n    print(x)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <stdlib.h>\n#include <stack>\n#include <numeric>\ntypedef long long ll;\n#define MAX 100005\nusing namespace std;\nint n,m,k;\n#define INF 2147483647\n#define G 9.8\nbool debug = false;\n\n\nint x[MAX],b,c;\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i=0;i<n;i++) scanf(\"%d\", x+i);\n    int ans = 2;\n    if (n==1) puts(\"0\");\n    else {\n        // save 0 and 1\n        if ((x[0]==0&&x[1]==0) || (x[0]!=0 &&x[1] % x[0] == 0)) { // remain\n            b = x[0]==0 ? 0: x[1] / x[0];\n            int last = x[1];\n            ans = 0;\n            for (int j=2;j<n;j++) {\n                if(x[j] == last * b) last = x[j];\n                else if (ans==0) { ans=1; }\n                else {ans = 2; break;}\n            }\n        }\n        if (ans == 2) {\n            ans=1;\n            if (n > 2) {\n                ans = 2;\n                // get rid of x[0]\n                if ((x[2]==0&&x[1]==0) || (x[1]!=0 &&x[2] % x[1] == 0)) { // remain\n                    b = x[1]==0 ? 0: x[2] / x[1];\n                    int last = x[2];\n                    ans = 1;\n                    for (int j=3;j<n;j++) {\n                        if(x[j] == last * b) last = x[j];\n                        else {ans = 2; break;}\n                    }\n                }\n                if (ans == 2) {\n                    // try to remove x[1]\n                    if ((x[2]==0&&x[0]==0) || (x[0]!=0 &&x[2] % x[0] == 0)) { // remain\n                        b = x[0]==0 ? 0: x[2] / x[0];\n                        int last = x[2];\n                        ans = 1;\n                        for (int j=3;j<n;j++) {\n                            if(x[j] == last * b) last = x[j];\n                            else {ans = 2; break;}\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <stdlib.h>\n#include <stack>\n#include <numeric>\ntypedef long long ll;\n#define MAX 100005\nusing namespace std;\nint n,m,k;\n#define INF 2147483647\n#define G 9.8\nbool debug = false;\n\n\nint x[MAX];\ndouble b;\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i=0;i<n;i++) scanf(\"%d\", x+i);\n    int ans = 2;\n    if (n==1) puts(\"0\");\n    else {\n        // save 0 and 1\n        if ((x[0]==0&&x[1]==0) || x[0]!=0) { // remain\n            b = x[0]==0 ? 0: (double)x[1] / x[0];\n            double last = x[1];\n            ans = 0;\n            for (int j=2;j<n;j++) {\n                if(fabs(x[j] - last * b) < 1e-6) last = x[j];\n                else if (ans==0) { ans=1; }\n                else {ans = 2; break;}\n            }\n        }\n        if (ans == 2) {\n            ans=1;\n            if (n > 2) {\n                ans = 2;\n                // get rid of x[0]\n                if ((x[2]==0&&x[1]==0) || (x[1]!=0)) { // remain\n                    b = x[1]==0 ? 0: (double)x[2] / x[1];\n                    double last = x[2];\n                    ans = 1;\n                    for (int j=3;j<n;j++) {\n                        if(fabs(x[j] - last * b) < 1e-6) last = x[j];\n                        else {ans = 2; break;}\n                    }\n                }\n                if (ans == 2) {\n                    // try to remove x[1]\n                    if ((x[2]==0&&x[0]==0) || (x[0]!=0)) { // remain\n                        b = x[0]==0 ? 0: (double)x[2] / x[0];\n                        double last = x[2];\n                        ans = 1;\n                        for (int j=3;j<n;j++) {\n                            if(fabs(x[j] - last * b) < 1e-6) last = x[j];\n                            else {ans = 2; break;}\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define modM %1000000007\n\n// bool canReach(int src, int dest,int *dp , unordered_set<int>& dirty){\n//     if(dirty.count(src) > 0)\n//         return false;\n//     // base case\n//     if(src == dest)\n//         return true;\n    \n//     if(dp[src] != -1)\n//         return dp[src] ;\n    \n//     bool ans = false;\n    \n//     if(dirty.count(src+1) == 0 && src +1 <= dest)\n//         ans = ans || canReach(src+1 , dest, dp , dirty);\n//     if(dirty.count(src+2) == 0 && src +2 <= dest)\n//         ans = ans || canReach(src+2 , dest, dp , dirty);\n//     if(dirty.count(src+3) == 0 && src +3 <= dest)\n//         ans = ans || canReach(src+3 , dest, dp , dirty);\n    \n//     return dp[src] = ans;\n// }\n\nvoid solve(){\n    int n , m ;\n    cin>>n>>m;\n\n    vector<int> dirty ;\n    for(int i =0 ;i < m;i++){\n        int a ;\n        cin>>a;\n        dirty.push_back(a);\n    }\n    sort(dirty.begin() , dirty.end());\n    \n    int longest = 0;\n    for(int i =0 ;i < m;i++){\n        int st = i ;\n        while(i+1 < m && dirty[i+1] == dirty[i] + 1)\n            i++;\n        longest = max(longest , i - st+1);\n        if(longest >= 3)\n            break ;\n    }\n    \n    if(longest >=3 || dirty[m-1] == n || (m>0 && dirty[0] == 1) )\n        cout<<\"NO\"    ;\n    else cout<<\"YES\";\n    \n}\nint main()\n{    \n    solve();\n    return 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define modM %1000000007\n\n// bool canReach(int src, int dest,int *dp , unordered_set<int>& dirty){\n//     if(dirty.count(src) > 0)\n//         return false;\n//     // base case\n//     if(src == dest)\n//         return true;\n    \n//     if(dp[src] != -1)\n//         return dp[src] ;\n    \n//     bool ans = false;\n    \n//     if(dirty.count(src+1) == 0 && src +1 <= dest)\n//         ans = ans || canReach(src+1 , dest, dp , dirty);\n//     if(dirty.count(src+2) == 0 && src +2 <= dest)\n//         ans = ans || canReach(src+2 , dest, dp , dirty);\n//     if(dirty.count(src+3) == 0 && src +3 <= dest)\n//         ans = ans || canReach(src+3 , dest, dp , dirty);\n    \n//     return dp[src] = ans;\n// }\n\nvoid solve(){\n    int n , m ;\n    cin>>n>>m;\n\n    vector<int> dirty ;\n    for(int i =0 ;i < m;i++){\n        int a ;\n        cin>>a;\n        dirty.push_back(a);\n    }\n    sort(dirty.begin() , dirty.end());\n    \n    int longest = 0;\n    for(int i =0 ;i < m;i++){\n        int st = i ;\n        while(i+1 < m && dirty[i+1] == (dirty[i] + 1))\n            i++;\n        longest = max(longest , i - st+1);\n        if(longest >= 3)\n            break ;\n    }\n    \n    if(longest >=3 || (m > 0 && dirty[m-1] == n) || (m>0 && dirty[0] == 1) )\n        cout<<\"NO\"    ;\n    else cout<<\"YES\";\n    \n}\nint main()\n{    \n    solve();\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\npair< pair<int , int>  ,  int > Money_mem_id [1001] ;\nvector<pair<int ,int > > ID_Ans ;\nvector<pair<int , int > >Table;\nint n , Available[1001], k  , Money , Num ,  s ;\nint main()\n{\n    cin>>n;\n    for(int i = 0 ; i<n ; i++ )\n    {\n        cin>>Money_mem_id[i].first.second>>Money_mem_id[i].first.first;\n        Money_mem_id[i].second = i+1 ;\n    }\n    sort(Money_mem_id, Money_mem_id+ sizeof Money_mem_id / sizeof *Money_mem_id);\n    reverse(Money_mem_id, Money_mem_id+ sizeof Money_mem_id / sizeof *Money_mem_id);\n    cin>>k ;\n    for(int i = 0 ; i< k ; i++)\n    {\n        cin>>Available[i];\n        Table.push_back(make_pair(Available[i] , i + 1 ) )   ;\n    }\n    sort(Table.begin() , Table.end()) ;\n    sort(Available , Available + k);\n    for(int i = 0 ; i<n ; i++)\n    {\n       int pos = lower_bound(Available , Available + k , Money_mem_id[i].first.second ) - Available ;\n        if(Available [pos] >= Money_mem_id[i].first.second && Available[pos]!=-1 &&ID_Ans.size()<k)\n        {\n            ID_Ans.push_back(make_pair( Money_mem_id[i].second, Table[pos].second ) ) ;\n            s+=Money_mem_id[i].first.first ;\n            Available[pos] = -1 ;\n        }\n    }\n    sort(ID_Ans.begin() , ID_Ans.end());\n    cout<<ID_Ans.size()<<' '<<s<<endl;\n    for(int i = 0 ; i< ID_Ans.size() ; i++ )cout<<ID_Ans[i].first<<\" \"<<ID_Ans[i].second<<endl;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\npair< pair<int , int>  ,  int > Money_mem_id [1001] ;\nvector<pair<int ,int > > ID_Ans ;\nvector<pair<int , int > >Table;\nint n , k  , Money , Num ,  s , x  ;\nint main()\n{\n    cin>>n;\n    for(int i = 0 ; i<n ; i++ )\n    {\n        cin>>Money_mem_id[i].first.second>>Money_mem_id[i].first.first;\n        Money_mem_id[i].second = i+1 ;\n    }\n    sort(Money_mem_id, Money_mem_id+ sizeof Money_mem_id / sizeof *Money_mem_id);\n    reverse(Money_mem_id, Money_mem_id+ sizeof Money_mem_id / sizeof *Money_mem_id);\n   // cout<<endl<<endl;for(int  i =  0 ;i<n ; i++)cout<<Money_mem_id[i].first.first<<' '<<Money_mem_id[i].first.second<<\" \"<<Money_mem_id[i].second<<endl;\n    cin>>k ;\n    for(int i = 0 ; i< k ; i++)\n    {\n        cin>>x;\n        Table.push_back(make_pair( x , i + 1 ) )   ;\n    }\n    sort(Table.begin() , Table.end()) ; //  for(int i = 0 ; i<k ; i++)cout<<Table[i].first<<' '<<Table[i].second<<endl;\n    for(int i = 0 ; i<n ; i++)\n    {\n        for(int j = 0 ; j< k ; j++)\n        {\n            if(Table[j].first >= Money_mem_id[i].first.second && Table[j].first != -1 )\n            {\n                ID_Ans.push_back(make_pair( Money_mem_id[i].second, Table[j].second ) ) ;\n                s+=Money_mem_id[i].first.first ;\n                Table[j].first = -1 ;\n                break;\n            }\n        }\n    }\n    sort(ID_Ans.begin() , ID_Ans.end());\n    cout<<ID_Ans.size()<<' '<<s<<endl;\n    for(int i = 0 ; i< ID_Ans.size() ; i++ )cout<<ID_Ans[i].first<<\" \"<<ID_Ans[i].second<<endl;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint gcd(int a, int b){\n  if (b == 0)\n    return a;\n  return gcd(b, a % b);\n}\n \nint lcm(int a, int b){\n    return (a / gcd(a, b)) * b;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int rez = 0;\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            if(lcm(i,j)/gcd(i,j) <= 3){\n                rez++;\n            }\n        }\n    }\n    cout << rez << endl;\n}\n     \nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);    \n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++){\n        solve();\n    }\n    return 0;\n}\n     \n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid solve(){\n    int n;\n    cin >> n;\n    cout << n + 2*((n/2)+(n/3)) << \"\\n\";\n}\n     \nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);    \n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++){\n        solve();\n    }\n    return 0;\n}\n     \n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\nint main(){\r\n    ll t;\r\n    cin>>t;\r\n    while(t--){\r\n        ll n;\r\n        cin>>n;\r\n        ll arr[n];\r\n        ll sum1=0;\r\n        for(int i=0;i<n;i++){\r\n            cin>>arr[i];\r\n            if(arr[i]%2==0){\r\n                sum1++;\r\n            }\r\n            else{\r\n                sum2++;\r\n            }\r\n        }\r\n        cout<<min(sum1,sum2);\r\n    }\r\n}",
        "fixed_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\nint main(){\r\n    ll t;\r\n    cin>>t;\r\n    while(t--){\r\n        ll n;\r\n        cin>>n;\r\n        ll arr[n];\r\n        ll sum1=0;\r\n        ll sum2=0;\r\n        for(int i=0;i<n;i++){\r\n            cin>>arr[i];\r\n            if(arr[i]%2==0){\r\n                sum1++;\r\n            }\r\n            else{\r\n                sum2++;\r\n            }\r\n        }\r\n        cout<<min(sum1,sum2)<<endl;\r\n    }\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define ll long long\n#define MOD (ll)(1e9+7)\nusing namespace std;\nint main(void)\n{\n   ll n;\n   cin>>n;\n   if(n==1)\n   {\n   \t\tcout<<\"NO\\n\";\n   \t\treturn 0;\n   }\n   vector<ll> v(2*n+1);\n   ll x=n;\n   for(ll i=0;i<n;i++)\n   {\n   \tif(i%2==0)\n   \t{\n   \t\tv[2*n-i]=2*x;\n   \t\tv[n-i]=(2*x-1);\n   \t}\n   \telse\n   \t{\n   \t\tv[2*n-i]=2*x-1;\n   \t\tv[n-i]=2*x;\n   \t}\n   \t\tx--;\n   }\n   for(ll i=2;i<=2*n;i++)\n   \tv[i]+=v[i-1];\n   ll s1=v[n],s2=v[n+1]-v[1];\n   for(ll i=3;i<=n+1;i++)\n   {\n   \t\tll x=v[i+n-1]-v[i-1];\n   \t\tif(x==s1||x==s2)\n   \t\t\tcontinue;\n   \t\telse\n   \t\t{\n   \t\t\tcout<<\"NO\\n\";\n   \t\t\treturn 0;\n   \t\t}\n   }\n   for(ll i=n+2;i<=2*n;i++)\n   {\n   \t\tll x=v[2*n]-v[i-1];\n   \t\tll y=i-n-1;\n   \t\tx+=v[y];\n   \t\tif(x==s1||x==s2)\n   \t\t\tcontinue;\n   \t\telse\n   \t\t{\n   \t\t\tcout<<\"NO\\n\";\n   \t\t\treturn 0;\n   \t\t}\n   }\n   cout<<\"YES\\n\";\n   for(ll i=1;i<=2*n;i++)\n   {\n   \tif(i>1)\n   \t\tcout<<v[i]-v[i-1]<<\" \";\n   \telse\n   \t\tcout<<v[i]<<\" \";\n   }\n   cout<<endl;\n   return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#define ll long long\n#define MOD (ll)(1e9+7)\nusing namespace std;\nint main(void)\n{\n   ll n;\n   cin>>n;\n   vector<ll> v(2*n+1);\n   ll x=n;\n   for(ll i=0;i<n;i++)\n   {\n   \tif(i%2==0)\n   \t{\n   \t\tv[2*n-i]=2*x;\n   \t\tv[n-i]=(2*x-1);\n   \t}\n   \telse\n   \t{\n   \t\tv[2*n-i]=2*x-1;\n   \t\tv[n-i]=2*x;\n   \t}\n   \t\tx--;\n   }\n   for(ll i=2;i<=2*n;i++)\n   \tv[i]+=v[i-1];\n   ll s1=v[n],s2=v[n+1]-v[1];\n   for(ll i=3;i<=n+1;i++)\n   {\n   \t\tll x=v[i+n-1]-v[i-1];\n   \t\tif(x==s1||x==s2)\n   \t\t\tcontinue;\n   \t\telse\n   \t\t{\n   \t\t\tcout<<\"NO\\n\";\n   \t\t\treturn 0;\n   \t\t}\n   }\n   for(ll i=n+2;i<=2*n;i++)\n   {\n   \t\tll x=v[2*n]-v[i-1];\n   \t\tll y=i-n-1;\n   \t\tx+=v[y];\n   \t\tif(x==s1||x==s2)\n   \t\t\tcontinue;\n   \t\telse\n   \t\t{\n   \t\t\tcout<<\"NO\\n\";\n   \t\t\treturn 0;\n   \t\t}\n   }\n   cout<<\"YES\\n\";\n   for(ll i=1;i<=2*n;i++)\n   {\n   \tif(i>1)\n   \t\tcout<<v[i]-v[i-1]<<\" \";\n   \telse\n   \t\tcout<<v[i]<<\" \";\n   }\n   cout<<endl;\n   return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <queue>\r\n#include <vector>\r\n#include <string>\r\n#include <climits>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <unordered_map>\r\nusing namespace std;\r\n\r\ntypedef long long                                        ll;\r\ntypedef long double                                      ld;\r\ntypedef pair <int, int>                                  pii;\r\ntypedef pair <pii, int>                                  ppi;\r\ntypedef pair <int, pii>                                  pip;\r\ntypedef pair <pii, pii>                                  ppp;\r\ntypedef pair <ll, ll>                                    pll;\r\ntypedef vector <int>                                     vi;\r\ntypedef vector <long long>                               vll;\r\n\r\n#define mod                                              (int)(1e9+7)\r\n#define pb                                               push_back\r\n#define mp                                               make_pair\r\n#define sortI(a)                                         sort(a.begin(),a.end())\r\n#define sortD(a)                                         sort(a.rbegin(),a.rend())\r\n#define print(a)                                         for(int i=0;i<a.size();i++) {cout<<a[i]<<\" \";} cout<<endl\r\n\r\nvoid Primes(vector<int>& a){\r\n    int size = a.size();\r\n    for(int i=0;i<size;i++) a[i] = i+1;\r\n    vector<int> b;\r\n    vector<bool> c(size,true);\r\n    c[0] = false;\r\n    int index = 1;\r\n    while(index < size){\r\n        if(c[index] == true){\r\n            int temp = a[index];\r\n            for(int i=temp*temp;i<=size;i+=temp) c[i-1] = false;\r\n        }\r\n        index++;\r\n    }\r\n    for(int i=0;i<size;i++) if(c[i] == true) b.push_back(i+1);\r\n    a = b;\r\n    b.clear();\r\n    c.clear();\r\n}\r\n\r\n/**************************************************************************************************************************/\r\n\r\n\r\nvoid Solve(){\r\n    int n,k;\r\n    cin>>n>>k;\r\n    vector<ll> a(n);\r\n    for(int i=0;i<n;i++) cin>>a[i];\r\n    for(int i=1;i<n;i++){\r\n        for(int j=0;j<i;j++){\r\n            if(abs(a[i]-a[j]) == k){\r\n                cout<<\"YES\"<<endl;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    cout<<\"NO\"<<endl;\r\n}\r\n\r\nint main(){\r\n    ios_base :: sync_with_stdio(0);\r\n\tcin.tie(0);\r\n    int t;\r\n    cin>>t;\r\n    while(t--) Solve();\r\n    return 0;\r\n}",
        "fixed_code": "#include <queue>\r\n#include <vector>\r\n#include <string>\r\n#include <climits>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <unordered_map>\r\nusing namespace std;\r\n\r\ntypedef long long                                        ll;\r\ntypedef long double                                      ld;\r\ntypedef pair <int, int>                                  pii;\r\ntypedef pair <pii, int>                                  ppi;\r\ntypedef pair <int, pii>                                  pip;\r\ntypedef pair <pii, pii>                                  ppp;\r\ntypedef pair <ll, ll>                                    pll;\r\ntypedef vector <int>                                     vi;\r\ntypedef vector <long long>                               vll;\r\n\r\n#define mod                                              (int)(1e9+7)\r\n#define pb                                               push_back\r\n#define mp                                               make_pair\r\n#define sortI(a)                                         sort(a.begin(),a.end())\r\n#define sortD(a)                                         sort(a.rbegin(),a.rend())\r\n#define print(a)                                         for(int i=0;i<a.size();i++) {cout<<a[i]<<\" \";} cout<<endl\r\n\r\nvoid Primes(vector<int>& a){\r\n    int size = a.size();\r\n    for(int i=0;i<size;i++) a[i] = i+1;\r\n    vector<int> b;\r\n    vector<bool> c(size,true);\r\n    c[0] = false;\r\n    int index = 1;\r\n    while(index < size){\r\n        if(c[index] == true){\r\n            int temp = a[index];\r\n            for(int i=temp*temp;i<=size;i+=temp) c[i-1] = false;\r\n        }\r\n        index++;\r\n    }\r\n    for(int i=0;i<size;i++) if(c[i] == true) b.push_back(i+1);\r\n    a = b;\r\n    b.clear();\r\n    c.clear();\r\n}\r\n\r\n/**************************************************************************************************************************/\r\n\r\n\r\nvoid Solve(){\r\n    int n,k;\r\n    cin>>n>>k;\r\n    vector<ll> a(n);\r\n    for(int i=0;i<n;i++) cin>>a[i];\r\n    sort(a.begin(), a.end());\r\n    int i=0, j=n-1;\r\n    for(int i=n-1;i>=0;i--){\r\n        int temp = a[i]-k;\r\n        auto lower = lower_bound(a.begin(), a.end(), temp);\r\n        if(*lower == temp){\r\n            cout<<\"YES\"<<endl;\r\n            return;\r\n        }\r\n    }\r\n    cout<<\"NO\"<<endl;\r\n}\r\n\r\nint main(){\r\n    ios_base :: sync_with_stdio(0);\r\n\tcin.tie(0);\r\n    int t;\r\n    cin>>t;\r\n    while(t--) Solve();\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    long long n;\n    cin>>n;\n    long long f[n+1];\n    f[0]=0;\n    f[1]=1;\n    for(long long i=2;i<n;i++){\n        f[i]=f[i-1]^i;\n    }\n    long long p[n+1];\n    for(long long i=1;i<n;i++){\n        cin>>p[i];\n    }\n    long long out=0;\n    for(long long i=1;i<n+1;i++){\n        if((n/i)%2==1){\n            out=out^f[i-1]^f[n%i]^p[i];\n        }else{\n            out=out^f[n%i]^p[i];\n        }\n    }\n    cout<<out;\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    long long n;\n    cin>>n;\n    long long f[n+1];\n    f[0]=0;\n    f[1]=1;\n    for(long long i=2;i<n+1;i++){\n        f[i]=f[i-1]^i;\n    }\n    long long p[n+1];\n    for(long long i=1;i<n+1;i++){\n        cin>>p[i];\n    }\n    unsigned long long out=0;\n    for(long long i=1;i<n+1;i++){\n        if((n/i)%2==1){\n            out=out^f[i-1]^f[n%i]^p[i];\n        }else{\n            out=out^f[n%i]^p[i];\n        }\n    }\n    cout<<out;\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public java.lang.Object historyChampion(java.lang.Integer nper) {\n    java.util.Date date = new java.util.Date();\n    date.setTime(((date.getTime()) - 40));\n    java.util.List<com.racing.model.po.RecordResult> list = recordResultRepo.selectRacingResult(date, com.racing.util.PageUtil.createPage(1, nper));\n    java.lang.String results = \"|\";\n    if (org.apache.commons.collections.CollectionUtils.isNotEmpty(list)) {\n        for (com.racing.model.po.RecordResult recordResult : list) {\n            results = (results + (recordResult.getFirst())) + \"|\";\n        }\n    }\n    return com.racing.controller.vo.ApiResult.createSuccessReuslt(results);\n}",
        "fixed_code": "public java.lang.Object historyChampion(java.lang.Integer nper) {\n    java.util.Date date = new java.util.Date();\n    date.setTime(((date.getTime()) - 20));\n    java.util.List<com.racing.model.po.RecordResult> list = recordResultRepo.selectRacingResult(date, com.racing.util.PageUtil.createPage(1, nper));\n    java.lang.String results = \"\";\n    if (org.apache.commons.collections.CollectionUtils.isNotEmpty(list)) {\n        for (com.racing.model.po.RecordResult recordResult : list) {\n            results = (results + (recordResult.getFirst())) + \"-\";\n        }\n    }\n    return com.racing.controller.vo.ApiResult.createSuccessReuslt(results.substring(0, ((results.length()) - 1)));\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <memory.h>\n#include <limits>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <iterator>\n#include <bitset>\n\nusing namespace std;\n\ntypedef vector<int>  vint;\ntypedef vector<vint> mint;\n\nint fmax(int* a, int n, int k) {\n    int m = -1;\n    int ret = -1;\n    for (int i = 0; i != n; ++i) {\n        if (a[i] <= k && a[i] > m) {\n            ret = i;\n            m = a[i];\n        }\n    }\n    return ret;\n}\n\nint min_element(int* a, int n) {\n    int mm  = INT_MAX;\n    int ret = -1;\n    for (int i = n-1; i != 0; --i) {\n        if (a[i] < mm) {\n            ret = i;\n            mm = a[i];\n        }\n    }\n    return ret;\n}\n\n\nint main() {\n    //freopen(\"e:\\\\test.txt\", \"rt\", stdin);\n    int v = 0;\n    int a[11];\n    scanf(\"%d\", &v);\n\n    for (int i = 1; i != 10; ++i) {\n        scanf(\"%d\", a+i);\n    }\n\n    int mi = min_element(a, 10);\n    int len = v/a[mi];\n    int rem = v%a[mi];\n    if (len == 0) {\n        printf(\"-1\");return 0;\n    }\n    if (rem == 0) {\n        while (len != 0) {\n            printf(\"%d\", mi); --len;\n        }\n        return 0;\n    }\n\n    std::queue<int> nums;\n    while (rem != 0) {\n        int idx = fmax(a+1, 10, a[mi]+rem) + 1;\n        if (-1 == idx || mi >= idx) break;\n        rem -= (a[idx] - a[mi]);\n        nums.push(idx);\n        --len;\n    }\n\n    while (!nums.empty()) {\n        int n = nums.front();\n        nums.pop();\n        printf(\"%d\", n);\n    }\n\n    while (len > 0) {\n        printf(\"%d\", mi); --len;\n    }\n\n    return 0;\n}",
        "fixed_code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <memory.h>\n#include <limits>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <iterator>\n#include <bitset>\n\nusing namespace std;\n\ntypedef vector<int>  vint;\ntypedef vector<vint> mint;\n\nint fmax(int* a, int n, int k) {\n    for (int i = n-1; i != -1; --i) {\n        if (a[i] <= k) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint min_element(int* a, int n) {\n    int mm  = INT_MAX;\n    int ret = -1;\n    for (int i = n-1; i != 0; --i) {\n        if (a[i] < mm) {\n            ret = i;\n            mm = a[i];\n        }\n    }\n    return ret;\n}\n\n\nint main() {\n    //freopen(\"e:\\\\test.txt\", \"rt\", stdin);\n    int v = 0;\n    int a[11];\n    scanf(\"%d\", &v);\n\n    for (int i = 1; i != 10; ++i) {\n        scanf(\"%d\", a+i);\n    }\n\n    int mi = min_element(a, 10);\n    int len = v/a[mi];\n    int rem = v%a[mi];\n    if (len == 0) {\n        printf(\"-1\");return 0;\n    }\n    if (rem == 0) {\n        while (len != 0) {\n            printf(\"%d\", mi); --len;\n        }\n        return 0;\n    }\n\n    std::queue<int> nums;\n    while (rem != 0) {\n        int idx = fmax(a+1, 9, a[mi]+rem) + 1;\n        if (-1 == idx || mi >= idx) break;\n        rem -= (a[idx] - a[mi]);\n        nums.push(idx);\n        --len;\n    }\n\n    while (!nums.empty()) {\n        int n = nums.front();\n        nums.pop();\n        printf(\"%d\", n);\n    }\n\n    while (len > 0) {\n        printf(\"%d\", mi); --len;\n    }\n\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private void checkTPFocusOnClosingWithKey(org.openqa.selenium.Keys key) {\n    clickToOpenTimePicker();\n    org.openqa.selenium.WebElement activeElement = ((org.openqa.selenium.WebElement) (auraUITestingUtil.getEval(ACTIVE_ELEM)));\n    activeElement.sendKeys(key);\n    waitForElementDisappear(\"TimePicker should not be present\", org.openqa.selenium.By.cssSelector(TIME_PICKER_SEL));\n    activeElement = ((org.openqa.selenium.WebElement) (auraUITestingUtil.getEval(ACTIVE_ELEM)));\n    org.openqa.selenium.WebElement inputTimeBox = findDomElement(org.openqa.selenium.By.cssSelector(TIME_INPUT_BOX_SEL));\n    assertEquals(\"Focus is not on input time box\", activeElement, inputTimeBox);\n}",
        "fixed_code": "private void checkTPFocusOnClosingWithKey(org.openqa.selenium.Keys key) {\n    clickToOpenTimePicker();\n    org.openqa.selenium.WebElement activeElement = findDomElement(org.openqa.selenium.By.xpath(TIME_1200_XPATH));\n    activeElement.sendKeys(key);\n    waitForTimePickerDisappear();\n    activeElement = ((org.openqa.selenium.WebElement) (auraUITestingUtil.getEval(ACTIVE_ELEM)));\n    org.openqa.selenium.WebElement inputTimeBox = findDomElement(org.openqa.selenium.By.cssSelector(TIME_INPUT_BOX_SEL));\n    assertEquals(\"Focus is not on input time box\", activeElement, inputTimeBox);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@org.springframework.web.bind.annotation.RequestMapping(value = \"/eventkeywordsearch\", method = org.springframework.web.bind.annotation.RequestMethod.POST)\npublic org.springframework.http.ResponseEntity<fi.hiit.dime.search.SearchResults> eventSearch(org.springframework.security.core.Authentication auth, @org.springframework.web.bind.annotation.RequestBody\nfi.hiit.dime.search.WeightedKeyword[] input) {\n    fi.hiit.dime.authentication.User user = getUser(auth);\n    try {\n        fi.hiit.dime.search.KeywordSearchQuery query = new fi.hiit.dime.search.KeywordSearchQuery(input);\n        fi.hiit.dime.search.SearchResults results = doEventSearch(query, null, null, (-1), user, WeightType.Tf);\n        return new org.springframework.http.ResponseEntity<fi.hiit.dime.search.SearchResults>(results, org.springframework.http.HttpStatus.OK);\n    } catch (java.io.IOException e) {\n        return new org.springframework.http.ResponseEntity<fi.hiit.dime.search.SearchResults>(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}",
        "fixed_code": "@org.springframework.web.bind.annotation.RequestMapping(value = \"/eventkeywordsearch\", method = org.springframework.web.bind.annotation.RequestMethod.POST)\npublic org.springframework.http.ResponseEntity<fi.hiit.dime.search.SearchResults> eventSearch(org.springframework.security.core.Authentication auth, @org.springframework.web.bind.annotation.RequestBody\nfi.hiit.dime.search.WeightedKeyword[] input) {\n    fi.hiit.dime.authentication.User user = getUser(auth);\n    try {\n        fi.hiit.dime.search.KeywordSearchQuery query = new fi.hiit.dime.search.KeywordSearchQuery(input);\n        fi.hiit.dime.search.SearchResults results = doEventSearch(query, null, null, (-1), user, WeightType.Tf);\n        return new org.springframework.http.ResponseEntity<fi.hiit.dime.search.SearchResults>(results, org.springframework.http.HttpStatus.OK);\n    } catch (java.io.IOException e) {\n        return new org.springframework.http.ResponseEntity<fi.hiit.dime.search.SearchResults>(new fi.hiit.dime.search.SearchResults(e.getMessage()), org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR);\n    } catch (fi.hiit.dime.search.SearchIndex.SearchQueryException e) {\n        return new org.springframework.http.ResponseEntity<fi.hiit.dime.search.SearchResults>(new fi.hiit.dime.search.SearchResults(e.getMessage()), org.springframework.http.HttpStatus.BAD_REQUEST);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nint t;\r\nint n,m;\r\nstring s;\r\n \r\nint ans=-0x3f3f3f3f;\r\nstruct node{\r\n\tint x,y;\r\n\tint startX,startY;\r\n}cor;\r\n\r\nnode getBox(string s){\r\n\tint x=0,y=0;\r\n\tint maxx=0,minx=0;\r\n\tint maxy=0,miny=0;\r\n\t//反正都是从0,0开始 \r\n\tfor(int i=0;i<s.size();i++){\r\n\t\tif(s[i]=='L') y--;\r\n\t\telse if(s[i]=='R') y++;\r\n\t\telse if(s[i]=='U') x--;\r\n\t\telse if(s[i]=='D') x++;\r\n\t\tmaxx=max(maxx,x);\r\n\t\tmaxy=max(maxy,y);\r\n\t\tminx=min(minx,x);\r\n\t\tminy=min(miny,y);\r\n\t}\r\n\tmaxx-=minx;\r\n\tmaxy-=miny;\r\n\tnode res={maxx,maxy,-minx,-miny};\r\n\treturn res;\r\n}\r\n \r\nint check(int x,int y){\r\n\tint ans=0;\r\n\tif(x>n||y>m||x<1||y<1) return -1;\r\n\tfor(int i=0;i<s.size();i++){\r\n\t\t\r\n\t\tif(s[i]=='L') y--;\r\n\t\telse if(s[i]=='R') y++;\r\n\t\telse if(s[i]=='U') x--;\r\n\t\telse if(s[i]=='D') x++;\r\n\t\tif(x>n||y>m||x<1||y<1) return ans;\r\n\t\tans++;\r\n\t}\r\n\treturn ans;\r\n}\r\n \r\nnode getAns(){\r\n\tint sx=cor.startX,sy=cor.startY;\r\n\tint xx=cor.x,yy=cor.y;\r\n\tint xxx[]={1,1,n,n,1+sx,1+sx,n-xx+sx,n-xx+sx,1,n,1+sx,1+sx};\r\n\tint yyy[]={1,m,1,m,1+sy,m-yy+sy,1+sy,m-yy+sy,1+sy,1+sy,1,m};\r\n\tint ma=-0x3f3f3f3f;\r\n\tfor(int i=0;i<12;i++) ma=max(ma,check(xxx[i],yyy[i]));\r\n\tnode ans;\r\n\tif(ma==-1){\r\n\t\tans={1,1,0,0};\r\n\t\treturn ans;\r\n\t}\r\n\tfor(int i=0;i<12;i++) if(check(xxx[i],yyy[i])==ma){\r\n\t\tans={xxx[i],yyy[i]};\r\n\t\treturn ans;\r\n\t}\r\n}\r\n \r\nint main(){\r\n// \tfreopen(\"1.in\",\"r\",stdin);\r\n\tscanf(\"%d\",&t);\r\n\tfor(int i=1;i<=t;i++){\r\n\t\tscanf(\"%d%d\",&n,&m);\r\n\t\tcin>>s;\r\n//\t\tfor(int i=0;i<s.size();i++) cout<<s[i];\r\n//\t\tputs(\"\");\r\n\t\tcor=getBox(s);//得到碰撞箱\r\n//\t\tprintf(\"%d %d %d %d\\n\",cor.x,cor.y,cor.startX,cor.startY);\r\n\t\tnode ans=getAns();\r\n\t\tprintf(\"%d %d\\n\",ans.x,ans.y);\r\n\t}\r\n\treturn 0;\r\n}",
        "fixed_code": "#include<bits/stdc++.h> \nusing namespace std;\nint t;\nstring s;\nint main(){\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint n,m;scanf(\"%d%d\",&n,&m);\n\t\tint x=0,y=0,maxx=0,maxy=0,minx=0,miny=0;\n\t\tcin>>s;\n\t\tfor(char c:s){\n\t\t\tif(c=='U') minx=min(minx,--x);\n\t\t\tif(c=='D') maxx=max(maxx,++x);\n\t\t\tif(c=='L') miny=min(miny,--y);\n\t\t\tif(c=='R') maxy=max(maxy,++y);\n\t\t\tif(maxy-miny>=m){\n\t\t\t\tif(y==miny) miny++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(maxx-minx>=n){\n\t\t\t\tif(x==minx) minx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",1-minx,1-miny);\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<list>\n#include<set>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<unordered_set>\n#include<iomanip>\n#include<cstdlib>  //for srand()\nusing namespace std;\n#define int int64_t\nint32_t main()\n{\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    int n,k;cin>>n>>k;\n    vector<pair<int,int> > vp;\n    for(int i=0;i<n;i++)\n    {\n        int x,cin>>x;\n        vp.push_back(make_pair(-x,i+1));\n    }\n    sort(vp.begin(),vp.end());\n    for(int i=0;i<k;i++)\n    {\n        cout<<vp[i].second<<\" \";\n    }\n    cout<<\"\\n\";\n    return 0;\n}\n\n",
        "fixed_code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<list>\n#include<set>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<unordered_set>\n#include<iomanip>\n#include<cstdlib>  //for srand()\nusing namespace std;\n#define int int64_t\nint32_t main()\n{\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    int n,k;cin>>n>>k;\n    vector<pair<int,int> > vp;\n    for(int i=0;i<n;i++)\n    {\n        int x;cin>>x;\n        vp.push_back(make_pair(-x,i+1));\n    }\n    sort(vp.begin(),vp.end());\n    cout<<-vp[k-1].first<<\"\\n\";\n    for(int i=0;i<k;i++)\n    {\n        cout<<vp[i].second<<\" \";\n    }\n    cout<<\"\\n\";\n    return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<fstream>\nusing namespace std;\nvoid main()\n{\n    fstream in(\"input.txt\");\n    fstream out(\"output.txt\");\n    int c=3,a[]={0,1,2,3},i; in>>i;\n    while(c--)\n    {\n        int m1,m2;\n        in>>m1>>m2;\n        swap(a[m1],a[m2]);\n    }\n    out<<a[i];\n}",
        "fixed_code": "#include <fstream>\nusing namespace std;\nstd::ifstream in(\"input.txt\");\nstd::ofstream out(\"output.txt\");\nint main(){\n    int c=3,a[]={0,1,2,3},i; in>>i;\n    while(c--)\n    {\n        int m1,m2;\n        in>>m1>>m2;\n        swap(a[m1],a[m2]);\n    }\n    out<<a[i];\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define ll long long int\n#define INF 1000000000000000000\n\nusing namespace std;\n\nint main() \n{\n    ll t;\n    cin >> t;\n    while(t--)\n    {\n        ll n;\n        cin >> n;\n        ll i=0,sum=0,prevsum=0;\n        while(1)\n        {\n            sum+=3*pow(2,i);\n            if(sum>=n)\n            {\n                break;\n            }\n            i+=2;\n            prevsum=sum;\n        }\n        ll temp = n-prevsum,seg;\n        if(temp%3==0)\n        {\n            seg = temp/3;\n        }\n        else\n        {\n            seg = temp/3+1;\n        }\n        ll first = pow(2,i)+seg-1;\n        ll plus[] = {0,2,3,1};\n        ll second = pow(2,i+1)+((seg-1)/4)*4+plus[(seg-1)%4];\n        ll third = first^second;\n        if(temp%3==1)\n        {\n            cout << first << endl;\n        }\n        else if(temp%3==2)\n        {\n            cout << min(second,third) << endl;\n        }\n        else\n        {\n            cout << max(second,third) << endl;\n        }\n    }\n}",
        "fixed_code": "#include <bits/stdc++.h>\n#define ll long long int\n#define INF 1000000000000000000\n\nusing namespace std;\n\nll getSecond(ll x)\n{\n    vector<ll> bits;\n    while(x>0)\n    {\n        bits.push_back(x%2);\n        x/=2;\n    }\n    bits.push_back(0);\n    reverse(bits.begin(),bits.end());\n    ll n=bits.size(),i;\n    vector<ll> sbits(n);\n    for(i=(n-1); i>=0; i-=2)\n    {\n        if(bits[i-1]==0 && bits[i]==0)\n        {\n            sbits[i-1]=0;\n            sbits[i]=0;\n        }\n        else if(bits[i-1]==0 && bits[i]==1)\n        {\n            sbits[i-1]=1;\n            sbits[i]=0;\n        }\n        else if(bits[i-1]==1 && bits[i]==0)\n        {\n            sbits[i-1]=1;\n            sbits[i]=1;\n        }\n        else if(bits[i-1]==1 && bits[i]==1)\n        {\n            sbits[i-1]=0;\n            sbits[i]=1;\n        }\n    }\n    reverse(sbits.begin(),sbits.end());\n    ll ans=0;\n    for(i=0; i<sbits.size(); i++)\n    {\n        ans+=sbits[i]*pow(2,i);\n    }\n    return ans;\n}\n\nint main() \n{\n    ll t;\n    cin >> t;\n    while(t--)\n    {\n        ll n;\n        cin >> n;\n        ll i=0,sum=0,prevsum=0;\n        while(1)\n        {\n            sum+=3*pow(2,i);\n            if(sum>=n)\n            {\n                break;\n            }\n            i+=2;\n            prevsum=sum;\n        }\n        ll temp = n-prevsum,seg;\n        if(temp%3==0)\n        {\n            seg = temp/3;\n        }\n        else\n        {\n            seg = temp/3+1;\n        }\n        seg--;\n        ll first = pow(2,i)+seg;\n        ll second = getSecond(first);\n        ll third = first^second;\n        if(temp%3==1)\n        {\n            cout << first << endl;\n        }\n        else if(temp%3==2)\n        {\n            cout << second << endl;\n        }\n        else\n        {\n            cout << third << endl;\n        }\n    }\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic java.lang.Object eGet(org.eclipse.emf.ecore.EStructuralFeature eFeature, boolean resolve) {\n    if ((eIsProxy()) && resolve) {\n        if ((fragmentation) == null) {\n            throw new java.lang.IllegalStateException(\"Unloaded FObject without fragmentation.\");\n        }\n        org.eclipse.emf.ecore.util.EcoreUtil.resolve(this, fragmentation);\n    }\n    java.lang.Object value = super.eGet(eFeature, resolve);\n    if (eIsProxy()) {\n        throw new java.lang.IllegalStateException(\"FObject unloaded immediately after eGet.\");\n    }\n    return value;\n}",
        "fixed_code": "@java.lang.Override\npublic java.lang.Object eGet(org.eclipse.emf.ecore.EStructuralFeature eFeature, boolean resolve) {\n    ensureIsLoaded(resolve);\n    return super.eGet(eFeature, resolve);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n\n    int n; cin>>n;\n    vector<int> v(n);\n    for(int i=0; i<n; i++) cin>>v[i];\n    if(n<=2){\n        if(n==1) {\n            cout << 0 << endl;\n            return 0;\n        }\n        if(v[0]==v[1]) cout << v[0] << endl;\n        else cout << 0 << endl;\n        return 0;\n    }\n    long long ma=0, l=v[0], r=v[n-1];\n    for(int i=1,j=n-2; i<=j;){\n        if(l==r && i!=j){\n            ma = l;\n            r += v[j];\n            l += v[i];\n            i++;j--;\n            if(l==r) ma=l;\n        }\n        if(l>r) {\n            r += v[j];\n            j--;\n            if(l==r) ma =l;\n        }\n        else if(r>l){\n            l += v[i];\n            i++;\n            if(l==r) ma=l;\n        }\n    }\n    cout << ma << endl;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n\n    int n; cin>>n;\n    vector<long long> v(n),b;\n    long long total=0;\n    for(int i=0; i<n; i++) {\n        cin>>v[i];\n        total += v[i];\n    }\n    b=v;\n    reverse(b.begin(), b.end());\n\n\n    if(n<=2){\n        if(n==1) {\n            cout << 0 << endl;\n            return 0;\n        }\n        if(v[0]==v[1]) cout << v[0] << endl;\n        else cout << 0 << endl;\n        return 0;\n    }\n\n    long long ma=0;\n    for(int i=1; i<n; i++) {\n        v[i] += v[i-1];\n        b[i] += b[i-1];\n    }\n    v.insert(v.end(), b.begin(), b.end());\n    sort(v.begin(), v.end());\n    for(int i=0; i<2*n-1; i++){\n        if(v[i]==v[i+1] && 2*v[i]<=total)\n            ma=v[i];\n    }\n    cout << ma << endl;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "n=int(input())\nfor i in range(n):\n    s=input()\n    l1=list(s)\n    \n    c=0\n    for i in range(len(l1)-1):\n        if(l1[i]==l1[i+1] and l1[i]!=\"?\"):\n            c=1\n            print(-1)\n            break\n    if(c==1):\n        continue\n    else:\n        if(l1[0]==\"?\"):\n            if(l1[1]==\"?\"):\n                l1[0]=\"a\"\n            elif(l1[1]==\"a\" or l1[1]==\"b\"):\n                l1[0]=\"c\"\n            elif(l1[1]==\"b\" or l1[1]==\"c\"):\n                l1[0]=\"a\"\n            elif(l1[1]==\"a\"or l1[1]==\"c\"):\n                l1[0]=\"b\"\n    for i in range(len(l1)-1):\n        if(l1[i]==\"?\"):\n            if(l1[i+1]==\"?\" and l1[i-1]!=\"?\"):\n                if(l1[i-1]==\"a\" or l1[i-1]==\"b\"):\n                    l1[i]=\"c\"\n                    \n                elif(l1[i-1]==\"b\" or l1[i-1]==\"c\"):\n                    l1[i]=\"a\"\n                elif(l1[i-1]==\"a\"or l1[i-1]==\"c\"):\n                    l1[i]=\"b\"\n                    \n            if(l1[i-1]!=\"?\" and l1[i+1]!=\"?\"):\n                if((l1[i-1]==\"a\" or l1[i-1]==\"b\") and (l1[i+1]==\"a\" or l1[i+1]==\"b\")):\n                    l1[i]=\"c\"\n                    \n                elif((l1[i-1]==\"c\" or l1[i-1]==\"b\") and (l1[i+1]==\"c\" or l1[i+1]==\"b\")):\n                    l1[i]=\"a\"\n                elif((l1[i-1]==\"c\" or l1[i-1]==\"a\") and (l1[i+1]==\"c\" or l1[i+1]==\"a\")):\n                    l1[i]=\"b\"\n                    \n                    \n                \n                \n#             \n#            elif(l1[i-1]==\"?\" and l1[i+1]!=\"?\"):\n#                \n#                if(l1[i+1]==\"a\" or l1[i+1]==\"b\"):\n#                    l1[i]=\"c\"\n#                    \n#                elif(l1[i+1]==\"b\" or l1[i+1]==\"c\"):\n#                    l1[i]=\"a\"\n#                elif(l1[i+1]==\"a\"or l1[i+1]==\"c\"):\n#                    l1[i]=\"b\"\n    if(l1[len(l1)-1]==\"?\"):\n                if(l1[len(l1)-2]==\"a\" or l1[len(l1)-2]==\"b\"):\n                            l1[len(l1)-1]=\"c\"\n                    \n                elif(l1[len(l1)-2]==\"b\" or l1[len(l1)-2]==\"c\"):\n                    l1[len(l1)-1]=\"a\"\n                elif(l1[len(l1)-2]==\"a\"or l1[len(l1)-2]==\"c\"):\n                    l1[len(l1)-1]=\"b\"\n        \n        \n        \n        \n    st1r=\"\"  \n    for i in l1:\n        st1r+=str(i)\n    print(st1r)\n        \n            ",
        "fixed_code": "n=int(input())\nfor i in range(n):\n    s=input()\n    l1=list(s)\n    \n    c=0\n    if(s==\"?\"):\n        \n        print(\"a\")\n        continue\n    for i in range(len(l1)-1):\n        if(l1[i]==l1[i+1] and l1[i]!=\"?\"):\n            c=1\n            print(-1)\n            break\n    if(c==1):\n        continue\n    else:\n        if(l1[0]==\"?\"):\n            if(l1[1]==\"?\"):\n                l1[0]=\"a\"\n            elif(l1[1]==\"a\" or l1[1]==\"b\"):\n                l1[0]=\"c\"\n            elif(l1[1]==\"b\" or l1[1]==\"c\"):\n                l1[0]=\"a\"\n            elif(l1[1]==\"a\"or l1[1]==\"c\"):\n                l1[0]=\"b\"\n    for i in range(len(l1)-1):\n        if(l1[i]==\"?\"):\n            if(l1[i+1]==\"?\" and l1[i-1]!=\"?\"):\n                if(l1[i-1]==\"a\" or l1[i-1]==\"b\"):\n                    l1[i]=\"c\"\n                    \n                elif(l1[i-1]==\"b\" or l1[i-1]==\"c\"):\n                    l1[i]=\"a\"\n                elif(l1[i-1]==\"a\"or l1[i-1]==\"c\"):\n                    l1[i]=\"b\"\n                    \n            if(l1[i-1]!=\"?\" and l1[i+1]!=\"?\"):\n                if((l1[i-1]==\"a\" or l1[i-1]==\"b\") and (l1[i+1]==\"a\" or l1[i+1]==\"b\")):\n                    l1[i]=\"c\"\n                    \n                elif((l1[i-1]==\"c\" or l1[i-1]==\"b\") and (l1[i+1]==\"c\" or l1[i+1]==\"b\")):\n                    l1[i]=\"a\"\n                elif((l1[i-1]==\"c\" or l1[i-1]==\"a\") and (l1[i+1]==\"c\" or l1[i+1]==\"a\")):\n                    l1[i]=\"b\"\n                    \n                    \n                \n                \n#             \n#            elif(l1[i-1]==\"?\" and l1[i+1]!=\"?\"):\n#                \n#                if(l1[i+1]==\"a\" or l1[i+1]==\"b\"):\n#                    l1[i]=\"c\"\n#                    \n#                elif(l1[i+1]==\"b\" or l1[i+1]==\"c\"):\n#                    l1[i]=\"a\"\n#                elif(l1[i+1]==\"a\"or l1[i+1]==\"c\"):\n#                    l1[i]=\"b\"\n    if(l1[len(l1)-1]==\"?\"):\n                if(l1[len(l1)-2]==\"a\" or l1[len(l1)-2]==\"b\"):\n                            l1[len(l1)-1]=\"c\"\n                    \n                elif(l1[len(l1)-2]==\"b\" or l1[len(l1)-2]==\"c\"):\n                    l1[len(l1)-1]=\"a\"\n                elif(l1[len(l1)-2]==\"a\"or l1[len(l1)-2]==\"c\"):\n                    l1[len(l1)-1]=\"b\"\n        \n        \n        \n        \n    st1r=\"\"  \n    for i in l1:\n        st1r+=str(i)\n    print(st1r)\n        \n            ",
        "source": "Python_461356.json"
    },
    {
        "source_code": "for _ in range(int(input())):\r\n    n=int(input())\r\n    flag=0\r\n    pos=1\r\n    matrix=[]\r\n    newm=[]\r\n    c1,c2=0,0\r\n    if n==1:\r\n        m1=[int(i)for i in input().split()]\r\n        print(1)\r\n    else:\r\n        players=[]\r\n        for i in range(n):\r\n            players+=[[int(i)for i in input().split()]]\r\n        m1=players[0]\r\n        m2=players[1]\r\n        for i in range(2,n+1): \r\n            c1,c2=0,0\r\n            if i==n:\r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        pos=i\r\n                        break\r\n            else:                \r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        m2=players[i]\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        pos=i\r\n                        m2=players[i]\r\n                        break\r\n        players.pop(players.index(m1))\r\n        m3=m1.copy()\r\n        m2=players[0]\r\n        for i in range(1,len(players)+1):\r\n            if i==len(players):\r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        break\r\n            else:\r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        m2=players[i]\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        m2=players[i]\r\n                        break\r\n            if m1!=m3:\r\n                print(-1)\r\n                flag=1\r\n                break\r\n        if flag==0:\r\n            print(pos)\r\n\r\n\r\n\r\n        \r\n        \r\n\r\n                \r\n",
        "fixed_code": "for _ in range(int(input())):\r\n    n=int(input())\r\n    flag=0\r\n    pos=1\r\n    c1,c2=0,0\r\n    if n==1:\r\n        m1=[int(i)for i in input().split()]\r\n        print(1)\r\n    else:\r\n        players=[]\r\n        for i in range(n):\r\n            players+=[[int(i)for i in input().split()]]\r\n        m1=players[0]\r\n        m2=players[1]\r\n        for i in range(2,n+1): \r\n            c1,c2=0,0\r\n            if i==n:\r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        pos=i\r\n                        break   \r\n            else:                \r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        m2=players[i]\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        pos=i\r\n                        m2=players[i]\r\n                        break\r\n        players.pop(players.index(m1))\r\n        m3=m1.copy()\r\n        m2=players[0]\r\n        \r\n        for i in range(1,len(players)+1):\r\n            c1,c2=0,0\r\n            if i==len(players):\r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        break\r\n            else:\r\n                for j,k in zip(m1,m2):\r\n                    if j<k:c1+=1\r\n                    else:c2+=1\r\n                    if c1>=3:\r\n                        m2=players[i]\r\n                        break\r\n                    if c2>=3:\r\n                        m1=m2.copy()\r\n                        m2=players[i]\r\n                        break\r\n            if m1!=m3:\r\n                print(-1)\r\n                flag=1\r\n                break\r\n        if flag==0:\r\n            print(pos)\r\n\r\n\r\n\r\n        \r\n        \r\n\r\n                \r\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "private int getCopiesToKeep(com.emc.storageos.model.property.PropertyInfo propInfo) {\n    int retentionNumber = com.emc.storageos.management.backup.BackupConstants.DEFAULT_BACKUP_COPIES_TO_KEEP;\n    java.lang.String copiesStr = propInfo.getProperty(BackupConstants.COPIES_TO_KEEP);\n    if ((copiesStr != null) && ((copiesStr.length()) > 0)) {\n        retentionNumber = java.lang.Integer.parseInt(copiesStr);\n    }\n    return retentionNumber;\n}",
        "fixed_code": "private int fetchCopiesToKeep(com.emc.storageos.model.property.PropertyInfo propInfo) {\n    int retentionNumber = com.emc.storageos.management.backup.BackupConstants.DEFAULT_BACKUP_COPIES_TO_KEEP;\n    java.lang.String copiesStr = propInfo.getProperty(BackupConstants.COPIES_TO_KEEP);\n    if ((copiesStr != null) && ((copiesStr.length()) > 0)) {\n        retentionNumber = java.lang.Integer.parseInt(copiesStr);\n    }\n    return retentionNumber;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n\r\nvoid sayNo(){\r\n\tcout<<\"NO\"<<endl;\r\n}\r\n\r\nvoid sayYes(){\r\n\tcout<<\"YES\"<<endl;\r\n}\r\n\r\nvoid print(int arr[], int n){\r\n\tcout<<endl;\r\n\tfor(int i=0;i<n;i++){\r\n\t\tcout<<arr[i]<<\" \";\r\n\t}\r\n\tcout<<endl;\r\n}\r\n\r\nvoid print(vector<int> arr){\r\n\tcout<<endl;\r\n\tfor(int i=0;i<arr.size();i++)cout<<arr[i]<<\" \";\r\n\tcout<<endl;\r\n}\r\n\r\nvoid print(map<int,int> mp){\r\n\tcout<<endl;\r\n\tfor(auto i=mp.begin();i!=mp.end();i++)cout<<i->first<<\" \"<<i->second<<endl;\r\n\tcout<<endl;\r\n}\r\n\r\nvoid print(map<int,vector<int>> mp){\r\n\tcout<<endl;\r\n\tfor(auto i=mp.begin();i!=mp.end();i++)\r\n\t\t{\r\n\t\t\tcout<<i->first<<\" _ \";\r\n\t\t\tfor(int it=0;it<i->second.size();it++){\r\n\t\t\t\tcout<<i->second[it]<<\" \";\r\n\t\t\t}\r\n\t\t\tcout<<endl;\r\n\t\t}\r\n\tcout<<endl;\r\n}\r\n\r\nint factorial(int n) {\r\n    int factorial = 1;\r\n    for (int i = 2; i <= n; i++)\r\n        factorial = factorial * i;\r\n    return factorial;\r\n}\r\n \r\nint nCr(int n, int r) {\r\n    return factorial(n) / (factorial(r) * factorial(n - r));\r\n}\r\n\r\n/*\r\nfor(int i=0;i<_;i++){}\r\n*/\r\nvoid solution(){\r\n\tint n, m;\r\n\tcin>>n>>m;\r\n\tdeque<int> a;\r\n\tint max=1;\r\n\tint cnt=1;\r\n\tint last;\r\n\tfor(int i=0;i<n;i++){\r\n\t\tint t;\r\n\t \tcin>>t;\r\n\t \ta.push_back(t);\r\n\t \t// if(i!=0){\r\n\t \t// \tif(t==last)cnt++;\r\n\t \t// \telse{if(cnt>=m)max++;cnt=1;last=t;}\r\n\t \t// }\r\n\t \t// else{\r\n\t \t// \tlast=t;\r\n\t \t// }\r\n\t}\r\n\tint k;\r\n\tcin>>k;\r\n\tdeque<int> b;\r\n\tfor(int i=0;i<k;i++){\r\n\t\tint t;\r\n\t \tcin>>t;\r\n\t \tb.push_back(t);\r\n\t}\r\n\t// for(auto it = a.begin(); it != a.end(); ++it)\r\n //        cout << ' ' << *it;\r\n //    cout<<endl;\r\n //    for(auto it = b.begin(); it != b.end(); ++it)\r\n //        cout << ' ' << *it;\r\n //    cout<<endl;\r\n\tbool flag=true;\r\n\twhile(flag&&a.size()>0&&b.size()>0){\r\n\t\t\t\t\t// for(auto it = a.begin(); it != a.end(); ++it)\r\n\t\t\t\t //        cout << ' ' << *it;\r\n\t\t\t\t //    cout<<endl;\r\n\t\t\t\t //    for(auto it = b.begin(); it != b.end(); ++it)\r\n\t\t\t\t //        cout << ' ' << *it;\r\n\t\t\t\t //    cout<<endl;\r\n\t\tint v1 = a.front();\r\n\t\tint v2 = b.front();\r\n\t\tif(v1==v2){\r\n\t\t\t// cout<<a.front()<<\"_1\"<<endl;\r\n\t\t\ta.pop_front();b.pop_front();\r\n\t\t}\r\n\t\telse if(v1>v2){\r\n\t\t\twhile(v1>v2){\r\n\t\t\t\tif(v1%m!=0){flag=false;break;}\r\n\t\t\t\tint ans = v1/m;\r\n\t\t\t\ta.pop_front();\r\n\t\t\t\tfor(int j=0;j<m;j++)a.push_front(ans);\r\n\t\t\t\tv1=ans;\t\r\n\t\t\t}\r\n\t\t\tif(v1!=v2){flag=false;break;}\r\n\t\t\telse{\r\n\t\t\t\t// cout<<a.front()<<\"_2\"<<endl;\r\n\t\t\t\ta.pop_front();b.pop_front();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(b.front()%(a.front()*m)!=0){flag=false;break;}\r\n\t\t\tint same=1;\r\n\t\t\tif(a.size()>=m){\r\n\t\t\t\tfor(int i=1;i<m;i++){\r\n\t\t\t\t\tif(a.at(i)==a.at(0))same++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(same==m){\r\n\t\t\t\tint t=a.at(0);\r\n\t\t\t\tfor(int i=0;i<m;i++){a.pop_front();}\r\n\t\t\t\ta.push_front(t*m);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tbool swap=false;\r\n\t\t\t\tint pos = 0;\r\n\t\t\t\tfor(int i=1;i<a.size();i++){\r\n\t\t\t\t\tif(a.at(i)>a.at(0)&&a.at(i)%m==0){\r\n\t\t\t\t\t\tswap=true;\r\n\t\t\t\t\t\tpos=i;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(swap){\r\n\t\t\t\t\tint ans = a.at(pos)/m;\r\n\t\t\t\t\tint arr[pos];\r\n\t\t\t\t\tfor(int itr = 0;itr<pos;++itr){\r\n\t\t\t\t\t\tarr[itr]=a.front();a.pop_front();\r\n\t\t\t\t\t}\r\n\t\t\t\t\ta.pop_front();\r\n\t\t\t\t\tfor(int j=0;j<m;j++)a.push_front(ans);\r\n\t\t\t\t\tfor(int itr = pos-1;itr>=0;--itr){\r\n\t\t\t\t\t\ta.push_front(arr[itr]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tint mcx=0;\r\n\t\t\t\t\tint cnt=1;\r\n\t\t\t\t\tbool found = false;\r\n\t\t\t\t\tfor(int itr=1;itr<a.size();++itr){\r\n\t\t\t\t\t\tif(a.at(itr)==a.at(itr-1))cnt++;\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif(cnt>=m){\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\tcnt=1;\r\n\t\t\t\t\t\t\t\tmcx=itr;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(cnt>=m){\r\n\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(found){\r\n\t\t\t\t\t\tint arr[mcx];\r\n\t\t\t\t\t\tfor(int itr = 0;itr<mcx;++itr){\r\n\t\t\t\t\t\t\tarr[itr]=a.front();a.pop_front();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tint ans = a.front()*m;\r\n\t\t\t\t\t\tfor(int j=0;j<m;j++)a.pop_front();\r\n\t\t\t\t\t\ta.push_front(ans);\r\n\t\t\t\t\t\tfor(int itr = mcx-1;itr>=0;--itr){\r\n\t\t\t\t\t\t\ta.push_front(arr[itr]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tflag=false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif(flag==false)sayNo();\r\n\telse if(a.size()==0&&b.size()==0)sayYes();\r\n\telse sayNo();\r\n\r\n}\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\tint m;\r\n\tcin>>m;\r\n\twhile(m--){\r\n\t\tsolution();\r\n\t}\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n\r\nvoid sayNo(){\r\n\tcout<<\"NO\"<<endl;\r\n}\r\n\r\nvoid sayYes(){\r\n\tcout<<\"YES\"<<endl;\r\n}\r\n\r\nvoid prll(ll arr[], ll n){\r\n\tcout<<endl;\r\n\tfor(ll i=0;i<n;i++){\r\n\t\tcout<<arr[i]<<\" \";\r\n\t}\r\n\tcout<<endl;\r\n}\r\n\r\nvoid prll(vector<ll> arr){\r\n\tcout<<endl;\r\n\tfor(ll i=0;i<arr.size();i++)cout<<arr[i]<<\" \";\r\n\tcout<<endl;\r\n}\r\n\r\nll factorial(ll n) {\r\n    ll factorial = 1;\r\n    for (ll i = 2; i <= n; i++)\r\n        factorial = factorial * i;\r\n    return factorial;\r\n}\r\n \r\nll nCr(ll n, ll r) {\r\n    return factorial(n) / (factorial(r) * factorial(n - r));\r\n}\r\n\r\n/*\r\nfor(ll i=0;i<_;i++){}\r\n*/\r\n\r\nvoid solution(){\r\n\tll n,m;\r\n\tcin>>n>>m;\r\n\tvector<pair<ll,ll>>a;\r\n\tll k;\r\n\tvector<pair<ll,ll>>b;\r\n\tfor(ll i=0;i<n;i++){\r\n\t\tll t;\r\n\t\tcin>>t;\r\n\t\tll cnt=0;\r\n\t\twhile(t%m==0){\r\n\t\t\tt=t/m;\r\n\t\t\tcnt++;\r\n\t\t}\r\n\t\tif(a.size()>0&&a.back().first==t){\r\n\t\t\ta[a.size()-1].second+=pow(m,cnt);\r\n\t\t}\r\n\t\telse{\r\n\t\t\ta.push_back({t,pow(m,cnt)});\r\n\t\t}\r\n\r\n\t}\r\n\tcin>>k;\r\n\tfor(ll i=0;i<k;i++){\r\n\t\tll t;\r\n\t\tcin>>t;\r\n\t\tll cnt=0;\r\n\t\twhile(t%m==0){\r\n\t\t\tt=t/m;\r\n\t\t\tcnt++;\r\n\t\t}\r\n\t\tif(b.size()>0&&b.back().first==t){\r\n\t\t\tb[b.size()-1].second+=pow(m,cnt);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tb.push_back({t,pow(m,cnt)});\r\n\t\t}\r\n\t}\r\n\tif(a.size()!=b.size()){sayNo();return;}\r\n\tfor(ll i=0;i<a.size();i++){\r\n\t\t// cout<<a[i].first<<\" \"<<b[i].first<<\" \"<<a[i].second<<\" \"<<b[i].second<<endl;\r\n\t\tif(!(a[i].first==b[i].first&&a[i].second==b[i].second)){sayNo();return;}\r\n\t}\r\n\tsayYes();\r\n}\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\tll m;\r\n\tcin>>m;\r\n\twhile(m--){\r\n\t\tsolution();\r\n\t}\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "android.view.LayoutInflater getLayoutInflater() {\n    return layoutInflater;\n}",
        "fixed_code": "android.view.LayoutInflater getK9LayoutInflater() {\n    return layoutInflater;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\n\n\npublic class AntonAndLetters {\n\n\tpublic static void main(String[] args) throws IOException  {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString str=br.readLine();\n\t\tstr=str.substring(1, str.length()-1);\n\t\tString []strArr=str.split(\",\");\n\t\tSet<Character> unique=new HashSet<Character>();\n\t\tfor(int i=0;i<strArr.length;i++){\n\t\t\tunique.add(strArr[i].charAt(0));\n\t\t}\n\t\tSystem.out.println(unique.size());\n\t\t\n\t}\n\n}\n",
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\n\n\npublic class AntonAndLetters {\n\n\tpublic static void main(String[] args) throws IOException  {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString str=br.readLine();\n\t\tif(str.equals(\"{}\")){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tstr=str.substring(1, str.length()-1);\n\t\t\n\t\tString []strArr=str.split(\", \");\n\t\tSet<Character> unique=new HashSet<Character>();\n\t\tfor(int i=0;i<strArr.length;i++){\n\t\t\tunique.add(strArr[i].charAt(0));\n\t\t}\n\t\tSystem.out.println(unique.size());\n\t\t\n\t}\n\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n\ntypedef long long ll;\n\nlong long modinverse(long long a, long long b, long long s0 = 1, long long s1 = 0)\n{\n    //std::cout << \"on (\" << a << \", \" << b << \", \" << s0 << \", \" << s1 << \")\\n\";\n    if(!b)\n        return s0;\n    else\n        return modinverse(b, a % b, s1, s0 - s1 * (a / b));\n}\n\nlong long gcd(long long a, long long b)\n{\n    if(!b)\n        return a;\n    else\n        return gcd(b, a % b);\n}\n\nll mul(ll a, ll b, ll m)\n{\n    ll q = (long double) a * (long double) b / (long double) m;\n    ll r = a * b - q * m;\n\n    return (r + 5 * m) % m;\n}\n\nlong long safemod(long long a, long long m)\n{\n    return (a % m + m) % m;\n}\n\nstruct equation\n{\n    equation(long long a, long long m){mod = m, ans = a, valid = true;}\n    equation(){valid = false;}\n    equation(equation a, equation b)\n    {\n        if(!a.valid || !b.valid)\n        {\n            valid = false;\n            return;\n        }\n        long long g = gcd(a.mod, b.mod);\n        if((a.ans - b.ans) % g != 0)\n        {\n            valid = false;\n            return;\n        }\n        valid = true;\n        mod = a.mod * (b.mod / g);\n        ans = a.ans +\n              mul(\n                      mul(a.mod, modinverse(a.mod, b.mod), mod),\n                      (b.ans - a.ans) / g\n              , mod);\n        ans = safemod(ans, mod);\n    }\n    long long mod, ans;\n    bool valid;\n\n    void print()\n    {\n        if(!valid)\n            std::cout << \"equation is not valid\\n\";\n        else\n            std::cout << \"equation is \" << ans << \" mod \" << mod << '\\n';\n    }\n};\n\n\nll lcm(ll a, ll b)\n{\n    return (ll) std::min((long double) 1e13, (long double) a * (b / gcd(a, b)));\n}\n\nstd::vector<ll> a, primes, divs;\nstd::vector<int> pos[1010];\n\nint main()\n{\n    ll n, m;\n    std::cin >> n >> m;\n    int k;\n    std::cin >> k;\n    ll tot = 1;\n    for(int i = 0; i < k; i++)\n    {\n        ll temp;\n        std::cin >> temp;\n        tot = lcm(tot, temp);\n        a.push_back(temp);\n    }\n    //std::cout << \"lcm is \" << tot << '\\n';\n    if(tot > n)\n    {\n        std::cout << \"NO\\n\";\n        return 0;\n    }\n\n    equation ans (0, 1);\n    for(int i = 0; i < k; i++)\n    {\n        ans = equation(ans, equation((-i % a[i] + a[i]) % a[i], a[i]));\n    }\n    if(!ans.valid)\n    {\n        //std::cout << \"equation not valid\\n\";\n        std::cout << \"NO\\n\";\n        return 0;\n    }\n    if(ans.ans == 0)\n        ans.ans += tot;\n    //std::cout << \"first position should be \" << ans.ans << '\\n';\n    if(ans.ans + k - 1 > m)\n    {\n        std::cout << \"NO\\n\";\n        return 0;\n    }\n\n    std::cout << \"YES\\n\";\n}\n",
        "fixed_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n\ntypedef long long ll;\n\nlong long modinverse(long long a, long long b, long long s0 = 1, long long s1 = 0)\n{\n    //std::cout << \"on (\" << a << \", \" << b << \", \" << s0 << \", \" << s1 << \")\\n\";\n    if(!b)\n        return s0;\n    else\n        return modinverse(b, a % b, s1, s0 - s1 * (a / b));\n}\n\nlong long gcd(long long a, long long b)\n{\n    if(!b)\n        return a;\n    else\n        return gcd(b, a % b);\n}\n\nll mul(ll a, ll b, ll m)\n{\n    ll q = (long double) a * (long double) b / (long double) m;\n    ll r = a * b - q * m;\n\n    return (r + 5 * m) % m;\n}\n\nlong long safemod(long long a, long long m)\n{\n    return (a % m + m) % m;\n}\n\nstruct equation\n{\n    equation(long long a, long long m){mod = m, ans = a, valid = true;}\n    equation(){valid = false;}\n    equation(equation a, equation b)\n    {\n        if(!a.valid || !b.valid)\n        {\n            valid = false;\n            return;\n        }\n        long long g = gcd(a.mod, b.mod);\n        if((a.ans - b.ans) % g != 0)\n        {\n            valid = false;\n            return;\n        }\n        valid = true;\n        mod = a.mod * (b.mod / g);\n        ans = a.ans +\n              mul(\n                      mul(a.mod, modinverse(a.mod, b.mod), mod),\n                      (b.ans - a.ans) / g\n              , mod);\n        ans = safemod(ans, mod);\n    }\n    long long mod, ans;\n    bool valid;\n\n    void print()\n    {\n        if(!valid)\n            std::cout << \"equation is not valid\\n\";\n        else\n            std::cout << \"equation is \" << ans << \" mod \" << mod << '\\n';\n    }\n};\n\n\nll lcm(ll a, ll b)\n{\n    return (ll) std::min((long double) 1e13, (long double) a * (b / gcd(a, b)));\n}\n\nstd::vector<ll> a, primes, divs;\nstd::vector<int> pos[1010];\n\nint main()\n{\n    ll n, m;\n    std::cin >> n >> m;\n    int k;\n    std::cin >> k;\n    ll tot = 1;\n    for(int i = 0; i < k; i++)\n    {\n        ll temp;\n        std::cin >> temp;\n        tot = lcm(tot, temp);\n        a.push_back(temp);\n    }\n    //std::cout << \"lcm is \" << tot << '\\n';\n    if(tot > n)\n    {\n        std::cout << \"NO\\n\";\n        return 0;\n    }\n\n    equation ans (0, 1);\n    for(int i = 0; i < k; i++)\n    {\n        ans = equation(ans, equation((-i % a[i] + a[i]) % a[i], a[i]));\n    }\n    if(!ans.valid)\n    {\n        //std::cout << \"equation not valid\\n\";\n        std::cout << \"NO\\n\";\n        return 0;\n    }\n    if(ans.ans == 0)\n        ans.ans += tot;\n    //std::cout << \"first position should be \" << ans.ans << '\\n';\n    if(ans.ans + k - 1 > m)\n    {\n        std::cout << \"NO\\n\";\n        return 0;\n    }\n\n    for(ll i = 0; i < k; i++)\n    {\n        if(gcd(tot, ans.ans + i) != a[i])\n        {\n            std::cout  << \"NO\\n\";\n            return 0;\n        }\n    }\n    std::cout << \"YES\\n\";\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public double getOpponentTotalBetSizeFromImage() {\n    double opponentTotalBetSize;\n    java.lang.String opponentTotalBetSizeAsString = readTopPlayerTotalBetSize();\n    if (opponentTotalBetSizeAsString.matches(\".*\\\\d.*\")) {\n        opponentTotalBetSize = java.lang.Double.parseDouble(opponentTotalBetSizeAsString);\n    }else {\n        opponentTotalBetSize = 0;\n    }\n    if ((opponentTotalBetSize / (bigBlind)) > 40) {\n        java.lang.String timeStamp = getCurrentTimeStamp();\n        java.lang.System.out.println((((\"opponentTotalBetSize: \" + opponentTotalBetSize) + \" ---bigger than 40bb, screenshot saved: \") + timeStamp));\n        com.lennart.model.imageprocessing.ImageProcessor.createPartialSreenShot(451, 191, 66, 18, (\"path\" + timeStamp));\n    }\n    return opponentTotalBetSize;\n}",
        "fixed_code": "public double getOpponentTotalBetSizeFromImage() {\n    double opponentTotalBetSize;\n    java.lang.String opponentTotalBetSizeAsString = readTopPlayerTotalBetSize();\n    if (opponentTotalBetSizeAsString.matches(\".*\\\\d.*\")) {\n        opponentTotalBetSize = java.lang.Double.parseDouble(opponentTotalBetSizeAsString);\n    }else {\n        opponentTotalBetSize = 0;\n    }\n    if ((opponentTotalBetSize / (bigBlind)) > 40) {\n        java.lang.String timeStamp = getCurrentTimeStamp();\n        java.lang.System.out.println((((\"opponentTotalBetSize: \" + opponentTotalBetSize) + \" ---bigger than 40bb, screenshot saved: \") + timeStamp));\n        com.lennart.model.imageprocessing.ImageProcessor.createPartialSreenShot(451, 191, 66, 18, ((\"C:/Users/Lennart/Documents/netbetscreens/\" + timeStamp) + \".png\"));\n    }\n    return opponentTotalBetSize;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "/* ***********************************************\n┆  ┏┓　　　┏┓ ┆\n┆┏┛┻━━━┛┻┓ ┆\n┆┃　　　　　　　┃ ┆\n┆┃　　　━　　　┃ ┆\n┆┃　┳┛　┗┳　┃ ┆\n┆┃　　　　　　　┃ ┆\n┆┃　　　┻　　　┃ ┆\n┆┗━┓　马　┏━┛ ┆\n┆　　┃　勒　┃　　┆　　　　　　\n┆　　┃　戈　┗━━━┓ ┆\n┆　　┃　壁　　　　　┣┓┆\n┆　　┃　的草泥马　　┏┛┆\n┆　　┗┓┓┏━┳┓┏┛ ┆\n┆　　　┃┫┫　┃┫┫ ┆\n┆　　　┗┻┛　┗┻┛ ┆\n************************************************ */\n\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <string>\n#include <math.h>\n#include <stdlib.h>\nusing namespace std;\n\n#define inf 0x3f3f3f3f\n#define ll long long\n#define ull unsigned long long\n#define maxn 200005\nll x[maxn],y[maxn];\n\nbool dis(int i,int j)\n{\n    ull a;\n    ull b;\n    a=abs(x[i]-x[j])+abs(y[i]-y[j]);\n    b=(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));\n    //cout<<a<<\" \"<<b<<endl;\n    if((a)==b)return true;\n    return false;\n}\n\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n;\n    cin>>n;\n    ll ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>x[i]>>y[i];\n    }\n    for(int i=1;i<n;i++)\n    {\n        for(int j=i+1;j<=n;j++)\n        {\n            if(dis(i,j))\n                ans++;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n",
        "fixed_code": "/* ***********************************************\n┆  ┏┓　　　┏┓ ┆\n┆┏┛┻━━━┛┻┓ ┆\n┆┃　　　　　　　┃ ┆\n┆┃　　　━　　　┃ ┆\n┆┃　┳┛　┗┳　┃ ┆\n┆┃　　　　　　　┃ ┆\n┆┃　　　┻　　　┃ ┆\n┆┗━┓　马　┏━┛ ┆\n┆　　┃　勒　┃　　┆　　　　　　\n┆　　┃　戈　┗━━━┓ ┆\n┆　　┃　壁　　　　　┣┓┆\n┆　　┃　的草泥马　　┏┛┆\n┆　　┗┓┓┏━┳┓┏┛ ┆\n┆　　　┃┫┫　┃┫┫ ┆\n┆　　　┗┻┛　┗┻┛ ┆\n************************************************ */\n\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <string>\n#include <math.h>\n#include <stdlib.h>\nusing namespace std;\n\n#define inf 0x3f3f3f3f\n#define ll long long\n#define ull unsigned long long\n#define maxn 200005\n#define pb push_back\n#define f first\n#define se second\ntypedef pair<int,int> p;\nvector<p> sx;\nvector<p> sy;\n\nint main()\n{\n    int n;\n    int x,y;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n\n        scanf(\"%d%d\",&x,&y);\n        sx.push_back(p(x,y));\n        sy.push_back(p(y,x));\n    }\n    sort(sx.begin(),sx.end());\n    sort(sy.begin(),sy.end());\n    int temp=sx[0].f;\n    long long cnt=1;\n    long long sumx=0;\n    for(int i=1;i<n;i++)\n    {\n        if(sx[i].f==temp)\n        {\n            cnt++;\n        }\n        else\n        {\n            sumx+=(cnt*(cnt-1))/2;\n            cnt=1;\n            temp=sx[i].f;\n        }\n    }\n    sumx+=(cnt*(cnt-1))/2;\n    //cout<<sumx<<endl;\n    cnt=1;\n    ll sumy=0;\n    temp=sy[0].f;\n    for(int i=1;i<n;i++)\n    {\n        if(sy[i].f==temp)\n        {\n            cnt++;\n        }\n        else\n        {\n            sumy+=(cnt*(cnt-1))/2;\n            cnt=1;\n            temp=sy[i].f;\n        }\n    }\n    sumy+=(cnt*(cnt-1))/2;\n    //cout<<sumy<<endl;\n\n    int temp2,temp1;\n    temp2=sx[0].se;\n    temp1=sx[0].f;\n    cnt=1;\n    ll sub=0;\n    for(int i=1;i<n;i++)\n    {\n        if(sx[i].f==temp1 && sx[i].se==temp2)\n        {\n            cnt++;\n        }\n        else\n        {\n            sub+=(cnt*(cnt-1))/2;\n            cnt=1;\n            temp2=sx[i].se;\n            temp1=sx[i].f;\n        }\n    }\n    sub+=(cnt*(cnt-1))/2;\n\n    cout<<sumx+sumy-sub<<endl;\n    return 0;\n}\n\n\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int n,w,s[1000001],a[1000001],st[4000000];\nvoid build(long long int v=1,long long int l=0,long long int r=n-1)\n{\n    if(l==r)\n    {\n        st[v]=a[l];\n    }\n    else\n    {\n        build(2*v,l,(l+r)/2);\n        build(2*v+1,(l+r)/2+1,r);\n        st[v]=max(st[2*v],st[2*v+1]);\n    }\n    return ;\n    \n}\nlong long int querry(long long int l,long long int r,long long int tl=0,long long int tr=n-1,long long int v=1)\n{\n    if(l>r)\n        return 0;\n    else\n    {\n        if(tr==r&&tl==l)\n            return st[v];\n        else\n        {\n            long long int tm=(tr+tl)/2;\n            return max(querry(l,min(tm,r),tl,tm,2*v),querry(max(l,tm+1),r,tm+1,tr,2*v+1));\n        }\n        \n    }\n    \n\n}\n\nint main()\n{\n    cin>>n>>w;\n    for(long long int i=0;i<n;i++)\n    {\n        long long int l;\n        cin>>l;\n        long long int k=w-l;\n        for(long long int i=0;i<l;i++)\n            cin>>a[i];\n        build();\n        for(long long int i=0;i<w;i++)\n        {\n            s[i]+=querry(max((long long)0,i-k),min(l-1,i),0,n-1,1);\n        }\n\n    }\n    for(long long int i=0;i<w;i++)\n        cout<<s[i]<<\" \";\n    return 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, w, mini = -(1e+9 + 1);\nlong long int st[4000004], a[1000001], s[1000000], t[1000000];\nbool lazy[4000001];\n\nvoid push(long long int v)\n{\n    if (lazy[v])\n    {\n        // cout<<\"*\";\n        st[2 * v] = st[v];\n        st[2 * v + 1] = st[v];\n        lazy[2 * v] = true;\n        lazy[2 * v + 1] = true;\n        lazy[v] = false;\n    }\n}\n\nvoid build(long long int v, long long int l, long long int r)\n{\n    if (l == r)\n    {\n        st[v] = a[l];\n    }\n    else\n    {\n        build(2 * v, l, (l + r) / 2);\n        build(2 * v + 1, (l + r) / 2 + 1, r);\n        st[v] = max(st[2 * v], st[2 * v + 1]);\n    }\n    return;\n}\n\nlong long int querry(long long int l, long long int r, long long int tl, long long int tr, long long int v)\n{\n    if (l > r)\n        return mini;\n    else\n    {\n        if (l == tl && r == tr)\n            return st[v];\n        long long int tm = (tr + tl) / 2;\n        push(v);\n\n        return max(querry(l, min(tm, r), tl, tm, 2 * v), querry(max(tm + 1, l), r, tm + 1, tr, 2 * v + 1));\n    }\n}\n\nvoid update(long long int v, long long int tl, long long int tr, long long int val, long long int l, long long int r)\n{\n    if (l > r)\n        return;\n    if (tr == r && l == tl)\n    {\n        lazy[v] = true;\n        st[v] = val;\n    }\n    else\n    {\n        long long int tm = (tl + tr) / 2;\n        push(v);\n        update(2 * v, tl, tm, val, l, min(tm, r));\n        update(2 * v + 1, tm + 1, tr, val, max(tm + 1, l), r);\n        st[v] = max(st[2 * v], st[2 * v + 1]);\n    }\n    return;\n}\n\nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n\n    // cin >> n >> w;\n    scanf(\"%lld %lld\", &n, &w);\n    for (long long int i = 0; i <= 1000000; i++)\n        a[i] = mini;\n    build(1, 0, 1000000);\n    // cout << querry(0, 1, 0, 1000000, 1);\n    for (long long int j = 0; j < n; j++)\n    {\n        long long int l;\n        // cin >> l;\n        scanf(\"%lld\", &l);\n        long long int k = w - l;\n        for (long long int i = 0; i < l; i++)\n        {\n            // cin >> a[i];\n            scanf(\"%lld\", &a[i]);\n            update(1, 0, 1000000, a[i], i, i);\n        }\n        if (l < w)\n        {\n            update(1, 0, 1000000, 0, l, w - 1);\n            // cout<<\"*\";\n        }\n        update(1, 0, 1000000, mini, w, 1000000);\n        for (long long int i = 0; i < l; i++)\n        {\n            long long int x = (w - l >= i + 1 ? 0 : mini);\n            s[i] += max(querry(max((long long)0, i - k), min(w - 1, i), 0, 1000000, 1), x);\n        }\n        long long int c = 0, i = w - 1;\n        while (c < l && i >= l)\n        {\n            long long int x = (w - l >= c + 1 ? 0 : mini);\n            s[i] += max(querry(max((long long)0, l - 1 - c), l - 1, 0, 1000000, 1), x);\n            ;\n            i--;\n            c++;\n        }\n        if (w > 2*l)\n        {\n            long long int val = max((long long)0, querry(0, l - 1, 0, 1000000, 1));\n            t[l] += val;\n            t[w - l] -= val;\n        }\n    }\n    for (long long int i = 1; i <= 1000000; i++)\n        t[i] += t[i - 1];\n    for (long long int i = 0; i < w; i++)\n        printf(\"%lld \", s[i]+t[i]);\n    // cout << s[i] << \" \";\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\n\nn = int(input())\nt = [[int(x) for x in input().split(\" \")] for _ in range(n)]\n\n#n = int(\"4\")\n#t = [ [1,2], [2,3], [3,4], [4,1] ]\n#t = [ [1,1], [2,2], [3,3], [4,4] ]\n#n = int(\"3\")\n#t = [ [2,828], [4,392], [4,903] ]\n# 2 828\n# 4 392\n# 4 903\na=[]\nb=[]\na = [t[i][0] for i in range(n)]\nb = [t[i][1] for i in range(n)]\nc = [0 for i in range(n)]\n#a1=set(a)\nfor i in range(len(b)):\n    j=0\n    while(j<len(c)):\n      if (b[i]==a[j])and(i!=j):\n         c[j]=1\n      j+=1\nh=0      \nfor i in c:\n    if c[i]==0:\n        h+=1\nprint(h)",
        "fixed_code": "\n\nn = int(input())\nt = [[int(x) for x in input().split(\" \")] for _ in range(n)]\n\n#n = int(\"4\")\n#t = [ [1,2], [2,3], [3,4], [4,1] ]\n#t = [ [1,1], [2,2], [3,3], [4,4] ]\n#n = int(\"3\")\n#t = [ [2,828], [4,392], [4,903] ]\n# 2 828\n# 4 392\n# 4 903\n\n# n = int(\"4\")\n# t = [ [2,3], [1,772], [3,870], [3,668] ]\n# 2 3\n# 1 772\n# 3 870\n# 3 668\n\na=[]\nb=[]\na = [t[i][0] for i in range(n)]\nb = [t[i][1] for i in range(n)]\nc = [0 for i in range(n)]\n#a1=set(a)\nfor i in range(len(b)):\n    for j in range(len(c)):\n      if (b[i]==a[j])and(i!=j):\n         c[j]=1\n\n    \nh=0      \nfor i in c:\n    if i==0:\n        h+=1\nprint(h)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n\n#define ll long long\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define o cout<<\"BUG\"<<endl;\n#define\tIOS ios_base::sync_with_stdio(0);\n#define en \"\\n\"\n#define FOR(i, j, n) for(int j = i; j < n; ++j)\n#define forn(i, j, n) for(int j = i; j <= n; ++j)\n#define nfor(i, j, n) for(int j = n; j >= i; --j)\n#define all(v) v.begin(), v.end()\n#define ld long double\n#define ull unsigned long long\n#define pii pair <int, int>\n\n\nusing namespace std;\nconst ll maxn=1e6+100,inf=1e18,LOG=23,mod=1e9+7;\nint block = 300, timer = 0;\nconst ld EPS = 1e-7;\n\n#define bt(i) (1 << (i))\n#define int ll\n//#define double ld\n\nint n, ans[maxn], a, b;\npii t[maxn];\n\nbool cmp(pii i, pii j)\n{\n\treturn i.f*a - i.f*b < j.f*a - j.f*b;\n}\n\nmain()\n{\n\tcin >> n >> a >> b;\n\tforn(1, i, n)\n\t{\n\t\tcin >> t[i].f;\n\t\tt[i].s = i;\n\t}\n\tsort(t + 1, t + 1 + n, cmp);\n\tforn(1, i, a)\n\t{\n\t\tans[t[i].s] = 1;\n\t}\n\tforn(1, i, n)\n\t{\n\t\tif(ans[i] == 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\tcout << 2 << \" \";\n\t}\n}",
        "fixed_code": "#include <bits/stdc++.h>\n\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n\n#define ll long long\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define o cout<<\"BUG\"<<endl;\n#define\tIOS ios_base::sync_with_stdio(0);\n#define en \"\\n\"\n#define FOR(i, j, n) for(int j = i; j < n; ++j)\n#define forn(i, j, n) for(int j = i; j <= n; ++j)\n#define nfor(i, j, n) for(int j = n; j >= i; --j)\n#define all(v) v.begin(), v.end()\n#define ld long double\n#define ull unsigned long long\n#define pii pair <int, int>\n\n\nusing namespace std;\nconst ll maxn=1e6+100,inf=1e18,LOG=23,mod=1e9+7;\nint block = 300, timer = 0;\nconst ld EPS = 1e-7;\n\n#define bt(i) (1 << (i))\n#define int ll\n//#define double ld\n\nint n, ans[maxn], a, b;\npii t[maxn];\n\nbool cmp(pii i, pii j)\n{\n\tif(i.f*a - i.f*b == j.f*a - j.f*b)\n\t{\n\t\treturn i.s < j.s;\n\t}\n\treturn i.f*a - i.f*b < j.f*a - j.f*b;\n}\n\nmain()\n{\n\tcin >> n >> a >> b;\n\tforn(1, i, n)\n\t{\n\t\tcin >> t[i].f;\n\t\tt[i].s = i;\n\t}\n\tsort(t + 1, t + 1 + n, cmp);\n\tforn(1, i, a)\n\t{\n\t\tans[t[i].s] = 1;\n\t}\n\tforn(1, i, n)\n\t{\n\t\tif(ans[i] == 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\tcout << 2 << \" \";\n\t}\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\nimport com.sun.org.apache.bcel.internal.generic.ALOAD;\n\n\npublic class C {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tstatic ArrayList<Integer>[]ages;\n\tstatic int[]order;\n\tstatic boolean[]used;\n\tstatic int size;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = nextInt();\n\t\tages = new ArrayList[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tages[i] = new ArrayList<>();\n\t\t}\n\t\tint m = nextInt();\n\t\tint k = nextInt();\n\t\tSet<Long> set = new TreeSet<>();\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tif (x==y)\n\t\t\t\tcontinue;\n\t\t\tlong hash1 = (long)(n+1) * x + y;\n\t\t\tlong hash2 = (long)(n+1) * y + x;\n\t\t\tif (set.contains(hash1) || set.contains(hash2))\n\t\t\t\tcontinue;\n\t\t\tages[x].add(y);\n\t\t\tages[y].add(x);\n\t\t\tset.add(hash1);\n\t\t\tset.add(hash2);\n\t\t}\n\t\tused = new boolean[n+1];\n\t\torder = new int[3*n+1];\n\t\tdfs(1, 0);\n\t\tint eachLen = 2 * n / k;\n\t\tif (2*n % k > 0)\n\t\t\teachLen++;\n\t\tint pos = 0;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint cnt = Math.min(eachLen, size-pos);\n\t\t\tpw.print(cnt+\" \");\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tpw.print(order[pos++]+\" \");\n\t\t\t}\n\t\t\tpw.println();\n\t\t}\n\t\tpw.close();\n\t}\n\tprivate static void dfs(int v, int p) {\n\t\tused[v] = true;\n\t\torder[size++] = v;\n\t\tfor (int to : ages[v]) {\n\t\t\tif (used[to])\n\t\t\t\tcontinue;\n\t\t\tdfs(to, v);\n\t\t\torder[size++] = v;\n\t\t}\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}",
        "fixed_code": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\nimport com.sun.org.apache.bcel.internal.generic.ALOAD;\n\n\npublic class C {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tstatic ArrayList<Integer>[]ages;\n\tstatic int[]order;\n\tstatic boolean[]used;\n\tstatic int size;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = nextInt();\n\t\tages = new ArrayList[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tages[i] = new ArrayList<>();\n\t\t}\n\t\tint m = nextInt();\n\t\tint k = nextInt();\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tif (x==y)\n\t\t\t\tcontinue;\n//\t\t\tlong hash1 = (long)(n+1) * x + y;\n//\t\t\tlong hash2 = (long)(n+1) * y + x;\n//\t\t\tif (set.contains(hash1) || set.contains(hash2))\n//\t\t\t\tcontinue;\n\t\t\tages[x].add(y);\n\t\t\tages[y].add(x);\n//\t\t\tset.add(hash1);\n//\t\t\tset.add(hash2);\n\t\t}\n\t\tused = new boolean[n+1];\n\t\torder = new int[3*n+1];\n\t\tdfs(1, 0);\n\t\tint eachLen = 2 * n / k;\n\t\tif (2*n % k > 0)\n\t\t\teachLen++;\n\t\tint pos = 0;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint cnt = Math.min(eachLen, size-pos);\n\t\t\tif (cnt==0) {\n\t\t\t\tpw.println(1+\" \"+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpw.print(cnt+\" \");\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tpw.print(order[pos++]+\" \");\n\t\t\t}\n\t\t\tpw.println();\n\t\t}\n\t\tpw.close();\n\t}\n\tprivate static void dfs(int v, int p) {\n\t\tused[v] = true;\n\t\torder[size++] = v;\n\t\tfor (int to : ages[v]) {\n\t\t\tif (used[to])\n\t\t\t\tcontinue;\n\t\t\tdfs(to, v);\n\t\t\torder[size++] = v;\n\t\t}\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "from math import inf as inf\nfrom math import *\nfrom collections import *\nimport sys\ninput=sys.stdin.readline\nt=1\nwhile(t):\n    t-=1\n    n=int(input())\n    flag=0\n    ch=n//4\n    ch1=0\n    if(n%4):\n        re=n%4\n    else:\n        re=0\n    while(1):\n        if(re==0 or ch<0):\n            break\n        re=4+re\n        ch-=1\n        if(re%7==0):\n            ch1+=re//7\n            re=0\n    if((4*ch)+(7*ch1)!=n or ch<0 or ch1<0):\n        print(-1)\n        exit(0)\n    print(ch*'4',ch1*'7',sep=\"\")\n            \n",
        "fixed_code": "from math import inf as inf\nfrom math import *\nfrom collections import *\nimport sys\ninput=sys.stdin.readline\nt=1\nwhile(t):\n    t-=1\n    n=int(input())\n    flag=0\n    ch=n//7\n    ch1=0\n    if(n%7):\n        re=n%7\n    else:\n        re=0\n    while(1):\n        if(re==0 or ch<0):\n            break\n        if(re%4==0):\n            ch1+=re//4\n            re=0\n            break\n        re=7+re\n        ch-=1\n    if((4*ch1)+(7*ch)!=n or ch<0 or ch1<0):\n        print(-1)\n        exit(0)\n    print(ch1*'4',ch*'7',sep=\"\")\n            \n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <stdio.h>\r\n\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint a[100007], b[100007];\r\n\r\nint main(){\r\n\tint t;\r\n\tscanf(\"%d\", &t);\r\n\tfor (int i = 1; i <= t; i++){\r\n\t\tint n, m, cnt = 0, ans = 0;\r\n\t\tscanf(\"%d %d\", &n, &m);\r\n\t\tfor (int j = 1; j <= m; j++){\r\n\t\t\tscanf(\"%d\", &a[j]);\r\n\t\t}\r\n\t\tsort(a + 1, a + m + 1);\r\n\t\tfor (int j = 1; j < m; j++){\r\n\t\t\tif (a[j + 1] - a[j] - 1 > 0) b[++cnt] = a[j + 1] - a[j] - 1;\r\n\t\t}\r\n\t\tif (a[m] != n || a[1] != 1) b[++cnt] = (n - a[m]) + (a[1] - 1);\r\n\t\tsort(b + 1, b + cnt + 1, greater<int>());\r\n\t\tfor (int j = 1, k = 0; j <= cnt; j++){\r\n\t\t\tb[j] = max(b[j] - k * 2, 0);\r\n\t\t\tif (b[j] == 1 || b[j] == 2){\r\n\t\t\t\tk++;\r\n\t\t\t\tans++;\r\n\t\t\t} else if (b[j] > 2){\r\n\t\t\t\tk += 2;\r\n\t\t\t\tans += b[j] - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprintf(\"%d\\n\", n - ans);\r\n\t}\r\n\treturn 0;\r\n}",
        "fixed_code": "#include <stdio.h>\r\n\r\n#include <algorithm>\r\n#include <functional>\r\n\r\nusing namespace std;\r\n\r\nint a[100007], b[100007];\r\n\r\nint main(){\r\n\tint t;\r\n\tscanf(\"%d\", &t);\r\n\tfor (int i = 1; i <= t; i++){\r\n\t\tint n, m, cnt = 0, ans = 0;\r\n\t\tscanf(\"%d %d\", &n, &m);\r\n\t\tfor (int j = 1; j <= m; j++){\r\n\t\t\tscanf(\"%d\", &a[j]);\r\n\t\t}\r\n\t\tsort(a + 1, a + m + 1);\r\n\t\tfor (int j = 1; j < m; j++){\r\n\t\t\tif (a[j + 1] - a[j] - 1 > 0) b[++cnt] = a[j + 1] - a[j] - 1;\r\n\t\t}\r\n\t\tif (a[m] != n || a[1] != 1) b[++cnt] = (n - a[m]) + (a[1] - 1);\r\n\t\tsort(b + 1, b + cnt + 1, greater<int>());\r\n\t\tfor (int j = 1, k = 0; j <= cnt; j++){\r\n\t\t\tb[j] = max(b[j] - k * 2, 0);\r\n\t\t\tif (b[j] == 1 || b[j] == 2){\r\n\t\t\t\tk++;\r\n\t\t\t\tans++;\r\n\t\t\t} else if (b[j] > 2){\r\n\t\t\t\tk += 2;\r\n\t\t\t\tans += b[j] - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprintf(\"%d\\n\", n - ans);\r\n\t}\r\n\treturn 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public java.util.List<model.Employee> getEmpSup(model.Employee e) {\n    javax.persistence.TypedQuery<model.Employee> query = em.createQuery((\"SELECT e FROM Employee AS e \" + \"WHERE e.empSupId = :sup\"), model.Employee.class);\n    query.setParameter(\"sup\", e.getEmpId());\n    java.util.List<model.Employee> employees = query.getResultList();\n    return employees != null ? employees : new java.util.ArrayList<model.Employee>();\n}",
        "fixed_code": "public java.util.List<model.Employee> getEmpSup(model.Employee e) {\n    javax.persistence.TypedQuery<model.Employee> query = em.createQuery((\"SELECT e FROM Employee AS e \" + \"WHERE e.empSupId = :sup AND e.empDel != 1 \"), model.Employee.class);\n    query.setParameter(\"sup\", e.getEmpId());\n    java.util.List<model.Employee> employees = query.getResultList();\n    return employees != null ? employees : new java.util.ArrayList<model.Employee>();\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<=n;i++)\n#define per(i,a,n) for(int i=n;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define FI first\n#define SE second\n#define maxn 300000\n#define mod 1000000007\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef double db;\n\nset<pii> S;\nvector<pii> upd[maxn+5];\nint n;\n\nvoid ins(int id,int from,int len)\n{\n    upd[id].pb(mp(from,len));\n}\n\nll pre[maxn+5];\nll sum;\nll cal(int x)\n{\n    int now=1;\n    ll cnt=0;\n    ll s=0; sum=0;\n    memset(pre,0,sizeof(ll)*(n+2));\n    rep(i,1,n)\n    {\n        for(auto it: upd[i])\n        {\n            int from=it.FI;\n            int len=it.SE;\n            if(from+1<now)\n            {\n                s+=1ll*(now-from-1)*len;\n                pre[now]+=len;\n            }\n            else pre[from+1]+=len;\n            pre[i+1]-=len;\n        }\n        while(now<=n && pre[now]>=x) s+=pre[now++],pre[now]+=pre[now-1];\n        sum+=s;\n        cnt+=now-1;\n    }\n    return cnt;\n}\n\nint main()\n{\n    int k; scanf(\"%d%d\",&n,&k);\n    S.insert(mp(inf,0));\n    rep(i,1,n)\n    {\n        int l,r; scanf(\"%d%d\",&l,&r);\n        int L=l,oldid=-1;\n        while(1)\n        {\n            auto it=S.lower_bound(mp(L,0));\n            if(oldid==-1) oldid=it->SE;\n            if(it->FI<=r)\n            {\n                ins(i,it->SE,it->FI-L);\n                L=it->FI;\n                S.erase(it);\n            }\n            else\n            {\n                ins(i,it->SE,r-L);\n                S.insert(mp(l,oldid));\n                S.insert(mp(r,i));\n                break;\n            }\n        }\n    }\n    int l=1,r=inf;\n    while(l<r)\n    {\n        int mid=(l+r)>>1;\n        int cnt=cal(mid);\n        if(cnt<k) r=mid;\n        else l=mid+1;\n    }\n    int cnt=cal(l);\n    ll ans=sum+1ll*(k-cnt)*(l-1);\n    printf(\"%I64d\\n\",ans);\n    return 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<=n;i++)\n#define per(i,a,n) for(int i=n;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define FI first\n#define SE second\n#define maxn 300000\n#define mod 1000000007\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef double db;\n\nset<pii> S;\nvector<pii> upd[maxn+5];\nint n;\n\nvoid ins(int id,int from,int len)\n{\n    upd[id].pb(mp(from,len));\n}\n\nll pre[maxn+5];\nll sum;\nll cal(int x)\n{\n    int now=1;\n    ll cnt=0;\n    ll s=0; sum=0;\n    memset(pre,0,sizeof(ll)*(n+2));\n    rep(i,1,n)\n    {\n        for(auto it: upd[i])\n        {\n            int from=it.FI;\n            int len=it.SE;\n            if(from+1<now)\n            {\n                s+=1ll*(now-from-1)*len;\n                pre[now]+=len;\n            }\n            else pre[from+1]+=len;\n            pre[i+1]-=len;\n        }\n        while(now<=n && pre[now]>=x) s+=pre[now++],pre[now]+=pre[now-1];\n        sum+=s;\n        cnt+=now-1;\n    }\n    return cnt;\n}\n\nint main()\n{\n    int k; scanf(\"%d%d\",&n,&k);\n    S.insert(mp(inf,0));\n    rep(i,1,n)\n    {\n        int l,r; scanf(\"%d%d\",&l,&r);\n        int L=l,oldid=-1;\n        while(1)\n        {\n            auto it=S.lower_bound(mp(L,0));\n            if(oldid==-1) oldid=it->SE;\n            if(it->FI<=r)\n            {\n                ins(i,it->SE,it->FI-L);\n                L=it->FI;\n                S.erase(it);\n            }\n            else\n            {\n                ins(i,it->SE,r-L);\n                S.insert(mp(l,oldid));\n                S.insert(mp(r,i));\n                break;\n            }\n        }\n    }\n    int l=1,r=inf;\n    while(l<r)\n    {\n        int mid=(l+r)>>1;\n        ll cnt=cal(mid);\n        if(cnt<k) r=mid;\n        else l=mid+1;\n    }\n    ll cnt=cal(l);\n    ll ans=sum+1ll*(k-cnt)*(l-1);\n    printf(\"%I64d\\n\",ans);\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define ss second\n#define ff first\n#define INF 300000000000001\n#define ll_max 9000000000000000000\n#define mod 998244353\n#define PI 3.14159265358979323846L\n#define fast ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define db(args...) {string _ss = #args; replace(_ss.begin(), _ss.end(), ',' , ' '); stringstream ___s(_ss) ; debug(___s, args);}\nusing namespace std;\ntypedef vector<pair<ll,ll> > vll;\ntypedef vector<pair<int,int> > vii ;\ntypedef pair<ll,ll> pll;\nconst ll N = 200001;\nconst ll M = 21;\nstruct point {\n    ll x, y, cur;\n    bool operator == (const point b)\n    {\n        if(this -> x == b.x && this -> y == b.y) return 1;\n        return 0;\n    }\n    bool operator != (const point b) {return !(*this == b);}\n    friend bool operator < (const point a, const point b)\n    {\n        if(a.x != b.x)\n            return a.x < b.x;\n        return a.y < b.y;\n    }\n};\n\nvoid debug(stringstream &s){}\ntemplate <typename T, typename... Args>\nvoid debug(stringstream &s, T a, Args... args)\n{\n    string word;\n    s >> word;\n    cout << word << \" = \" << a << endl;\n    debug(s, args...);\n}\n\nll fast_exp(ll x, ll n)\n{\n    if(n == 0) return 1;\n    ll ans;\n    if(n % 2 == 0)\n    {\n         ans = fast_exp(x, n / 2);\n         ans = ans * ans % mod;\n    }\n    else ans = fast_exp(x, n - 1) * x % mod;\n    return ans;\n}\n\nvoid solve(vector<int> tree[], ll x, bool v[], set<int> &sol, ll y = 0)\n{\n    if(v[x]) return;\n    if(y == 2)\n    {\n        sol.insert(x);\n        v[x] = 1;\n        return;\n    }\n    for(auto i:tree[x])\n    {\n        solve(tree, i, v, sol, y + 1);\n    }\n}\n\nint main()\n{\n    fast;\n    int _ = 1;\n    cin >> _;\n    while(_--)\n    {\n        ll n, m = 0, x = 0, y = 1, ans = 0, k;\n        cin >> n >> m;\n        vector<int> tree[n + 1];\n        for(int i = 0; i < m; i++)\n        {\n            cin >> x >> y;\n            tree[x].pb(y);\n        }\n        bool v[n + 1] = {};\n        set<int> sol;\n        for(int i = 0; i < n; i++)\n            sort(tree[i].begin(), tree[i].end());\n        for(int i = 0; i < n; i++)\n        {\n            if(!v[i])\n                solve(tree, i, v, sol);\n        }\n        cout << sol.size() << \"\\n\";\n        for(auto i:sol) cout << i << \" \";\n        cout << \"\\n\";\n     }\n     return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define ss second\n#define ff first\n#define INF 300000000000001\n#define ll_max 9000000000000000000\n#define mod 998244353\n#define PI 3.14159265358979323846L\n#define fast ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define db(args...) {string _ss = #args; replace(_ss.begin(), _ss.end(), ',' , ' '); stringstream ___s(_ss) ; debug(___s, args);}\nusing namespace std;\ntypedef vector<pair<ll,ll> > vll;\ntypedef vector<pair<int,int> > vii ;\ntypedef pair<ll,ll> pll;\nconst ll N = 200001;\nconst ll M = 21;\nstruct point {\n    ll x, y, cur;\n    bool operator == (const point b)\n    {\n        if(this -> x == b.x && this -> y == b.y) return 1;\n        return 0;\n    }\n    bool operator != (const point b) {return !(*this == b);}\n    friend bool operator < (const point a, const point b)\n    {\n        if(a.x != b.x)\n            return a.x < b.x;\n        return a.y < b.y;\n    }\n};\n\nvoid debug(stringstream &s){}\ntemplate <typename T, typename... Args>\nvoid debug(stringstream &s, T a, Args... args)\n{\n    string word;\n    s >> word;\n    cout << word << \" = \" << a << endl;\n    debug(s, args...);\n}\n\nll fast_exp(ll x, ll n)\n{\n    if(n == 0) return 1;\n    ll ans;\n    if(n % 2 == 0)\n    {\n         ans = fast_exp(x, n / 2);\n         ans = ans * ans % mod;\n    }\n    else ans = fast_exp(x, n - 1) * x % mod;\n    return ans;\n}\n\nbool solve(vector<int> tree[], ll x, bool v[], ll y = 0)\n{\n    if(v[x]) return 1;\n    if(y == 2)\n    {\n        return 0;\n    }\n    bool ans = 1;\n    for(auto i:tree[x])\n    {\n        ans &= solve(tree, i, v, y + 1);\n    }\n    return ans;\n}\n\nint main()\n{\n    fast;\n    int _ = 1;\n    cin >> _;\n    while(_--)\n    {\n        ll n, m = 0, x = 0, y = 1, ans = 0, k;\n        cin >> n >> m;\n        vector<int> tree[n + 1];\n        for(int i = 0; i < m; i++)\n        {\n            cin >> x >> y;\n            tree[y].pb(x);\n        }\n        bool v[n + 1] = {};\n        set<int> sol;\n        for(int i = 0; i < n; i++)\n            sort(tree[i].begin(), tree[i].end());\n        for(int i = 1; i <= n; i++)\n        {\n            if(!solve(tree, i, v))\n            {\n                sol.insert(i);\n                v[i] = 1;\n            }\n        }\n        cout << sol.size() << \"\\n\";\n        for(auto i:sol) cout << i << \" \";\n        cout << \"\\n\";\n     }\n     return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef unsigned long long int ull;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pp;\n\n#define ll long long\n#define sd(t) scanf(\"%d\",&(t))\n#define slld(t) scanf(\"%lld\",&(t))\n#define all(a) (a).begin(), (a).end()\n#define pb(a) push_back(a)\n#define pf(a) pop_front(a)\n#define pd(t) printf(\"%d\\n\",(t))\n#define plld(t) printf(\"%lld\\n\",(t))\n#define iarr(A,n) for(int lpl=0;lpl<n;lpl++){slld(A[lpl]);}\n#define parr(A,n) for(int lpl=0;lpl<n;lpl++){cout<<A[lpl]<<\" \";}cout<<endl;\n#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nll getSum(ll BITree[], ll index)\n{\n    ll sum = 0; // Initialize result\n    while (index > 0)\n    {\n        sum += BITree[index];\n        index -= index & (-index);\n    }\n    return sum;\n}\n \n// Updates a node in Binary Index Tree (BITree) at given index\n// in BITree.  The given value 'val' is added to BITree[i] and\n// all of its ancestors in tree.\nvoid updateBIT(ll BITree[], ll n, ll index, ll val)\n{\n    // Traverse all ancestors and add 'val'\n    while (index <= n)\n    {\n       // Add 'val' to current node of BI Tree\n       BITree[index] += val;\n \n       // Update index to that of parent in update View\n       index += index & (-index);\n    }\n}\n \n// Converts an array to an array with values from 1 to n\n// and relative order of smaller and greater elements remains\n// same.  For example, {7, -90, 100, 1} is converted to\n// {3, 1, 4 ,2 }\nvoid convert(ll arr[], ll n)\n{\n    // Create a copy of arrp[] in temp and sort the temp array\n    // in increasing order\n    ll temp[n];\n    for (ll i=0; i<n; i++)\n        temp[i] = arr[i];\n    sort(temp, temp+n);\n \n    // Traverse all array elements\n    for (ll i=0; i<n; i++)\n    {\n        // lower_bound() Returns poller to the first element\n        // greater than or equal to arr[i]\n        arr[i] = lower_bound(temp, temp+n, arr[i]) - temp + 1;\n    }\n}\n \n// Returns inversion count arr[0..n-1]\nll getInvCount(ll arr[], ll n)\n{\n    ll invcount = 0; // Initialize result\n    convert(arr, n);\n    ll BIT[n+1];\n    for (ll i=1; i<=n; i++)\n        BIT[i] = 0;\n    for (ll i=n-1; i>=0; i--)\n    {\n        invcount += getSum(BIT, arr[i]-1);\n        updateBIT(BIT, n, arr[i], 1);\n    }\n \n    return invcount;\n}\n\nint main()\n{    \n    boost;\n    ll n;\n    cin >> n;\n    ll A[n];\n    for (int i = 0; i < n; ++i)\n    {\n      cin >> A[i];\n    }\n    ll m;\n    cin >> m;\n    ll ans = getInvCount(A,n);\n    // cout << \"ANS : \" << ans << endl;\n    for (int i = 0; i < m; ++i)\n    {\n      parr(A,n);\n      ll l,r;\n      cin >> l >> r;\n      ll arr[r-l+1];\n      reverse(A+l-1,A+r);\n      // cout << \"A\" <<endl;\n      // for (int j = l-1; j < r; ++j)\n      // {\n      //   arr[j-(l-1)] = A[j];\n      // }\n      // // cout << \"A\" <<endl;\n      ans = getInvCount(A,n);\n      // // cout << \"A\" <<endl;\n      // ll n1 = (((r-l+1)*(r-l))/2);\n      // cout << \"A\" <<endl;\n      \n      if(ans%2==0)cout<<\"even\"<<endl;\n      else cout << \"odd\"<<endl; \n    }\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef unsigned long long int ull;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pp;\n\n#define ll long long\n#define sd(t) scanf(\"%d\",&(t))\n#define slld(t) scanf(\"%lld\",&(t))\n#define all(a) (a).begin(), (a).end()\n#define pb(a) push_back(a)\n#define pf(a) pop_front(a)\n#define pd(t) printf(\"%d\\n\",(t))\n#define plld(t) printf(\"%lld\\n\",(t))\n#define iarr(A,n) for(int lpl=0;lpl<n;lpl++){slld(A[lpl]);}\n#define parr(A,n) for(int lpl=0;lpl<n;lpl++){cout<<A[lpl]<<\" \";}cout<<endl;\n#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nll getSum(ll BITree[], ll index)\n{\n    ll sum = 0; // Initialize result\n    while (index > 0)\n    {\n        sum += BITree[index];\n        index -= index & (-index);\n    }\n    return sum;\n}\n \n// Updates a node in Binary Index Tree (BITree) at given index\n// in BITree.  The given value 'val' is added to BITree[i] and\n// all of its ancestors in tree.\nvoid updateBIT(ll BITree[], ll n, ll index, ll val)\n{\n    // Traverse all ancestors and add 'val'\n    while (index <= n)\n    {\n       // Add 'val' to current node of BI Tree\n       BITree[index] += val;\n \n       // Update index to that of parent in update View\n       index += index & (-index);\n    }\n}\n \n// Converts an array to an array with values from 1 to n\n// and relative order of smaller and greater elements remains\n// same.  For example, {7, -90, 100, 1} is converted to\n// {3, 1, 4 ,2 }\nvoid convert(ll arr[], ll n)\n{\n    // Create a copy of arrp[] in temp and sort the temp array\n    // in increasing order\n    ll temp[n];\n    for (ll i=0; i<n; i++)\n        temp[i] = arr[i];\n    sort(temp, temp+n);\n \n    // Traverse all array elements\n    for (ll i=0; i<n; i++)\n    {\n        // lower_bound() Returns poller to the first element\n        // greater than or equal to arr[i]\n        arr[i] = lower_bound(temp, temp+n, arr[i]) - temp + 1;\n    }\n}\n \n// Returns inversion count arr[0..n-1]\nll getInvCount(ll arr[], ll n)\n{\n    ll invcount = 0; // Initialize result\n    convert(arr, n);\n    ll BIT[n+1];\n    for (ll i=1; i<=n; i++)\n        BIT[i] = 0;\n    for (ll i=n-1; i>=0; i--)\n    {\n        invcount += getSum(BIT, arr[i]-1);\n        updateBIT(BIT, n, arr[i], 1);\n    }\n \n    return invcount;\n}\n\nint main()\n{    \n    boost;\n    ll n;\n    cin >> n;\n    ll A[n];\n    for (int i = 0; i < n; ++i)\n    {\n      cin >> A[i];\n    }\n    ll m;\n    cin >> m;\n    ll ans = getInvCount(A,n);\n    for (int i = 0; i < m; ++i)\n    {\n      // parr(A,n);\n      ll l,r;\n      cin >> l >> r;\n      // ll arr[r-l+1];\n      // cout << \"A\" <<endl;\n      // for (int j = l-1; j < r; ++j)\n      // {\n      //   arr[j-(l-1)] = A[j];\n      // }\n      // cout << \"A\" <<endl;\n      // ll num = getInvCount(A+l-1,r-l+1);\n      // reverse(A+l-1,A+r);\n      // cout << \"A\" <<endl;\n      ll n1 = (((r-l+1)*(r-l))/2);\n      // cout << \"A\" <<endl;\n      ans += (n1);\n      if(ans%2==0)cout<<\"even\"<<endl;\n      else cout << \"odd\"<<endl; \n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#define inf 1000000000\n\nusing namespace std;\n\nint n;\nint p[100005];\nint max1[100005], max2[100005];\nint cnt[100005];\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\n\tif(n <= 2){\n\t\tcout << p[1] << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tmax1[i] = max2[i] = -1;\n\t}\n\t\n\tint max_i = inf;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(max1[i-1] <= p[i]){\n\t\t\tmax2[i] = max1[i-1];\n\t\t\tmax1[i] = p[i];\n\t\t}\n\t\telse if(max2[i-1] <= p[i]){\n\t\t\tmax1[i] = max1[i-1];\n\t\t\tmax2[i] = p[i];\n\t\t}\n\t\telse{\n\t\t\tmax1[i] = max1[i-1];\n\t\t\tmax2[i] = max2[i-1];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(max1[i-1] >= p[i] && max2[i-1] < p[i]){\n\t\t\tcnt[max1[i-1]]++;\n\t\t}\n\t}\n\tint max_v = -1, ans;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(max_v < cnt[i]){\n\t\t\tmax_v = cnt[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}",
        "fixed_code": "#include <iostream>\n#define inf 1000000000\n\nusing namespace std;\n\nint n;\nint p[100005];\nint max1[100005], max2[100005];\nint cnt[100005];\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\n\tif(n <= 2){\n\t\tcout << p[1] << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tmax1[i] = max2[i] = -1;\n\t}\n\t\n\tint max_i = inf;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(max1[i-1] <= p[i]){\n\t\t\tmax2[i] = max1[i-1];\n\t\t\tmax1[i] = p[i];\n\t\t}\n\t\telse if(max2[i-1] <= p[i]){\n\t\t\tmax1[i] = max1[i-1];\n\t\t\tmax2[i] = p[i];\n\t\t}\n\t\telse{\n\t\t\tmax1[i] = max1[i-1];\n\t\t\tmax2[i] = max2[i-1];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(max1[i-1] >= p[i] && max2[i-1] < p[i]){\n\t\t\tcnt[max1[i-1]]++;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tif(max1[i-1] < p[i]){\n\t\t\tcnt[p[i]]--;\n\t\t}\n\t}\n\t\n\tint max_v = -inf, ans;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(max_v < cnt[i]){\n\t\t\tmax_v = cnt[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n\r\n    int n;\r\n    cin >>n;\r\n    for(int k=0;k<n;k++){\r\n            int a;\r\n    cin>>a;\r\n    int odd[a];\r\n    int even[a];\r\n    for(int i=0;i<a;i++){\r\n        cin>>odd[i];\r\n    }\r\n    for(int i=0;i<a;i++){\r\n        cin>>even[i];\r\n    }\r\n    map<int,int>m;\r\n    for(int i=0;i<a;i++){\r\n        m[odd[i]]=i;\r\n        m[even[i]]=i;\r\n    }\r\n    sort(odd,odd+a);\r\n    sort(even,even+a);\r\n    int mi=INT_MAX;\r\n    for(int i=0;i<a;i++){\r\n       \r\n        int g=m[odd[i]];\r\n        int op=INT_MAX;\r\n        for(int j=i;j<a;j++){\r\n            op=min(op,m[even[j]]);\r\n        }\r\n        mi=min(mi,op+g);\r\n    }\r\n    cout<<mi<<endl;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    return 0;\r\n}\r\n",
        "fixed_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n\r\n    int n;\r\n    cin >>n;\r\n    for(int k=0;k<n;k++){\r\n            int a;\r\n    cin>>a;\r\n    int odd[a];\r\n    int even[a];\r\n    for(int i=0;i<a;i++){\r\n        cin>>odd[i];\r\n    }\r\n    for(int i=0;i<a;i++){\r\n        cin>>even[i];\r\n    }\r\n    if(odd[0]<even[0]){\r\n        cout<<0<<endl;\r\n        continue;\r\n    }\r\n    map<int,int>m;\r\n    for(int i=0;i<a;i++){\r\n        m[odd[i]]=i;\r\n        m[even[i]]=i;\r\n    }\r\n    sort(odd,odd+a);\r\n    sort(even,even+a);\r\n    vector<int>opoo(a,INT_MAX);\r\n    opoo[a-1]=m[even[a-1]];\r\n    for(int i=a-2;i>=0;i--){\r\n        opoo[i]=min(opoo[i+1],m[even[i]]);\r\n    }\r\n    \r\n    int mi=INT_MAX;\r\n    \r\n    for(int i=0;i<a;i++){\r\n       \r\n        mi=min(mi,m[odd[i]]+opoo[i]);\r\n    }\r\n    cout<<mi<<endl;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void save(org.jumpmind.metl.core.model.FlowStep flowStep) {\n    org.jumpmind.metl.core.model.Component component = flowStep.getComponent();\n    if (!(component.isShared())) {\n        save(component);\n    }\n    save(((org.jumpmind.metl.core.model.AbstractObject) (flowStep)));\n}",
        "fixed_code": "protected void save(org.jumpmind.metl.core.model.FlowStep flowStep, boolean newProjectVersion) {\n    org.jumpmind.metl.core.model.Component component = flowStep.getComponent();\n    save(component);\n    save(((org.jumpmind.metl.core.model.AbstractObject) (flowStep)));\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "s = raw_input()\n\nn = len(s)\n\nsieve = range(2,n+1)\n\nps = []\nwhile len(sieve) > 0:\n    p = sieve[0]\n    ps.append(p)\n    sieve = filter(lambda x: x%p != 0, sieve)\n    \nps = [1] + filter(lambda x: x*2 > n, ps)\nlongest = n - len(ps)\n\ndic = {}\n\nfor x in s:\n    dic[x] = dic.get(x, 0) + 1\n\nkey = None\nmax_v = 0\nfor (k, v) in dic.items():\n    if max_v < v:\n        key = k\n        max_v = v\n\n\nif max_v < longest:\n    print 'NO'\nelse:\n    print 'YES'\n    ans = [key] * n\n    del dic[key]\n    i = 0\n    print dic\n    print ps\n    for (k, v) in dic.items():\n        for _ in range(v):\n            i = ps.pop()\n            ans[i-1] = k\n    print (reduce(lambda x,y: x+y, ans))\n",
        "fixed_code": "s = raw_input()\n\nn = len(s)\n\nsieve = range(2,n+1)\n\nps = []\nwhile len(sieve) > 0:\n    p = sieve[0]\n    ps.append(p)\n    sieve = filter(lambda x: x%p != 0, sieve)\n    \nps = [1] + filter(lambda x: x*2 > n, ps)\nlongest = n - len(ps)\n\ndic = {}\n\nfor x in s:\n    dic[x] = dic.get(x, 0) + 1\n\nkey = None\nmax_v = 0\nfor (k, v) in dic.items():\n    if max_v < v:\n        key = k\n        max_v = v\n\n\nif max_v < longest:\n    print 'NO'\nelse:\n    print 'YES'\n    ans = [key] * n\n    del dic[key]\n    i = 0\n    for (k, v) in dic.items():\n        for _ in range(v):\n            i = ps.pop()\n            ans[i-1] = k\n    print (reduce(lambda x,y: x+y, ans))\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "public void setupWindow() {\n    this.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n    this.setSize(450, 400);\n    this.setLocation(400, 200);\n    this.setVisible(true);\n    this.setResizable(false);\n}",
        "fixed_code": "public void setupWindow() {\n    this.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n    this.setSize(550, 500);\n    this.setLocation(300, 150);\n    this.setVisible(true);\n    this.setResizable(false);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\n#define forr(i, a, n) for(int i = n; i >= a; i--)\n#define fi first\n#define se second\n#include <algorithm>\n#define all(x) std::begin(x),std::end(x)\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <utility>\n#define forn(i, n) for(int i=0;i<n;i++)\n#define limpiar(a, b) memset(a, b, sizeof(a))\n\nusing namespace std;\n\nconst int MAXN = 2e5+5;\nvector<int> graph[MAXN];\nint profundidades[MAXN];\nint dist_0[MAXN];\nint dist_n[MAXN];\n\nvoid dfs(int nodo, int prof) {\n    queue<pair<int, int> > cola;\n    cola.push(make_pair(nodo, 0));\n    while (cola.size()) {\n        nodo = cola.front().first;\n        prof = cola.front().second;\n        cola.pop();\n\n        profundidades[nodo] = prof;\n        for (int v : graph[nodo]) {\n            if (profundidades[v] == -1) {\n                profundidades[v] = 0;\n                cola.push(make_pair(v, prof+1));\n            }\n        }\n    }\n}\n\nstruct segtree {\n    int size;\n    vector<pair<int, int> > arr;\n    vector<pair<int, int> > lazy;\n\n    segtree(int n) {\n        int copia = n;\n        size = 1;\n\n        while(copia > 1) {copia>>=1; size<<=1;}    \n\n        if (size < n) {\n            size <<= 1;\n        }\n\n        arr.resize(2*size, make_pair(0,0));\n        // lazy.resize(size);\n    }\n    \n    pair<int, int> query(int a, int b, int nodo=1, int l=0, int r=0) {\n        if (nodo == 1) {\n            r = size-1;\n        }\n\n        if (a > r || b < l) {\n            return make_pair(0,0);\n        }\n\n        if (l >= a && r <= b) {\n            return arr[nodo];\n        }\n\n        int m = (l + r) / 2;\n\n        auto lc = query(a, b, nodo<<1, l, m);\n        auto rc = query(a, b, nodo<<1|1, m+1, r);\n\n        return make_pair(max(lc.fi, rc.fi), max(lc.se, rc.se));\n    }\n};\n\nint bit[MAXN];\nint k;\n\nvoid update(int ind, int val) {\n    for (ind++; ind<=k; ind += (ind & -ind)) {\n        bit[ind] = max(val, bit[ind]);\n    }\n}\n\nint query(int ind) {\n    int ans = 0;\n    for (ind++; ind > 0; ind -= (ind & -ind)) {\n        ans = max(ans, bit[ind]);\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m >> k;\n\n    vector<int> nodos_especiales(k);\n    forn (i, k) {\n        int especial;\n        cin >> especial;\n\n        nodos_especiales[i] = especial-1;\n    }\n\n    forn (i, m) {\n        int a, b;\n        cin >> a >> b;\n\n        a--, b--;\n\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    limpiar(profundidades, -1);\n    dfs(0, 0);\n\n    memcpy(dist_0, profundidades, sizeof(profundidades));\n\n    limpiar(profundidades, -1);\n    dfs(n-1, 0);\n\n    memcpy(dist_n, profundidades, sizeof(profundidades));\n\n    vector<pair<int,int> > X(k);\n    forn (i, k) {\n        int nodo = nodos_especiales[i];\n\n        X[i] = make_pair(dist_0[nodo] - dist_n[nodo], nodo);\n    }\n\n    sort(all(X));\n\n    segtree st(k);\n    \n    forn (i, k) {\n        int nodo = X[i].se;\n\n        // update(i, dist_n[nodo]);\n        int nodo_arbol = st.size + i;\n\n        st.arr[nodo_arbol] = make_pair(dist_0[nodo], dist_n[nodo]);\n        for (nodo_arbol;nodo_arbol>0;nodo_arbol>>=1) {\n            st.arr[nodo_arbol>>1] = make_pair(\n                max(st.arr[nodo_arbol].fi, st.arr[nodo_arbol^1].fi),\n                max(st.arr[nodo_arbol].se, st.arr[nodo_arbol^1].se)\n            );\n        }\n    }\n\n    int maximo = 0;\n    forr (i, 1, k-1) {\n        int nodo = X[i].se;\n\n        int eleccion = st.query(i+1, k-1).se;\n        // int eleccion = query(i-1);\n\n        maximo = max(maximo, eleccion+1+dist_0[nodo]);\n    }\n\n    cout << min(dist_0[n-1], maximo) << endl;\n}",
        "fixed_code": "#include <iostream>\n#define forr(i, a, n) for(int i = n; i >= a; i--)\n#define fi first\n#define se second\n#include <algorithm>\n#define all(x) std::begin(x),std::end(x)\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <utility>\n#define forn(i, n) for(int i=0;i<n;i++)\n#define limpiar(a, b) memset(a, b, sizeof(a))\n\nusing namespace std;\n\nconst int MAXN = 2e5+5;\nvector<int> graph[MAXN];\nint profundidades[MAXN];\nint dist_0[MAXN];\nint dist_n[MAXN];\n\nvoid dfs(int nodo, int prof) {\n    queue<pair<int, int> > cola;\n    cola.push(make_pair(nodo, 0));\n    while (cola.size()) {\n        nodo = cola.front().first;\n        prof = cola.front().second;\n        cola.pop();\n\n        profundidades[nodo] = prof;\n        for (int v : graph[nodo]) {\n            if (profundidades[v] == -1) {\n                profundidades[v] = 0;\n                cola.push(make_pair(v, prof+1));\n            }\n        }\n    }\n}\n\nstruct segtree {\n    int size;\n    vector<pair<int, int> > arr;\n    vector<pair<int, int> > lazy;\n\n    segtree(int n) {\n        int copia = n;\n        size = 1;\n\n        while(copia > 1) {copia>>=1; size<<=1;}    \n\n        if (size < n) {\n            size <<= 1;\n        }\n\n        arr.resize(2*size, make_pair(0,0));\n        // lazy.resize(size);\n    }\n    \n    pair<int, int> query(int a, int b, int nodo=1, int l=0, int r=0) {\n        if (nodo == 1) {\n            r = size-1;\n        }\n\n        if (a > r || b < l) {\n            return make_pair(0,0);\n        }\n\n        if (l >= a && r <= b) {\n            return arr[nodo];\n        }\n\n        int m = (l + r) / 2;\n\n        auto lc = query(a, b, nodo<<1, l, m);\n        auto rc = query(a, b, nodo<<1|1, m+1, r);\n\n        return make_pair(max(lc.fi, rc.fi), max(lc.se, rc.se));\n    }\n};\n\nint bit[MAXN];\nint k;\n\nvoid update(int ind, int val) {\n    for (ind++; ind<=k; ind += (ind & -ind)) {\n        bit[ind] = max(val, bit[ind]);\n    }\n}\n\nint query(int ind) {\n    int ans = 0;\n    for (ind++; ind > 0; ind -= (ind & -ind)) {\n        ans = max(ans, bit[ind]);\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m >> k;\n\n    vector<int> nodos_especiales(k);\n    forn (i, k) {\n        int especial;\n        cin >> especial;\n\n        nodos_especiales[i] = especial-1;\n    }\n\n    forn (i, m) {\n        int a, b;\n        cin >> a >> b;\n\n        a--, b--;\n\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    limpiar(profundidades, -1);\n    dfs(0, 0);\n\n    memcpy(dist_0, profundidades, sizeof(profundidades));\n\n    limpiar(profundidades, -1);\n    dfs(n-1, 0);\n\n    memcpy(dist_n, profundidades, sizeof(profundidades));\n\n    vector<pair<int,int> > X(k);\n    forn (i, k) {\n        int nodo = nodos_especiales[i];\n\n        X[i] = make_pair(dist_0[nodo] - dist_n[nodo], nodo);\n    }\n\n    sort(all(X));\n\n    segtree st(k);\n    \n    forn (i, k) {\n        int nodo = X[i].se;\n\n        // update(i, dist_n[nodo]);\n        int nodo_arbol = st.size + i;\n\n        st.arr[nodo_arbol] = make_pair(dist_0[nodo], dist_n[nodo]);\n        for (nodo_arbol;nodo_arbol>0;nodo_arbol>>=1) {\n            st.arr[nodo_arbol>>1] = make_pair(\n                max(st.arr[nodo_arbol].fi, st.arr[nodo_arbol^1].fi),\n                max(st.arr[nodo_arbol].se, st.arr[nodo_arbol^1].se)\n            );\n        }\n    }\n\n    int maximo = 0;\n    forn (i, k-1) {\n        int nodo = X[i].se;\n\n        int eleccion = st.query(i+1, k-1).se;\n        // int eleccion = query(i-1);\n\n        maximo = max(maximo, eleccion+1+dist_0[nodo]);\n    }\n\n    cout << min(dist_0[n-1], maximo) << endl;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\n    string name;\n\n    cin>>name;\n\n    vector<int>v1;\n    vector<int>v2;\n    int n=name.size();\n    int left=0,right=0;\n\n    for(int i=0; i<n; i++)\n        if(name[i]==')')\n            left++;\n\n    for(int i=0; i<n; i++)\n        if(name[i]=='(')\n            right++;\n\n\n    for(int i=0; i<min(left,right); i++)\n    {\n        if(name[i]=='(')\n            v1.push_back(i+1);\n\n\n    }\n\n\n    for(int i=name.size()-1; i>=min(left,right); i--)\n    {\n        if(name[i]==')')\n            v2.push_back(i+1);\n\n\n    }\n    if(v1.size()==0||v2.size()==0)\n    {\n        cout<<\"0\"<<endl;\n        return 0;\n\n    }\n    sort(v2.begin(),v2.end());\n    cout<<\"1\"<<endl;\n    cout<<v2.size()*2<<endl;\n/// cout<<v1.size()<<v2.size()<<endl;\n\n    for(auto&it : v1)\n        cout<<it<<\" \";\n    for(auto&it : v2)\n        cout<<it<<\" \";\n\n\n\n\n\n\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\n    string name;\n\n    cin>>name;\n\n    vector<int>v1;\n    vector<int>v2;\n    int n=name.size();\n    int left=0,right=INT_MAX;\n\n    for(int i=0; i<n; i++)\n        if(name[i]==')')\n            left++;\n\n\n\n    for(int i=0; i<min(left,right); i++)\n    {\n        if(name[i]=='(')\n            v1.push_back(i+1);\n\n\n    }\n\n\n    for(int i=name.size()-1; i>=min(left,right); i--)\n    {\n        if(name[i]==')')\n            v2.push_back(i+1);\n\n\n    }\n    if(v1.size()==0||v2.size()==0)\n    {\n        cout<<\"0\"<<endl;\n        return 0;\n\n    }\n    sort(v2.begin(),v2.end());\n    cout<<\"1\"<<endl;\n    cout<<v2.size()*2<<endl;\n/// cout<<v1.size()<<v2.size()<<endl;\n\n    for(auto&it : v1)\n        cout<<it<<\" \";\n    for(auto&it : v2)\n        cout<<it<<\" \";\n\n\n\n\n\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <map>\n#include <stdlib.h>\nusing namespace std;\n\nint main()\n{\n    long long *arr=new long long[100],*arr1=new long long[100],n,x,z,co=0,co1=0,k,m,fin=1000000;\n    map<long long,long long>left;\n    map<long long,long long>right;\n    cin>>n;\n    if(n%2==0)\n        k=n/2;\n    else\n        k=(n/2)+1;\n    for(int i=0;i<n;i++)\n    {\n        cin>>x>>z;\n        if(left[x]==0)\n            {arr[co++]=x; left[x]++;}\n        else\n            left[x]++;\n        if(right[z]==0)\n            {arr1[co1++]=z; right[z]++;}\n        else\n            right[z]++;\n    }\n    for(int i=0;i<co;i++)\n    {\n        m=1000001;\n        if((left[arr[i]]+right[arr[i]])>=k)\n        {\n            m=k-left[arr[i]];\n            if(m<0)\n            {\n                cout<<\"0\";\n                exit(0);\n            }\n        }\n            if(m<fin)\n                fin=m;\n    }\n    if(fin==1000000)\n    {\n        for(int i=0;i<co1;i++)\n        {\n            if(right[arr1[i]]>=k)\n            {\n                cout<<k;\n                exit(0);\n            }\n        }\n    }\n    if(fin==1000000)\n        cout<<\"-1\";\n    else\n        cout<<fin;\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <map>\n#include <stdlib.h>\nusing namespace std;\n\nint main()\n{\n    long long arr[100000],arr1[100000],n,x,z,co=0,co1=0,k,m,fin=1000000;\n    map<long long,long long>left;\n    map<long long,long long>right;\n    cin>>n;\n    if(n%2==0)\n        k=n/2;\n    else\n        k=(n/2)+1;\n    for(int i=0;i<n;i++)\n    {\n        cin>>x>>z;\n        if(x==z)\n        {\n            if(left[x]==0)\n                {arr[co++]=x; left[x]++;}\n            else\n                left[x]++;\n        }\n        else\n        {\n            if(left[x]==0)\n                {arr[co++]=x; left[x]++;}\n            else\n                left[x]++;\n            if(right[z]==0)\n                {arr1[co1++]=z; right[z]++;}\n            else\n                right[z]++;\n        }\n    }\n    for(int i=0;i<co;i++)\n    {\n        m=1000001;\n        if((left[arr[i]]+right[arr[i]])>=k)\n        {\n            m=k-left[arr[i]];\n\n            if(m<0)\n            {\n                cout<<\"0\";\n                exit(0);\n            }\n        }\n            if(m<fin)\n                {fin=m;}\n    }\n    if(fin==1000000)\n    {\n        for(int i=0;i<co1;i++)\n        {\n            if(right[arr1[i]]>=k)\n            {\n                cout<<k;\n                exit(0);\n            }\n        }\n    }\n    if(fin==1000000)\n        cout<<\"-1\";\n    else\n        cout<<fin;\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private void setProxSpeaker(final boolean speaker) {\n    mHandler.removeCallbacks(mActivateSpeaker);\n    final int audioMode = mAudioModeProvider.getAudioMode();\n    final boolean proxSpeakerIncallOnlyPref = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.PROXIMITY_AUTO_SPEAKER_INCALL_ONLY, 0)) == 1;\n    mProxSpeakerDelay = Settings.System.getInt(mContext.getContentResolver(), Settings.System.PROXIMITY_AUTO_SPEAKER_DELAY, 100);\n    if ((((mIsPhoneOffhook) && ((Settings.System.getInt(mContext.getContentResolver(), Settings.System.PROXIMITY_AUTO_SPEAKER, 0)) == 1)) && (audioMode != (com.android.services.telephony.common.AudioMode.WIRED_HEADSET))) && (audioMode != (com.android.services.telephony.common.AudioMode.BLUETOOTH))) {\n        if (speaker && (audioMode != (com.android.services.telephony.common.AudioMode.SPEAKER))) {\n            if ((!proxSpeakerIncallOnlyPref) || (proxSpeakerIncallOnlyPref && (!(mHasOutgoingCall)))) {\n                mHandler.postDelayed(mActivateSpeaker, mProxSpeakerDelay);\n            }\n        }else\n            if (!speaker) {\n                com.android.incallui.TelecomAdapter.getInstance().setAudioRoute(AudioMode.EARPIECE);\n            }\n        \n    }\n}",
        "fixed_code": "private void setProxSpeaker(final boolean speaker) {\n    mHandler.removeCallbacks(mActivateSpeaker);\n    final int audioMode = mAudioModeProvider.getAudioMode();\n    final boolean proxAutoSpeaker = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.PROXIMITY_AUTO_SPEAKER, 0)) == 1;\n    mProxSpeakerDelay = Settings.System.getInt(mContext.getContentResolver(), Settings.System.PROXIMITY_AUTO_SPEAKER_DELAY, 100);\n    if ((mIsPhoneOffhook) && proxAutoSpeaker) {\n        if (audioMode == (com.android.services.telephony.common.AudioMode.SPEAKER)) {\n            mHandler.postDelayed(mActivateSpeaker, 100);\n        }else {\n            mHandler.postDelayed(mActivateSpeaker, mProxSpeakerDelay);\n        }\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "m = int(input())\nfor i in range(m):\n    a, b, n, S = map(int, input().split())\n\n    amount = 0\n    if S >= n:\n        if S >= n * a:\n            if S - n * a > b:\n                print(\"NO\")\n            else:\n                print(\"YES\")\n        else:\n            for j in range(1, a + 1):\n                if n * j > S:\n                    break\n                else:\n                    amount += 1\n            if S - amount * n <= b:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n    else:\n        if S <= b:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n",
        "fixed_code": "m = int(input())\nfor i in range(m):\n    a, b, n, S = map(int, input().split())\n    amount = 0\n    if S >= n:\n        if S >= n * a:\n            if S - n * a > b:\n                print(\"NO\")\n            else:\n                print(\"YES\")\n        else:\n            amount = S // n\n            if S - amount * n <= b:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n    else:\n        if S <= b:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "@org.springframework.web.bind.annotation.RequestMapping(value = { \"/invest/{projectId}/rewardDisplay/{rewardId}\" }, method = org.springframework.web.bind.annotation.RequestMethod.GET)\npublic java.lang.String projectDisplay(javax.servlet.http.HttpServletRequest request, org.springframework.ui.ModelMap model, @org.springframework.web.bind.annotation.PathVariable\nlong projectId, @org.springframework.web.bind.annotation.PathVariable\nlong rewardId) {\n    fr.epita.sigl.mepa.core.domain.AppUser tmpUser = ((fr.epita.sigl.mepa.core.domain.AppUser) (request.getSession().getAttribute(\"userCo\")));\n    if ((((boolean) (request.getSession().getAttribute(\"isCo\"))) == false) || (tmpUser == null)) {\n        java.lang.String errorCo = \"Veuillez vous identifier pour investir dans un projet\";\n        model.addAttribute(\"messageRedirect\", errorCo);\n        return \"/authentification/signin\";\n    }\n    fr.epita.sigl.mepa.core.domain.Reward reward = rewardService.getRewardById(rewardId);\n    if (reward == null) {\n        java.lang.String errorMessage = \"Votre donation n'a pu être prise en compte. La contrepartie sélectionnée n'existe pas. Veuillez rééssayer ultérieurement.\";\n        model.addAttribute(\"errorInvest\", errorMessage);\n        return projectDisplayController.projectDisplay(request, model, projectId);\n    }\n    long rewardPrice = reward.getCostStart();\n    java.lang.String description = reward.getDescription();\n    java.lang.String rewardName = reward.getName();\n    model.addAttribute(\"rewardPrice\", rewardPrice);\n    model.addAttribute(\"description\", description);\n    model.addAttribute(\"rewardName\", rewardName);\n    model.addAttribute(\"projectId\", projectId);\n    model.addAttribute(\"rewardId\", rewardId);\n    return \"/invest/rewardpay\";\n}",
        "fixed_code": "@org.springframework.web.bind.annotation.RequestMapping(value = { \"/invest/{projectId}/rewardDisplay/{rewardId}\" }, method = org.springframework.web.bind.annotation.RequestMethod.GET)\npublic java.lang.String projectDisplay(javax.servlet.http.HttpServletRequest request, org.springframework.ui.ModelMap model, @org.springframework.web.bind.annotation.PathVariable\nlong projectId, @org.springframework.web.bind.annotation.PathVariable\nlong rewardId) {\n    fr.epita.sigl.mepa.core.domain.AppUser tmpUser = ((fr.epita.sigl.mepa.core.domain.AppUser) (request.getSession().getAttribute(\"userCo\")));\n    if ((((boolean) (request.getSession().getAttribute(\"isCo\"))) == false) || (tmpUser == null)) {\n        java.lang.String errorCo = \"Veuillez vous identifier pour investir dans un projet\";\n        model.addAttribute(\"messageRedirect\", errorCo);\n        return \"/authentification/signin\";\n    }\n    fr.epita.sigl.mepa.core.domain.Reward reward = rewardService.getRewardById(rewardId);\n    if (reward == null) {\n        java.lang.String errorMessage = \"Votre donation n'a pu être prise en compte. La contrepartie sélectionnée n'existe pas. Veuillez rééssayer ultérieurement.\";\n        model.addAttribute(\"errorInvest\", errorMessage);\n        return projectDisplayController.projectDisplay(request, model, projectId);\n    }\n    float rewardPrice = reward.getCostStart();\n    java.lang.String description = reward.getDescription();\n    java.lang.String rewardName = reward.getName();\n    model.addAttribute(\"rewardPrice\", rewardPrice);\n    model.addAttribute(\"description\", description);\n    model.addAttribute(\"rewardName\", rewardName);\n    model.addAttribute(\"projectId\", projectId);\n    model.addAttribute(\"rewardId\", rewardId);\n    return \"/invest/rewardpay\";\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<stdio.h>\nint main()\n{\n    long long n,k,i,l=2,p;\n    scanf(\"%lld%lld\",&n,&k);\n    p=k;\n    if(k>n-1)\n    {\n    printf(\"-1\\n\");\n    return 0;\n}   \nelse {\n    printf(\"2 \");\n    while(k--)\n    {\n        printf(\"%lld \",l);\n        l++;\n    }\n}\n    for(i=p+1;i<n;i++)\n    printf(\"%lld \",1);\n    return 0;\n}",
        "fixed_code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint n, k, i, a[110000];\n\nint main()\n{\n\tcin >> n >> k;\n\n\tif(n <= k)\n\t{\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\n\tfor(i = n; i > n - k; i--)\n\t\ta[i] = i;\n\n\tfor(i = n - k; i > 0; i--)\n\t\ta[i] = i - 1;\n\n\ta[1] = n - k;\n\n\tfor(i = 1; i <= n; i++)\n\t\tcout << a[i] << \" \";\n\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*package whatever //do not write package name here */\r\n\r\nimport java.util.Scanner;\r\npublic class code{\r\n    public static void main(String args[]){\r\n        Scanner s = new Scanner(System.in);\r\n        int t = s.nextInt();\r\n        while(t-->0){\r\n            long n = s.nextLong();\r\n            long sum = 0;\r\n            for(long i = 1;i<=n;i++){\r\n                if(i%2==0){\r\n                    sum+=(i/2);\r\n                }else{\r\n                    sum+=(i/2)+1;\r\n                }\r\n            }\r\n            double d1 = Math.sqrt(sum);\r\n            long ans = (long)d1;\r\n            System.out.println(ans);\r\n        }\r\n    }\r\n}",
        "fixed_code": "/*package whatever //do not write package name here */\r\n\r\nimport java.util.Scanner;\r\npublic class code{\r\n    public static void main(String args[]){\r\n        Scanner s = new Scanner(System.in);\r\n        int t = s.nextInt();\r\n        while(t-->0){\r\n            long n = s.nextLong();\r\n            long t1 = n;\r\n            if(n%2!=0){\r\n                t1 = n-1;\r\n            }\r\n            t1 = t1/2;\r\n            long sum1 = (t1*(t1+1)/2)*2;\r\n            if(n%2!=0){\r\n                sum1+=(n/2)+1;\r\n            }\r\n            double d1 = Math.sqrt(sum1);\r\n            long ans = (long)d1;\r\n            System.out.println(ans);\r\n        }\r\n    }\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nint Query(vector<int> x, vector<int> y)\n{\n    int i;\n    string o;\n\n    cout << \"? \" << x.size() << ' ' << y.size() << endl;\n    for(i = 0; i < (signed)x.size(); i ++)\n        cout << x[i] << \" \\n\"[i == (signed)x.size() - 1];\n    for(i = 0; i < (signed)y.size(); i ++)\n        cout << y[i] << \" \\n\"[i == (signed)y.size() - 1];\n    \n    cout.flush();\n    cin >> o;\n\n    return o == \"SECOND\" ? -1 : o == \"FIRST\";\n}\n\nvoid Answer(int x)\n{\n    cout << \"! \" << x << endl;\n    cout.flush();\n\n    return;\n}\n\nint Solve(vector<int> x, vector<int> y)\n{\n    int l, m, r;\n\n    for(l = -1, r = (int)y.size() - 1; l + 1 < r; )\n    {\n        m = (l + r) / 2;\n        if(!Query(vector<int>(x.begin(), x.begin() + m), vector<int>(y.begin(), y.begin() + m)))\n            l = m;\n        else\n            r = m;\n    }\n\n    return y[r];\n}\n\nint main(void)\n{\n    int t, n, k;\n    int i, p, q;\n    vector<int> x, y;\n\n    cin >> t;\n    while(t --)\n    {\n        cin >> n >> k;\n        for(i = 0, p = 1; i < 30; i ++)\n        {\n            do\n                q = rand() % n + 1;\n            while(p == q);\n            if(Query({p}, {q}) == -1)\n                p = q;\n        }\n\n        x = {p};\n        y.clear();\n        for(i = 1; i <= n; i ++)\n            if(i != p)\n                y.push_back(i);\n\n        while(true)\n        {\n            q = (int)min(x.size(), y.size());\n            if(!Query(vector<int>(x.begin(), x.begin() + q), vector<int>(y.begin(), y.begin() + q)))\n            {\n                x.insert(x.end(), y.begin(), y.begin() + q);\n                y.erase(y.begin(), y.begin() + q);\n            }\n            else\n            {\n                Answer(Solve(vector<int>(x.begin(), x.begin() + q), vector<int>(y.begin(), y.begin() + q)));\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n",
        "fixed_code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nint Query(vector<int> x, vector<int> y)\n{\n    int i;\n    string o;\n\n    cout << \"? \" << x.size() << ' ' << y.size() << endl;\n    for(i = 0; i < (signed)x.size(); i ++)\n        cout << x[i] << \" \\n\"[i == (signed)x.size() - 1];\n    for(i = 0; i < (signed)y.size(); i ++)\n        cout << y[i] << \" \\n\"[i == (signed)y.size() - 1];\n    \n    cout.flush();\n    cin >> o;\n\n    return o == \"SECOND\" ? -1 : o == \"FIRST\";\n}\n\nvoid Answer(int x)\n{\n    cout << \"! \" << x << endl;\n    cout.flush();\n\n    return;\n}\n\nint Solve(vector<int> x, vector<int> y)\n{\n    int l, m, r;\n\n    for(l = -1, r = (int)y.size() - 1; l + 1 < r; )\n    {\n        m = (l + r) / 2;\n        if(!Query(vector<int>(x.begin(), x.begin() + m + 1), vector<int>(y.begin(), y.begin() + m + 1)))\n            l = m;\n        else\n            r = m;\n    }\n\n    return y[r];\n}\n\nint main(void)\n{\n    int t, n, k;\n    int i, p, q;\n    vector<int> x, y;\n\n    cin >> t;\n    while(t --)\n    {\n        cin >> n >> k;\n        for(i = 0, p = 1; i < 30; i ++)\n        {\n            do\n                q = rand() % n + 1;\n            while(p == q);\n            if(Query({p}, {q}) == -1)\n                p = q;\n        }\n\n        x = {p};\n        y.clear();\n        for(i = 1; i <= n; i ++)\n            if(i != p)\n                y.push_back(i);\n\n        while(true)\n        {\n            q = (int)min(x.size(), y.size());\n            if(!Query(vector<int>(x.begin(), x.begin() + q), vector<int>(y.begin(), y.begin() + q)))\n            {\n                x.insert(x.end(), y.begin(), y.begin() + q);\n                y.erase(y.begin(), y.begin() + q);\n            }\n            else\n            {\n                Answer(Solve(vector<int>(x.begin(), x.begin() + q), vector<int>(y.begin(), y.begin() + q)));\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define ll long long\n#define M 10004205361450474\nusing namespace std;\nll p[100000];\nvoid solve(ll l, ll r, int k)\n{\n\tp[0] = l - 1;\n\tp[k + 1] = r;\n\tll len = r - l + 1;\n\tif (len <= k)\n\t{\n\t\tprintf(\"%I64d\", len);\n\t\tfor (ll i = l; i <= r; i++)\n\t\t\tprintf(\" %I64d\", i);\n\t\tputs(\"\");\n\t\tfflush(stdout);\n\t\treturn;\n\t}\n\tlen /= k;\n\tfor (int i = 1; i <= k; i++)\n\t{\n\t\tp[i] = l + k - 1;\n\t\tl += k;\n\t}\n\tprintf(\"%d\", k);\n\tfor (int i = 1; i <= k; i++)\n\t\tprintf(\" %I64d\", p[i]);\n\tputs(\"\");\n\tfflush(stdout);\n\tint tmp;\n\tscanf(\"%d\", &tmp);\n\tif (tmp == -1) return;\n\tsolve(p[tmp] + 1, p[tmp + 1] - 1, k);\n}\nint main()\n{\n\tint tmp;\n\tputs(\"1 10000\");\n\tfflush(stdout);\n\tscanf(\"%d\", &tmp);\n\tif (tmp == -1) return 0;\n\telse if (tmp == 1) {solve(10001, M, 10000); return 0;}\n\tputs(\"1 21\"); \n\tfflush(stdout);\n\tscanf(\"%d\", &tmp);\n\tif (tmp == -1) return 0;\n\telse if (tmp == 1) {solve(22, 9999, 22); return 0;}\n\tputs(\"1 4\");\n\tfflush(stdout);\n\tscanf(\"%d\", &tmp);\n\tif (tmp == -1) return 0;\n\telse if (tmp == 1) {solve(5, 21, 5); return 0;}\n\tputs(\"1 2\");\n\tfflush(stdout);\n\tscanf(\"%d\", &tmp);\n\tif (tmp == -1) return 0;\n\telse if (tmp == 0) {puts(\"1 1\"); fflush(stdout); return 0;}\n\telse if (tmp == 1) {puts(\"1 3\"); fflush(stdout); return 0;}\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 20000\nusing namespace std;\nll f[maxn][6], cur[maxn];\nint main()\n{\n\tll n = 10000;\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i][1] = i;\n\tfor (int j = 2; j <= 5; j++)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (j == 5 && i > 1) break;\n\t\t\tll cur = i;\n\t\t\tfor (int k = 1; k <= i + 1; k++)\n\t\t\t\tcur += f[min(cur, n)][j - 1] + 1;\n\t\t\tf[i][j] = cur - i - 1;\n\t\t}\n\tll now = 1;\n\tfor (int i = 5; i >= 1; i--)\n\t{\n\t\tcur[0] = now - 1;\n\t\tll pre = now;\n\t\tfor (int j = 1; j <= pre && j <= n; j++)\n\t\t{\n\t\t\tnow += f[min(now, n)][i - 1];\n\t\t\tcur[j] = now; now++;\n\t\t}\n\t\tcur[min(pre, n) + 1] = now;\n\t\tprintf(\"%I64d\", min(pre, n));\n\t\tfor (int j = 1; j <= min(pre, n); j++)\n\t\t\tprintf(\" %I64d\", cur[j]);\n\t\tputs(\"\");\n\t\tfflush(stdout);\n\t\tint tmp;\n\t\tscanf(\"%d\", &tmp);\n\t\tif (tmp == -1) return 0;\n\t\tnow = cur[tmp] + 1;\n\t}\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\n#define N 1000005\r\n#define int long long\r\nusing namespace std;\r\nint n,a[N],p1[N],p2[N],cnt,ans;\r\nstruct node{\r\n\tint l,r;\r\n}x[N];\r\nbool cmp(node u,node v){\r\n\treturn u.l<v.l;\r\n}\r\nvoid dfs(int now,int flag){\r\n\tif(now>cnt)return;\r\n\tif(flag)ans+=x[now].r-x[now].l-1;\r\n\tint p=now;\r\n\twhile(x[p+1].l<=x[now].r&&p<cnt)p++;\r\n\tif(p>now&&x[p].r>x[now].r){\r\n\t\tans+=x[p].r-x[now].r-1,dfs(p,0);\r\n\t}\r\n\telse{\r\n\t\tdfs(p+1,1);\r\n\t}\r\n}\r\nsigned main(){\r\n\tcin>>n;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tcin>>a[i];\r\n\t\tp2[a[i]]=i;\r\n\t\tif(!p1[a[i]])p1[a[i]]=i;\r\n\t} \r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(p1[i]!=p2[i]){\r\n\t\t\tx[++cnt].l=p1[i];\r\n\t\t\tx[cnt].r=p2[i];\r\n\t\t}\r\n\t}\r\n\tsort(x+1,x+cnt+1,cmp);\r\n\tdfs(1,1);\r\n\tcout<<ans<<endl;\r\n} ",
        "fixed_code": "#include<bits/stdc++.h>\r\n#define N 1000005\r\n#define int long long\r\nusing namespace std;\r\nint n,a[N],p1[N],p2[N],cnt,ans;\r\nstruct node{\r\n\tint l,r;\r\n}x[N];\r\nbool cmp(node u,node v){\r\n\treturn u.l<v.l;\r\n}\r\nvoid dfs(int now,int flag){\r\n\tif(now>cnt)return;\r\n\tif(flag)ans+=x[now].r-x[now].l-1;\r\n\tint p=now,mx=0,mxp=0;\r\n\twhile(x[p+1].l<=x[now].r&&p<cnt){\r\n\t\tp++;\r\n\t\tif(x[p].r>mx){\r\n\t\t\tmx=x[p].r;\r\n\t\t\tmxp=p;\r\n\t\t}\r\n\t}\r\n\tif(mxp>now&&mx>x[now].r)ans+=mx-x[now].r-1,dfs(mxp,0);\r\n\telse dfs(p+1,1);\r\n}\r\nsigned main(){\r\n\tcin>>n;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tcin>>a[i];\r\n\t\tp2[a[i]]=i;\r\n\t\tif(!p1[a[i]])p1[a[i]]=i;\r\n\t} \r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(p1[i]!=p2[i]){\r\n\t\t\tx[++cnt].l=p1[i];\r\n\t\t\tx[cnt].r=p2[i];\r\n\t\t}\r\n\t}\r\n\tsort(x+1,x+cnt+1,cmp);\r\n\tdfs(1,1);\r\n\tcout<<ans<<endl;\r\n} ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 1e9+7;\nconst LL MINT = ~0u>>1;\n\ntypedef multiset <int >::iterator type;\nstruct node\n{\n\tvector <int > data;\n\tvoid Init(int a,int b,int c)\n\t{\n\t\tdata.push_back(a);\n\t\tdata.push_back(b);\n\t\tdata.push_back(c);\n\t\tsort(data.begin(),data.end(),greater<int>());\n\t}\n\tbool operator < (const node& n)const\n\t{\n\t\treturn data<n.data;\n\t} \n}s[30];\n\nmultiset <int > st;\n\nvoid process(int x)\n{\n\tif(st.empty())\treturn ;\n\tif(x<*st.begin())\treturn ;\n\ttype ite = st.lower_bound(x);\n\tif(*ite==x)\n\t{\n\t\tst.erase(ite);\n\t\treturn ;\n\t}\n\t--ite;\n\tst.erase(ite);\n}\n\nint main()\n{\n\t\n\tint n,a,b,c; \n\tscanf(\"%d\",&n);\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tst.insert(x);\n\t}\n\ts[0].Init(a,b,c);\n\ts[1].Init(a+b,c,0);\n\ts[2].Init(a+c,b,0);\n\ts[3].Init(b+c,a,0);\n\ts[4].Init(a+b+c,0,0);\n\tsort(s,s+5);\n\tint ans=0;\n\twhile(!st.empty())\n\t{\n\t\ttype ite = st.end();\n\t\t--ite;\n\t\tif(*ite>a+b+c)\t\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tans++;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t//\tprintf(\" I:%d %d %d %d\\n\",i,s[i].data[0],s[i].data[1],s[i].data[2]);\n\t\t\tif(s[i].data[2]>=*ite)\n\t\t\t{\n\t\t\t\tst.erase(ite);\n\t\t\t\tprocess(s[i].data[1]);\n\t\t\t\tprocess(s[i].data[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(s[i].data[1]>=*ite)\n\t\t\t{\n\t\t\t\tst.erase(ite);\n\t\t\t\tprocess(s[i].data[2]);\n\t\t\t\tprocess(s[i].data[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(s[i].data[0]>=*ite)\n\t\t\t{\n\t\t\t\tst.erase(ite);\n\t\t\t\tprocess(s[i].data[2]);\n\t\t\t\tprocess(s[i].data[1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans; \n\treturn 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 1e9+7;\nconst LL MINT = ~0u>>1;\n\nstruct node\n{\n\tint big,small;\n\tnode(int a=0,int b=0):\n\t\tbig(a),small(b){}\n\tbool operator < (const node& n)const\n\t{\n\t\tif(big==n.big)\treturn small<n.small;\n\t\treturn big<n.big;\n\t} \n}s[3];\n\nmultiset <int > st;\ntypedef multiset <int >::iterator type;\n\nint pro(int x)\n{\n\tif(st.empty() || x<*st.begin())\treturn 0;\n\ttype ite = st.lower_bound(x);\n\tif(ite!=st.end() &&  *ite==x)\n\t{\n\t\tst.erase(ite);\n\t\treturn x;\n\t}\n\tint e = *(--ite);\n\tst.erase(ite);\n\treturn e;\n}\n\nvoid handle(int b,int c)\n{\n\tint f1 = pro(b);\n\tint f2 = pro(c);\n\tif(f1 && f2)\treturn ;\n\tif(!f1 && !f2)\n\t{\n\t\tpro(b+c);\n\t\treturn ;\n\t}\n\tif(!f1)\n\t\tst.insert(f2);\n\tif(!f2)\n\t\tst.insert(f1);\n\tpro(b+c);\t\n}\n\nbool handleCase(int a,int b,int c)\n{\n\tif(st.empty())\treturn false;\n\ttype ite = --st.end();\n\tif(*ite>a && *ite>b && *ite>c)\treturn false;\n\tint val = *ite;\n\tst.erase(ite);\n\tif(a>=val)\n\t\thandle(b,c);\n\telse if(b>=val)\n\t\thandle(a,c);\n\telse\n\t\thandle(a,b);\n\treturn true;\n}\n\nint main()\n{\n\tint n,a,b,c; \n\tscanf(\"%d\",&n);\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tint t[3]={a,b,c};\n\tsort(t,t+3);\n\tfor(int i=1,x;i<=n;i++,st.insert(x))\n\t\tscanf(\"%d\",&x);\n\ttype maxi = --st.end();\n\tif(*maxi>a+b+c)\n\t{\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\ts[0]=node(a+b,c);\n\ts[1]=node(a+c,b);\n\ts[2]=node(b+c,a);\n\tsort(s,s+3);\n\tint ans=0;\n\twhile(!st.empty())\n\t{\n\t\ttype ite = --st.end();\n\t\tans++;\n\t\tif(handleCase(t[0],t[1],t[2]))\n\t\t\tcontinue ;\n\t\tint val = *ite;\n\t\tst.erase(ite);\n\t\tfor(int i=0;i<3;i++)\n\t\t\tif(s[i].big>=val)\n\t\t\t{\n\t\t\t\tpro(s[i].small);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef struct{\nint speed;\nint ram;\nint hdd;\nint costo;\n}compu;\ntypedef struct{\ncompu vec[100];\nint ultimo;\n}listacompus;\nlistacompus insertarcompu(listacompus tienda, compu tramite)\n{\n    tienda.ultimo++;\n    tienda.vec[tienda.ultimo]=tramite;\n    return tienda;\n}\nvoid mostrarlista(compu tramite)\n{\n    printf(\" %d speed     %d    ram     %d   hdd   %d   costo\\n\",tramite.speed,tramite.ram,tramite.hdd,tramite.costo);\n}\nint main()\n{\n    listacompus tienda;\n    int casos;\n    tienda.ultimo=-1;\n    cin>>casos;\n    for(int cont=0;cont<casos;cont++)\n    {\n        compu tramite;\n        cin>>tramite.speed>>tramite.ram>>tramite.hdd>>tramite.costo;\n        tienda=insertarcompu(tienda,tramite);\n    }\n    int auxi;\n\n    for(int cont2=0;cont2<=tienda.ultimo;cont2++)\n    {\n        for(int aux=cont2+1;aux<=tienda.ultimo;aux++)\n        {\n            if(tienda.vec[cont2].speed<=tienda.vec[aux].speed   && tienda.vec[cont2].ram<=tienda.vec[aux].ram && tienda.vec[cont2].hdd<=tienda.vec[aux].hdd)\n            {\n                auxi=tienda.vec[cont2].costo;\n                tienda.vec[cont2].costo=1001;\n                if(tienda.vec[cont2].speed==tienda.vec[aux].speed   && tienda.vec[cont2].ram==tienda.vec[aux].ram && tienda.vec[cont2].hdd==tienda.vec[aux].hdd)\n                {\n                     tienda.vec[cont2].costo=auxi;\n                }\n\n            }\n            else\n                if(tienda.vec[cont2].speed>=tienda.vec[aux].speed   && tienda.vec[cont2].ram>=tienda.vec[aux].ram && tienda.vec[cont2].hdd>=tienda.vec[aux].hdd)\n                    {\n                        auxi=tienda.vec[aux].costo;\n                        tienda.vec[aux].costo=1001;\n                        if(tienda.vec[cont2].speed==tienda.vec[aux].speed   && tienda.vec[cont2].ram==tienda.vec[aux].ram && tienda.vec[cont2].hdd==tienda.vec[aux].hdd)\n                        {\n                             tienda.vec[aux].costo=auxi;\n                        }\n\n                    }\n        }\n    }\n    mostrarlista(tienda.vec[0]);\n    mostrarlista(tienda.vec[1]);\n    int menor=1001;\n    int posicion=-1;\n    int cont3;\n    for(cont3=0;cont3<=tienda.ultimo;cont3++)\n    {\n        if(menor>=tienda.vec[cont3].costo)\n        {\n            menor=tienda.vec[cont3].costo;\n            posicion=cont3;\n\n        }\n    }\n    cout<<posicion+1;\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef struct{\nint speed;\nint ram;\nint hdd;\nint costo;\n}compu;\ntypedef struct{\ncompu vec[100];\nint ultimo;\n}listacompus;\nlistacompus insertarcompu(listacompus tienda, compu tramite)\n{\n    tienda.ultimo++;\n    tienda.vec[tienda.ultimo]=tramite;\n    return tienda;\n}\nvoid mostrarlista(compu tramite)\n{\n    printf(\" %d speed     %d    ram     %d   hdd   %d   costo\\n\",tramite.speed,tramite.ram,tramite.hdd,tramite.costo);\n}\nint main()\n{\n    listacompus tienda;\n    int casos;\n    tienda.ultimo=-1;\n    cin>>casos;\n    for(int cont=0;cont<casos;cont++)\n    {\n        compu tramite;\n        cin>>tramite.speed>>tramite.ram>>tramite.hdd>>tramite.costo;\n        tienda=insertarcompu(tienda,tramite);\n    }\n    int auxi;\n\n    for(int cont2=0;cont2<=tienda.ultimo;cont2++)\n    {\n        for(int aux=cont2+1;aux<=tienda.ultimo;aux++)\n        {\n            if(tienda.vec[cont2].speed<=tienda.vec[aux].speed   && tienda.vec[cont2].ram<=tienda.vec[aux].ram && tienda.vec[cont2].hdd<=tienda.vec[aux].hdd)\n            {\n                auxi=tienda.vec[cont2].costo;\n                tienda.vec[cont2].costo=1001;\n                if(tienda.vec[cont2].speed==tienda.vec[aux].speed   && tienda.vec[cont2].ram==tienda.vec[aux].ram && tienda.vec[cont2].hdd==tienda.vec[aux].hdd)\n                {\n                     tienda.vec[cont2].costo=auxi;\n                }\n\n            }\n            else\n                if(tienda.vec[cont2].speed>=tienda.vec[aux].speed   && tienda.vec[cont2].ram>=tienda.vec[aux].ram && tienda.vec[cont2].hdd>=tienda.vec[aux].hdd)\n                    {\n                        auxi=tienda.vec[aux].costo;\n                        tienda.vec[aux].costo=1001;\n                        if(tienda.vec[cont2].speed==tienda.vec[aux].speed   && tienda.vec[cont2].ram==tienda.vec[aux].ram && tienda.vec[cont2].hdd==tienda.vec[aux].hdd)\n                        {\n                             tienda.vec[aux].costo=auxi;\n                        }\n\n                    }\n        }\n    }\n    int menor=1001;\n    int posicion=-1;\n    int cont3;\n    for(cont3=0;cont3<=tienda.ultimo;cont3++)\n    {\n        if(menor>=tienda.vec[cont3].costo)\n        {\n            menor=tienda.vec[cont3].costo;\n            posicion=cont3;\n\n        }\n    }\n    cout<<posicion+1;\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define bug cout<<\"--------------\"<<endl\nusing namespace std;\ntypedef long long ll;\nconst double PI=acos(-1.0);\nconst double eps=1e-6;\nconst int intf=1e9;\nconst ll llf=2000LL*100000LL;\nconst int mod=1e9+7;\nconst int maxn=1e5+10;\nll n;\nll a[maxn];\nint main(){\n\t//ios::sync_with_stdio(false);\n\t//freopen(\"in\",\"r\",stdin);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\tll q=0;\n\tcout<<n+1<<endl;\n\tfor(ll i=n;i>=1;i--){\n\t\tif(i-a[i]>=0){\n\t\t\tcout<<1<<\" \"<<i<<\" \"<<i-a[i]<<endl;\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\ta[j]+=i-a[i];\n\t\t\t}\n\t\t}else{\n\t\t\tll d=(a[i]-i)/n+1;\n\t\t\tll x=i-a[i]+d*n;\n\t\t\tcout<<1<<\" \"<<i<<\" \"<<x<<endl;\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\ta[j]+=x;\n\t\t\t}\n\t\t}\n\t}\n\tif(n!=1) cout<<2<<\" \"<<n-1<<\" \"<<n<<endl;\n\treturn 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#define bug cout<<\"--------------\"<<endl\nusing namespace std;\ntypedef long long ll;\nconst double PI=acos(-1.0);\nconst double eps=1e-6;\nconst int intf=1e9;\nconst ll llf=2000LL*100000LL;\nconst int mod=1e9+7;\nconst int maxn=1e5+10;\nll n;\nll a[maxn];\nint main(){\n\t//ios::sync_with_stdio(false);\n\t//freopen(\"in\",\"r\",stdin);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\tll q=0;\n\tcout<<n+(n!=1)<<endl;\n\tfor(ll i=n;i>=1;i--){\n\t\tif(i-a[i]>=0){\n\t\t\tcout<<1<<\" \"<<i<<\" \"<<i-a[i]<<endl;\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\ta[j]+=i-a[i];\n\t\t\t}\n\t\t}else{\n\t\t\tll d=(a[i]-i)/n+1;\n\t\t\tll x=i-a[i]+d*n;\n\t\t\tcout<<1<<\" \"<<i<<\" \"<<x<<endl;\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\ta[j]+=x;\n\t\t\t}\n\t\t}\n\t}\n\tif(n!=1) cout<<2<<\" \"<<n-1<<\" \"<<n<<endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MX 300005\nint tree[3 * MX];\nvoid update (int node, int a, int b, int i, int j, int val) {\n    if (a > j || b < i) return;\n    int v =  (tree[node] == 0) ? val : tree[node];\n    if (a >= i && b <= j) {tree[node] = v; return;}\n    int ls = node<<1, mid = (a + b)>>1, rs = ls|1;\n    update(ls, a, mid, i, j, v); update(rs, mid + 1, b, i, j, v);\n}\nint query (int node, int a, int b, int i, int c) {\n    if (i > b || i < a) return 0;\n    int vc = (tree[node] == 0) ? c : tree[node];\n    if (i >= b && i <= a) {return vc;}\n    int ls = node<<1, rs = ls|1, mid = (a + b)>>1;\n    return max(query(ls, a, mid, i, vc), query(rs, mid + 1, b, i, vc));\n}\nint main () {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int a, b, c;\n    while (m--) {\n        scanf(\"%d %d %d\", &a, &b, &c);\n        update(1, 1, n, a, c - 1, c);\n        update(1, 1, n, c + 1, b, c);\n    }\n    for (int i = 1; i <= n; i++) printf(\"%d \", query(1, 1, n, i, 0));\n    printf(\"\\n\");\n    return 0;\n}\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MX 300005\nint ara[MX], tree[3 * MX];\nvoid update (int node, int a, int b, int i, int j, int val) {\n    if (a > j || b < i) return;\n    int v =  (tree[node] == 0) ? val : tree[node];\n    if (a >= i && b <= j) {tree[node] = v; return;}\n    int ls = node<<1, mid = (a + b)>>1, rs = ls|1;\n    update(ls, a, mid, i, j, v); update(rs, mid + 1, b, i, j, v);\n}\nint query (int node, int a, int b, int i, int c) {\n    if (i > b || i < a) return 0;\n    int vc = (tree[node] == 0) ? c : tree[node];\n    if (i >= b && i <= a) {return vc;}\n    int ls = node<<1, rs = ls|1, mid = (a + b)>>1;\n    return max(query(ls, a, mid, i, vc), query(rs, mid + 1, b, i, vc));\n}\nint main () {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int a, b, c;\n    while (m--) {\n        scanf(\"%d %d %d\", &a, &b, &c);\n        update(1, 1, n, a, c - 1, c);\n        update(1, 1, n, c + 1, b, c);\n    }\n    for (int i = 1; i <= n; i++) printf(\"%d \", query(1, 1, n, i, 0));\n    printf(\"\\n\");\n    return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "a=list(map(int,input().split()))\nb=a.sort()\nx=b[3]-b[1]\ny=b[3]-b[2]\nz=b[3]-b[0]\nprint(x y z)\n",
        "fixed_code": "a=list(map(int,input().split()))\na.sort()\nx=0\ny=0\nz=0\nx=a[3]-a[1]\ny=a[3]-a[2]\nz=a[3]-a[0]\nprint(x,y,z)\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "// Problem: B. Minimal Cost\r\n// Contest: Codeforces - Codeforces Global Round 13\r\n// URL: https://codeforces.com/problemset/problem/1491/B\r\n// Memory Limit: 256 MB\r\n// Time Limit: 2000 ms\r\n// \r\n// Powered by CP Editor (https://cpeditor.org)\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n\r\nvoid solve(int n,int u, int v){\r\n\tint cost=INT_MAX;\r\n\t\r\n\tint a[n];\r\n\tfor(int i=0;i<n;i++){\r\n\t\tcin>>a[i];\r\n\t}\r\n\tfor(ll i=1;i<n;i++){\r\n\t\t\r\n\t\tll diff=abs(a[i]=a[i-1]);\r\n\t\tif(diff<=1){\r\n\t\t\tif(diff) cost=min(cost,min(u,v));\r\n\t\t\telse cost=min(cost,v+min(u,v));\r\n\t\t}\r\n\t\telse cost=0;\r\n\t}\r\n\tcout<<cost<<endl;\r\n\t\r\n}\r\n\r\nint main(){\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--){\r\n\t\tint n,u,v;\r\n\t\tcin>>n>>u>>v;\r\n\t\tsolve(n,u,v);\r\n\t}\r\n}",
        "fixed_code": "// Problem: B. Minimal Cost\r\n// Contest: Codeforces - Codeforces Global Round 13\r\n// URL: https://codeforces.com/problemset/problem/1491/B\r\n// Memory Limit: 256 MB\r\n// Time Limit: 2000 ms\r\n// \r\n// Powered by CP Editor (https://cpeditor.org)\r\n\r\n/*\r\nsee conditions of when stuff happens\r\nalso see edge cases\r\n\r\nand the fuck are the data types here\r\n*/\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nconst int N = 1e6 + 5;\r\nint n, a[N], ans = INT_MAX, u, v, T;\r\nint main()\r\n{\r\n\tios::sync_with_stdio(false);\r\n\tcin>>T;\r\n\twhile(T--){\r\n\t    ans = INT_MAX;\r\n\t    cin >> n >> u >> v;\r\n\t    for(int i = 1; i <= n; i++)\r\n\t\t    cin >> a[i];\r\n\t    for(int i = 2; i <= n; i++)\r\n\t    {\r\n\t\t    if(abs(a[i] - a[i - 1]) >= 2) ans = 0;\r\n\t    \tif(abs(a[i] - a[i - 1]) == 1) ans = min(ans, min(u, v));\r\n\t\t    if(a[i] == a[i - 1]) ans = min(ans, v + min(u, v));\r\n\t    }\r\n\t    cout << ans << endl;\r\n\t}\r\n\t\r\n\treturn 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nchar str[200005];\nint ans[200005];\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    scanf(\"%s\",str);\n    int flag=0;\n    for (int i=n-1;i>=0;i--)\n    {\n        if (flag==0&&str[i]==')')\n        {\n            flag=1;\n            ans[i]=1;\n        }\n        else if (flag==1&&str[i]=='('){\n            flag=0;\n            ans[i]=1;\n        }\n    }\n    for (int i=0;i<n;i++) printf(\"%d\",ans[i]);\n    return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nchar str[200005];\nint ans[200005];\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    scanf(\"%s\",str);\n    int flag=0;\n    int cnt1=0,cnt2=0;\n    for (int i=n-1;i>=0;i--)\n    {\n        if (str[i]=='(')\n        {\n            ans[i]=(cnt1&1);\n            cnt1++;\n        }\n        else if (str[i]==')')\n        {\n            ans[i]=(cnt2&1);\n            cnt2++;\n        }\n    }\n    for (int i=0;i<n;i++) printf(\"%d\",ans[i]);\n\n\n\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#pragma GCC optimize(\"O2\")\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<cmath>\n#include<climits>\n#include<random>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\nusing namespace std;\n \n#define pb push_back\n#define ff first\n#define ss second\n#define endl '\\n'\n#define fast ios::sync_with_stdio(false); cin.tie(NULL);\n \n/////////////////////////////////////////////\n \nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n \ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n \n///////////////////////////////\n \n#define int long long\n\n\nvoid solve(){\n\t\n\tint n , m;\n\tcin>>n;\n\tvector<pair<int,int>> v[n];\n\tvector<int> deg(n , 0);\n\tint a[n];\n\tfor(int i = 0 ; i < n ; ++i)\n\t\tcin>>a[i];\n\tcin>>m;\n\twhile(m--){\n\t\t\n\t\tint x , y , c;\n\t\tcin>>x>>y>>c;\n\t\t--x , --y;\n\t\tv[x].push_back({y , c});\n\t\t++deg[y];\n\t\t//v[y].push_back({x , c});\n\t}\n\n\tusing T = pair<int,int>;\n\tpriority_queue<T , vector<T> , greater<T>> pq;\n\tint cnt = 0;\n\tfor(int i = 0 ; i < n ; ++i){\n\t\t\n\t\tif(deg[i]==0){\n\t\t\tpq.push({0 , i});\n\t\t\t++cnt;\n\t\t}\n\t\t\n\t}\n\tif(cnt != 1){\n\t\t\n\t\tcout<<-1<<endl;\n\t\treturn;\n\t}\n\tint ans = 0;\n\tbool vis[n];\n\tcnt = 0;\n\tmemset(vis , false , sizeof vis);\n\twhile(!pq.empty()){\n\t\t\n\t\tauto [cost , node] = pq.top();\n\t\tpq.pop();\n\t\t\n\t\tif(vis[node])\n\t\t\tcontinue;\n\t\tvis[node] = true;\n\t\t++cnt;\n\t\tans += cost;\n\t\tfor(auto [child , paisa] : v[node]){\n\t\t\t\n\t\t\tif(!vis[child])\n\t\t\t\tpq.push({paisa , child});\n\t\t}\n\t}\n\tif(cnt!=n)\n\t\tans = -1;\n\tcout<<ans<<endl;\n\t\n}\n \nsigned main(){\n \n\tfast;\n\tint t = 1;\n\t//cin>>t;\n\tfor(int i = 1 ; i <= t ; ++i)\n\t\tsolve();\n}",
        "fixed_code": "#pragma GCC optimize(\"O2\")\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<cmath>\n#include<climits>\n#include<random>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\nusing namespace std;\n \n#define pb push_back\n#define ff first\n#define ss second\n#define endl '\\n'\n#define fast ios::sync_with_stdio(false); cin.tie(NULL);\n \n/////////////////////////////////////////////\n \nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n \ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n \n///////////////////////////////\n \n#define int long long\n\n\nvoid solve(){\n\t\n\tint n , m;\n\tcin>>n;\n\tvector<pair<int,int>> v[n];\n\tvector<int> deg(n , 0);\n\tint a[n];\n\tfor(int i = 0 ; i < n ; ++i)\n\t\tcin>>a[i];\n\tcin>>m;\n\tint ans[n];\n\tfor(int i = 0 ; i < n ; ++i)\n\t\tans[i] = 1e9;\n\twhile(m--){\n\t\t\n\t\tint x , y , c;\n\t\tcin>>x>>y>>c;\n\t\t--x , --y;\n\t\t++deg[y];\n\t\tans[y] = min(ans[y] , c);\n\t\t//v[y].push_back({x , c});\n\t}\n\n\tint cnt = 0;\n\tfor(int i = 0 ; i < n ;++i)\n\t\tcnt += (deg[i]==0);\n\t\n\tif(cnt !=1)\n\t\tcout<<-1<<endl;\n\telse{\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i = 0 ; i < n ; ++i)\n\t\t\tif(ans[i] < 1e9)\n\t\t\t\tsum += ans[i];\n\t\tcout<<sum<<endl;\n\t}\n\t\n}\n \nsigned main(){\n \n\tfast;\n\tint t = 1;\n\t//cin>>t;\n\tfor(int i = 1 ; i <= t ; ++i)\n\t\tsolve();\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n#include <queue>\n#include <random>\n#include <ctime>\n\n#define ll long long\n#define ld long double\n#define F first\n#define S second\n#define upn(x, init, n) for (ll x = init; x <= n; ++x)\n#define upiter(x, container) for (auto x = container.begin(); x != container.end(); ++x)\n#define downn(x, init, n) for(ll x = init; x >= n; --x)\n#define downiter(x, container) for (auto x = container.rbegin(); x != container.rend(); ++x)\n#define pb push_back\n#define mp make_pair\n#define pll pair<ll, ll>\n#define el '\\n'\n#define finish(out) cout << out << el; return 0\n#define PI 3.1415926535897932384626433832795\n#define eps 0.0000001\n#define mod 1000000007\n\nusing namespace std;\nll n, q, x;\n\nll get(ll a) {\n\tif (a % 2 == 1)\n\t    return (a + 1) / 2;\n\telse {\n\t\tll cnt = (2*n - a) / 2;\n\t\treturn get(a + cnt);\n\t}\n}\nint main() {\n    cin.sync_with_stdio(0); cin.tie(0);\n    cin >> n >> q;\n    upn(i, 1, q) {\n    \tcin >> x;\n    \tcout << get(x);\n    }\n}",
        "fixed_code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n#include <queue>\n#include <random>\n#include <ctime>\n\n#define ll long long\n#define ld long double\n#define F first\n#define S second\n#define upn(x, init, n) for (ll x = init; x <= n; ++x)\n#define upiter(x, container) for (auto x = container.begin(); x != container.end(); ++x)\n#define downn(x, init, n) for(ll x = init; x >= n; --x)\n#define downiter(x, container) for (auto x = container.rbegin(); x != container.rend(); ++x)\n#define pb push_back\n#define mp make_pair\n#define pll pair<ll, ll>\n#define el '\\n'\n#define finish(out) cout << out << el; return 0\n#define PI 3.1415926535897932384626433832795\n#define eps 0.0000001\n#define mod 1000000007\n\nusing namespace std;\nll n, q, x;\n\nll get(ll a) {\n\tif (a % 2 == 1)\n\t    return (a + 1) / 2;\n\telse {\n\t\tll cnt = (2*n - a) / 2;\n\t\treturn get(a + cnt);\n\t}\n}\nint main() {\n    cin.sync_with_stdio(0); cin.tie(0);\n    cin >> n >> q;\n    upn(i, 1, q) {\n    \tcin >> x;\n    \tcout << get(x) << el;\n    }\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(register int i=(a);i<=(b);i++)\n#define REP(i,a,b) for(register int i=(a);i>=(b);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define hvie '\\n'\n#define debug puts(\"QAQ\")\nconst int inf=0x3f3f3f3f;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\ntemplate<typename T=int>\nT yh(){\n\tT ret=0;bool f=0;char c=getchar();\n\twhile(!isdigit(c)){if(c==EOF)return -1;if(c=='-')f=1;c=getchar();}\n\twhile(isdigit(c))ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\treturn f?-ret:ret;\n}\ntemplate<typename T>\nvoid yh(T&ret){\n\tret=0;bool f=0;char c=getchar();\n\twhile(!isdigit(c)){if(c==EOF)return ret=-1,void();if(c=='-')f=1;c=getchar();}\n\twhile(isdigit(c))ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\tret=f?-ret:ret;\n}\nconst int maxn=50005;\nint n,m;\nint c[maxn],r[maxn];\ntypedef int Data;\nstruct edge{\n\tint to,nxt;\n\tData w;\n};\nvector<edge>E(maxn<<4);\nint h[maxn],en=1;\nvoid addedge(int x,int y,Data w){\n\tif(++en==(int)E.size()) E.pb((edge){0,0,0});\n\tE[en].to=y;\n\tE[en].nxt=h[x];\n\tE[en].w=w;\n\th[x]=en;\n}\nvoid link(int x,int y,Data w){\n\taddedge(x,y,w);\n\taddedge(y,x,0);\n}\nint S=0;\n#define T ((n<<1)+1)//这里要求T一定是最大的编号,否则自己清零的时候注意\n#define maxnode ((n<<1)+1)\nint dep[maxn];\nint cur[maxn];\nqueue<int>q;\nbool bfs(){\n\twhile(!q.empty()) q.pop();\n\tfor(int i=0;i<=maxnode;i++) dep[i]=inf;//这个右边界不一定是T\n\tdep[S]=0;\n\tq.push(S);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tfor(int e=h[x];e;e=E[e].nxt){\n\t\t\tint y=E[e].to;\n\t\t\tif(E[e].w&&dep[y]>dep[x]+1){\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T]<inf;\n}\nData dfs(int x,Data flow){\n\tif(x==T)return flow;\n\tData delta=0;\n\tfor(int &e=cur[x];e;e=E[e].nxt){\n\t\tint y=E[e].to;\n\t\tif(E[e].w&&dep[y]==dep[x]+1){\n\t\t\tdelta=dfs(y,min(flow,E[e].w));\n\t\t\tif(delta){\n\t\t\t\tE[e].w-=delta;\n\t\t\t\tE[e^1].w+=delta;\n\t\t\t\treturn delta;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nData calc(){\n\tData ans=0;\n\twhile(bfs()){\n\t\tFOR(i,0,maxnode) cur[i]=h[i];//右边界不一定是T\n\t\twhile(int path=dfs(S,inf))ans+=path;\n\t}\n\treturn ans;\n}\nbool mp[205][205];\nint main(){\n\tn=yh(),m=yh();\n\tFOR(i,1,m){\n\t\tint x=yh(),y=yh();\n\t\tc[++*c]=x,r[++*r]=y;\n\t\tmp[x][y]=1;\n\t}\n\tint ANS=0x7fffffff;\n\tFOR(center,1,n){\n\t\t\n\t\ten=1;\n\t\tFOR(i,0,maxnode)h[i]=0;\n\n\t\tint ans=0;\n\t\tFOR(i,1,n)if(!mp[i][center])ans++;\n\t\tFOR(i,1,n)if(!mp[center][i])ans++;\n\t\tans-=!mp[center][center];\n\t\tFOR(i,1,n) link(S,i,1);\n\t\tFOR(i,1,n) link(i+n,T,1);\n\t\tFOR(i,1,*c)if(c[i]!=center&&r[i]!=center)\n\t\t\tlink(c[i],r[i]+n,1),ans++;\n\t\tint tmp=calc();\n\t\t// cout<<ans<<endl;\n\t\tANS=min(ans+n-1-(tmp<<1),ANS);\n\t}\n\tcout<<ANS<<hvie;\n\treturn 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(register int i=(a);i<=(b);i++)\n#define REP(i,a,b) for(register int i=(a);i>=(b);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define hvie '\\n'\n#define debug puts(\"QAQ\")\nconst int inf=0x3f3f3f3f;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\ntemplate<typename T=int>\nT yh(){\n\tT ret=0;bool f=0;char c=getchar();\n\twhile(!isdigit(c)){if(c==EOF)return -1;if(c=='-')f=1;c=getchar();}\n\twhile(isdigit(c))ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\treturn f?-ret:ret;\n}\ntemplate<typename T>\nvoid yh(T&ret){\n\tret=0;bool f=0;char c=getchar();\n\twhile(!isdigit(c)){if(c==EOF)return ret=-1,void();if(c=='-')f=1;c=getchar();}\n\twhile(isdigit(c))ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\tret=f?-ret:ret;\n}\nconst int maxn=50005;\nint n,m;\nint c[maxn],r[maxn];\ntypedef int Data;\nstruct edge{\n\tint to,nxt;\n\tData w;\n};\nvector<edge>E(maxn<<4);\nint h[maxn],en=1;\nvoid addedge(int x,int y,Data w){\n\tif(++en==(int)E.size()) E.pb((edge){0,0,0});\n\tE[en].to=y;\n\tE[en].nxt=h[x];\n\tE[en].w=w;\n\th[x]=en;\n}\nvoid link(int x,int y,Data w){\n\taddedge(x,y,w);\n\taddedge(y,x,0);\n}\nint S=0;\n#define T ((n<<1)+10)//这里要求T一定是最大的编号,否则自己清零的时候注意\n#define maxnode ((n<<1)+10)\nint dep[maxn];\nint cur[maxn];\nqueue<int>q;\nbool bfs(){\n\twhile(!q.empty()) q.pop();\n\tfor(int i=0;i<=maxnode;i++) dep[i]=inf;//这个右边界不一定是T\n\tdep[S]=0;\n\tq.push(S);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tfor(int e=h[x];e;e=E[e].nxt){\n\t\t\tint y=E[e].to;\n\t\t\tif(E[e].w&&dep[y]>dep[x]+1){\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T]<inf;\n}\nData dfs(int x,Data flow){\n\tif(x==T)return flow;\n\tData delta=0;\n\tfor(int &e=cur[x];e;e=E[e].nxt){\n\t\tint y=E[e].to;\n\t\tif(E[e].w&&dep[y]==dep[x]+1){\n\t\t\tdelta=dfs(y,min(flow,E[e].w));\n\t\t\tif(delta){\n\t\t\t\tE[e].w-=delta;\n\t\t\t\tE[e^1].w+=delta;\n\t\t\t\treturn delta;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nData calc(){\n\tData ans=0;\n\twhile(bfs()){\n\t\tFOR(i,0,maxnode) cur[i]=h[i];//右边界不一定是T\n\t\twhile(int path=dfs(S,inf))ans+=path;\n\t}\n\treturn ans;\n}\nbool mp[505][505];\nint main(){\n\tn=yh(),m=yh();\n\tFOR(i,1,m){\n\t\tint x=yh(),y=yh();\n\t\tc[++*c]=x,r[++*r]=y;\n\t\tmp[x][y]=1;\n\t}\n\tint ANS=0x7fffffff;\n\tFOR(center,1,n){\n\t\t\n\t\ten=1;\n\t\tFOR(i,0,maxnode)h[i]=0;\n\n\t\tint ans=0;\n\t\tFOR(i,1,n){\n\t\t\tif(!mp[i][center])ans++;\n\t\t\tif(!mp[center][i])ans++;\n\t\t}\n\t\tans-=!mp[center][center];\n\t\tFOR(i,1,n) link(S,i,1);\n\t\tFOR(i,1,n) link(i+n,T,1);\n\t\tFOR(i,1,m)if(c[i]!=center&&r[i]!=center)\n\t\t\tlink(c[i],r[i]+n,1),ans++;\n\t\tint tmp=calc();\n\t\tANS=min(ans+n-1-(tmp<<1),ANS);\n\t}\n\tcout<<ANS<<hvie;\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#define ll long long\nusing namespace std;\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)]\n    {\n        ll a,b,c;\n        cin>>a>>b>>c;\n        cout<<(a+b+c)/2<<endl;\n        \n    }\n    return 0;\n}",
        "fixed_code": "#include<iostream>\n#define ll long long\nusing namespace std;\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        ll a,b,c;\n        cin>>a>>b>>c;\n        cout<<(a+b+c)/2<<endl;\n        \n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\nusing namespace std;\nlong long n, input[10000042], ansOnD[32], maxD, m, cop[10000042];\n\nlong long merg ( long long s, long long m, long long f, bool jv ) {\n    long long ret = 0, i1 = s, i2 = m;\n    for ( ; i1 < m && i2 < f ; ) {\n        if ( input[i1] > input[i2] ) {\n            cop[i1+i2-m] = input[i2];\n            ret += m-i1;\n            i2++;\n        }else {\n            cop[i1+i2-m] = input[i1];\n            i1++;\n        }\n    }\n\n    for ( ; i1 < m ; i1 ++ ) { cop[i1+i2-m] = input[i1]; }\n    for ( ; i2 < m ; i2 ++ ) { cop[i1+i2-m] = input[i2]; ret += m-i1; }\n\n    if ( jv ) {\n        for ( long long i = s ; i < f ; i ++ ) {\n            input[i] = cop[i];\n        }\n    }\n\n    return ret;\n\n}\n\nvoid sort2( long long s, long long f, long long d ) {\n    if ( s+1 == f ) {\n        return;\n    }\n    sort2( s, (s+f)/2, d-1 );\n    sort2( (s+f)/2, f, d-1 );\n//    cout << \"for \" << s << \" \" << f << \" = \" << merg( s, (s+f)/2, f, 0 ) << '\\n';\n    ansOnD[d] += merg( s, (s+f)/2, f, 1 );\n}\n\nvoid rev( long long ind ) {\n\n    ansOnD[ ind ] = ( 1<<(maxD-ind) )*( 1<<(ind-1) )*( ( 1<<(ind-1) ) ) - ansOnD[ind];\n\n}\n\nint main () {\n    ios::sync_with_stdio ( false );\n    cin.tie(NULL);\n\n\n    cin >> maxD;\n    n = (1<<maxD);\n    for ( long long i = 0 ; i < n ; i ++ ) {\n        cin >> input[i];\n    }\n\n    sort2( 0, n, maxD );\n\n    cin >> m;\n\n    for ( long long i = 0 ; i < m ; i ++ ) {\n        long long q;\n        cin >> q;\n\n        for ( long long j = q; j >= 0 ; j -- ) {\n            rev(j);\n        }\n        long long sum = 0;\n        for ( long long j = 0 ; j <= maxD ; j ++ ) {\n            sum += ansOnD[j];\n        }\n        cout << sum << \"\\n\";\n\n    }\n\n    return 0;\n}\n/*\n\n2\n1 1 3 1\n3\n0 1 2\n\n*/\n",
        "fixed_code": "#include <iostream>\nusing namespace std;\nlong long n, input[10000042], ansOnD[32], revAns[32], maxD, m, cop[10000042], cop2[10000042];\n\nlong long merg ( long long s, long long m, long long f ) {\n    long long ret = 0, i1 = s, i2 = m;\n    for ( ; i1 < m && i2 < f ; ) {\n        if ( input[i1] > input[i2] ) {\n            cop[i1+i2-m] = input[i2];\n            ret += m-i1;\n            i2++;\n        }else {\n            cop[i1+i2-m] = input[i1];\n            i1++;\n        }\n    }\n\n    for ( ; i1 < m ; i1 ++ ) { cop[i1+i2-m] = input[i1]; }\n    for ( ; i2 < m ; i2 ++ ) { cop[i1+i2-m] = input[i2]; ret += m-i1; }\n\n    return ret;\n\n}\n\nlong long revMerg ( long long s, long long m, long long f ) {\n    for ( int i = s ; i < m ; i ++ ) {\n        swap( input[i], input[m+i-s] );\n    }\n\n    long long ret = 0, i1 = s, i2 = m;\n    for ( ; i1 < m && i2 < f ; ) {\n        if ( input[i1] > input[i2] ) {\n            cop[i1+i2-m] = input[i2];\n            ret += m-i1;\n            i2++;\n        }else {\n            cop[i1+i2-m] = input[i1];\n            i1++;\n        }\n    }\n\n    for ( ; i1 < m ; i1 ++ ) { cop[i1+i2-m] = input[i1]; }\n    for ( ; i2 < m ; i2 ++ ) { cop[i1+i2-m] = input[i2]; ret += m-i1; }\n\n    for ( int i = s ; i < m ; i ++ ) {\n        swap( input[i], input[m+i-s] );\n    }\n\n    return ret;\n\n}\n\nvoid sort2( long long s, long long f, long long d ) {\n    if ( s+1 == f ) {\n        return;\n    }\n    sort2( s, (s+f)/2, d-1 );\n    sort2( (s+f)/2, f, d-1 );\n//    cout << \"for \" << s << \" \" << f << \" = \" << merg( s, (s+f)/2, f, 0 ) << '\\n';\n    ansOnD[d] += merg( s, (s+f)/2, f );\n    revAns[d] += revMerg( s, (s+f)/2, f );\n\n\n    for ( long long i = s ; i < f ; i ++ ) {\n        input[i] = cop[i];\n    }\n\n}\n\nvoid rev( long long ind ) {\n\n    swap( ansOnD[ind], revAns[ind] );\n\n}\n\nint main () {\n    ios::sync_with_stdio ( false );\n    cin.tie(NULL);\n\n    cin >> maxD;\n    n = (1<<maxD);\n    for ( long long i = 0 ; i < n ; i ++ ) {\n        cin >> input[i];\n    }\n\n    sort2( 0, n, maxD );\n\n\n    cin >> m;\n\n    for ( long long i = 0 ; i < m ; i ++ ) {\n        long long q;\n        cin >> q;\n\n        for ( long long j = q; j >= 0 ; j -- ) {\n            rev(j);\n        }\n        long long sum = 0;\n        for ( long long j = 0 ; j <= maxD ; j ++ ) {\n            sum += ansOnD[j];\n        }\n        cout << sum << \"\\n\";\n\n    }\n\n    return 0;\n}\n/*\n\n2\n1 1 3 1\n3\n0 1 2\n\n*/\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <string.h>\nusing namespace std;\n\nint main() {\n    \n    int n;\n    cin >> n;\n    int arr[n];\n    for(int i=0;i<n;i++)\n    {\n        cin >> arr[i];\n        \n    }\n    \n   \n    sort(arr,arr+n);\n    \n    \n    int min=0,max = n-1;\n    \n    for(int i=0;i<n;i++)\n    {\n        if(arr[i]==arr[0]) min++;\n        else break;\n    }\n    \n    for(int i=n-1;i>0;i--)\n    {\n        if(arr[i]==arr[n-1]) max--;\n        else break;\n    }\n    \n    cout << max-min +1 << endl;\n    return 0;\n    \n}\n",
        "fixed_code": "#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <string.h>\nusing namespace std;\n\nint main() {\n    \n    int n;\n    cin >> n;\n    int arr[n];\n    for(int i=0;i<n;i++)\n    {\n        cin >> arr[i];\n        \n    }\n    \n   \n    sort(arr,arr+n);\n    \n    \n    int min=0,max = n-1;\n    \n    for(int i=0;i<n;i++)\n    {\n        if(arr[i]==arr[0]) min++;\n        else break;\n    }\n    \n    for(int i=n-1;i>0;i--)\n    {\n        if(arr[i]==arr[n-1]) max--;\n        else break;\n    }\n    if(max<min) cout << 0 << endl;\n    else cout << max-min +1 << endl;\n    return 0;\n    \n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@org.junit.Test\npublic void testGetProps() {\n    org.talend.components.api.properties.ComponentProperties props = new org.talend.components.salesforce.tsalesforceconnection.TSalesforceConnectionDefinition().createProperties();\n    org.talend.daikon.properties.presentation.Form f = props.getForm(Form.MAIN);\n    org.talend.components.api.test.ComponentTestUtils.checkSerialize(props, errorCollector);\n    org.talend.components.salesforce.SalesforceComponentTestIT.LOGGER.debug(f.toString());\n    org.talend.components.salesforce.SalesforceComponentTestIT.LOGGER.debug(props.toString());\n    org.junit.Assert.assertEquals(Form.MAIN, f.getName());\n}",
        "fixed_code": "@org.junit.Test\npublic void testGetProps() {\n    org.talend.components.api.properties.ComponentProperties props = new org.talend.components.salesforce.tsalesforceconnection.TSalesforceConnectionDefinition().createProperties();\n    org.talend.daikon.properties.presentation.Form f = props.getForm(Form.MAIN);\n    org.talend.components.api.test.ComponentTestUtils.checkSerialize(props, errorCollector);\n    org.talend.components.salesforce.SalesforceComponentTestIT.LOGGER.debug(f.toString());\n    org.talend.components.salesforce.SalesforceComponentTestIT.LOGGER.debug(props.toString());\n    assertEquals(Form.MAIN, f.getName());\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@java.lang.Override\nprotected void onCreate(android.os.Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    findViewById(R.id.turbo_button).setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View view) {\n            findViewById(R.id.message_for_press_button).setVisibility(View.GONE);\n            findViewById(R.id.layout_enter).setVisibility(View.VISIBLE);\n            startPlaying();\n        }\n    });\n    if (!(isMyServiceRunning(com.rk.turbobutton.utills.NotificationService.class))) {\n        startService(new android.content.Intent(this, com.rk.turbobutton.utills.NotificationService.class));\n    }\n    preferences = com.rk.turbobutton.utills.Preferences.getInstance(this);\n    android.widget.TextView title = ((android.widget.TextView) (findViewById(R.id.title)));\n    title.setText(java.lang.String.format(\"Hello %s!\", preferences.getString(Preferences.FIRST_NAME)));\n    android.content.res.Resources r = getResources();\n    int padding = ((int) (r.getDimension(R.dimen.action_bar_left_padding)));\n    int px = ((int) (android.util.TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, padding, r.getDisplayMetrics())));\n    title.setPadding(px, 0, 0, 0);\n    mCommentView = ((android.widget.EditText) (findViewById(R.id.comment)));\n    mLeftCharView = ((android.widget.TextView) (findViewById(R.id.tv_char_left)));\n    mCommentView.addTextChangedListener(watch);\n    android.widget.Button mSubmitShareButton = ((android.widget.Button) (findViewById(R.id.submit_share_button)));\n    mSubmitShareButton.setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View view) {\n            attemptSubmit();\n        }\n    });\n    mcommentFormView = findViewById(R.id.comment_form);\n    mProgressView = findViewById(R.id.comment_progress);\n}",
        "fixed_code": "@java.lang.Override\nprotected void onCreate(android.os.Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    findViewById(R.id.turbo_button).setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View view) {\n            findViewById(R.id.message_for_press_button).setVisibility(View.GONE);\n            findViewById(R.id.turbo_button).setEnabled(false);\n            findViewById(R.id.layout_enter).setVisibility(View.VISIBLE);\n            startPlaying();\n        }\n    });\n    if (!(isMyServiceRunning(com.rk.turbobutton.utills.NotificationService.class))) {\n        startService(new android.content.Intent(this, com.rk.turbobutton.utills.NotificationService.class));\n    }\n    preferences = com.rk.turbobutton.utills.Preferences.getInstance(this);\n    android.widget.TextView title = ((android.widget.TextView) (findViewById(R.id.title)));\n    title.setText(java.lang.String.format(\"Hello %s!\", preferences.getString(Preferences.FIRST_NAME)));\n    android.content.res.Resources r = getResources();\n    int padding = ((int) (r.getDimension(R.dimen.action_bar_left_padding)));\n    int px = ((int) (android.util.TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, padding, r.getDisplayMetrics())));\n    title.setPadding(px, 0, 0, 0);\n    mCommentView = ((android.widget.EditText) (findViewById(R.id.comment)));\n    mLeftCharView = ((android.widget.TextView) (findViewById(R.id.tv_char_left)));\n    mCommentView.addTextChangedListener(watch);\n    android.widget.Button mSubmitShareButton = ((android.widget.Button) (findViewById(R.id.submit_share_button)));\n    mSubmitShareButton.setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View view) {\n            attemptSubmit();\n        }\n    });\n    mcommentFormView = findViewById(R.id.comment_form);\n    mProgressView = findViewById(R.id.comment_progress);\n    findViewById(R.id.reset_button).setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View view) {\n            mCommentView.setText(\"\");\n            findViewById(R.id.message_for_press_button).setVisibility(View.VISIBLE);\n            findViewById(R.id.turbo_button).setEnabled(true);\n            findViewById(R.id.layout_enter).setVisibility(View.GONE);\n        }\n    });\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nint head[100001],q[100001],ll,rr,cnt,in[100001],n,m,a[100001],l[100002],len[100001],x,cnt1,cnt2,e1[100001][2],e2[100001][2],ans[100001];\nbool bo[100001];\n\nint getmin(int a,int b) {return a<b?a:b;}\n\nstruct node\n{\n\tint to,next;\n}e[200001];\n\nstruct node2\n{\n\tint x,y;\n}aaa[200001];\n\nvoid addedge(int x,int y)\n{\n\te[++cnt].next=head[x];\n\thead[x]=cnt;\n\te[cnt].to=y; in[y]++;\n}\n\nbool cmp(node2 a,node2 b) {return a.y<b.y;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m); l[0]=0; len[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&len[i]); l[i]=l[i-1]+len[i-1];\n\t\tfor (int j=l[i]; j<l[i]+len[i]; j++) scanf(\"%d\",&a[j]);\n\t}\n\tcnt1=cnt2=0;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tbool b=0;\n\t\tx=getmin(len[i],len[i+1]);\n\t\tfor (int j=0; j<x; j++)\n\t\t{\n\t\t\tif (a[j+l[i]]<a[j+l[i+1]]) {b=1; e1[++cnt1][0]=a[j+l[i]]; e1[cnt1][1]=a[j+l[i+1]]; break;}\n\t\t\telse if (a[j+l[i]]>a[j+l[i+1]]) {b=1; e2[++cnt2][0]=a[j+l[i]]; e2[cnt2][1]=a[j+l[i+1]]; break;}\n\t\t}\n\t\tif (!b&&len[i]>len[i+1]) {printf(\"No\\n\"); return 0;}\n\t}\n\tcnt=0; memset(head,0,sizeof(head));\n\tmemset(in,0,sizeof(in));\n\tfor (int i=1; i<=cnt1; i++) addedge(e1[i][0],e1[i][1]);\n\tfor (int i=1; i<=cnt2; i++) addedge(e2[i][0],e2[i][1]);\n\tll=1; rr=0;\n\tfor (int i=1; i<=m; i++)\n\t\tif (!in[i]) q[++rr]=i;\n\twhile (ll<=rr)\n\t{\n\t\tx=q[ll];\n\t\tfor (int i=head[x]; i; i=e[i].next)\n\t\t{\n\t\t\tin[e[i].to]--;\n\t\t\tif (!in[e[i].to]) q[++rr]=e[i].to;\n\t\t}\n\t\tll++;\n\t}\n\tfor (int i=1; i<=m; i++)\n\t\tif (in[i]) {printf(\"No\\n\"); return 0;}\n\tmemset(bo,0,sizeof(bo));\n\tfor (int i=1; i<=cnt2; i++) bo[e2[i][0]]=1;\n\tfor (int i=1; i<=cnt1; i++) aaa[i].x=e1[i][0],aaa[i].y=e1[i][1];\n\tsort(aaa+1,aaa+1+cnt1,cmp);\n\tfor (int i=cnt1; i>=1; i--)\n\t\tif (bo[aaa[i].y]) bo[aaa[i].x]=1;\n\tans[0]=0;\n\tfor (int i=1; i<=m; i++)\n\t\tif (bo[i]) ans[++ans[0]]=i;\n\tprintf(\"Yes\\n%d\\n\",ans[0]);\n\tfor (int i=1; i<=ans[0]; i++) printf(\"%d \",ans[i]); \n\treturn 0;\n}\n",
        "fixed_code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nint head[100001],q[100001],ll,rr,cnt,in[100001],n,m,a[100001],l[100002],len[100001],x,cnt1,cnt2,e1[100001][2],e2[100001][2],ans[100001];\nbool bo[100001];\n\nint getmin(int a,int b) {return a<b?a:b;}\n\nstruct node\n{\n\tint to,next;\n}e[200001];\n\nstruct node2\n{\n\tint x,y;\n}aaa[200001];\n\nvoid addedge(int x,int y)\n{\n\te[++cnt].next=head[x];\n\thead[x]=cnt;\n\te[cnt].to=y; in[y]++;\n}\n\nbool cmp(node2 a,node2 b) {return a.y<b.y;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m); l[0]=0; len[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&len[i]); l[i]=l[i-1]+len[i-1];\n\t\tfor (int j=l[i]; j<l[i]+len[i]; j++) scanf(\"%d\",&a[j]);\n\t}\n\tcnt1=cnt2=0;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tbool b=0;\n\t\tx=getmin(len[i],len[i+1]);\n\t\tfor (int j=0; j<x; j++)\n\t\t{\n\t\t\tif (a[j+l[i]]<a[j+l[i+1]]) {b=1; e1[++cnt1][0]=a[j+l[i]]; e1[cnt1][1]=a[j+l[i+1]]; break;}\n\t\t\telse if (a[j+l[i]]>a[j+l[i+1]]) {b=1; e2[++cnt2][0]=a[j+l[i]]; e2[cnt2][1]=a[j+l[i+1]]; break;}\n\t\t}\n\t\tif (!b&&len[i]>len[i+1]) {printf(\"No\\n\"); return 0;}\n\t}\n\tcnt=0; memset(head,0,sizeof(head));\n\tmemset(in,0,sizeof(in));\n\tfor (int i=1; i<=cnt1; i++) addedge(e1[i][0],e1[i][1]);\n\tfor (int i=1; i<=cnt2; i++) addedge(e2[i][0],e2[i][1]);\n\tll=1; rr=0;\n\tfor (int i=1; i<=m; i++)\n\t\tif (!in[i]) q[++rr]=i;\n\twhile (ll<=rr)\n\t{\n\t\tx=q[ll];\n\t\tfor (int i=head[x]; i; i=e[i].next)\n\t\t{\n\t\t\tin[e[i].to]--;\n\t\t\tif (!in[e[i].to]) q[++rr]=e[i].to;\n\t\t}\n\t\tll++;\n\t}\n\tfor (int i=1; i<=m; i++)\n\t\tif (in[i]) {printf(\"No\\n\"); return 0;}\n\tmemset(bo,0,sizeof(bo));\n\tfor (int i=1; i<=cnt2; i++) bo[e2[i][0]]=1;\n\tfor (int i=1; i<=cnt1; i++) aaa[i].x=e1[i][0],aaa[i].y=e1[i][1];\n\tsort(aaa+1,aaa+1+cnt1,cmp);\n\tfor (int i=cnt1; i>=1; i--)\n\t\tif (bo[aaa[i].y]) bo[aaa[i].x]=1;\n\tfor (int i=1; i<=cnt2; i++)\n\t\tif (bo[e2[i][0]]&&bo[e2[i][1]]) {printf(\"No\\n\"); return 0;}\n\tans[0]=0;\n\tfor (int i=1; i<=m; i++)\n\t\tif (bo[i]) ans[++ans[0]]=i;\n\tprintf(\"Yes\\n%d\\n\",ans[0]);\n\tfor (int i=1; i<=ans[0]; i++) printf(\"%d \",ans[i]); \n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nusing pii = pair<int, int>;\nusing pid = pair<int, double>;\nusing pdd = pair<double, double>;\nusing pic = pair<int, char>;\nusing pllll = pair<ll, ll>;\nusing pllc = pair<ll, char>;\nusing pill = pair<int, ll>;\nusing pss = pair<string, string>;\nusing pis = pair<int, string>;\nusing plls = pair<ll, string>;\nusing plld = pair<ll, double>;\n\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vs = vector<string>;\nusing vll = vector<ll>;\n\n#define pb push_back\n#define mp make_pair\n#define f(i, n) for(int i = 0; i < n; i++)\n#define fll(i, n) for(ll i = 0; i < n; i++)\n#define F(i, n)\tfor(int i = 1; i <= n; i++)\n#define Fll(i, n) for(ll i = 1; i <= n; i++)\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n#define fl fflush(stdout);\n\nint main(){\n\n\t//ios::sync_with_stdio(false);\n\n\tint n;\n\n    cin >> n;\n\n    vi a(n + 1, 0);\n\n    f(i, n){\n\n        cin >> a[i];\n\n    }\n\n    cout << 1 << \" \" << n << endl;\n\n    f(i, n){\n\n        ll rem = a[i] % (n - 1ll);\n        if(rem < 0){\n\n            rem += (n - 1ll);\n\n        }\n\n        cout << n * (n - 1ll - rem) << \" \";\n\n        \n\n    }\n\n    cout << endl;\n\n    f(i, n){\n\n        ll rem = a[i] % (n - 1ll);\n        if(rem < 0){\n\n            rem += (n - 1ll);\n\n        }\n\n        a[i] += n * (n - 1ll - rem);\n\n    }\n\n    cout << 1 << \" \" << (n - 1ll) << endl;\n\n    f(i, n - 1){\n\n        ll o = a[i] * -1;\n\n        cout << o << \" \";\n\n        //a[i] *= -1;\n\n    }\n\n    cout << endl;\n\n    cout << n << \" \" << n << endl;\n\n    ll out = -1 * a[n - 1];\n\n    cout << out << endl;\n\n\treturn 0;\n\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nusing pii = pair<int, int>;\nusing pid = pair<int, double>;\nusing pdd = pair<double, double>;\nusing pic = pair<int, char>;\nusing pllll = pair<ll, ll>;\nusing pllc = pair<ll, char>;\nusing pill = pair<int, ll>;\nusing pss = pair<string, string>;\nusing pis = pair<int, string>;\nusing plls = pair<ll, string>;\nusing plld = pair<ll, double>;\n\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vs = vector<string>;\nusing vll = vector<ll>;\n\n#define pb push_back\n#define mp make_pair\n#define f(i, n) for(int i = 0; i < n; i++)\n#define fll(i, n) for(ll i = 0; i < n; i++)\n#define F(i, n)\tfor(int i = 1; i <= n; i++)\n#define Fll(i, n) for(ll i = 1; i <= n; i++)\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n#define fl fflush(stdout);\n\nint main(){\n\n\t//ios::sync_with_stdio(false);\n\n\tll n;\n\n    cin >> n;\n\n    vll a(n + 1, 0);\n\n    fll(i, n){\n\n        cin >> a[i];\n\n    }\n\n    if(n == 1){\n\n        cout << 1 << \" \" << 1 << endl;\n\n        cout << -1 * a[0] << endl;\n\n        cout << 1 << \" \" << 1 << endl;\n\n        cout << 0 << endl;\n\n        cout << 1 << \" \" << 1 << endl;\n\n        cout << 0 << endl;\n\n    }\n\n    else{cout << 1 << \" \" << n << endl;\n\n    fll(i, n){\n\n        ll rem = a[i] % (n - 1ll);\n        if(rem < 0){\n\n            rem += (n - 1ll);\n\n        }\n\n        cout << n * (n - 1ll - rem) << \" \";\n\n        \n\n    }\n\n    cout << endl;\n\n    fll(i, n){\n\n        ll rem = a[i] % (n - 1ll);\n        if(rem < 0){\n\n            rem += (n - 1ll);\n\n        }\n\n        a[i] += n * (n - 1ll - rem);\n\n    }\n\n    cout << 1 << \" \" << (n - 1ll) << endl;\n\n    fll(i, n - 1){\n\n        ll o = a[i] * -1;\n\n        cout << o << \" \";\n\n        //a[i] *= -1;\n\n    }\n\n    cout << endl;\n\n    cout << n << \" \" << n << endl;\n\n    ll out = -1 * a[n - 1];\n\n    cout << out << endl;}\n\n\treturn 0;\n\n}\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void onClick(android.view.View view) {\n    int pos = getAdapterPosition();\n    if (longClick) {\n        if (view.isSelected()) {\n            view.setBackgroundColor(android.support.v4.content.ContextCompat.getColor(activity, R.color.backgroundDark));\n            view.setSelected(false);\n        }else {\n            view.setBackgroundColor(android.support.v4.content.ContextCompat.getColor(activity, R.color.backgroundLight));\n            view.setSelected(true);\n        }\n    }else {\n        android.content.Intent matchExpanded = new android.content.Intent(activity, com.mohits.calculator.Activities.MatchExpanded.class);\n        cursor.moveToPosition(pos);\n        int index = cursor.getColumnIndex(CalculationContract.Matches.ID);\n        java.lang.String value = cursor.getString(index);\n        matchExpanded.putExtra(\"match_id\", value);\n        index = cursor.getColumnIndex(CalculationContract.Matches.MATCH_NAME);\n        value = cursor.getString(index);\n        matchExpanded.putExtra(\"match_name\", value);\n        matchExpanded.putExtra(\"fragment\", fragment);\n        activity.startActivity(matchExpanded);\n    }\n}",
        "fixed_code": "@java.lang.Override\npublic void onClick(android.view.View view) {\n    int pos = getAdapterPosition();\n    if (longClick) {\n        if (view.isSelected()) {\n            view.setBackgroundColor(android.support.v4.content.ContextCompat.getColor(activity, R.color.backgroundDark));\n            view.setSelected(false);\n        }else {\n            view.setBackgroundColor(android.support.v4.content.ContextCompat.getColor(activity, R.color.backgroundLight));\n            view.setSelected(true);\n        }\n    }else {\n        android.content.Intent matchExpanded = new android.content.Intent(activity, com.mohits.calculator.Activities.MatchExpanded.class);\n        cursor.moveToPosition(pos);\n        int index = cursor.getColumnIndex(CalculationContract.Matches.ID);\n        java.lang.String value = cursor.getString(index);\n        matchExpanded.putExtra(\"match_id\", value);\n        index = cursor.getColumnIndex(CalculationContract.Matches.MATCH_NAME);\n        value = cursor.getString(index);\n        matchExpanded.putExtra(\"match_name\", value);\n        index = cursor.getColumnIndex(CalculationContract.Matches.MATCH_FORMAT);\n        value = cursor.getString(index);\n        matchExpanded.putExtra(\"match_format\", value);\n        matchExpanded.putExtra(\"fragment\", fragment);\n        activity.startActivity(matchExpanded);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "from collections import defaultdict\r\nfrom collections import deque\r\ntc = int(input())\r\nfor _ in range(tc):\r\n    input()\r\n    graph = defaultdict(list)\r\n    indegree = defaultdict(int)\r\n    n , k = map(int, input().split())\r\n    \r\n    for _ in range(n-1):\r\n        n1, n2 = map(int, input().split())\r\n        graph[n1].append(n2)\r\n        graph[n2].append(n1)\r\n        indegree[n1] += 1\r\n        indegree[n2] += 1\r\n    q = deque()\r\n    for key, v in indegree.items():\r\n        if v == 1:\r\n            q.append(key)\r\n    count = 0\r\n    while k > 0 and q:\r\n        size = len(q)\r\n        \r\n        for _ in range(size):\r\n            cur = q.popleft()\r\n            count += 1\r\n            \r\n            for ne in graph[cur]:\r\n                indegree[ne] -= 1\r\n                if indegree[ne] == 1:\r\n                    q.append(ne)\r\n            \r\n        k -= 1\r\n    print(n - count)",
        "fixed_code": "from collections import defaultdict\r\nfrom collections import deque\r\ntc = int(input())\r\nfor _ in range(tc):\r\n    input()\r\n    graph = defaultdict(list)\r\n    indegree = defaultdict(int)\r\n    n , k = map(int, input().split())\r\n    \r\n    for _ in range(n-1):\r\n        n1, n2 = map(int, input().split())\r\n        graph[n1].append(n2)\r\n        graph[n2].append(n1)\r\n        indegree[n1] += 1\r\n        indegree[n2] += 1\r\n    q = deque()\r\n    for key, v in indegree.items():\r\n        if v == 1:\r\n            q.append(key)\r\n    count = 0\r\n    while k > 0 and q:\r\n        size = len(q)\r\n        \r\n        for _ in range(size):\r\n            cur = q.popleft()\r\n            count += 1\r\n            \r\n            for ne in graph[cur]:\r\n                indegree[ne] -= 1\r\n                if indegree[ne] == 1:\r\n                    q.append(ne)\r\n            \r\n        k -= 1\r\n    if n <= 2: print(0)\r\n    else: print(n - count) ",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n      int t;\r\n      cin>>t;\r\n      while(t--)\r\n      {\r\n            int n;\r\n            cin>>n;\r\n            int a[n];\r\n            \r\n            for(int i=0;i<n;i++)\r\n            {\r\n                  cin>>a[i];\r\n            }\r\n            \r\n            int ans=0;\r\n            \r\n            for(int i=0;i<n;i++)\r\n            {\r\n                  for(int j=i;j<n;j++)\r\n                  {\r\n                        ans+=j-i+1;\r\n                  }\r\n                  \r\n                  for(int k=i;k<=j;k++)\r\n                  {\r\n                        if(a[k]==0)\r\n                        ans++;\r\n                  }\r\n            }\r\n            \r\n            cout<<ans<<endl;\r\n      }\r\n}",
        "fixed_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n      int t;\r\n      cin>>t;\r\n      while(t--)\r\n      {\r\n            int n;\r\n            cin>>n;\r\n            int a[n];\r\n            \r\n            for(int i=0;i<n;i++)\r\n            {\r\n                  cin>>a[i];\r\n            }\r\n            \r\n            int ans=0;\r\n            \r\n            for(int i=0;i<n;i++)\r\n            {\r\n                  for(int j=i;j<n;j++)\r\n                  {\r\n                        ans+=j-i+1;\r\n                        \r\n                        for(int k=i;k<=j;k++)\r\n                        {\r\n                              if(a[k]==0)\r\n                              ans++;\r\n                        }\r\n                  }\r\n                  \r\n            }\r\n            \r\n            cout<<ans<<endl;\r\n      }\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\nprotected void interrupted() {\n    java.lang.System.out.println(\"ive been ...\");\n}",
        "fixed_code": "@java.lang.Override\nprotected void interrupted() {\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int MAXN=2e5+10;\nint n,a[MAXN],ans[MAXN];\nint head[MAXN],to[MAXN*2],nxt[MAXN*2],tot=0;\nqueue<int> que;\n\nvoid add(int u,int v){\n\tto[++tot]=v;nxt[tot]=head[u];head[u]=tot;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tmemset(ans,0x3f,sizeof(ans));\n\tfor(int i=1;i<=n;i++)\n\t\tif(i-a[i]>=1) add(i-a[i],i);\n\t\telse if(i+a[i]<=n) add(i+a[i],i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(i-a[i]>=1&&a[i-a[i]]%2!=a[i]%2||i+a[i]<=n&&a[i+a[i]]%2!=a[i]%2)\n\t\t\tans[i]=1,que.push(i);\n\twhile(!que.empty()){\n\t\tint u=que.front();que.pop();\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t\tif(ans[to[i]]>ans[u]+1){\n\t\t\t\tans[to[i]]=ans[u]+1;\n\t\t\t\tque.push(to[i]);\n\t\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]==inf?-1:ans[i]);\n\treturn 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int MAXN=2e5+10;\nint n,a[MAXN],ans[MAXN];\nint head[MAXN],to[MAXN*2],nxt[MAXN*2],tot=0;\nqueue<int> que;\n\nvoid add(int u,int v){\n\tto[++tot]=v;nxt[tot]=head[u];head[u]=tot;\n}\n\nint main(){\n//\tfreopen(\"data.in\",\"r\",stdin);\n//\tfreopen(\"data.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tmemset(ans,0x3f,sizeof(ans));\n\tfor(int i=1;i<=n;i++){\n\t\tif(i-a[i]>=1&&a[i-a[i]]%2==a[i]%2) add(i-a[i],i);\n\t\tif(i+a[i]<=n&&a[i+a[i]]%2==a[i]%2) add(i+a[i],i);\n\t}\n\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tif(i-a[i]>=1&&a[i-a[i]]%2!=a[i]%2||i+a[i]<=n&&a[i+a[i]]%2!=a[i]%2)\n\t\t\tans[i]=1,que.push(i);\n\twhile(!que.empty()){\n\t\tint u=que.front();que.pop();\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t\tif(ans[to[i]]>ans[u]+1){\n\t\t\t\tans[to[i]]=ans[u]+1;\n\t\t\t\tque.push(to[i]);\n\t\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]==inf?-1:ans[i]);\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define REP(i,j) for(int i=0;i<j;i++)\n#define FORN(i,j,k) for(int i=j;i<k;i++)\n#define vi vector<int>\n#define vvi vector<vi >\n#define pii pair<int,int>\n#define vpii vector<pii >\nusing namespace std;\nstring s;\nstring ss;\nint a[50005],b[50005];\npriority_queue<pii,vpii,greater<pii> >q;\nvpii tem;\nll ans=0;\nint main(void){\n\tcin>>s;\n\tif(s.size()%2!=0){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tss=s;\n\tll l=0,r=0,qm=0;\n\tREP(i,s.size()){\n\t\tif(s[i]=='?'){\n\t\t\tqm++;\n\t\t\tss[i]=')';\n\t\t\tcin>>a[i]>>b[i];\n\t\t\tans+=b[i];\n\t\t}\n\t\telse if(s[i]=='(')l++;\n\t\telse r++;\n\t}\n\tif(l+qm<r||r+qm<l||s[0]==')'||s[s.size()-1]=='('){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tl=0,r=0;\n//\tcout<<ans<<' '<<ss<<endl;\n\tREP(i,ss.size()){\n\t\tif(s[i]=='?')q.push(mp(a[i]-b[i],i));\n\t\tif(ss[i]=='(')l++;\n\t\telse r++;\n\t\tif(r>l){\n//\t\t\tcout<<ss<<' ';\n\t\t\tif(q.empty()){\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpii _p=q.top();\n\t\t\tq.pop();\n\t\t\tss[_p.se]='(';\n\t\t\tans+=_p.fi;\n\t\t\tl++;\n\t\t\tr--;\n//\t\t\tcout<<i<<' '<<ans<<' '<<ss<<endl;\n\t\t}\n\t}\n\tcout<<ans<<endl<<ss;\n\treturn 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define REP(i,j) for(int i=0;i<j;i++)\n#define FORN(i,j,k) for(int i=j;i<k;i++)\n#define vi vector<int>\n#define vvi vector<vi >\n#define pii pair<int,int>\n#define vpii vector<pii >\nusing namespace std;\nstring s;\nstring ss;\nint a[50005],b[50005];\npriority_queue<pii,vpii,greater<pii> >q;\nvpii tem;\nll ans=0;\nint main(void){\n\tcin>>s;\n\tif(s.size()%2!=0){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tss=s;\n\tll l=0,r=0,qm=0;\n\tREP(i,s.size()){\n\t\tif(s[i]=='?'){\n\t\t\tqm++;\n\t\t\tss[i]=')';\n\t\t\tcin>>a[i]>>b[i];\n\t\t\tans+=b[i];\n\t\t}\n\t\telse if(s[i]=='(')l++;\n\t\telse r++;\n\t}\n\tif(l+qm<r||r+qm<l||s[0]==')'||s[s.size()-1]=='('){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tl=0,r=0;\n//\tcout<<ans<<' '<<ss<<endl;\n\tREP(i,ss.size()){\n\t\tif(s[i]=='?')q.push(mp(a[i]-b[i],i));\n\t\tif(ss[i]=='(')l++;\n\t\telse r++;\n\t\tif(r>l){\n//\t\t\tcout<<ss<<' ';\n\t\t\tif(q.empty()){\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpii _p=q.top();\n\t\t\tq.pop();\n\t\t\tss[_p.se]='(';\n\t\t\tans+=_p.fi;\n\t\t\tl++;\n\t\t\tr--;\n//\t\t\tcout<<i<<' '<<ans<<' '<<ss<<endl;\n\t\t}\n\t}\n\tif(l-r!=0){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tcout<<ans<<endl<<ss;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*\n * if you are interested in the reference code here,\n * see https://github.com/georeth/OJLIBS for more information\n *\n * Solution Author : Georeth Chow <georeth2010@gmail.com>\n */\n#include <cstdio>\n#include <cmath>\n#include <climits>      // INT_MIN LLONG_MIN\n#include <cfloat>       // DBL_MIN DBL_MAX\n#include <cstring>      // memset\n#include <cstdlib>      // malloc\n#include <cstdint>      // int64_t\n#include <cinttypes>    // PRId64 SCNd64\n#include <ctime>        // clock\n#include <cassert>      // assert\n#include <limits>       // numeric_limits\n#include <vector>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>        // pair, tuple\n#include <iostream>     // be careful.\n                        // mix with cstdio: slowwww...\n                        // mix with cstdio + fastio: bug\n#include <sstream>\n#include <algorithm>\nusing namespace std;    // use as solution header. name polution is fine.\n#ifdef LOCAL_JUDGE\n#  define pr_debug(...) fprintf(stderr, __VA_ARGS__)\n#  define pr_line() fprintf(stderr, \"%s: %d\\n\", __FILE__, __LINE__)\n#else\n#  define pr_debug(...)\n#  define pr_line()\n#endif\ntemplate <typename T>\nbool chmax(T &m, const T &v) { if (v > m) return m = v, true; return false; }\ntemplate <typename T>\nbool chmin(T &m, const T &v) { if (v < m) return m = v, true; return false; }\ntemplate <typename T>\nbool chinc(T &v1, T &v2) { if (v1 > v2) return swap(v1, v2), true; return false; }\ntemplate <typename T>\nbool chdec(T &v1, T &v2) { if (v1 < v2) return swap(v1, v2), true; return false; }\n#define ALL(x) begin(x), end(x)\n#define FOR0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define FOR1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define FOR(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define FOD0(i,n) for(int i=(n)-1;~i;i--)\n#define FOD1(i,n) for(int i=n;i;i--)\n#define FOD(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define FORE(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pair<int, int>> vii;\ntypedef vector<vector<int>> vvi;\nnamespace fio {\n#define LL long long\n#define I inline\n#define OP operator\n#define RT return*this;\n#define ALL_INT(mcr) mcr(int)mcr(long)mcr(LL)mcr(unsigned)mcr(unsigned long)mcr(unsigned LL)\n#define ALL_FLT(mcr) mcr(float)mcr(double)mcr(long double)\n#define S2D x=0;int c=P();while((c<'0'||c>'9')&&c!='-')c=P();bool h=false;if(c=='-')h=true,c=P()\n#define R2D for(;c>='0'&&c<='9';c=P())x=x*10+c-'0'\n#define R2F if(c=='.'){double u=0.1;for(c=P();c>='0'&&c<='9';c=P(),u*=0.1)x+=u*(c-'0');}\n#define RD_INT(Int) I Fr&OP,(Int&x){S2D;R2D;if(h)x=-x;RT}\n#define RD_FLT(Flt) I Fr&OP,(Flt&x){S2D;R2D;R2F;if(h)x=-x;RT}\nstruct Cg{I char OP()(){return (char)getchar();}};\nstruct Cp{I void OP()(int x){putchar(x);}};\nstruct Ce{I void OP()(int x){putc(x,stderr);}};\nI bool IS(char x){return x==' '||x=='\\r'||x=='\\n'||x=='\\t';}\ntemplate<class T>struct Fr{T P;ALL_INT(RD_INT)ALL_FLT(RD_FLT)I Fr&OP,(char&x){for(x=P();IS(x);)x=P();RT}\nI Fr&OP,(char*s){for(*s=P();IS(*s);)*s=P();for(;!IS(*s);)*++s=P();*s=0;RT}\nI Fr&OP,(string &s){char c=P();for(;IS(c);)c=P();for(;!IS(c);)s.push_back(c),c=P();RT}\n};\n#define W4D if(x){if(x<0)P('-'),x=-x;int p=0;while(x)B[p++]=x%10+'0',x/=10;while(p--)P(B[p]);}else P('0')\n#define WR_INT(Int) I Fw&OP,(Int x){W4D;RT}\n#define WR_FLT(Flt) I Fw&OP()(Flt g,int d){if(d){double t=0.5;for(int i=d;i--;)t*=0.1;if(g<0)P('-'),g=-g;g+=t;*this,(LL)(g);P('.');g-=floor(g);while(d--){g*=10;int i=(int)floor(g);P(i+'0');g-=i;}}else*this,(g>0?(LL)(g+0.5):(LL)(g-0.5));RT}\ntemplate<class T>struct Fw{T P;char B[32];ALL_INT(WR_INT)ALL_FLT(WR_FLT)I Fw&OP,(char x){P(x);RT}typedef char_traits<char>CT;typedef basic_ostream<char,CT>&OS;typedef basic_istream<char,CT>&IS;I Fw&OP,(OS&(*func)(OS)){if(func==static_cast<OS&(*)(OS)>(endl<char,CT>))P('\\n');RT}I Fw&OP,(IS&(*func)(IS)){if(func==static_cast<IS&(*)(IS)>(ws<char,CT>))P(' ');RT}\nI Fw&OP,(const char*s){for(;*s;++s)P(*s);RT}\nI Fw&OP,(const string&s){(*this),s.c_str();RT}\ntemplate<class U>I Fw&all(const vector<U> &v, char sep=' ', char nl='\\n'){for(int i=0;i<(int)v.size();++i){if(i&&sep)P(sep);(*this),v[i];}if(nl)P(nl);RT}\ntemplate<class U>I Fw&print(U x){(*this),x;P('\\n');RT}\ntemplate<class U,class...Us>I Fw&print(U x,Us...args){(*this),x;P(' ');print(args...);RT}\n};\n#undef LL\n#undef I\n#undef OP\n#undef RT\n#undef ALL_INT\n#undef ALL_FLT\n#undef S2D\n#undef R2D\n#undef R2F\n#undef RD_INT\n#undef RD_FLT\n#undef W4D\n#undef WR_INT\n#undef WR_FLT\n};\nfio::Fr<fio::Cg>fin;\nfio::Fw<fio::Cp>fout;\nfio::Fw<fio::Ce>ferr;\n// \t fout.all(vec)\n#include <random>\n/* =====  SOLUTION START  ===== */\n// formalize:\n// dimension analysis:\nstatic const int maxn = 2505;\nstatic const int thres = 2505;\nint n, m, q;\nint64_t fen[maxn][maxn];\nmt19937_64 rd;\nvoid update(int r, int c, int64_t v) {\n    for (int x = r; x < maxn; x += x & -x) {\n        for (int y = c; y < maxn; y += y & -y) {\n            fen[x][y] += v;\n        }\n    }\n}\nint64_t query(int r, int c) {\n    int64_t v = 0;\n    for (int x = r; x > 0; x -= x & -x) {\n        for (int y = c; y > 0; y -= y & -y) {\n            v += fen[x][y];\n        }\n    }\n    return v;\n}\nint main() {\n    fin, n, m, q;\n    map<tuple<int,int,int,int>, int64_t> qs;\n    FOR(qid, 1, q) {\n        int t, r1, c1, r2, c2;\n        fin, t, r1, c1, r2, c2;\n        if (t == 1) {\n            int64_t r = rd();\n            qs[{r1, c1, r2, c2}] = r;\n            update(r2, c2, r);\n            update(r1 - 1, c1 - 1, r);\n            update(r1 - 1, c2, -r);\n            update(r2, c1 - 1, -r);\n        } else if (t == 2) {\n            int64_t r = qs[{r1, c1, r2, c2}];\n            update(r2, c2, -r);\n            update(r1 - 1, c1 - 1, -r);\n            update(r1 - 1, c2, r);\n            update(r2, c1 - 1, r);\n        } else if (t == 3) {\n            int64_t q1 = query(r1, c1);\n            int64_t q2 = query(r2, c2);\n            fout, q1 == q2 ? \"Yes\\n\" : \"No\\n\";\n        }\n    }\n    return 0;\n}\n",
        "fixed_code": "/*\n * if you are interested in the reference code here,\n * see https://github.com/georeth/OJLIBS for more information\n *\n * Solution Author : Georeth Chow <georeth2010@gmail.com>\n */\n#include <cstdio>\n#include <cmath>\n#include <climits>      // INT_MIN LLONG_MIN\n#include <cfloat>       // DBL_MIN DBL_MAX\n#include <cstring>      // memset\n#include <cstdlib>      // malloc\n#include <cstdint>      // int64_t\n#include <cinttypes>    // PRId64 SCNd64\n#include <ctime>        // clock\n#include <cassert>      // assert\n#include <limits>       // numeric_limits\n#include <vector>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>        // pair, tuple\n#include <iostream>     // be careful.\n                        // mix with cstdio: slowwww...\n                        // mix with cstdio + fastio: bug\n#include <sstream>\n#include <algorithm>\nusing namespace std;    // use as solution header. name polution is fine.\n#ifdef LOCAL_JUDGE\n#  define pr_debug(...) fprintf(stderr, __VA_ARGS__)\n#  define pr_line() fprintf(stderr, \"%s: %d\\n\", __FILE__, __LINE__)\n#else\n#  define pr_debug(...)\n#  define pr_line()\n#endif\ntemplate <typename T>\nbool chmax(T &m, const T &v) { if (v > m) return m = v, true; return false; }\ntemplate <typename T>\nbool chmin(T &m, const T &v) { if (v < m) return m = v, true; return false; }\ntemplate <typename T>\nbool chinc(T &v1, T &v2) { if (v1 > v2) return swap(v1, v2), true; return false; }\ntemplate <typename T>\nbool chdec(T &v1, T &v2) { if (v1 < v2) return swap(v1, v2), true; return false; }\n#define ALL(x) begin(x), end(x)\n#define FOR0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define FOR1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define FOR(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define FOD0(i,n) for(int i=(n)-1;~i;i--)\n#define FOD1(i,n) for(int i=n;i;i--)\n#define FOD(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define FORE(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pair<int, int>> vii;\ntypedef vector<vector<int>> vvi;\nnamespace fio {\n#define LL long long\n#define I inline\n#define OP operator\n#define RT return*this;\n#define ALL_INT(mcr) mcr(int)mcr(long)mcr(LL)mcr(unsigned)mcr(unsigned long)mcr(unsigned LL)\n#define ALL_FLT(mcr) mcr(float)mcr(double)mcr(long double)\n#define S2D x=0;int c=P();while((c<'0'||c>'9')&&c!='-')c=P();bool h=false;if(c=='-')h=true,c=P()\n#define R2D for(;c>='0'&&c<='9';c=P())x=x*10+c-'0'\n#define R2F if(c=='.'){double u=0.1;for(c=P();c>='0'&&c<='9';c=P(),u*=0.1)x+=u*(c-'0');}\n#define RD_INT(Int) I Fr&OP,(Int&x){S2D;R2D;if(h)x=-x;RT}\n#define RD_FLT(Flt) I Fr&OP,(Flt&x){S2D;R2D;R2F;if(h)x=-x;RT}\nstruct Cg{I char OP()(){return (char)getchar();}};\nstruct Cp{I void OP()(int x){putchar(x);}};\nstruct Ce{I void OP()(int x){putc(x,stderr);}};\nI bool IS(char x){return x==' '||x=='\\r'||x=='\\n'||x=='\\t';}\ntemplate<class T>struct Fr{T P;ALL_INT(RD_INT)ALL_FLT(RD_FLT)I Fr&OP,(char&x){for(x=P();IS(x);)x=P();RT}\nI Fr&OP,(char*s){for(*s=P();IS(*s);)*s=P();for(;!IS(*s);)*++s=P();*s=0;RT}\nI Fr&OP,(string &s){char c=P();for(;IS(c);)c=P();for(;!IS(c);)s.push_back(c),c=P();RT}\n};\n#define W4D if(x){if(x<0)P('-'),x=-x;int p=0;while(x)B[p++]=x%10+'0',x/=10;while(p--)P(B[p]);}else P('0')\n#define WR_INT(Int) I Fw&OP,(Int x){W4D;RT}\n#define WR_FLT(Flt) I Fw&OP()(Flt g,int d){if(d){double t=0.5;for(int i=d;i--;)t*=0.1;if(g<0)P('-'),g=-g;g+=t;*this,(LL)(g);P('.');g-=floor(g);while(d--){g*=10;int i=(int)floor(g);P(i+'0');g-=i;}}else*this,(g>0?(LL)(g+0.5):(LL)(g-0.5));RT}\ntemplate<class T>struct Fw{T P;char B[32];ALL_INT(WR_INT)ALL_FLT(WR_FLT)I Fw&OP,(char x){P(x);RT}typedef char_traits<char>CT;typedef basic_ostream<char,CT>&OS;typedef basic_istream<char,CT>&IS;I Fw&OP,(OS&(*func)(OS)){if(func==static_cast<OS&(*)(OS)>(endl<char,CT>))P('\\n');RT}I Fw&OP,(IS&(*func)(IS)){if(func==static_cast<IS&(*)(IS)>(ws<char,CT>))P(' ');RT}\nI Fw&OP,(const char*s){for(;*s;++s)P(*s);RT}\nI Fw&OP,(const string&s){(*this),s.c_str();RT}\ntemplate<class U>I Fw&all(const vector<U> &v, char sep=' ', char nl='\\n'){for(int i=0;i<(int)v.size();++i){if(i&&sep)P(sep);(*this),v[i];}if(nl)P(nl);RT}\ntemplate<class U>I Fw&print(U x){(*this),x;P('\\n');RT}\ntemplate<class U,class...Us>I Fw&print(U x,Us...args){(*this),x;P(' ');print(args...);RT}\n};\n#undef LL\n#undef I\n#undef OP\n#undef RT\n#undef ALL_INT\n#undef ALL_FLT\n#undef S2D\n#undef R2D\n#undef R2F\n#undef RD_INT\n#undef RD_FLT\n#undef W4D\n#undef WR_INT\n#undef WR_FLT\n};\nfio::Fr<fio::Cg>fin;\nfio::Fw<fio::Cp>fout;\nfio::Fw<fio::Ce>ferr;\n// \t fout.all(vec)\n#include <random>\n/* =====  SOLUTION START  ===== */\n// formalize:\n// dimension analysis:\nstatic const int maxn = 2505;\nstatic const int thres = 2505;\nint n, m, q;\nint64_t fen[maxn][maxn];\nmt19937_64 rd;\nvoid update(int r, int c, int64_t v) {\n    for (int x = r; x < maxn; x += x & -x) {\n        for (int y = c; y < maxn; y += y & -y) {\n            fen[x][y] += v;\n        }\n    }\n}\nint64_t query(int r, int c) {\n    int64_t v = 0;\n    for (int x = r; x > 0; x -= x & -x) {\n        for (int y = c; y > 0; y -= y & -y) {\n            v += fen[x][y];\n        }\n    }\n    return v;\n}\nint main() {\n    fin, n, m, q;\n    map<tuple<int,int,int,int>, int64_t> qs;\n    FOR(qid, 1, q) {\n        int t, r1, c1, r2, c2;\n        fin, t, r1, c1, r2, c2;\n        if (t == 1) {\n            int64_t r = rd();\n            qs[make_tuple(r1, c1, r2, c2)] = r;\n            update(r1, c1, r);\n            update(r2 + 1, c2 + 1, r);\n            update(r1, c2 + 1, -r);\n            update(r2 + 1, c1, -r);\n        } else if (t == 2) {\n            int64_t r = qs[make_tuple(r1, c1, r2, c2)];\n            qs.erase(make_tuple(r1, c1, r2, c2));\n            update(r1, c1, -r);\n            update(r2 + 1, c2 + 1, -r);\n            update(r1, c2 + 1, r);\n            update(r2 + 1, c1, r);\n        } else if (t == 3) {\n            int64_t q1 = query(r1, c1);\n            int64_t q2 = query(r2, c2);\n            fout, q1 == q2 ? \"Yes\\n\" : \"No\\n\";\n        }\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tcin>>t;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tvector<int> plank;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint temp;\n\t\t\tscanf(\"%d\",&temp);\n\t\t\tplank.push_back(temp);\t\n\t\t}\n\t\tsort(plank.begin(),plank.end());\n\t\t\n\t\tplank.pop_back();\n\t\tint max_=plank.back();\t\n\t\t\n\t\tint answer = min(max_-1,n-2);\n\t\tprintf(\"%d\\n\",answer);\n\t\t\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tcin>>t;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tvector<int> plank;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint temp;\n\t\t\tscanf(\"%d\",&temp);\n\t\t\tplank.push_back(temp);\t\n\t\t}\n\t\tsort(plank.begin(),plank.end());\n\t\t\n\t\tplank.pop_back();\n\t\tint max_=plank.back();\t\n\t\t\n\t\tint answer = min(max_-1,n-2);\n\t\tprintf(\"%d\\n\",answer);\n\t\t\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/* Author: deetav \ngenerated on 23 Aug 2020 at 19:56*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define FOR(i,a,b) for (int i=a; i<b; i++)\n#define fj(n) for(ll j=0;j<n;j++)\n#define forex(s) for(int x:s)\n#define cont continue\n#define ll long long\n#define bs(c,a)  binary_search(a.begin(),a.end(),c)  \n#define pb push_back\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%lld\",&x)\n#define ss(s)   scanf(\"%s\",s)\n#define pi(x)   printf(\"%d\\n\",x)\n#define pl(x)   printf(\"%lld\\n\",x)\n#define ps(s)   printf(\"%s\\n\",s)\n#define forex(s) for(int x:s)\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)//traverse through a dataset\n#define sortall(x) sort(all(x))\n#define prv(v) forex(v) cout<<x<<\" \"; cout<<endl; \n#define PI 3.1415926535897932384626\n#define mode( arr ,n) map <int,int>freq; int c=0; forex(arr)  {freq[x]++;c=max(c,freq[x]);}\n#define lb lower_bound\n#define ub upper_bound\n#define len() length()\n#define sz() size()\n#define count(v,x)  count(all(v),x) \ntypedef pair<int, int>  pii;\ntypedef pair<ll, ll>    pl;\ntypedef vector <int>     vi;\ntypedef vector <ll>      vl;\ntypedef vector <pii>     vpii;\ntypedef vector <pl>      vpl;\ntypedef vector <vi>      vvi;\ntypedef vector <vl>      vvl;\ntypedef priority_queue <int> pqi;\nstring s;\nconst ll MOD = 1e9 + 7;\n \ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\n \nint read(){\n\tll s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\n/*ll Pow(ll a,ll b)\n{\n    if (a == 1 || b == 1)\n        return a;\n    if (b%2==1)\n        return (a*Pow(a,b-1))%MOD;\n    return (Pow(a,b/2)*Pow(a,b/2))%MOD;\n}\nll factorial(ll n) {\n    ll ans = 1;\n    while (--n)\n        ans = (ans * (n + 1)) % MOD;\n    return ans;\n}*/\n \n \nint main(){\n\t//\tfreopen(\"input.txt\",\"r\",stdin);\n    //\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n;\n    n=read();\n    int a[1005];\n    FOR(i,1,n+1)a[i]=read();\n    int cnt=0;\n    a[0]=-1;\n    a[n+1]=-1;\n    FOR(i,1,n+1)\n    {\n    \t\n    \tif(a[i]==1){\n    \t\tcnt++;\n    \t\t\n    \t}\n\t\tif(a[i]==0 && a[i+1]==1 && a[i-1]==1){\n\t\t\tcnt++;\n\t\t\t\n\t\t}\n\t\tif(a[i]==0 && a[i+1]==1 &&a[i-1]==0){\n\t\t\tcnt++;\n\t\t}\n\t\t\t}\n\tcout<<cnt;\n\treturn 0;\n\t\n\t}",
        "fixed_code": "/* Author: deetav \ngenerated on 23 Aug 2020 at 19:56*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define FOR(i,a,b) for (int i=a; i<b; i++)\n#define fj(n) for(ll j=0;j<n;j++)\n#define forex(s) for(int x:s)\n#define cont continue\n#define ll long long\n#define bs(c,a)  binary_search(a.begin(),a.end(),c)  \n#define pb push_back\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%lld\",&x)\n#define ss(s)   scanf(\"%s\",s)\n#define pi(x)   printf(\"%d\\n\",x)\n#define pl(x)   printf(\"%lld\\n\",x)\n#define ps(s)   printf(\"%s\\n\",s)\n#define forex(s) for(int x:s)\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)//traverse through a dataset\n#define sortall(x) sort(all(x))\n#define prv(v) forex(v) cout<<x<<\" \"; cout<<endl; \n#define PI 3.1415926535897932384626\n#define mode( arr ,n) map <int,int>freq; int c=0; forex(arr)  {freq[x]++;c=max(c,freq[x]);}\n#define lb lower_bound\n#define ub upper_bound\n#define len() length()\n#define sz() size()\n#define count(v,x)  count(all(v),x) \ntypedef pair<int, int>  pii;\ntypedef pair<ll, ll>    pl;\ntypedef vector <int>     vi;\ntypedef vector <ll>      vl;\ntypedef vector <pii>     vpii;\ntypedef vector <pl>      vpl;\ntypedef vector <vi>      vvi;\ntypedef vector <vl>      vvl;\ntypedef priority_queue <int> pqi;\nstring s;\nconst ll MOD = 1e9 + 7;\n \ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\n \nint read(){\n\tll s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\n/*ll Pow(ll a,ll b)\n{\n    if (a == 1 || b == 1)\n        return a;\n    if (b%2==1)\n        return (a*Pow(a,b-1))%MOD;\n    return (Pow(a,b/2)*Pow(a,b/2))%MOD;\n}\nll factorial(ll n) {\n    ll ans = 1;\n    while (--n)\n        ans = (ans * (n + 1)) % MOD;\n    return ans;\n}*/\n \n \nint main(){\n\t//\tfreopen(\"input.txt\",\"r\",stdin);\n    //\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n;\n    n=read();\n    int a[1005];\n    FOR(i,1,n+1)a[i]=read();\n    int cnt=0;\n    a[0]=-1;\n    a[n+1]=-1;\n    FOR(i,1,n+1)\n    {\n    \t\n    \tif(a[i]==1){\n    \t\tcnt++;\n    \t\t\n    \t}\n\t\tif(a[i]==0 && a[i+1]==1 && a[i-1]==1){\n\t\t\tcnt++;\n\t\t\t\n\t\t}\n\t\tif(a[i]==0 && a[i+1]==1 &&a[i-1]==0 && cnt>0){\n\t\t\tcnt++;\n\t\t}\n\t\t\t}\n\tcout<<cnt;\n\treturn 0;\n\t\n\t}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void run() {\n    cs4341proj1.Logger log = cs4341proj1.Logger.getInstance();\n    cs4341proj1.GameBoard board = cs4341proj1.GameBoard.getInstance();\n    log.print(\"About to minimax\");\n    board.minimax();\n    log.print(board.toString());\n    while (!(java.lang.Thread.currentThread().isInterrupted())) {\n        log.print(\"About to calculate Ply\");\n        board.calculatePly();\n        log.print(board.toString());\n        log.print(\"About to minimax\");\n        if (java.lang.Thread.currentThread().isInterrupted()) {\n            break;\n        }\n        board.minimax();\n        log.print(board.toString());\n    } \n}",
        "fixed_code": "@java.lang.Override\npublic void run() {\n    try {\n        cs4341proj1.Logger log = cs4341proj1.Logger.getInstance();\n        cs4341proj1.GameBoard board = cs4341proj1.GameBoard.getInstance();\n        log.print(\"About to minimax\");\n        board.minimax();\n        log.print(board.toString());\n        while (!(java.lang.Thread.currentThread().isInterrupted())) {\n            log.print(\"About to calculate Ply\");\n            board.calculatePly();\n            log.print(board.toString());\n            log.print(\"About to minimax\");\n            if (java.lang.Thread.currentThread().isInterrupted()) {\n                break;\n            }\n            board.minimax();\n            log.print(board.toString());\n        } \n    } catch (java.lang.Exception e) {\n        cs4341proj1.Logger.getInstance().print(e.toString());\n        java.lang.StackTraceElement[] trace = e.getStackTrace();\n        for (java.lang.StackTraceElement s : trace) {\n            cs4341proj1.Logger.getInstance().print(((s.toString()) + \"\\n\\t\\t\"));\n        }\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    long long n,m,a[12][100002],i,j,c=0,sum=0,renum[100002],reach[100002];\n    cin>>n>>m;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            cin>>a[i][j];\n        }\n    }\n    for(i=0;i<=n;i++)\n    {\n        reach[i]=n;\n        renum[a[0][i]]=i+1;\n    }\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            a[i][j]=renum[a[i][j]];\n           // cout<<a[i][j]<<' ';\n        }\n       // cout<<endl;\n    }\n    for( i = 0; i < m; ++i){\n\t\tint cur = 0;\n\t\tfor( j = 0; j < n; ++j){\n\t\t\tif(cur < j)\n\t\t\t\t++cur;\n\n\t\t\twhile(cur < n-1 && a[i][cur + 1] == a[i][cur] + 1)\n\t\t\t\t++cur;\n\t\t\treach[a[i][j]] = min(reach[a[i][j]], a[i][cur]);\n\t\t}\n\t}\n//\tfor(i=1;i<=n;i++)cout<<reach[i]<<' ';\n    long long int res = 0;\n\tint now = 1;\n\twhile(now <= n){\n\t\tint cur = reach[now] - now + 1;\n\t\tres += 1LL * (cur + 1) * cur / 2LL;\n\t\tnow = reach[now] + 1;\n\t}\n    cout<<res;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\n\nconst int N = 1e5 + 7;\n\nint n, m;\nint mn[N];\nint ren[N];\nint perm[15][N];\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tscanf(\"%d\", &perm[i][j]);\n\t\n\tfor(int i = 1; i <= n; ++i)\n\t\tren[perm[1][i]] = i;\n\t\n\tfor(int i = 1; i <= m; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tperm[i][j] = ren[perm[i][j]];\n\t\t\n\tfor(int i = 1; i <= n; ++i)\n\t\tmn[i] = n;\n\t\t\n\tfor(int i = 1; i <= m; ++i){\n\t\tint cur = 1;\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tif(cur < j)\n\t\t\t\t++cur;\n\n\t\t\twhile(cur < n && perm[i][cur + 1] == perm[i][cur] + 1)\n\t\t\t\t++cur;\n\t\t\tmn[perm[i][j]] = min(mn[perm[i][j]], perm[i][cur]);\n\t\t}\n\t}\n\t\n\tLL res = 0;\n\tint now = 1;\n\twhile(now <= n){\n\t\tint cur = mn[now] - now + 1;\n\t\tres += 1LL * (cur + 1) * cur / 2LL;\n\t\tnow = mn[now] + 1;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "void scanAfterDelay(int delay) {\n    com.eveningoutpost.dexdrip.Models.UserError.Log.d(com.eveningoutpost.dexdrip.Services.G5CollectionService.TAG, \"ScanDelay\");\n    handler.postDelayed(new java.lang.Runnable() {\n        public void run() {\n            startScan();\n        }\n    }, delay);\n}",
        "fixed_code": "void scanAfterDelay(int delay) {\n    com.eveningoutpost.dexdrip.Models.UserError.Log.d(com.eveningoutpost.dexdrip.Services.G5CollectionService.TAG, \"ScanDelay\");\n    handler.postDelayed(new java.lang.Runnable() {\n        public void run() {\n            startScan();\n        }\n    }, delay);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "// be omide khodet\n#include <iostream>\n#include <bits/stdc++.h>\n#define pb push_back\n#define ob pop_back\n#define xx first\n#define yy second\n#define dob double\n#define int long long int\n#define ss size()\nusing namespace std;\nvector <int> v;\nconst int M=998244353,maxn=1e5+10;\nint ans,n,k,m,x,y,q,adj[maxn],ps[320][maxn];\nbool mark[maxn];\n\nint32_t main(){\n    cin>>n>>q;\n    int a[n];\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        if(a[i]<maxn){\n            adj[a[i]]++;\n            if(!mark[a[i]]&&adj[a[i]]>=a[i]){\n                v.pb(a[i]);\n                mark[a[i]]=1;\n            }\n        }\n    }\n    for(int i=0;i<v.ss;i++){\n        int u=v[i];\n        for(int j=0;j<n;j++){\n            if(j>0)\n                ps[i][j]=ps[i][j-1];\n            if(a[j]==u)\n                ps[i][j]++;\n        }\n    }\n    for(int i=0;i<q;i++){\n        cin>>x>>y;\n        x--;y--;\n        ans=0;\n        for(int j=0;j<v.ss;j++){\n            int u=v[j];\n            if(ps[j][y]-ps[j][x]==u)\n                ans++;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n",
        "fixed_code": "// be omide khodet\n#include <iostream>\n#include <bits/stdc++.h>\n#define pb push_back\n#define ob pop_back\n#define xx first\n#define yy second\n#define dob double\n#define ss size()\nusing namespace std;\nvector <int> v;\nconst int maxn=1e5+2;\nint ans,n,x,y,q,adj[maxn],ps[450][maxn];\nbool mark[maxn];\n\nint32_t main(){\n    cin>>n>>q;\n    int a[n];\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        if(a[i]<maxn){\n            adj[a[i]]++;\n            if(!mark[a[i]]&&adj[a[i]]>=a[i]){\n                v.pb(a[i]);\n                mark[a[i]]=1;\n            }\n        }\n    }\n    for(int i=0;i<v.ss;i++){\n        int u=v[i];\n        for(int j=0;j<n;j++){\n            if(j>0)\n                ps[i][j+1]=ps[i][j];\n            if(a[j]==u)\n                ps[i][j+1]++;\n        }\n    }\n    for(int i=0;i<q;i++){\n        cin>>x>>y;\n        ans=0;\n        for(int j=0;j<v.ss;j++){\n            int u=v[j];\n            if(ps[j][y]-ps[j][x-1]==u)\n                ans++;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\nprotected org.orekit.propagation.SpacecraftState getInitialIntegrationState() throws org.orekit.errors.OrekitException {\n    if (initialIsOsculating) {\n        return org.orekit.propagation.semianalytical.dsst.DSSTPropagator.computeMeanState(getInitialState(), forceModels);\n    }else {\n        return getInitialState();\n    }\n}",
        "fixed_code": "@java.lang.Override\nprotected org.orekit.propagation.SpacecraftState getInitialIntegrationState() throws org.orekit.errors.OrekitException {\n    if (initialIsOsculating) {\n        return org.orekit.propagation.semianalytical.dsst.DSSTPropagator.computeMeanState(getInitialState(), getAttitudeProvider(), forceModels);\n    }else {\n        return getInitialState();\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.util.*;\nimport java.util.Map.Entry;\n\n\nimport java.io.*;\n/*\n-> Written by <-\n  -----------\n |J_O_B_E_E_L|\n |___________|\n |    ___    |\n |   (^_^)   |\n |  /( | )\\  |\n |____|_|____|\n*/\n\npublic class Test {\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint x=sc.nextInt();\n\t\t\tint [] arr=new int [x+1];\n\t\t\tint [] freq=new int [x+1];\n\t\t\tint max=0;\n\t\t\tfor(int i=1;i<=x;i++) {\n\t\t\t\tfreq[i]=1;\n\t\t\t\tarr[i]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=1;i<=x;i++) {\n\t\t\t\tfor(int j=i*2;j<=x;j+=i) {\n\t\t\t\t\tif(arr[j]>=arr[i]) freq[j]=Math.max(freq[j], freq[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int w:freq) max=Math.max(max, w);\n\t\t\t//pw.println(Arrays.toString(freq));\n\t\t\tpw.println(max);\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\t\n\t\n    static class Scanner {\n    \t \n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n \n        public Scanner(InputStream in) {\n            this.in = in;\n            this.curbuf = this.lenbuf = 0;\n        }\n \n        public boolean hasNextByte() {\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0)\n                    return false;\n            }\n            return true;\n        }\n \n        private int readByte() {\n            if (hasNextByte())\n                return buffer[curbuf++];\n            else\n                return -1;\n        }\n \n        private boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n \n        private void skip() {\n            while (hasNextByte() && isSpaceChar(buffer[curbuf]))\n                curbuf++;\n        }\n \n        public boolean hasNext() {\n            skip();\n            return hasNextByte();\n        }\n \n        public String next() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isSpaceChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n \n        public int nextInt() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c))\n                c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n \n        public long nextLong() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c))\n                c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n \n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n \n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n \n    }\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n}\n",
        "fixed_code": "import java.util.*;\nimport java.util.Map.Entry;\n\n\nimport java.io.*;\n/*\n-> Written by <-\n  -----------\n |J_O_B_E_E_L|\n |___________|\n |    ___    |\n |   (^_^)   |\n |  /( | )\\  |\n |____|_|____|\n*/\n\npublic class Test {\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint x=sc.nextInt();\n\t\t\tint [] arr=new int [x+1];\n\t\t\tint [] freq=new int [x+1];\n\t\t\tint max=0;\n\t\t\tfor(int i=1;i<=x;i++) {\n\t\t\t\tfreq[i]=1;\n\t\t\t\tarr[i]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=1;i<=x;i++) {\n\t\t\t\tfor(int j=i*2;j<=x;j+=i) {\n\t\t\t\t\tif(arr[j]>arr[i]) freq[j]=Math.max(freq[j], freq[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int w:freq) max=Math.max(max, w);\n\t\t\t//pw.println(Arrays.toString(freq));\n\t\t\tpw.println(max);\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\t\n\t\n    static class Scanner {\n    \t \n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n \n        public Scanner(InputStream in) {\n            this.in = in;\n            this.curbuf = this.lenbuf = 0;\n        }\n \n        public boolean hasNextByte() {\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0)\n                    return false;\n            }\n            return true;\n        }\n \n        private int readByte() {\n            if (hasNextByte())\n                return buffer[curbuf++];\n            else\n                return -1;\n        }\n \n        private boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n \n        private void skip() {\n            while (hasNextByte() && isSpaceChar(buffer[curbuf]))\n                curbuf++;\n        }\n \n        public boolean hasNext() {\n            skip();\n            return hasNextByte();\n        }\n \n        public String next() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isSpaceChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n \n        public int nextInt() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c))\n                c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n \n        public long nextLong() {\n            if (!hasNext())\n                throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c))\n                c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n \n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n \n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n \n    }\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tif(k%2){\n\t\t\tprintf(\"%d %d\\n\",k/2,k/2);\n\t\t}else{\n\t\t\tprintf(\"%d %d\\n\",1,k-1);\n\t\t}\n\t}\n}\n",
        "fixed_code": "#include<stdio.h>\nint main(){\n\tint n,i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tif(!k%2){\n\t\t\tprintf(\"%d %d\\n\",k/2,k/2);\n\t\t}else{\n\t\t\tprintf(\"%d %d\\n\",1,k-1);\n\t\t}\n\t}\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*****   BY MURAD   ******/\n/*Everyone has a different way of thinking, so God Created us*/\n/*Hope You Respect My Way..,Thank You*/\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CCommonDivisors solver=new CCommonDivisors();\n        solver.solv(1,in,out);\n        out.close();\n    }\n    static class CCommonDivisors{\n        public void solv(int TestNumber,InputReader in,PrintWriter out){\n            int n=in.nextInt();\n            long a[]=in.readLongArray(n);\n            long g=0,ans=0;\n            for(long x:a){\n                g=NumberTheory.gcd(g,x);\n            }\n            for(long i=1;i*i<=g;i++)\n            {\n                if(g%i==0)\n                    ans++;\n                if((g/i)!=i)\n                    ans++;\n            }\n            out.println(ans);\n        }\n    }\n    static class Pair<C, I extends Number> implements Comparable<Pair<C, Number>> {\n        long value;\n        long idx;\n        Pair(long v, long i)\n        {\n            value = v;\n            idx = i;\n        }\n\n        @Override\n        public int compareTo(Pair<C, Number> p) {\n            return (int)(value - p.value);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n        public int[] readIntArray(int n) {\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextInt();\n            }\n            return x;\n        }\n    }\n    static class NumberTheory{\n       public static long gcd(long a,long b){\n           long c;\n           while (a != 0) {\n               c = a;\n               a = b % a;\n               b = c;\n           }\n           return b;\n        }\n    }\n    /*\n      int maxValueInMap=(Collections.max(mp.values()));  // This will return max value in the Hashmap\n        for (Map.Entry<String, Integer> entry : mp.entrySet()) {  // Itrate through hashmap\n            if (entry.getValue()==maxValueInMap) {\n                System.out.println(entry.getKey());\n                break;\n            }\n        }\n        Relatively Prime :- if diffrence between two number is equal to 1\n    */\n}",
        "fixed_code": "/*****   BY MURAD   ******/\n/*Everyone has a different way of thinking, so God Created us*/\n/*Hope You Respect My Way..,Thank You*/\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CCommonDivisors solver=new CCommonDivisors();\n        solver.solv(1,in,out);\n        out.close();\n    }\n    static class CCommonDivisors{\n        public void solv(int TestNumber,InputReader in,PrintWriter out){\n            int n=in.nextInt();\n            long a[]=in.readLongArray(n);\n            long g=0,ans=0;\n            for(long x:a){\n                g=NumberTheory.gcd(g,x);\n            }\n            for(long i=1;i*i<=g;i++)\n            {\n                if(g%i==0)\n                    ans+=2;\n                if(i*i==g)\n                    ans--;\n            }\n            out.println(ans);\n        }\n    }\n    static class Pair<C, I extends Number> implements Comparable<Pair<C, Number>> {\n        long value;\n        long idx;\n        Pair(long v, long i)\n        {\n            value = v;\n            idx = i;\n        }\n\n        @Override\n        public int compareTo(Pair<C, Number> p) {\n            return (int)(value - p.value);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public long[] readLongArray(int n) {\n            long[] x = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextLong();\n            }\n            return x;\n        }\n        public int[] readIntArray(int n) {\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = nextInt();\n            }\n            return x;\n        }\n    }\n    static class NumberTheory{\n       public static long gcd(long a,long b){\n           long c;\n           while (a != 0) {\n               c = a;\n               a = b % a;\n               b = c;\n           }\n           return b;\n        }\n    }\n    /*\n      int maxValueInMap=(Collections.max(mp.values()));  // This will return max value in the Hashmap\n        for (Map.Entry<String, Integer> entry : mp.entrySet()) {  // Itrate through hashmap\n            if (entry.getValue()==maxValueInMap) {\n                System.out.println(entry.getKey());\n                break;\n            }\n        }\n        Relatively Prime :- if diffrence between two number is equal to 1\n    */\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 2013\nVisualStudioVersion = 12.0.30501.0\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"5656565\", \"5656565\\5656565.vcxproj\", \"{299F744E-B282-4CC0-B3B9-1124EB5B6EEE}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Win32 = Debug|Win32\n\t\tRelease|Win32 = Release|Win32\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{299F744E-B282-4CC0-B3B9-1124EB5B6EEE}.Debug|Win32.ActiveCfg = Debug|Win32\n\t\t{299F744E-B282-4CC0-B3B9-1124EB5B6EEE}.Debug|Win32.Build.0 = Debug|Win32\n\t\t{299F744E-B282-4CC0-B3B9-1124EB5B6EEE}.Release|Win32.ActiveCfg = Release|Win32\n\t\t{299F744E-B282-4CC0-B3B9-1124EB5B6EEE}.Release|Win32.Build.0 = Release|Win32\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\nEndGlobal\n",
        "fixed_code": "/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst ll a = 11289;\nconst ll b = 40961;\nconst ll p = 233333333;\nconst ll q = 998244353;\nstruct edgee\n{\n\tint to;\n};\nstruct diann\n{\n\tll hashvalue;\n\tchar namee[11];\n};\nedgee edge[2][200200];\ndiann dian[2][100100];\nmap<string, int>name[2];\nint n, edgetot[2];\nchar aa[20], bb[20];\nint nametot[2];\nint first[2][100200], nextt[2][200200];\nvoid addedge(int from, int to, int kind)\n{\n\tedge[kind][edgetot[kind]].to = to;\n\tnextt[kind][edgetot[kind]] = first[kind][from];\n\tfirst[kind][from] = edgetot[kind]++;\n\tedge[kind][edgetot[kind]].to = from;\n\tnextt[kind][edgetot[kind]] = first[kind][to];\n\tfirst[kind][to] = edgetot[kind]++;\n}\nint read(char *aa, int kind)\n{\n\tif (name[kind][aa] == 0)\n\t{\n\t\tstrcpy(dian[kind][nametot[kind]].namee, aa);\n\t\tname[kind][aa] = nametot[kind]++;\n\t}\n\treturn name[kind][aa];\n}\nbool visit[2][100100], isinstack[2][100100];\nbool visitroot[2][2];\nll hashvaluee[2][100100], temphash[100100];\nint du[2][100100], height[2][100100];\nint root[2][2],maxheight;\nint son[2][100020];\nvector<int>parent[2][100010];\nvoid gethash(int kind)\n{\n\tqueue<int>que; maxheight = -1;\n\tfor (int i = 1; i <nametot[kind]; i++)\n\t{\n\t\tvisit[kind][i] = 0; isinstack[kind][i] = 0;\n\t\tif (du[kind][i] == 1)\n\t\t{\n\t\t\theight[kind][i] = 1;\n\t\t\thashvaluee[kind][i] = 1;\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tvisit[kind][now] = 1;\n\t\tint all = -1;\n\t\tfor (int i = first[kind][now]; i != -1; i = nextt[kind][i])\n\t\t{\n\t\t\tint to = edge[kind][i].to;\n\t\t\tif (visit[kind][to] == 1&&height[kind][to]==height[kind][now]-1)\n\t\t\t\ttemphash[++all] = hashvaluee[kind][to];\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isinstack[kind][to] == 0)\n\t\t\t\t{\n\t\t\t\t\tque.push(to);\n\t\t\t\t\tisinstack[kind][to] = 1;\n\t\t\t\t\theight[kind][to] = height[kind][now] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (all != -1)\n\t\t{\n\t\t\tall++;\n\t\t\tsort(temphash, temphash + all);\n\t\t\thashvaluee[kind][now] = (a*p) % q;\n\t\t\tfor (int i = 0; i < all; i++)\n\t\t\t{\n\t\t\t\thashvaluee[kind][now] = (hashvaluee[kind][now] * p^temphash[i]) % q;\n\t\t\t}\n\t\t\thashvaluee[kind][now] = (hashvaluee[kind][now] * b) % q;\n\t\t}\n\t\tif (height[kind][now] > maxheight)\n\t\t{\n\t\t\troot[kind][0] = now; root[kind][1] = -1;\n\t\t\tmaxheight = height[kind][now];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (height[kind][now] == maxheight)\n\t\t\t{\n\t\t\t\troot[kind][1] = now;\n\t\t\t\tif (hashvaluee[kind][root[kind][1]] < hashvaluee[kind][root[kind][0]])\n\t\t\t\t\tswap(root[kind][0], root[kind][1]);\n\t\t\t}\n\t\t}\n\t\t}\n\t\t}\n\t\tbool com1(int a, int b)\n\t\t{\n\t\treturn hashvaluee[0][a] < hashvaluee[0][b];\n\t\t}\n\t\tbool com2(int a, int b)\n\t\t{\n\t\treturn hashvaluee[1][a] < hashvaluee[1][b];\n\t\t}\n\t\tvoid print(int l, int r,int fal,int far)\n\t\t{\n\t\tif (l == -1 || r == -1)\n\t\treturn;\n\t\tprintf(\"%s %s\\n\", dian[0][l].namee, dian[1][r].namee);\n\t\tint alll = -1,allr=-1;\n\t\tfor (int i = first[0][l]; i != -1; i = nextt[0][i])\n\t\t{\n\t\tif (edge[0][i].to!=fal&&edge[0][i].to!=root[0][0]&&edge[0][i].to!=root[0][1])\n\t\tson[0][++alll]=edge[0][i].to;\n\t\t}\n\t\tsort(son[0], son[0] + alll+1, com1);\n\t\tfor (int i = 0; i <=alll; i++)\n\t\tparent[0][l].push_back(son[0][i]);\n\t\tfor (int i = first[1][r]; i != -1; i = nextt[1][i])\n\t\t{\n\t\tif (edge[1][i].to != far&&edge[1][i].to!=root[1][0]&&edge[1][i].to!=root[1][1]);\n\t\tson[1][++allr] = edge[1][i].to;\n\t\t}\n\t\tsort(son[1], son[1] + allr+1, com2);\n\t\tfor (int i = 0; i <=allr; i++)\n\t\tparent[1][r].push_back(son[1][i]);\n\t\tfor (int i = 0; i <=alll; i++)\n\t\t{\n\t\tint ll = parent[0][l][i]; int rr = parent[1][r][i];\n\t\tprint(ll, rr,l,r);\n\t\t}\n\t\t}\n\t\tint main()\n\t\t{\n\t\twhile (scanf(\"%d\", &n))\n\t\t{\n\t\tnametot[0] = 1; nametot[1] = 1;\n\t\tname[0].clear(); name[1].clear();\n\t\troot[0][0] = root[0][1] = root[1][0] = root[1][1] = -1;\n\t\tvisitroot[0][0] = visitroot[0][1] = visitroot[1][0] =visitroot[1][1] = 0;\n\t\tfor (int i = 0; i <= n; i++)\n\t\tfirst[0][i] = -1, first[1][i] = -1,\n\t\tparent[0][i].clear(), parent[1][i].clear(),\n\t\tdu[0][i]=du[1][i]=0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\tscanf(\"%s%s\", aa, bb);\n\t\tint a1 = read(aa, 0);\n\t\tint b1 = read(bb, 0);\n\t\taddedge(a1, b1, 0);\n\t\tdu[0][a1]++, du[0][b1]++;\n\t\t}\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\tscanf(\"%s%s\", aa, bb);\n\t\tint a2 = read(aa, 1);\n\t\tint b2 = read(bb, 1);\n\t\taddedge(a2, b2, 1);\n\t\tdu[1][a2]++, du[1][b2]++;\n\t\t}\n\t\tgethash(0);\n\t\tgethash(1);\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\tif (root[0][i] == -1)break;\n\t\tprint(root[0][i], root[1][i],-1,-1);\n\t\t}\n\t\t}\n\t\t}*/\n/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n\tint value;\n\tbool issame;\n\tint samevalue;\n};\nnode tree[600000];\nint a1[100010], b1[100010];\nint choose[20][100010];\nint a, b, C, M, last;\nint n, m, A, B;\nint rand(int last)\n{\n\ta = (36969 + (last >> 3))*(a&M) + (a >> 16);\n\tb = (18000 + (last >> 3))*(b&M) + (b >> 16);\n\treturn (C&((a << 16) + b)) % 1000000000;\n}\nint getrank(int l, int r, int h, int value)\n{\n\twhile (l < r)\n\t{\n\t\tint mid = (l + r) / 2+1;\n\t\tif (choose[h][mid] <= mid)\n\t\t\tl = mid;\n\t\telse\n\t\t\tr = mid - 1;\n\t}\n\treturn l;\n}\nvoid pushup(int k)\n{\n\ttree[k].value = tree[k << 1].value + tree[k << 1 | 1].value;\n}\nvoid pushdown(int k, int h, int l, int r)\n{\n\tif (tree[k].issame)\n\t{\n\t\ttree[k << 1].issame = 1;\n\t\ttree[k << 1 | 1].issame = 1;\n\t\ttree[k].issame = 0;\n\t\ttree[k << 1].samevalue = tree[k].samevalue;\n\t\ttree[k << 1 | 1].samevalue = tree[k].samevalue;\n\t\tint mid = (l + r) / 2;\n\t\tint l1 = getrank(l, mid, h + 1, tree[k].samevalue);\n\t\tint l2 = getrank(mid + 1, r, h + 1, tree[k].samevalue);\n\t\tif (l1 == l)\n\t\t\ttree[k << 1].value = tree[k << 1].samevalue >= choose[h + 1][l] ? 1 : 0;\n\t\telse\n\t\t\ttree[k << 1].value = l1 - l + 1;\n\t\tif (l2 == mid + 1)\n\t\t\ttree[k << 1 | 1].value = tree[k << 1 | 1].samevalue >= choose[h + 1][mid + 1] ? 1 : 0;\n\t\telse\n\t\t\ttree[k << 1 | 1].value = l2 - mid - 1 + 1;\n\t}\n}\nvoid build(int l, int r, int k, int h)\n{\n\t\tif (l == r)\n\t\t{\n\t\t\ttree[k].value = a1[l] >= b1[l] ? 1 : 0;\n\t\t\treturn;\n\t\t}\n\t\tint mid = (l + r) / 2;\n\t\tbuild(l, mid, k << 1, h + 1);\n\t\tbuild(mid + 1, r, k << 1 | 1, h + 1);\n\t\tint l1 = l;\n\t\tint l2 = mid + 1;\n\t\tint kk = l;\n\t\twhile (l1 <= mid&&l2 <= r)\n\t\t{\n\t\t\tif (choose[h + 1][l1] <= choose[h + 1][l2])\n\t\t\t\tchoose[h][kk++] = choose[h + 1][l1++];\n\t\t\telse\n\t\t\t\tchoose[h][kk++] = choose[h + 1][l2++];\n\t\t}\n\t\t\twhile (l1 <= mid)\n\t\t\t\tchoose[h][kk++] = choose[h + 1][l1++];\n\t\t\twhile (l2 <= r)\n\t\t\t\tchoose[h][kk++] = choose[h + 1][l2++];\n\t\t\tpushup(k);\n}\nvoid same(int l, int r, int ll, int rr, int k, int value, int h)\n{\n\tif (ll>=l&&rr<=r)\n\t{\n\t\tint rank = getrank(ll, rr, h, value);\n\t\tif (rank == ll)\n\t\t\ttree[k].value = value >= choose[h][ll] ? 1 : 0;\n\t\telse\n\t\t\ttree[k].value = rank - ll + 1;\n\t\ttree[k].issame = 1;\n\t\ttree[k].samevalue = value;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tpushdown(k, h, ll, rr);\n\t\tint mid = (ll + rr) / 2;\n\t\tif (mid >= l)same(l, r, ll, mid, k << 1, value, h + 1);\n\t\tif (mid+1<= r)same(l, r, mid + 1, rr, k << 1 | 1, value, h + 1);\n\t\tpushup(k);\n\t}\n}\nint getsum(int l, int r, int ll, int rr, int k, int h)\n{\n\tif (ll >= l&&rr <= r)\n\t{\n\t\treturn tree[k].value;\n\t}\n\telse\n\t{\n\t\tpushdown(k, h, ll, rr);\n\t\tint mid = (ll + rr) / 2;\n\t\tint l1 = 0, l2 = 0;\n\t\tif (mid >= l)l1 = getsum(l, r, ll, mid, k << 1, h + 1);\n\t\tif (mid + 1 <= rr)l2 = getsum(l, r, mid + 1, rr, k << 1 | 1, h + 1);\n\t\treturn l1 + l2;\n\t}\n}\nint main()\n{\n\twhile (scanf(\"%d%d%d%d\", &n, &m, &A, &B) != EOF)\n\t{\n\t\ta = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1,last=0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%d\", &a1[i]);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%d\", &b1[i]);\n\t\tbuild(1, n, 1, 0);\n\t\twhile (m--)\n\t\t{\n\t\t\tint l, r, x;\n\t\t\tl = rand(last)%n+1; r = rand(last)%n+1; x = rand(last)%n+1;\n\t\t\tif (l > r)swap(l, r);\n\t\t\tif ((l + r + x) % 2 == 0)\n\t\t\t{\n\t\t\t\tint valuee = getsum(l, r, 1, n, 1, 0);\n\t\t\t\tlast = valuee;\n\t\t\t\tprintf(\"%d\\n\", valuee);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsame(l, r, 1, n, 1, x, 0);\n\t\t\t}\n\t\t}\n\t}\n}*/\n/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#include<string.h>\nusing namespace std;\nbitset<100001>dp[2][3], mode[26];\nchar a[100010], b[5020];\nint n, m, t;\nint main()\n{\n//\t//dp[0][0][0] = 1;\n\t//dp[1][0][0] = 1;\n\t//dp[0][0]=dp[0][0] << 1;\n\t//dp[1][0] = dp[0][0] | dp[1][0];\n\tscanf(\"%d\", &t);\n\twhile (t--)\n\t{\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (int i = 0; i < 26; i++)\n\t\t\tmode[i].reset();\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\tdp[i][j].reset();\n\t\tscanf(\"%s%s\", a, b);\n\t\tint lena =n;\n\t\tint lenb =m;\n\t\tfor (int i = 0; i < lena; i++)\n\t\t{\n\t\t\tint kind = a[i] - 'a';\n\t\t\tmode[kind][i] = 1;\n\t\t}\n\t\tdp[1][1] = mode[b[0] - 'a'];\n\t\tif (lenb>=2)\n\t\tdp[1][2] = mode[b[1] - 'a'];\n\t\tb[lenb] = 'a';\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i < lenb; i++)\n\t\t{\n\t\t\t\tdp[cnt][0] = (dp[cnt ^ 1][2] << 1)&mode[b[i - 1] - 'a'];\n\t\t\tdp[cnt][1] = (((dp[cnt ^ 1][1] |dp[cnt ^ 1][0])<<1)&mode[b[i] - 'a']);\n\tdp[cnt][2] = (((dp[cnt ^ 1][0]|dp[cnt ^ 1][1]) << 1)&mode[b[i + 1] - 'a']);\n\n\t\t\tcnt ^= 1;\n\t\t}\n\t\tcnt ^= 1;\n\t\tfor (int i = 0; i<=n-1; i++)\n\t\t\tif (dp[cnt][0][i + lenb - 1] | dp[cnt][1][i + lenb - 1] && i <= n - 1 - lenb + 1)\n\t\t\t\tprintf(\"1\");\n\t\t\telse\n\t\t\t\tprintf(\"0\");\n\t\tprintf(\"\\n\");\n\t}\n}*/\n/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint t;\nint a[1010];\nint main()\n{\n\twhile (scanf(\"%d\", &t) != EOF)\n\t{\n\t\tfor (int i = 0; i < t; i++)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tdouble sum1 = 0, sum2 = 0;\n\t\tsum1 = a[0] + a[t - 1];\n\t\tsum1 /= 2;\n\t\tfor (int i = 1; i < t - 1; i++)\n\t\t\tsum2 += a[i];\n\t\tsum2 /= 3;\n\t\tprintf(\"%.6llf\\n\", sum1 + sum2);\n\t}\n\treturn 0;\n}*/\n//hdu5762\n/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string.h>\nusing  namespace std;\ntypedef long long ll;\nstruct nodee\n{\n\tint son[26];\n\tint fa,pos,maxx;\n\t//char value;\n};\nnodee tree[300200];\nint t,tot;\nchar s[100100];\nchar cc[10];\nint maxx,noww;\nvoid insert(char c)\n{\n\tint tempp = noww;\n\tnoww = tot;\n\tif (c== cc[0])\n\t{\n\t\ttree[noww].pos = maxx;\n\t}\n\t//tree[noww].value = c;\n\tint kind = c - 'a';\n\tif (tree[noww].pos == 0)\n\t\ttree[noww].pos = tree[tempp].pos;\n\ttree[noww].maxx = maxx;\n\twhile (tempp&&tree[tempp].son[kind] == 0)\n\t\ttree[tempp].son[kind] = noww,\n\t\ttempp=tree[tempp].fa;\n\tif (tempp == 0 && tree[tempp].son[kind]==0)\n\t\ttree[tempp].son[kind] = noww,\n\t    tree[noww].fa = tempp;\n\telse\n\t{\n\t\t\tint nextt = tree[tempp].son[kind];\n\t\t\tif (tree[nextt].maxx - 1 == tree[tempp].maxx)\n\t\t\t\ttree[noww].fa = nextt;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint neww = ++tot;\n\t\t\t\ttree[neww] = tree[nextt];\n\t\t\t\ttree[neww].maxx = tree[tempp].maxx + 1;\n\t\t\t\tif (tree[nextt].maxx == tree[nextt].pos)\n\t\t\t\t\ttree[neww].pos = tree[tempp].maxx + 1;\n\t\t\t\telse\n\t\t\t\t\ttree[neww].pos = tree[tempp].pos;\n\t\t\t\twhile (tempp&&tree[tempp].son[kind] == nextt)\n\t\t\t\t\ttree[tempp].son[kind] = neww;\n\t\t\t\tif (tempp == 0 && tree[tempp].son[kind] == nextt)\n\t\t\t\t\ttree[tempp].son[kind] = neww;\n\t\t\t\ttree[noww].fa = neww; tree[nextt].fa = neww;\n\t\t\t}\n\t}\n\ttot++;\n\tmaxx++;\n}\nint main()\n{\n\tscanf(\"%d\", &t);\n\tint k = 1;\n\twhile (t--)\n\t{\n\t\tfor (int i = 0; i <=tot; i++)for (int j = 0; j < 26; j++)tree[i].son[j] = 0, tree[i].fa = 0, tree[i].pos = 0,tree[i].maxx=0;\n\t\ttot = 1; maxx = 1; noww = 0;\n\t\tscanf(\"%s\", cc);\n\t\tscanf(\"%s\", s);\n\t\t//cc[0] = (rand() % 26) + 'a';\n\t\t//for (int i = 0; i < 100000; i++)\n\t\t\t//s[i] = (rand() % 26) + 'a';\n\t\tint len = strlen(s);\n\t\t//len = 100000;\n\t\tfor (int i = 0; i < len; i++)\n\t\t{\n\t\t\tinsert(s[i]);\n\t\t}\n\t\tll sum = 0;\n\t\tfor (int i = tot - 1; i >= 1; i--)\n\t\t{\n\t\t\tint fa = tree[i].fa;\n\t\t\tsum += min(tree[i].maxx - tree[fa].maxx, tree[i].pos);\n\t\t}\n\t\tprintf(\"Case #%d: %lld\\n\",k++,sum);\n\t}\n}/**/\n\n/*#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100010;\nint t1[MAXN], t2[MAXN], c[MAXN];//��SA������Ҫ���м����������Ҫ��ֵ\n//��������ַ�������s�����У���s[0]��s[n-1],����Ϊn,�����ֵС��m,\n//��s[n-1]�������s[i]������0��r[n-1]=0\n//���������Ժ�������sa������\n//sa[1~n]->[0,N] rank[0~n-1]->[1,N]  height[1~n]\nbool cmp(int *r, int a, int b, int l)\n{\n\treturn r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid da(int str[], int sa[], int Rank[], int height[], int n, int m)\n{\n\tn++;\n\tint i, j, p, *x = t1, *y = t2;\n\t//��һ�ֻ����������s�����ֵ�ܴ󣬿ɸ�Ϊ��������\n\tfor (i = 0; i < m; i++)c[i] = 0;\n\tfor (i = 0; i < n; i++)c[x[i] = str[i]]++;\n\tfor (i = 1; i < m; i++)c[i] += c[i - 1];\n\tfor (i = n - 1; i >= 0; i--)sa[--c[x[i]]] = i;\n\tfor (j = 1; j <= n; j <<= 1)\n\t{\n\t\tp = 0;\n\t\t//ֱ������sa��������ڶ��ؼ���\n\t\tfor (i = n - j; i < n; i++)y[p++] = i;//�����j�����ڶ��ؼ���Ϊ�յ���С\n\t\tfor (i = 0; i < n; i++)if (sa[i] >= j)y[p++] = sa[i] - j;\n\t\t//��������y����ľ��ǰ��յڶ��ؼ�������Ľ��\n\t\t//���������һ�ؼ���\n\t\tfor (i = 0; i < m; i++)c[i] = 0;\n\t\tfor (i = 0; i < n; i++)c[x[y[i]]]++;\n\t\tfor (i = 1; i < m; i++)c[i] += c[i - 1];\n\t\tfor (i = n - 1; i >= 0; i--)sa[--c[x[y[i]]]] = y[i];\n\t\t//����sa��x��������µ�x����\n\t\tswap(x, y);\n\t\tp = 1; x[sa[0]] = 0;\n\t\tfor (i = 1; i < n; i++)\n\t\t\tx[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n\t\tif (p >= n)break;\n\t\tm = p;//�´λ�����������ֵ\n\t}\n\tint k = 0;\n\tn--;\n\tfor (i = 0; i <= n; i++)Rank[sa[i]] = i;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (k)k--;\n\t\tj = sa[Rank[i] - 1];\n\t\twhile (str[i + k] == str[j + k])k++;\n\t\theight[Rank[i]] = k;\n\t}\n}\nint Rank[MAXN], height[MAXN];\n\nchar str[MAXN];\nchar X[3];\nint r[MAXN];\nint sa[MAXN];\nint nxt[MAXN];\n\nint main(){\n\tint T;\n\tscanf(\"%d\", &T);\n\tfor (int cs = 1; cs <= T; cs++) {\n\t\t//X[0]= (rand() % 26) + 'a';\n\t\t//for (int i = 0; i < 100000; i++)\n\t\t\t//str[i] = (rand() % 26) + 'a';\n\t\tscanf(\"%s%s\", X, str);\n\t\tint n = strlen(str);\n\t\t//n = 100000;\n\t\tint temp = n;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (str[i] == X[0]) temp = i;\n\t\t\tnxt[i] = temp;\n\n\t\t}\n\t\tfor (int i = 0; i < n; i++) r[i] = str[i];\n\t\tr[n] = 0;\n\t\tda(r, sa, Rank, height, n, 128);\n\t\tll ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t//printf(\"%d %d %d\\n\",nxt[sa[i]], sa[i] , height[i]);\n\t\t\tans += n - max(nxt[sa[i]], sa[i] + height[i]);\n\t\t}\n\t\tprintf(\"Case #%d: %I64d\\n\", cs, ans);\n\t}\n\treturn 0;\n}/**/\n/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\ntypedef long long ll;\nstruct nodee\n{\n\tint son[26];\n\tint maxx,fa;\n};\nnodee tree[2000200];\nchar s[1000100];\nint tot, maxx, tempp,noww;\nvoid insert(char c)\n{\n\ttree[tot].maxx = maxx;\n\ttempp = noww;\n\tnoww = tot;\n\tint kind = c - 'a';\n\twhile (tempp&&tree[tempp].son[kind] == 0)\n\t\ttree[tempp].son[kind] = noww,\n\t\ttempp=tree[tempp].fa;\n\tif (tempp == 0 && tree[tempp].son[kind] == 0)\n\t\ttree[tempp].son[kind] = noww,\n\t\ttree[noww].fa = tempp;\n\telse\n\t{\n\t\tint nextt = tree[tempp].son[kind];\n\t\tif (tree[nextt].maxx - 1 == tree[tempp].maxx)\n\t\t\ttree[noww].fa = nextt;\n\t\telse\n\t\t{\n\t\t\tint neww = ++tot;\n\t\t\ttree[neww] = tree[nextt];\n\t\t\ttree[neww].maxx = tree[tempp].maxx + 1;\n\t\t\ttree[noww].fa = neww; tree[nextt].fa = neww;\n\t\t\twhile (tree[tempp].son[kind] == nextt)\n\t\t\t{\n\t\t\t\ttree[tempp].son[kind] = neww;\n\t\t\t\tif (tempp == 0)break;\n\t\t\t\ttempp = tree[tempp].fa;\n\t\t\t}\n\t\t}\n\t}\n\ttot++, maxx++;\n}\nint main()\n{\n\ttot = 1; noww = 0; maxx = 1;\n\tscanf(\"%s\", s);\n\tint len = strlen(s);\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tinsert(s[i]);\n\t}\n\tll ans = 0;\n\tfor (int i = tot - 1; i >= 1; i--)\n\t{\n\t\tint fa = tree[i].fa;\n\t\tans += tree[i].maxx - tree[fa].maxx;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}/**/\n//hihocoder 1449\n/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string.h>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nstruct nodee\n{\n\tint maxl, maxr,fa;\n\tll amount;\n\tint son[26];\n\tchar vv;\n};\nstruct lenth\n{\n\tll to, value;\n};\nlenth realvalue[1000200];\nnodee tree[2000200];\nint maxx, tot, noww, tempp;\nchar s[1000200];\nint to[2000200];\nvoid insert(char cc)\n{\n\ttempp = noww;\n\tnoww = tot;\n\ttree[noww].maxr = maxx;\n\ttree[noww].amount = 1;\n\ttree[noww].vv = cc;\n\tint kind = cc - 'a';\n\twhile (tempp&&tree[tempp].son[kind] == 0)\n\t\ttree[tempp].son[kind] = noww,\n\t\ttempp = tree[tempp].fa;\n\tif (tempp == 0 && tree[tempp].son[kind] == 0)\n\t{\n\t\ttree[tempp].son[kind] = noww;\n\t\ttree[noww].fa = tempp;\n\t}\n\telse\n\t{\n\t\tint nextt = tree[tempp].son[kind];\n\t\tif (tree[nextt].maxr - tree[tempp].maxr == 1)\n\t\t{\n\t\t\ttree[noww].fa = nextt;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint neww = ++tot;\n\t\t\ttree[neww] = tree[nextt];\n\t\t\ttree[neww].amount = 0;\n\t\t\ttree[neww].maxr = tree[tempp].maxr + 1;\n\t\t\ttree[nextt].fa = neww; tree[noww].fa = neww;\n\t\t\twhile (tree[tempp].son[kind] == nextt)\n\t\t\t{\n\t\t\t\ttree[tempp].son[kind] = neww;\n\t\t\t\tif (tempp == 0)break;\n\t\t\t\ttempp = tree[tempp].fa;\n\t\t\t}\n\t\t}\n\t}\n\ttot++;\n\tmaxx++;\n}\nqueue<int>que;\nbool visit[2000200];\nvoid getsum()\n{\n\twhile (!que.empty())\n\t{\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tint fa = tree[now].fa;\n\t\ttree[fa].amount+=tree[now].amount;\n\t\tif (visit[fa] == 0)\n\t\t{\n\t\t\tvisit[fa] = 1;\n\t\t\tif (fa)\n\t\t\tque.push(fa);\n\t\t}\n\t}\n}\nbool com(nodee a, nodee b)\n{\n\treturn a.amount < b.amount;\n}\nint main()\n{\n\tnoww = 0; maxx = 1; tot = 1;\n\tscanf(\"%s\", s);\n\tint len = strlen(s);\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tinsert(s[i]);\n\t}\n\tfor (int i = tot - 1; i >= 1; i--)\n\t{\n\t\tint fa = tree[i].fa;\n\t\ttree[i].maxl = tree[fa].maxr + 1;\n\t\tto[fa]++;\n\t}\n\tfor (int i = tot - 1; i >= 1; i--)\n\t{\n\t\tif (to[i] == 0)\n\t\t{\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tgetsum();\n\n\tfor (int i = 1; i < tot; i++)\n\t{\n\t\tint noww = tree[i].maxr;\n\t\trealvalue[noww].value = max(realvalue[noww].value, tree[i].amount);\n\t}\n\tfor (int i = len-1; i >= 1; i--)\n\t{\n\t\trealvalue[i].value= max(realvalue[i].value, realvalue[i + 1].value);\n\t}\n\tfor (int i = 1; i <= len; i++)\n\t\tprintf(\"%lld\\n\", realvalue[i].value);\n\treturn 0;\n}/**/\n\n/*sort(tree+1, tree + tot, com);\nint amount = 0;\nfor (int i =tot-1; i>=1; i--)\n{\nif (amount == len)\nbreak;\nint l = tree[i].maxl;\nint r = tree[i].maxr;\nwhile (l <=r)\n{\nif (realvalue[l].value != 0)\n{\nl = realvalue[l].to + 1;\ncontinue;\n}\nrealvalue[l].to = r;\nrealvalue[l].value = tree[i].amount;\nl++;\namount++;\n}\n}*/\n/*#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e6 + 100;\nconst int M = 1e6 + 5;\nint tot, slink[2 * N], trans[2 * N][26], minlen[2 * N], maxlen[2 * N], edpts[2 * N], n;\nchar str[2 * N];\nint blue[2 * N], ind[2 * N], ans[2 * N + 10];\nint newstate(int _maxlen, int _minlen, int* _trans, int _slink) {\n\tmaxlen[++tot] = _maxlen;\n\tminlen[tot] = _minlen;\n\tslink[tot] = _slink;\n\tif (_trans)\n\t\tfor (int i = 0; i<26; i++)\n\t\t\ttrans[tot][i] = _trans[i];\n\treturn tot;\n}\nint add(char ch, int u) {\n\tint c = ch - 'a', v = u;\n\tint z = newstate(maxlen[u] + 1, -1, NULL, 0);\n\tblue[z] = 1;//��ɫ \n\twhile (v&&!trans[v][c]) {\n\t\ttrans[v][c] = z;\n\t\tv = slink[v];\n\t}\n\tif (!v) {\n\t\tminlen[z] = 1;\n\t\tslink[z] = 1;\n\t\tind[0]++;\n\t\treturn z;\n\t}\n\tint x = trans[v][c];\n\tif (maxlen[v] + 1 == maxlen[x]) {\n\t\tslink[z] = x;\n\t\tminlen[z] = maxlen[x] + 1;\n\t\tind[x]++;\n\t\treturn z;\n\t}\n\tint y = newstate(maxlen[v] + 1, -1, trans[x], slink[x]);\n\tslink[z] = slink[x] = y;\n\tind[y] += 2;\n\tminlen[x] = minlen[z] = maxlen[y] + 1;\n\twhile (v&&trans[v][c] == x) {\n\t\ttrans[v][c] = y;\n\t\tv = slink[v];\n\t}\n\tminlen[y] = maxlen[slink[y]] + 1;\n\treturn z;\n}\nvoid count() {\n\tqueue<int> q;\n\tfor (int i = 1; i <= tot; i++)if (!ind[i]) {\n\t\tq.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tif (blue[u]) edpts[u]++;\n\t\tedpts[slink[u]] += edpts[u];\n\t\tif (!--ind[slink[u]]) q.push(slink[u]);\n\t}\n}\n\nint main() {\n\tint i;\n\tscanf(\"%s\", str);\n\tint len = strlen(str), pre = 1;\n\ttot = 1;\n\tfor (i = 0; i<len; i++) {\n\t\tpre = add(str[i], pre);\n\t}\n\tcount();\n\tfor (i = 0; i <= tot; i++){\n\t\tans[maxlen[i]] = max(ans[maxlen[i]], edpts[i]);\n\t}\n\tfor (i = tot; i>0; i--){\n\t\tans[i] = max(ans[i], ans[i + 1]);\n\t}\n\tfor (i = 1; i <= len; i++)printf(\"%d\\n\", ans[i]);\n\treturn 0;\n}/**/\n/*#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nstruct edgee\n{\n\tint from, to;\n\tll cap,tempcap;\n\tedgee(int a, int b, ll c) :from(a), to(b), cap(c)\n\t{}\n\tedgee()\n\t{}\n};\nedgee edge[1010];\nint first[1010], nextt[1010];\nint edgetot = 0;\nint h[1010], num[1010],fa[1010],edgenum[1010];\nint tfirst[1010];\nbool isin[1010];\nvoid addedge(int from, int to, ll cap)\n{\n\tedge[edgetot] = edgee(from, to, cap);\n\tnextt[edgetot] = first[from];\n\tfirst[from] = edgetot++;\n\tedge[edgetot] = edgee(to, from, 0);\n\tnextt[edgetot] = first[to];\n\tfirst[to] = edgetot++;\n}\nint n, m, x;\nbool endd;\nvoid bfs(int t,int s)\n{\n\tfor (int i = 1; i <= n; i++)\n\t\th[i] = 1000000000;\n\th[t] = 0;\n\tnum[0] = 1;\n\tqueue<int>que;\n\tque.push(t);\n\twhile (!que.empty())\n\t{\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tfor (int i = first[now]; i != -1; i = nextt[i])\n\t\t{\n\t\t\tint to = edge[i].to;\n\t\t\tif (h[to] != 1000000000)\n\t\t\t\tcontinue;\n\t\t\th[to] =  h[now] + 1;\n\t\t\tnum[h[to]]++;\n\t\t\tque.push(to);\n\t\t}\n\t}\n}\nvoid augument(int t,ll &mincap)\n{\n\tfor (int i = fa[t]; i; i = fa[i])\n\t{\n\t\tedge[edgenum[i]].tempcap -= mincap;\n\t}\n}\nll isap(int s,int t)\n{\n\tint temp = s;\n\tll capp = 100000000000000000;\n\tll ans = 0;\n\twhile (h[s] <n)\n\t{\n\t\tint tempp = temp;\n\t\tif (temp == t)\n\t\t{\n\t\t\taugument(temp, capp);\n\t\t\tans += capp;\n\t\t\ttemp =s;\n\t\t\tcapp = 100000000000000000;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int &i = first[temp]; i != -1; i = nextt[i])\n\t\t{\n\t\t\tint to = edge[i].to;\n\t\t\tif (h[to] == h[temp] - 1 && edge[i].tempcap > 0)\n\t\t\t{\n\t\t\t\tfa[to] = temp;\n\t\t\t\tedgenum[temp] = i;\n\t\t\t\ttemp = to;\n\t\t\t\tcapp = min(capp, edge[i].tempcap);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (tempp != temp)\n\t\t\tcontinue;\n\t\tnum[h[temp]]--;\n\t\tif (num[h[temp]] == 0)\n\t\t\tbreak;\n\t\tint minh = 100000000;\n\t\tfor (int j = tfirst[temp]; j != -1; j = nextt[j])\n\t\t{\n\t\t\tint to = edge[j].to;\n\t\t\tif (edge[j].tempcap > 0)\n\t\t\t\tminh = min(minh, h[to]);\n\t\t}\n\t\tfirst[temp] = tfirst[temp];\n\t\tif (minh != 100000000)\n\t\t\th[temp] = minh;\n\t\telse\n\t\t\th[temp] = 100000000;\n\t\tnum[h[temp]]++;\n\t\tif (temp != s)\n\t\t\ttemp = fa[temp];\n\t}\n\treturn ans;\n}\nll solve(double k)\n{\n\tfor (int i = 0; i < edgetot; i++)\n\t\tedge[i].tempcap = (ll)(edge[i].cap / k);\n\tfor (int i = 1; i <= n; i++)\n\t\tfirst[i] = tfirst[i],fa[i]=0,edgenum[i]=0;\n\tll ans = 0;\n\tbfs(n, 1);\n\tans += isap(1, n);\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &x);\n\tfor (int i = 0; i <= n; i++)\n\t\tfirst[i] = -1;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\taddedge(a, b, c);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\ttfirst[i] = first[i];\n\tdouble l = 0, r = 1000000;\n\twhile (r - l < 1e-8)\n\t{\n\t\tdouble mid = (l + r) / 2;\n\t\tif (solve(mid)>=x)\n\t\t{\n\t\t\tl = mid;\n\t\t}\n\t\telse\n\t\t\tr = mid;\n\t}\n\tprintf(\"%lf\\n\", l*x);\n\treturn 0;\n}*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar s[2510][5010];\nint n;\nint m;\nint num[10],numtot,pos;\nint kind[30];\nvoid check(char *s1, char *s2)\n{\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (s1[i] != s2[i])\n\t\t\tnum[numtot++] = i;\n\t}\n}\nbool solve()\n{\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint erro = 0;\n\t\tint tnum[10];\n\t\tfor (int k = 0; k < 26; k++)\n\t\t\tkind[k] = 0;\n\t\tbool judge = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (s[i][j] != s[0][j])\n\t\t\t\ttnum[erro++] = j;\n\t\t\tkind[s[i][j] - 'a']++;\n\t\t\tif (kind[s[i][j] - 'a'] >= 2)\n\t\t\t\tjudge = 1;\n\t\t}\n\t\tif (erro == 0&&judge)\n\t\t\tcontinue;\n\t\tif (erro != 2)\n\t\t\treturn false;\n\t\telse\n\t\t{\n\t\t\terro--;\n\t\t\tif (s[i][tnum[erro]] != s[0][tnum[erro ^ 1]] || s[i][tnum[erro ^ 1]] != s[0][tnum[erro]])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%s\", s[i]);\n\t}\n\tbool judgee = 0;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tkind[s[0][i]-'a']++;\n\t\tif (kind[s[0][i]-'a'] >= 2)\n\t\t\tjudgee = 1;\n\t}\n\tif (n != 1)\n\t{\n\t\tfor (int i = 1; i < n&&numtot == 0; i++)\n\t\t{\n\t\t\tpos = i;\n\t\t\tcheck(s[0], s[i]);\n\t\t}\n\t\tif (numtot == 0 || numtot >= 2 && numtot <= 4)\n\t\t{\n\t\t\tif (numtot == 0)\n\t\t\t{\n\t\t\t\tswap(s[0][0], s[0][1]);\n\t\t\t\tprintf(\"%s\\n\", s[0]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (judgee&& solve())\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%s\\n\", s[0]);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < numtot; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = i + 1; j < numtot; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswap(s[0][num[i]], s[0][num[j]]);\n\t\t\t\t\t\t\tif (solve())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"%s\\n\", s[0]);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswap(s[0][num[i]], s[0][num[j]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(numtot!=2)\n\t\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (s[pos][num[i]] == s[0][j] && j != num[0] && j != num[1])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tswap(s[0][j], s[0][num[i]]);\n\t\t\t\t\t\t\t\t\tif (solve())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tprintf(\"%s\\n\", s[0]);\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tswap(s[0][j], s[0][num[i]]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\tprintf(\"-1\\n\");\n\t}\n\telse\n\t{\n\t\tswap(s[0][0], s[0][1]);\n\t\tprintf(\"%s\\n\", s[0]);\n\t}\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nchar str[200001];\n\nint main(){\n    int real,i,t,len;\n    cin>>len>>t;\n    scanf(\"%d.%s\",&real,str);\n    //cout<<real<<\" \"<<str<<endl;\n    \n    len = strlen(str);\n    for(i=0;i<len;i++)\n        if(str[i]>='5')\n            break;\n    for(;i!=len && i>0 && t;i--)\n        if(str[i]<'5')\n            break;\n        else{\n            str[i-1] += 1;\n            t--;\n        }\n    if(str[0]>='5')\n        cout<<real+1;\n    else{\n        cout<<real<<\".\";\n        len = i;\n        for(i=0;i<=len;i++)\n            cout<<str[i];\n    }\n    return 0;\n}\n\n",
        "fixed_code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nchar str[200001];\nchar real[200001];\nchar temp[200005];\n\nvoid inc(){\n    int i,len=strlen(real);\n  //  cout<<real<<\" \"<<len<<endl;\n    for(i=len-1;i>=0;i--){\n        if(real[i]=='9')\n            real[i] = '0';\n        else{\n            //cout<<str[i]<< \" \"<<(str[i] + 1)<<endl;\n            real[i] += 1;\n            break;\n        }\n    }\n   if(i==-1)\n       cout<<\"1\";\n\n   cout<<real;\n}\n\nint main(){\n    int i,t,len;\n    cin>>len>>t;\n    scanf(\"%s\",temp);\n    len = strlen(temp);\n    int comma;\n    for(i=0;i<len;i++)\n        if(temp[i]=='.'){\n            break;\n        }\n        else\n            real[i]=temp[i];\n    comma = ++i;\n    //cout<<\"comma \" <<comma<<\" len:\"<<len<<endl;\n    for(;i<len;i++)\n        str[i-comma] = temp[i];\n    //cout<<real<<\" \"<<str<<endl;\n    \n    len = strlen(str);\n    for(i=0;i<len;i++)\n        if(str[i]>='5')\n            break;\n    for(;i!=len && i>0 && t;i--)\n        if(str[i]<'5')\n            break;\n        else{\n            str[i-1] += 1;\n            t--;\n        }\n    if(str[0]>='5'&&t)\n        inc();\n    else if(i!=len){\n        cout<<real<<\".\";\n        len = i;\n        for(i=0;i<=len;i++)\n            cout<<str[i];\n    }\n    else\n        cout<<real<<\".\"<<str;\n    return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 8;\n\nstruct data\n{\n    int s, f;\n    ll c;\n};\n\nll l[N], r[N], nl[N], nr[N];\nll Min[N];\nvector<data> day[N];\nint trv[N];\n\nint main()\n{\n    //freopen(\".inp\", \"r\", stdin);\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n    int M = 0;\n    for (int i = 1; i <= m; i++)\n    {\n        int d;\n        data p;\n        scanf(\"%d %d %d %d\", &d, &p.s, &p.f, &p.c);\n        M = max(M, d);\n        day[d].push_back(p);\n    }\n    ll res = 1e18;\n    for (int i = 1; i <= M; i++)\n    {\n        for (int ii = 0; ii < day[i].size(); ii++)\n        {\n            data p = day[i][ii];\n            if (p.s != 0)\n            {\n                if (trv[p.s] != 1)\n                {\n                    trv[p.s] = 1;\n                    nl[i]++;\n                    l[i] += p.c;\n                    Min[p.s] = p.c;\n                }\n                else\n                {\n                    if (Min[p.s] > p.c)\n                    {\n                        l[i] += p.c - Min[p.s];\n                        Min[p.s] = p.c;\n                    }\n                }\n            }\n        }\n        l[i] += l[i - 1];\n        nl[i] += nl[i - 1];\n    }\n    for (int i = M; i >= 1; i--)\n    {\n        for (int ii = 0; ii < day[i].size(); ii++)\n        {\n            data p = day[i][ii];\n            if (p.s == 0)\n            {\n                if (trv[p.f] != 2)\n                {\n                    trv[p.f] = 2;\n                    nr[i]++;\n                    r[i] += p.c;\n                    Min[p.f] = p.c;\n                }\n                else\n                {\n                    if (Min[p.f] > p.c)\n                    {\n                        r[i] += p.c - Min[p.f];\n                        Min[p.f] = p.c;\n                    }\n                }\n            }\n        }\n        r[i] += r[i + 1];\n        nr[i] += nr[i + 1];\n    }\n    for (int i = 1; i <= M; i++)\n    {\n        if (i + k + 1 > M) break;\n        if (nl[i] == nr[i + k + 1] and nl[i] == n)\n        {\n            res = min(res, l[i] + r[i + k + 1]);\n        }\n    }\n    if (res < 1e18) cout << res;\n    else cout << -1;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 8;\n\nstruct data\n{\n    int s, f;\n    ll c;\n};\n\nll l[N], r[N], nl[N], nr[N];\nll Min[N];\nvector<data> day[N];\nint trv[N];\n\nint main()\n{\n    //freopen(\".inp\", \"r\", stdin);\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n    int M = 0;\n    for (int i = 1; i <= m; i++)\n    {\n        int d;\n        data p;\n        scanf(\"%d %d %d %lld\", &d, &p.s, &p.f, &p.c);\n        M = max(M, d);\n        day[d].push_back(p);\n    }\n    ll res = 1e18;\n    for (int i = 1; i <= M; i++)\n    {\n        for (int ii = 0; ii < day[i].size(); ii++)\n        {\n            data p = day[i][ii];\n            if (p.s != 0)\n            {\n                if (trv[p.s] != 1)\n                {\n                    trv[p.s] = 1;\n                    nl[i]++;\n                    l[i] += p.c;\n                    Min[p.s] = p.c;\n                }\n                else\n                {\n                    if (Min[p.s] > p.c)\n                    {\n                        l[i] += p.c - Min[p.s];\n                        Min[p.s] = p.c;\n                    }\n                }\n            }\n        }\n        l[i] += l[i - 1];\n        nl[i] += nl[i - 1];\n    }\n    for (int i = M; i >= 1; i--)\n    {\n        for (int ii = 0; ii < day[i].size(); ii++)\n        {\n            data p = day[i][ii];\n            if (p.s == 0)\n            {\n                if (trv[p.f] != 2)\n                {\n                    trv[p.f] = 2;\n                    nr[i]++;\n                    r[i] += p.c;\n                    Min[p.f] = p.c;\n                }\n                else\n                {\n                    if (Min[p.f] > p.c)\n                    {\n                        r[i] += p.c - Min[p.f];\n                        Min[p.f] = p.c;\n                    }\n                }\n            }\n        }\n        r[i] += r[i + 1];\n        nr[i] += nr[i + 1];\n    }\n    for (int i = 1; i <= M; i++)\n    {\n        if (i + k + 1 > M) break;\n        if (nl[i] == nr[i + k + 1] and nl[i] == n)\n        {\n            res = min(res, l[i] + r[i + k + 1]);\n        }\n    }\n    if (res < 1e18) cout << res;\n    else cout << -1;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private java.lang.String createWorkflowStepForDetachMirror(com.emc.storageos.workflow.Workflow workflow, com.emc.storageos.db.client.model.StorageSystem vplexSystem, com.emc.storageos.db.client.model.Volume vplexVolume, java.net.URI mirrorVolumeURI, java.lang.String stepId, java.lang.String waitFor, com.emc.storageos.workflow.Workflow.Method rollbackMethod) {\n    java.net.URI vplexURI = vplexSystem.getId();\n    java.net.URI vplexVolumeURI = vplexVolume.getId();\n    com.emc.storageos.workflow.Workflow.Method detachMirrorMethod = createDetachMirrorMethod(vplexURI, vplexVolumeURI, mirrorVolumeURI, vplexVolume.getConsistencyGroup());\n    workflow.createStep(com.emc.storageos.vplexcontroller.VPlexDeviceController.DETACH_MIRROR_STEP, java.lang.String.format(\"Detach mirror %s for VPLEX volume %s on system %s\", mirrorVolumeURI, vplexVolumeURI, vplexURI), waitFor, vplexURI, vplexSystem.getSystemType(), this.getClass(), detachMirrorMethod, rollbackMethod, stepId);\n    com.emc.storageos.vplexcontroller.VPlexDeviceController._log.info(\"Created workflow step to detach mirror {} from volume {}\", mirrorVolumeURI, vplexVolumeURI);\n    return com.emc.storageos.vplexcontroller.VPlexDeviceController.DETACH_MIRROR_STEP;\n}",
        "fixed_code": "private java.lang.String createWorkflowStepForDetachMirror(com.emc.storageos.workflow.Workflow workflow, com.emc.storageos.db.client.model.StorageSystem vplexSystem, com.emc.storageos.db.client.model.Volume vplexVolume, java.net.URI mirrorVolumeURI, java.lang.String stepId, java.lang.String waitFor, com.emc.storageos.workflow.Workflow.Method rollbackMethod) {\n    java.net.URI vplexURI = vplexSystem.getId();\n    java.net.URI vplexVolumeURI = vplexVolume.getId();\n    com.emc.storageos.workflow.Workflow.Method detachMirrorMethod = createDetachMirrorMethod(vplexURI, vplexVolumeURI, mirrorVolumeURI, vplexVolume.getConsistencyGroup());\n    workflow.createStep(com.emc.storageos.vplexcontroller.VPlexDeviceController.DETACH_MIRROR_STEP, java.lang.String.format(\"Detach mirror %s for VPLEX volume %s on system %s\", mirrorVolumeURI, vplexVolumeURI, vplexURI), waitFor, vplexURI, vplexSystem.getSystemType(), this.getClass(), detachMirrorMethod, rollbackMethod, stepId);\n    com.emc.storageos.vplexcontroller.VPlexDeviceController._log.info(\"Created workflow step to detach mirror {} from volume {}\", mirrorVolumeURI, vplexVolumeURI);\n    return com.emc.storageos.vplexcontroller.VPlexDeviceController.DETACH_MIRROR_STEP;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@java.lang.Override\nprotected void onPostExecute(java.lang.Boolean aBoolean) {\n    super.onPostExecute(aBoolean);\n    if (aBoolean) {\n        android.widget.Toast.makeText(mContext, \"Committed successfully.\", Toast.LENGTH_SHORT).show();\n    }else {\n        android.widget.Toast.makeText(mContext, \"Unable to commit files.\", Toast.LENGTH_SHORT).show();\n    }\n}",
        "fixed_code": "@java.lang.Override\nprotected java.lang.Boolean doInBackground(java.lang.String... strings) {\n    try {\n        org.eclipse.jgit.api.Git git = org.eclipse.jgit.api.Git.open(mRepo);\n        git.commit().setMessage(strings[0]).call();\n    } catch (org.eclipse.jgit.api.errors.GitAPIException e) {\n        android.util.Log.e(io.geeteshk.hyper.util.GitUtil.TAG, e.toString());\n        android.widget.Toast.makeText(mContext, e.getMessage(), Toast.LENGTH_LONG).show();\n        return false;\n    } catch (java.io.IOException e) {\n        android.util.Log.e(io.geeteshk.hyper.util.GitUtil.TAG, e.getMessage());\n        android.widget.Toast.makeText(mContext, e.getMessage(), Toast.LENGTH_LONG).show();\n        return false;\n    }\n    return true;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "t = int(input())\nfor case in range(t):\n    n, p, k = [int(x) for x in input().split(' ')]\n    a = input()\n    x, y = [int(s) for s in input().split(' ')]\n    m = float('inf')\n    a_dict = {}\n    for i in range(n):\n        if i >= p - 1 and a[i] == '1':\n            if (i - (p - 1)) % k in a_dict:\n                a_dict[(i - (p - 1)) % k] += 1\n            else:\n                a_dict[(i - (p - 1)) % k] = 1\n\n    for i in range(n - p + 1):\n        if i in a_dict:\n            z = a_dict[i % k]\n        else:\n            z = 0\n        cost = i * y + (1 + (n - p - i) // k - z) * x\n        m = min(m, cost)\n        if (i % k) in a_dict and a[p + i - 1] == '1':\n            a_dict[i % k] -= 1\n    print(m)\n",
        "fixed_code": "t = int(input())\n\nfor case in range(t):\n    n, p, k = [int(x) for x in input().split(' ')]\n    a = input()\n    x, y = [int(s) for s in input().split(' ')]\n    m = float('inf')\n    a_dict = {}\n    for i in range(n):\n        if i >= p - 1 and a[i] == '1':\n            if (i - (p - 1)) % k in a_dict:\n                a_dict[(i - (p - 1)) % k] += 1\n            else:\n                a_dict[(i - (p - 1)) % k] = 1\n\n    for i in range(n - p + 1):\n        if i % k in a_dict:\n            z = a_dict[i % k]\n        else:\n            z = 0\n        #print(a_dict, 1 + (n - p - i) // k, i % k , z)\n        cost = i * y + (1 + (n - p - i) // k - z) * x\n        m = min(m, cost)\n        if (i % k) in a_dict and a[p + i - 1] == '1':\n            a_dict[i % k] -= 1\n    print(m)\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=200;\nconst int mod=998244353;\nint primes[N],tot;\nint p[20000];\nint inv[20000];\nint cnt[100000];\nll gcd(ll a,ll b){\n    return b==0?a:gcd(b,a%b);\n}\nint C(int n,int m)\n{\n    if(m>n)return 0;\n    return ((ll)p[n]*inv[m]%mod*inv[n-m])%mod;\n}\nint qmi(int a,int b=mod-2)\n{\n    int ans=1;\n    while(b){\n        if(b&1)ans=(ll)ans*a%mod;\n        a=(ll)a*a%mod;\n        b>>=1;\n    }return ans;\n}\nint get_ans(ll k)\n{\n    tot=0;\n    for(ll i=2;i<=k/i;i++)\n    {\n        if(k%i==0){\n            int num=0;\n            while(k%i==0){\n                num++;\n                k/=i;\n            }\n            cnt[++tot]=num;\n        }\n    }\n    if(k>1){\n        cnt[++tot]=1;\n    }\n    int sum=0;\n    for(int i=1;i<=tot;i++)sum+=cnt[i];\n    ll ans=1;\n    for(int i=1;i<=tot;i++)\n    {\n        ans=(ans*C(sum,cnt[i]))%mod;\n        sum-=cnt[i];\n    }\n    return ans;\n}\nint main()\n{\n    ll d;\n    cin>>d;\n    int T;\n    cin>>T;\n    inv[0]=1;\n    p[0]=1;\n    for(int i=1;i<=199;i++)\n    {\n        p[i]=(ll)p[i-1]*i%mod;\n        inv[i]=(ll)inv[i-1]*qmi(i)%mod;\n    }\n    while(T--)\n    {\n        ll u,v;\n        scanf(\"%lld%lld\",&u,&v);\n        if(u>v)swap(u,v);\n        ll t=gcd(u,v);\n        ll  ans=(ll)get_ans(u/t)*get_ans(v/t)%mod;\n        printf(\"%lld\\n\",ans);\n    }\n}",
        "fixed_code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=200;\nconst int mod=998244353;\nll prime[N],tot;\nint inp[20000];\nint inv[20000];\nll gcd(ll a,ll b){\n    return b==0?a:gcd(b,a%b);\n}\n\nint qmi(int a,int b=mod-2)\n{\n    int ans=1;\n    while(b){\n        if(b&1)ans=(ll)ans*a%mod;\n        a=(ll)a*a%mod;\n        b>>=1;\n    }return ans;\n}\nint get_ans(ll u,ll v)\n{\n    int s=0;\n    ll f=1;\n    for(int i=1;i<=tot;i++){\n        int p=0,q=0;\n        while(u%prime[i]==0)u/=prime[i],p++;\n        while(v%prime[i]==0)v/=prime[i],q++;\n        f=(f*inv[abs(p-q)])%mod;\n        s+=abs(p-q);\n    }\n    f=(f*inp[s])%mod;\n    return f;\n}\nint main()\n{\n    ll d;\n    cin>>d;\n    int T;\n    cin>>T;\n    for(ll i=2;i<=d/i;i++)\n    {\n        if(d%i==0){\n            int num=0;\n            while(d%i==0){\n                num++;d/=i;\n            }\n            prime[++tot]=i;\n        }\n    }\n    if(d>1){\n        prime[++tot]=d;\n    }\n    // for(int i=1;i<=tot;i++)cout<<prime[i]<<' ';\n    // cout<<endl;\n    inv[0]=1,inp[0]=1;\n    for(int i=1;i<1000;i++){\n        inv[i]=(ll)inv[i-1]*qmi(i)%mod;\n        inp[i]=(ll)inp[i-1]*i%mod;\n    }\n    while(T--)\n    {\n        ll u,v;\n        scanf(\"%lld%lld\",&u,&v);\n        if(u>v)swap(u,v);\n        ll t=gcd(u,v);\n        ll  ans=(ll)get_ans(u,t)*get_ans(v,t)%mod;\n        printf(\"%lld\\n\",ans);\n    }\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint c=0;\nint bs(int l,int h,int a,int arr[])\n{\n    if(l>h) return c;\n    int m=(l+h)/2;\n    if(arr[m]<=a)\n    {\n        c=m+1;\n        bs(m+1,h,a,arr);\n    }\n    else\n    {\n        bs(l,h-1,a,arr);\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n,q,a,arr[100005],i,l=0,h,ar[100005],k=-1;\n    cin>>n;\n    h=n-1;\n    for(i=0;i<n;i++)\n        cin>>arr[i];\n    sort(arr,arr+n);\n    cin>>q;\n    for(i=0;i<q;i++)\n    {\n        cin>>a;\n        c=0;\n        int r=bs(l,h,a,arr);\n        ar[++k]=r;\n    }\n    for(i=0;i<=k;i++)\n        cout<<ar[i]<<endl;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nint c=0;\nint bs(int l,int h,int a,int arr[])\n{\n    while(l<=h)\n    {\n        int m=(l+h)/2;\n        if(arr[m]<=a)\n        {\n            c=m+1;\n            l=m+1;\n        }\n        else\n        {\n            h=m-1;\n        }\n    }\n    return c;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n,q,a,arr[100005],i,l=0,h,ar[100005],k=-1;\n    cin>>n;\n    h=n-1;\n    for(i=0; i<n; i++)\n        cin>>arr[i];\n    sort(arr,arr+n);\n    cin>>q;\n    for(i=0; i<q; i++)\n    {\n        cin>>a;\n        c=0;\n        int r=bs(l,h,a,arr);\n        ar[++k]=r;\n    }\n    for(i=0; i<=k; i++)\n        cout<<ar[i]<<endl;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\nchar a[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'} , b[26];\nint p[26] , z=0;\nint main()\n{\n    int x=0 , m=0 , c=0;\n    string s,t;\n    cin>>s>>t;\n    for (int i=0 ; i<s.size() ; i++)\n    {\n        m=0;\n        for (int g=0 ; g<z ; g++)\n        {\n            if (s[i]==b[p[g]] || t[i]==b[p[g]])\n            {\n                m=1;\n                if (s[i]==b[p[g]]) s[i]=a[p[g]];\n                else s[i]=b[p[g]];\n            }\n        }\n        if (m==0)\n        {\n            for (int j=0 ; j<26 ; j++)\n                    {\n                        if (s[i]==a[j])\n                            {\n                                b[j]=t[i];\n                                s[i]=t[i];\n                                p[z]=j;\n                                z++;\n                                break;\n                            }\n                    }\n        }\n            if (s[i]!=t[i])\n            {\n                x=1;\n                break;\n            }\n    }\n    if (x==1) cout <<-1<<endl;\n    else\n    {\n        for (int i=0 ; i<z ; i++)\n        {\n                if (b[p[i]]!=a[p[i]])\n                    c++;\n        }\n        cout <<c<<endl;\n        for (int i=0 ; i<z ; i++)\n        {\n            if (b[p[i]]!=a[p[i]]) cout <<a[p[i]]<<' '<<b[p[i]]<<endl;\n        }\n    }\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\nchar a[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'} , b[26];\nint p[26] , z=0;\nint main()\n{\n    int x=0 , m=0 , c=0;\n    string s,t;\n    cin>>s>>t;\n    for (int i=0 ; i<s.size() ; i++)\n    {\n        m=0;\n        for (int g=0 ; g<z ; g++)\n        {\n            if (s[i]==b[p[g]] || t[i]==b[p[g]] || s[i]==a[p[g]] || t[i]==a[p[g]])\n            {\n                m=1;\n                if (s[i]==b[p[g]]) s[i]=a[p[g]];\n                else {if (s[i]==a[p[g]]) s[i]=b[p[g]];\n                else {if (t[i]==b[p[g]]) t[i]=a[p[g]];\n                else if (t[i]==a[p[g]]) t[i]=b[p[g]];}}\n            }\n        }\n        if (m==0)\n        {\n            for (int j=0 ; j<26 ; j++)\n                    {\n                        if (s[i]==a[j])\n                            {\n                                b[j]=t[i];\n                                s[i]=t[i];\n                                p[z]=j;\n                                z++;\n                                break;\n                            }\n                    }\n        }\n            if (s[i]!=t[i])\n            {\n                x=1;\n                break;\n            }\n    }\n    if (x==1) cout <<-1<<endl;\n    else\n    {\n        for (int i=0 ; i<z ; i++)\n        {\n                if (b[p[i]]!=a[p[i]])\n                    c++;\n        }\n        cout <<c<<endl;\n        for (int i=0 ; i<z ; i++)\n        {\n            if (b[p[i]]!=a[p[i]]) cout <<a[p[i]]<<' '<<b[p[i]]<<endl;\n        }\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n\tchar x=getchar();int ans=0;\n\twhile(!isdigit(x)) x=getchar();\n\twhile(isdigit(x)) ans=ans*10+x-'0',x=getchar();\n\treturn ans;\n}\nint n,m;\nchar a[65][65];\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\ta[i][j]=getchar();\n\t\t\t\twhile(!isalpha(a[i][j])) a[i][j]=getchar();\n\t\t\t}\n\t\tint cnt=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\tif (a[i][j]=='A') cnt++;\n\t\tif (!cnt)\n\t\t{\n\t\t\tputs(\"MORTAL\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt==n*m)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tint flag1=0;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tif (a[1][i]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tif (a[n][i]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i][1]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i][m]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tbool FLAG=0;\n\t\tif (a[1][1]=='A'||a[1][m]=='A'||a[n][1]=='A'||a[n][m]=='A')\n\t\t{\n\t\t\tputs(\"2\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (FLAG) continue;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tbool flag=1;\n\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif (a[i][j]=='P')\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tputs(\"2\");\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (FLAG) continue;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tbool flag=1;\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i]=='P')\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tputs(\"2\");\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (FLAG) continue;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i][1]=='A'||a[i][m]=='A')\n\t\t\t{\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tif (a[1][i]=='A'||a[n][i]=='A')\n\t\t\t{\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (FLAG) puts(\"3\");\n\t\telse puts(\"4\");\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n\tchar x=getchar();int ans=0;\n\twhile(!isdigit(x)) x=getchar();\n\twhile(isdigit(x)) ans=ans*10+x-'0',x=getchar();\n\treturn ans;\n}\nint n,m;\nchar a[65][65];\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\ta[i][j]=getchar();\n\t\t\t\twhile(!isalpha(a[i][j])) a[i][j]=getchar();\n\t\t\t}\n\t\tint cnt=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\tif (a[i][j]=='A') cnt++;\n\t\tif (!cnt)\n\t\t{\n\t\t\tputs(\"MORTAL\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt==n*m)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tint flag1=0;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tif (a[1][i]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tflag1=0;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tif (a[n][i]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tflag1=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i][1]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tflag1=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i][m]!='A')\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tflag1=0;\n\t\tbool FLAG=0;\n\t\tif (a[1][1]=='A'||a[1][m]=='A'||a[n][1]=='A'||a[n][m]=='A')\n\t\t{\n\t\t\tputs(\"2\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (FLAG) continue;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tbool flag=1;\n\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif (a[i][j]=='P')\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tputs(\"2\");\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (FLAG) continue;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tbool flag=1;\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i]=='P')\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tputs(\"2\");\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (FLAG) continue;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i][1]=='A'||a[i][m]=='A')\n\t\t\t{\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tif (a[1][i]=='A'||a[n][i]=='A')\n\t\t\t{\n\t\t\t\tFLAG=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (FLAG) puts(\"3\");\n\t\telse puts(\"4\");\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private static int call3(double lat, double lng) {\n    if (lat < (-14.993814))\n        if (lng < (-64.158066))\n            if (lng < (-68.814156))\n                if (lat < (-23.428734))\n                    return 31;\n                else\n                    if (lat < (-16.337534))\n                        if (lat < (-19.883134))\n                            return 31;\n                        else\n                            if (lng < (-71.069149))\n                                return 164;\n                            else\n                                if (lat < (-18.110334)) {\n                                    if (TimezoneMapper.poly[262].contains(lat, lng))\n                                        return 164;\n                                    \n                                    if (TimezoneMapper.poly[263].contains(lat, lng))\n                                        return 190;\n                                    else\n                                        return 31;\n                                    \n                                }else {\n                                    if (TimezoneMapper.poly[264].contains(lat, lng))\n                                        return 31;\n                                    \n                                    if (TimezoneMapper.poly[265].contains(lat, lng))\n                                        return 190;\n                                    else\n                                        return 164;\n                                    \n                                }\n                            \n                        \n                    else {\n                        if (TimezoneMapper.poly[266].contains(lat, lng))\n                            return 190;\n                        else\n                            return 164;\n                        \n                    }\n                \n            else\n                if (lat < (-20.06183))\n                    if (lat < (-22.595838))\n                        if (lng < (-66.486111)) {\n                            if (TimezoneMapper.poly[267].contains(lat, lng))\n                                return 31;\n                            \n                            if (TimezoneMapper.poly[268].contains(lat, lng))\n                                return 159;\n                            \n                            if (TimezoneMapper.poly[269].contains(lat, lng))\n                                return 190;\n                            else\n                                return 127;\n                            \n                        }else\n                            if (lat < (-23.862842)) {\n                                if (TimezoneMapper.poly[270].contains(lat, lng))\n                                    return 159;\n                                \n                                if (TimezoneMapper.poly[271].contains(lat, lng))\n                                    return 159;\n                                else\n                                    return 127;\n                                \n                            }else {\n                                if (TimezoneMapper.poly[272].contains(lat, lng))\n                                    return 159;\n                                \n                                if (TimezoneMapper.poly[273].contains(lat, lng))\n                                    return 190;\n                                else\n                                    return 127;\n                                \n                            }\n                        \n                    else\n                        if (lng < (-66.486111)) {\n                            if (TimezoneMapper.poly[274].contains(lat, lng))\n                                return 31;\n                            \n                            if (TimezoneMapper.poly[275].contains(lat, lng))\n                                return 159;\n                            else\n                                return 190;\n                            \n                        }else {\n                            if (TimezoneMapper.poly[276].contains(lat, lng))\n                                return 127;\n                            \n                            if (TimezoneMapper.poly[277].contains(lat, lng))\n                                return 127;\n                            \n                            if (TimezoneMapper.poly[278].contains(lat, lng))\n                                return 159;\n                            else\n                                return 190;\n                            \n                        }\n                    \n                else {\n                    if (TimezoneMapper.poly[279].contains(lat, lng))\n                        return 31;\n                    else\n                        return 190;\n                    \n                }\n            \n        else\n            if (lat < (-19.294041))\n                if (lng < (-59.983578))\n                    if (lat < (-22.211944))\n                        if (lng < (-62.070822)) {\n                            if (TimezoneMapper.poly[280].contains(lat, lng))\n                                return 127;\n                            \n                            if (TimezoneMapper.poly[281].contains(lat, lng))\n                                return 190;\n                            \n                            if (TimezoneMapper.poly[282].contains(lat, lng))\n                                return 190;\n                            \n                            if (TimezoneMapper.poly[283].contains(lat, lng))\n                                return 278;\n                            else\n                                return 219;\n                            \n                        }else {\n                            if (TimezoneMapper.poly[284].contains(lat, lng))\n                                return 278;\n                            else\n                                return 219;\n                            \n                        }\n                    else {\n                        if (TimezoneMapper.poly[285].contains(lat, lng))\n                            return 127;\n                        \n                        if (TimezoneMapper.poly[286].contains(lat, lng))\n                            return 219;\n                        else\n                            return 190;\n                        \n                    }\n                else\n                    if (lng < (-55.679382))\n                        if (lat < (-22.211944))\n                            if (lng < (-57.83148)) {\n                                if (TimezoneMapper.poly[287].contains(lat, lng))\n                                    return 278;\n                                else\n                                    return 219;\n                                \n                            }else {\n                                if (TimezoneMapper.poly[288].contains(lat, lng))\n                                    return 317;\n                                \n                                if (TimezoneMapper.poly[289].contains(lat, lng))\n                                    return 317;\n                                \n                                if (TimezoneMapper.poly[290].contains(lat, lng))\n                                    return 317;\n                                \n                                if (TimezoneMapper.poly[291].contains(lat, lng))\n                                    return 317;\n                                else\n                                    return 219;\n                                \n                            }\n                        else\n                            if (lng < (-57.83148))\n                                if (lat < (-20.752992)) {\n                                    if (TimezoneMapper.poly[292].contains(lat, lng))\n                                        return 317;\n                                    \n                                    if (TimezoneMapper.poly[293].contains(lat, lng))\n                                        return 317;\n                                    else\n                                        return 219;\n                                    \n                                }else {\n                                    if (TimezoneMapper.poly[294].contains(lat, lng))\n                                        return 190;\n                                    \n                                    if (TimezoneMapper.poly[295].contains(lat, lng))\n                                        return 219;\n                                    else\n                                        return 317;\n                                    \n                                }\n                            else {\n                                if (TimezoneMapper.poly[296].contains(lat, lng))\n                                    return 219;\n                                \n                                if (TimezoneMapper.poly[297].contains(lat, lng))\n                                    return 219;\n                                \n                                if (TimezoneMapper.poly[298].contains(lat, lng))\n                                    return 219;\n                                \n                                if (TimezoneMapper.poly[299].contains(lat, lng))\n                                    return 219;\n                                else\n                                    return 317;\n                                \n                            }\n                        \n                    else\n                        if (lat < (-22.211944))\n                            if (lng < (-53.527285))\n                                if (lat < (-23.670895)) {\n                                    if (TimezoneMapper.poly[300].contains(lat, lng))\n                                        return 317;\n                                    \n                                    if (TimezoneMapper.poly[301].contains(lat, lng))\n                                        return 329;\n                                    else\n                                        return 219;\n                                    \n                                }else {\n                                    if (TimezoneMapper.poly[302].contains(lat, lng))\n                                        return 219;\n                                    \n                                    if (TimezoneMapper.poly[303].contains(lat, lng))\n                                        return 219;\n                                    \n                                    if (TimezoneMapper.poly[304].contains(lat, lng))\n                                        return 329;\n                                    else\n                                        return 317;\n                                    \n                                }\n                            else {\n                                if (TimezoneMapper.poly[305].contains(lat, lng))\n                                    return 317;\n                                else\n                                    return 329;\n                                \n                            }\n                        else {\n                            if (TimezoneMapper.poly[306].contains(lat, lng))\n                                return 329;\n                            else\n                                return 317;\n                            \n                        }\n                    \n                \n            else\n                if (lng < (-57.766626)) {\n                    if (TimezoneMapper.poly[307].contains(lat, lng))\n                        return 317;\n                    \n                    if (TimezoneMapper.poly[308].contains(lat, lng))\n                        return 317;\n                    \n                    if (TimezoneMapper.poly[309].contains(lat, lng))\n                        return 363;\n                    else\n                        return 190;\n                    \n                }else\n                    if (lng < (-54.570907))\n                        if (lat < (-17.143927))\n                            if (lng < (-56.168766)) {\n                                if (TimezoneMapper.poly[310].contains(lat, lng))\n                                    return 190;\n                                \n                                if (TimezoneMapper.poly[311].contains(lat, lng))\n                                    return 190;\n                                \n                                if (TimezoneMapper.poly[312].contains(lat, lng))\n                                    return 363;\n                                else\n                                    return 317;\n                                \n                            }else {\n                                if (TimezoneMapper.poly[313].contains(lat, lng))\n                                    return 363;\n                                else\n                                    return 317;\n                                \n                            }\n                        else\n                            return 363;\n                        \n                    else\n                        if (lat < (-17.143927))\n                            if (lng < (-52.973047)) {\n                                if (TimezoneMapper.poly[314].contains(lat, lng))\n                                    return 329;\n                                \n                                if (TimezoneMapper.poly[315].contains(lat, lng))\n                                    return 363;\n                                else\n                                    return 317;\n                                \n                            }else {\n                                if (TimezoneMapper.poly[316].contains(lat, lng))\n                                    return 329;\n                                else\n                                    return 317;\n                                \n                            }\n                        else {\n                            if (TimezoneMapper.poly[317].contains(lat, lng))\n                                return 329;\n                            else\n                                return 363;\n                            \n                        }\n                    \n                \n            \n        \n    else\n        if (lng < (-56.305687))\n            return TimezoneMapper.call2(lat, lng);\n        else\n            if (lat < (-0.409487))\n                if (lat < (-7.701651)) {\n                    if (TimezoneMapper.poly[318].contains(lat, lng))\n                        return 363;\n                    \n                    if (TimezoneMapper.poly[319].contains(lat, lng))\n                        return 400;\n                    else\n                        return 310;\n                    \n                }else\n                    if (lat < (-4.055569)) {\n                        if (TimezoneMapper.poly[320].contains(lat, lng))\n                            return 400;\n                        else\n                            return 310;\n                        \n                    }else\n                        if (lng < (-53.840437))\n                            return 310;\n                        else\n                            if (lat < (-2.232528)) {\n                                if (TimezoneMapper.poly[321].contains(lat, lng))\n                                    return 400;\n                                else\n                                    return 310;\n                                \n                            }else {\n                                if (TimezoneMapper.poly[322].contains(lat, lng))\n                                    return 310;\n                                else\n                                    return 400;\n                                \n                            }\n                        \n                    \n                \n            else\n                if (lat < 2.797529)\n                    if (lng < (-53.840437))\n                        if (lat < 1.194021)\n                            return 310;\n                        else\n                            if (lng < (-55.073062)) {\n                                if (TimezoneMapper.poly[323].contains(lat, lng))\n                                    return 310;\n                                else\n                                    return 200;\n                                \n                            }else\n                                if (lat < 1.995775) {\n                                    if (TimezoneMapper.poly[324].contains(lat, lng))\n                                        return 400;\n                                    else\n                                        return 310;\n                                    \n                                }else\n                                    if (lng < (-54.456749)) {\n                                        if (TimezoneMapper.poly[325].contains(lat, lng))\n                                            return 200;\n                                        \n                                        if (TimezoneMapper.poly[326].contains(lat, lng))\n                                            return 310;\n                                        \n                                        if (TimezoneMapper.poly[327].contains(lat, lng))\n                                            return 362;\n                                        else\n                                            return 400;\n                                        \n                                    }else {\n                                        if (TimezoneMapper.poly[328].contains(lat, lng))\n                                            return 200;\n                                        \n                                        if (TimezoneMapper.poly[329].contains(lat, lng))\n                                            return 400;\n                                        else\n                                            return 362;\n                                        \n                                    }\n                                \n                            \n                        \n                    else\n                        if (lat < 1.194021) {\n                            if (TimezoneMapper.poly[330].contains(lat, lng))\n                                return 310;\n                            else\n                                return 400;\n                            \n                        }else {\n                            if (TimezoneMapper.poly[331].contains(lat, lng))\n                                return 310;\n                            \n                            if (TimezoneMapper.poly[332].contains(lat, lng))\n                                return 362;\n                            else\n                                return 400;\n                            \n                        }\n                    \n                else\n                    if (lng < (-53.840437)) {\n                        if (TimezoneMapper.poly[333].contains(lat, lng))\n                            return 362;\n                        else\n                            return 200;\n                        \n                    }else {\n                        if (TimezoneMapper.poly[334].contains(lat, lng))\n                            return 400;\n                        else\n                            return 362;\n                        \n                    }\n                \n            \n        \n    \n}",
        "fixed_code": "private static int call1(float lat, float lng) {\n    if (lat < (-17.507553F))\n        if (lng < (-69.46265F))\n            if (lat < (-23.428734F))\n                return 31;\n            else {\n                if (TimezoneMapper.poly[88].contains(lat, lng))\n                    return 164;\n                else\n                    return 31;\n                \n            }\n        else\n            if (lat < (-21.418823F))\n                if (lng < (-66.810356F))\n                    if (lat < (-23.374458F)) {\n                        if (TimezoneMapper.poly[89].contains(lat, lng))\n                            return 31;\n                        \n                        if (TimezoneMapper.poly[90].contains(lat, lng))\n                            return 88;\n                        \n                        if (TimezoneMapper.poly[91].contains(lat, lng))\n                            return 159;\n                        else\n                            return 127;\n                        \n                    }else {\n                        if (TimezoneMapper.poly[92].contains(lat, lng))\n                            return 31;\n                        \n                        if (TimezoneMapper.poly[93].contains(lat, lng))\n                            return 159;\n                        else\n                            return 190;\n                        \n                    }\n                else\n                    if (lat < (-23.374458F))\n                        if (lng < (-65.484215F)) {\n                            if (TimezoneMapper.poly[94].contains(lat, lng))\n                                return 88;\n                            \n                            if (TimezoneMapper.poly[95].contains(lat, lng))\n                                return 159;\n                            \n                            if (TimezoneMapper.poly[96].contains(lat, lng))\n                                return 159;\n                            else\n                                return 127;\n                            \n                        }else {\n                            if (TimezoneMapper.poly[97].contains(lat, lng))\n                                return 159;\n                            else\n                                return 127;\n                            \n                        }\n                    else\n                        if (lng < (-65.484215F)) {\n                            if (TimezoneMapper.poly[98].contains(lat, lng))\n                                return 127;\n                            \n                            if (TimezoneMapper.poly[99].contains(lat, lng))\n                                return 190;\n                            else\n                                return 159;\n                            \n                        }else {\n                            if (TimezoneMapper.poly[100].contains(lat, lng))\n                                return 159;\n                            \n                            if (TimezoneMapper.poly[101].contains(lat, lng))\n                                return 190;\n                            else\n                                return 127;\n                            \n                        }\n                    \n                \n            else {\n                if (TimezoneMapper.poly[102].contains(lat, lng))\n                    return 190;\n                else\n                    return 31;\n                \n            }\n        \n    else\n        if (lat < 0.601751F)\n            if (lat < (-8.452901F))\n                if (lng < (-69.671326F))\n                    if (lat < (-12.980227F))\n                        return 164;\n                    else\n                        if (lng < (-72.427956F)) {\n                            if (TimezoneMapper.poly[103].contains(lat, lng))\n                                return 180;\n                            else\n                                return 164;\n                            \n                        }else\n                            if (lat < (-10.716564F)) {\n                                if (TimezoneMapper.poly[104].contains(lat, lng))\n                                    return 180;\n                                else\n                                    return 164;\n                                \n                            }else\n                                if (lng < (-71.049644F)) {\n                                    if (TimezoneMapper.poly[105].contains(lat, lng))\n                                        return 180;\n                                    else\n                                        return 164;\n                                    \n                                }else {\n                                    if (TimezoneMapper.poly[106].contains(lat, lng))\n                                        return 164;\n                                    \n                                    if (TimezoneMapper.poly[107].contains(lat, lng))\n                                        return 241;\n                                    else\n                                        return 180;\n                                    \n                                }\n                            \n                        \n                    \n                else\n                    if (lat < (-12.980227F))\n                        if (lng < (-66.914696F))\n                            if (lat < (-15.24389F)) {\n                                if (TimezoneMapper.poly[108].contains(lat, lng))\n                                    return 190;\n                                else\n                                    return 164;\n                                \n                            }else {\n                                if (TimezoneMapper.poly[109].contains(lat, lng))\n                                    return 190;\n                                else\n                                    return 164;\n                                \n                            }\n                        else\n                            return 190;\n                        \n                    else\n                        if (lng < (-66.914696F))\n                            if (lat < (-10.716564F)) {\n                                if (TimezoneMapper.poly[110].contains(lat, lng))\n                                    return 164;\n                                \n                                if (TimezoneMapper.poly[111].contains(lat, lng))\n                                    return 180;\n                                else\n                                    return 190;\n                                \n                            }else {\n                                if (TimezoneMapper.poly[112].contains(lat, lng))\n                                    return 7;\n                                \n                                if (TimezoneMapper.poly[113].contains(lat, lng))\n                                    return 190;\n                                \n                                if (TimezoneMapper.poly[114].contains(lat, lng))\n                                    return 241;\n                                else\n                                    return 180;\n                                \n                            }\n                        else\n                            if (lat < (-10.716564F)) {\n                                if (TimezoneMapper.poly[115].contains(lat, lng))\n                                    return 341;\n                                else\n                                    return 190;\n                                \n                            }else\n                                if (lng < (-65.536385F))\n                                    if (lat < (-9.584733F)) {\n                                        if (TimezoneMapper.poly[116].contains(lat, lng))\n                                            return 7;\n                                        \n                                        if (TimezoneMapper.poly[117].contains(lat, lng))\n                                            return 180;\n                                        \n                                        if (TimezoneMapper.poly[118].contains(lat, lng))\n                                            return 190;\n                                        else\n                                            return 341;\n                                        \n                                    }else {\n                                        if (TimezoneMapper.poly[119].contains(lat, lng))\n                                            return 341;\n                                        else\n                                            return 7;\n                                        \n                                    }\n                                else {\n                                    if (TimezoneMapper.poly[120].contains(lat, lng))\n                                        return 7;\n                                    \n                                    if (TimezoneMapper.poly[121].contains(lat, lng))\n                                        return 190;\n                                    else\n                                        return 341;\n                                    \n                                }\n                            \n                        \n                    \n                \n            else\n                if (lng < (-69.671326F))\n                    if (lat < (-3.925575F))\n                        if (lng < (-72.427956F))\n                            if (lat < (-6.189238F))\n                                if (lng < (-73.806274F)) {\n                                    if (TimezoneMapper.poly[122].contains(lat, lng))\n                                        return 180;\n                                    else\n                                        return 164;\n                                    \n                                }else\n                                    if (lat < (-7.32107F)) {\n                                        if (TimezoneMapper.poly[123].contains(lat, lng))\n                                            return 164;\n                                        \n                                        if (TimezoneMapper.poly[124].contains(lat, lng))\n                                            return 164;\n                                        \n                                        if (TimezoneMapper.poly[125].contains(lat, lng))\n                                            return 241;\n                                        else\n                                            return 180;\n                                        \n                                    }else {\n                                        if (TimezoneMapper.poly[126].contains(lat, lng))\n                                            return 180;\n                                        \n                                        if (TimezoneMapper.poly[127].contains(lat, lng))\n                                            return 241;\n                                        else\n                                            return 164;\n                                        \n                                    }\n                                \n                            else {\n                                if (TimezoneMapper.poly[128].contains(lat, lng))\n                                    return 241;\n                                else\n                                    return 164;\n                                \n                            }\n                        else\n                            if (lat < (-6.189238F)) {\n                                if (TimezoneMapper.poly[129].contains(lat, lng))\n                                    return 180;\n                                else\n                                    return 241;\n                                \n                            }else\n                                if (lng < (-71.049644F))\n                                    if (lat < (-5.057407F))\n                                        return 241;\n                                    else\n                                        if (lng < (-71.7388F)) {\n                                            if (TimezoneMapper.poly[130].contains(lat, lng))\n                                                return 241;\n                                            else\n                                                return 164;\n                                            \n                                        }else {\n                                            if (TimezoneMapper.poly[131].contains(lat, lng))\n                                                return 241;\n                                            else\n                                                return 164;\n                                            \n                                        }\n                                    \n                                else\n                                    if (lat < (-5.057407F))\n                                        return 241;\n                                    else\n                                        if (lng < (-70.36048F)) {\n                                            if (TimezoneMapper.poly[132].contains(lat, lng))\n                                                return 164;\n                                            else\n                                                return 241;\n                                            \n                                        }else {\n                                            if (TimezoneMapper.poly[133].contains(lat, lng))\n                                                return 7;\n                                            \n                                            if (TimezoneMapper.poly[134].contains(lat, lng))\n                                                return 241;\n                                            \n                                            if (TimezoneMapper.poly[135].contains(lat, lng))\n                                                return 390;\n                                            else\n                                                return 164;\n                                            \n                                        }\n                                    \n                                \n                            \n                        \n                    else\n                        if (lng < (-72.427956F))\n                            if (lat < (-1.661912F)) {\n                                if (TimezoneMapper.poly[136].contains(lat, lng))\n                                    return 390;\n                                else\n                                    return 164;\n                                \n                            }else\n                                if (lng < (-73.806274F)) {\n                                    if (TimezoneMapper.poly[137].contains(lat, lng))\n                                        return 390;\n                                    else\n                                        return 164;\n                                    \n                                }else {\n                                    if (TimezoneMapper.poly[138].contains(lat, lng))\n                                        return 164;\n                                    else\n                                        return 390;\n                                    \n                                }\n                            \n                        else\n                            if (lat < (-1.661912F))\n                                if (lng < (-71.049644F)) {\n                                    if (TimezoneMapper.poly[139].contains(lat, lng))\n                                        return 390;\n                                    else\n                                        return 164;\n                                    \n                                }else {\n                                    if (TimezoneMapper.poly[140].contains(lat, lng))\n                                        return 7;\n                                    \n                                    if (TimezoneMapper.poly[141].contains(lat, lng))\n                                        return 164;\n                                    else\n                                        return 390;\n                                    \n                                }\n                            else {\n                                if (TimezoneMapper.poly[142].contains(lat, lng))\n                                    return 7;\n                                else\n                                    return 390;\n                                \n                            }\n                        \n                    \n                else {\n                    if (TimezoneMapper.poly[143].contains(lat, lng))\n                        return 241;\n                    \n                    if (TimezoneMapper.poly[144].contains(lat, lng))\n                        return 390;\n                    else\n                        return 7;\n                    \n                }\n            \n        else\n            if (lng < (-69.20154F))\n                if (lng < (-69.59611F))\n                    if (lng < (-69.70038F)) {\n                        if (TimezoneMapper.poly[145].contains(lat, lng))\n                            return 7;\n                        else\n                            return 390;\n                        \n                    }else {\n                        if (TimezoneMapper.poly[146].contains(lat, lng))\n                            return 390;\n                        else\n                            return 7;\n                        \n                    }\n                else\n                    if (lng < (-69.31787F)) {\n                        if (TimezoneMapper.poly[147].contains(lat, lng))\n                            return 390;\n                        else\n                            return 7;\n                        \n                    }else {\n                        if (TimezoneMapper.poly[148].contains(lat, lng))\n                            return 390;\n                        else\n                            return 7;\n                        \n                    }\n                \n            else\n                if (lng < (-65.517845F)) {\n                    if (TimezoneMapper.poly[149].contains(lat, lng))\n                        return 390;\n                    else\n                        return 7;\n                    \n                }else {\n                    if (TimezoneMapper.poly[150].contains(lat, lng))\n                        return 397;\n                    else\n                        return 7;\n                    \n                }\n            \n        \n    \n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <iomanip>\n#include <cmath>\n\n#define ll long long\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define m_p make_pair\n#define sqr(x) ((x)*(x))\n#define ff first\n#define ss second\n#define ull unsigned long long\n//#define FILE\n\n#pragma GCC optimize(\"-O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9;\nconst ll INFL = 1e18;\nconst ll N = (1 << 24) + 1;\nconst ll hMod = 239017;\n\nll dp[N];\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n#ifdef FILE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    ll n;\n    cin >> n;\n\n    for (ll i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n\n        ll x = 0;\n\n        for (ll j = 0; j < 3; j++) {\n            x |= (s[j] - 'a');\n        }\n\n        dp[x]++;\n    }\n\n    for (ll i = 0; i < 24; i++) {\n        for (ll mask = 0; mask < (1 << 24); mask++) {\n            if (mask & (1 << i)) dp[mask] += dp[mask ^ (1 << i)];\n        }\n    }\n\n    ll ans = 0;\n    for (ll mask = 0; mask < (1 << 24); mask++) {\n        ans ^= sqr(n - dp[mask]);\n    }\n\n    cout << ans;\n\n    return 0;\n\n}\n",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <iomanip>\n#include <cmath>\n\n#define ll long long\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define m_p make_pair\n#define sqr(x) ((x)*(x))\n#define ff first\n#define ss second\n#define ull unsigned long long\n//#define FILE\n\n#pragma GCC optimize(\"-O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9;\nconst ll INFL = 1e18;\nconst ll N = (1 << 24) + 1;\nconst ll hMod = 239017;\n\nll dp[N];\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n#ifdef FILE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    ll n;\n    cin >> n;\n\n    for (ll i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n\n        ll x = 0;\n\n        for (ll j = 0; j < 3; j++) {\n            x |= (1 << (s[j] - 'a'));\n        }\n\n        dp[x]++;\n    }\n\n    for (ll i = 0; i < 24; i++) {\n        for (ll mask = 0; mask < (1 << 24); mask++) {\n            if (mask & (1 << i)) dp[mask] += dp[mask ^ (1 << i)];\n        }\n    }\n\n    ll ans = 0;\n    for (ll mask = 0; mask < (1 << 24); mask++) {\n        ans ^= sqr(n - dp[mask]);\n    }\n\n    cout << ans;\n\n    return 0;\n\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\n\r\nvoid balala(int n){\r\n\tint aa[123456];\r\n\tint bb[250000];\r\n\tint ans;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tcin>>aa[i];\r\n\t\tbb[aa[i]]=i;\r\n\t}\r\n\tsort(aa+1,aa+n+1);\r\n\tfor(int i=1;i<n;i++){\r\n\t\tfor(int j=i+1;j<=n&&aa[i]*aa[j]<=2*n;j++){\r\n\t\t\tif(aa[i]*aa[j]==bb[aa[i]]+bb[aa[j]]){\r\n\t\t\t\tans++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout<<ans<<endl;\r\n}\r\n\r\nint t,x;\r\n\r\nint main(){\r\n\tcin>>t;\r\n\twhile(t--){\r\n\tcin>>x;\r\n\tbalala(x);\t\r\n\t}\r\n\treturn 0;\r\n}",
        "fixed_code": "#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n#define int long long\r\nint t;\r\nint aa[100005],bb[200005];\r\nvoid out(int t){\r\n    int n,ans=0;\r\n    cin>>n;\r\n    for(int i=1;i<=n;i++){\r\n\t\tcin>>aa[i];\r\n\t\tbb[aa[i]]=i;\r\n    }\r\n    sort(aa+1,aa+n+1);\r\n    for(int i=1;i<=n;i++){\r\n\t\tfor(int j=i+1;j<=n&&aa[i]*aa[j]<=2*n;j++){\r\n\t\t    if(aa[i]*aa[j]==bb[aa[i]]+bb[aa[j]])ans++;\r\n\t\t}\r\n    }\r\n    cout<<ans<<endl;\r\n}\r\nsigned main(){\r\n    cin>>t;\r\n    while(t--){\r\n    \tout(t);\r\n    }\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic boolean equals(final java.lang.Object obj) {\n    if (!(obj instanceof com.qualinsight.plugins.sonarqube.badges.ws.measure.MeasureHolder)) {\n        return false;\n    }\n    final com.qualinsight.plugins.sonarqube.badges.ws.measure.MeasureHolder other = ((com.qualinsight.plugins.sonarqube.badges.ws.measure.MeasureHolder) (obj));\n    return new org.apache.commons.lang.builder.EqualsBuilder().append(this.metricName, other.metricName).append(this.value, other.value).isEquals();\n}",
        "fixed_code": "@java.lang.Override\npublic boolean equals(final java.lang.Object obj) {\n    if (!(obj instanceof com.qualinsight.plugins.sonarqube.badges.ws.measure.MeasureHolder)) {\n        return false;\n    }\n    final com.qualinsight.plugins.sonarqube.badges.ws.measure.MeasureHolder other = ((com.qualinsight.plugins.sonarqube.badges.ws.measure.MeasureHolder) (obj));\n    return new org.apache.commons.lang.builder.EqualsBuilder().append(this.metricName, other.metricName).append(this.value, other.value).append(this.backgroundColor, other.backgroundColor).isEquals();\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define maxn 100100\nusing namespace std;\ntypedef long double ldb;\nldb a[maxn],b[maxn],p;\nint n,x;\nbool check(ldb time){\n\tldb used=0,x=time*p;\n\tfor(int i=1;i<=n;++i)if(a[i]*time>b[i]){\n\t\tused+=(a[i]*time-b[i]);\n\t\tif(used>x)return false;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&x),p=x;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&x),a[i]=x,\n\t\tscanf(\"%d\",&x),b[i]=x;\n\tldb l=0,r=1e20;\n\twhile(r-l>1e-6){\n\t\tldb mid=(l+r)/2;\n\t\tif(check(mid))l=mid;\n\t\telse r=mid;\n\t}\n\tif(l>1e19)printf(\"-1\");\n\telse printf(\"%.9lf\",(double)l);\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define maxn 100100\nusing namespace std;\ntypedef long double ldb;\nldb a[maxn],b[maxn],p;\nint n,x,P;\nlong long tot;\nbool check(ldb time){\n\tldb used=0,x=time*p;\n\tfor(int i=1;i<=n;++i)if(a[i]*time>b[i]){\n\t\tused+=(a[i]*time-b[i]);\n\t\tif(used>x)return false;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&x),p=x,P=p;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&x),a[i]=x,tot+=x,\n\t\tscanf(\"%d\",&x),b[i]=x;\n\tif(tot<=P)return printf(\"-1\"),0;\n\tldb l=0,r=1e18;\n\twhile(r-l>1e-6){\n\t\tldb mid=(l+r)/2;\n\t\tif(check(mid))l=mid;\n\t\telse r=mid;\n\t}\n\tprintf(\"%.9lf\",(double)l);\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\nconst int maxn=2e5+5;\nint n;\nint v[maxn];\nvoid read()\n{\n    RI(n);\n    vector<int> c(n+1),q(n+1);\n    REP1(i,1,n) RI(c[i],q[i]);\n    vector<int> r(n);iota(ALL(r),1);\n    sort(ALL(r),[&](int i,int j){return tie(q[i],c[j])>tie(q[j],c[i]);});\n    v[1]=0;\n    REP1(i,1,n) v[i+1]=c[r[i-1]];\n    n++;\n}\nconst int K=30;\nstruct H\n{\n    int lev;\n    ll unit;\n    vector<int> small_id;\n    vector<ll> small_sum;\n    vector<int> big_id;\n    vector<ll> sum_till_big;\n    vector<int> par[__lg(maxn)+1];\n    void init(int _lev) //v start with 0\n    {\n        lev=_lev;\n        // debug(lev);\n        unit=1LL<<lev;\n        {\n            ll prv=0;\n            REP1(i,1,n)\n            {\n                // debug(i,v[i],unit);\n                if(v[i]<unit)\n                {\n                    small_id.pb(i);\n                    prv+=v[i];\n                    small_sum.pb(prv);\n                }\n                else if(unit<=v[i] && v[i]<=2*unit-1)\n                {\n                    big_id.pb(i);\n                    sum_till_big.pb(prv+v[i]);\n                }\n            }\n            // assert(small_id[0]==1 && v[small_id[0]]==0);\n        }\n        {\n            int siz=SZ(sum_till_big);\n            par[0].resize(siz+1);\n            par[0][siz]=siz;\n            vector<int> st;\n            PER1(i,siz-1,0)\n            {\n                while(SZ(st) && sum_till_big[i]<=sum_till_big[st.back()]) st.pop_back();\n                if(SZ(st)) par[0][i]=st.back();\n                else par[0][i]=siz;\n                st.pb(i);\n            }\n            REP(i,__lg(siz+1))\n            {\n                par[i+1].resize(siz+1);\n                REP(j,siz+1) par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n    tuple<int,ll,int> calc_small(int start,ll budget)\n    {\n        assert(1<=start && start<=n && unit<=budget && budget<=2*unit-1);\n        int id=lower_bound(ALL(small_id),start)-small_id.begin();\n        ll sum=budget + (id-1>=0?small_sum[id-1]:0);\n        //sum - small_sum[i] < unit\n        //small_sum[i] > sum - unit\n        int id2=upper_bound(ALL(small_sum),sum-unit)-small_sum.begin();\n        if(id2 == SZ(small_sum)) return {n+1,sum-small_sum.back(),(id2-1)-(id-1)};\n        else return {small_id[id2]+1,sum-small_sum[id2],id2-(id-1)};\n    }\n    tuple<int,ll,int> calc_big(int start,ll budget)\n    {\n        assert(1<=start && start<=n && unit<=budget && budget<=2*unit-1);\n        \n        int id=lower_bound(ALL(small_id),start)-small_id.begin();\n        ll sum=budget + (id-1>=0?small_sum[id-1]:0);\n        int nsiz=SZ(par[0]);\n        int id2=lower_bound(ALL(big_id),start)-big_id.begin();\n        if(id2==SZ(sum_till_big)) return {n+1,sum-small_sum.back(),SZ(small_sum)-1-(id-1)};\n\n        if(sum_till_big[id2]<=sum)\n        {\n            int id3=lower_bound(ALL(small_id),big_id[id2])-small_id.begin()-1;\n            return {big_id[id2]+1,sum-sum_till_big[id2],1 + id3-(id-1)};\n        }\n        \n        for(int i=__lg(nsiz)-1;i>=0;i--)\n        {\n            int p=par[i][id2];\n            if(p==SZ(sum_till_big)) continue;\n            if(sum_till_big[p]>sum) id2=p;\n        }\n        assert(id2<SZ(sum_till_big));\n        id2=par[0][id2];\n        if(id2==SZ(sum_till_big)) return {n+1,sum-small_sum.back(),SZ(small_sum)-1-(id-1)};\n        // assert(sum_till_big[id2]<=sum);\n        {\n            int id3=lower_bound(ALL(small_id),big_id[id2])-small_id.begin()-1;\n            return {big_id[id2]+1,sum-sum_till_big[id2],1 + id3-(id-1)};\n        }\n    }\n    tuple<int,ll,int> calc(int start,ll budget)\n    {\n        auto ans1=calc_small(start,budget);\n        auto ans2=calc_big(start,budget);\n        //{id, leftover}\n        return min(ans1,ans2);\n    }\n} h[K];\nvoid build()\n{\n    REP(i,K) h[i].init(i);\n}\nvoid sol()\n{\n    int q;RI(q);\n    while(q--)\n    {\n        ll budget;RI(budget);\n        int start=1,ans=-1;// insert 0 begin\n        PER1(i,K-1,0)\n        {\n            if(start==n+1) break;\n            if(budget<h[i].unit) continue;\n            auto nxt=h[i].calc(start,budget);\n            ans+=get<2>(nxt);\n            start=get<0>(nxt);\n            budget=get<1>(nxt);\n            // debug(i,start,budget,ans);\n        }\n        printf(\"%d%c\",ans,\" \\n\"[q==0]);\n    }\n}\nint main()\n{\n    read();\n    build();\n    sol();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*End Of File*/\n\n\n",
        "fixed_code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\nconst int maxn=2e5+5;\nint n;\nint v[maxn];\nvoid read()\n{\n    RI(n);\n    vector<int> c(n+1),q(n+1);\n    REP1(i,1,n) RI(c[i],q[i]);\n    vector<int> r(n);iota(ALL(r),1);\n    sort(ALL(r),[&](int i,int j){return tie(q[i],c[j])>tie(q[j],c[i]);});\n    v[1]=0;\n    REP1(i,1,n) v[i+1]=c[r[i-1]];\n    n++;\n}\nconst int K=30;\nstruct H\n{\n    int lev;\n    ll unit;\n    vector<int> small_id;\n    vector<ll> small_sum;\n    vector<int> big_id;\n    vector<ll> sum_till_big;\n    vector<int> par[__lg(maxn)+1];\n    void init(int _lev) //v start with 0\n    {\n        lev=_lev;\n        // debug(lev);\n        unit=1LL<<lev;\n        {\n            ll prv=0;\n            REP1(i,1,n)\n            {\n                // debug(i,v[i],unit);\n                if(v[i]<unit)\n                {\n                    small_id.pb(i);\n                    prv+=v[i];\n                    small_sum.pb(prv);\n                }\n                else if(unit<=v[i] && v[i]<=2*unit-1)\n                {\n                    big_id.pb(i);\n                    sum_till_big.pb(prv+v[i]);\n                }\n            }\n            // assert(small_id[0]==1 && v[small_id[0]]==0);\n        }\n        {\n            int siz=SZ(sum_till_big);\n            par[0].resize(siz+1);\n            par[0][siz]=siz;\n            vector<int> st;\n            PER1(i,siz-1,0)\n            {\n                while(SZ(st) && sum_till_big[i]<=sum_till_big[st.back()]) st.pop_back();\n                if(SZ(st)) par[0][i]=st.back();\n                else par[0][i]=siz;\n                st.pb(i);\n            }\n            REP(i,__lg(siz+1))\n            {\n                par[i+1].resize(siz+1);\n                REP(j,siz+1) par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n    tuple<int,ll,int> calc_small(int start,ll budget)\n    {\n        // assert(1<=start && start<=n && unit<=budget && budget<=2*unit-1);\n        int id=lower_bound(ALL(small_id),start)-small_id.begin();\n        ll sum=budget + (id-1>=0?small_sum[id-1]:0);\n        //sum - small_sum[i] < unit\n        //small_sum[i] > sum - unit\n        int id2=upper_bound(ALL(small_sum),sum-unit)-small_sum.begin();\n        if(id2 == SZ(small_sum)) return {n+1,sum-small_sum.back(),(id2-1)-(id-1)};\n        else return {small_id[id2]+1,sum-small_sum[id2],id2-(id-1)};\n    }\n    tuple<int,ll,int> calc_big(int start,ll budget)\n    {\n        // assert(1<=start && start<=n && unit<=budget && budget<=2*unit-1);\n        \n        int id=lower_bound(ALL(small_id),start)-small_id.begin();\n        ll sum=budget + (id-1>=0?small_sum[id-1]:0);\n        int nsiz=SZ(par[0]);\n        int id2=lower_bound(ALL(big_id),start)-big_id.begin();\n        if(id2==SZ(sum_till_big)) return {n+1,sum-small_sum.back(),SZ(small_sum)-1-(id-1)};\n\n        if(sum_till_big[id2]<=sum)\n        {\n            int id3=lower_bound(ALL(small_id),big_id[id2])-small_id.begin()-1;\n            return {big_id[id2]+1,sum-sum_till_big[id2],1 + id3-(id-1)};\n        }\n        \n        for(int i=__lg(nsiz);i>=0;i--)\n        {\n            int p=par[i][id2];\n            if(p==SZ(sum_till_big)) continue;\n            if(sum_till_big[p]>sum) id2=p;\n        }\n        // assert(id2<SZ(sum_till_big));\n        id2=par[0][id2];\n        if(id2==SZ(sum_till_big)) return {n+1,sum-small_sum.back(),SZ(small_sum)-1-(id-1)};\n        // assert(sum_till_big[id2]<=sum);\n        {\n            int id3=lower_bound(ALL(small_id),big_id[id2])-small_id.begin()-1;\n            return {big_id[id2]+1,sum-sum_till_big[id2],1 + id3-(id-1)};\n        }\n    }\n    tuple<int,ll,int> calc(int start,ll budget)\n    {\n        auto ans1=calc_small(start,budget);\n        auto ans2=calc_big(start,budget);\n        //{id, leftover}\n        return min(ans1,ans2);\n    }\n} h[K];\nvoid build()\n{\n    REP(i,K) h[i].init(i);\n}\nvoid sol()\n{\n    int q;RI(q);\n    while(q--)\n    {\n        ll budget;RI(budget);\n        int start=1,ans=-1;// insert 0 begin\n        PER1(i,K-1,0)\n        {\n            if(start==n+1) break;\n            if(budget<h[i].unit) continue;\n            auto nxt=h[i].calc(start,budget);\n            ans+=get<2>(nxt);\n            start=get<0>(nxt);\n            budget=get<1>(nxt);\n            // debug(i,start,budget,ans);\n        }\n        printf(\"%d%c\",ans,\" \\n\"[q==0]);\n    }\n}\nint main()\n{\n    read();\n    build();\n    sol();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*End Of File*/\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int N=2e5+100;\nint num[30],cnt,len;\nstring s1,s2;\nvector<char>v;\nvoid solve(){\n\tv.clear();\n\tfor(int i=0;i<len;i++){\n\t\tif(s1[i]!=s2[i]) v.push_back(i);\n\t\t\n\t}\n\tif(v.size()!=2){\n\t\tcout<<\"No\"<<endl;\n\t\treturn ;\n\t}\n\tswap(s1[v[0]],s2[v[1]]);//cout<<s1<<\" \"<<endl<<s2<<endl;\n\tif(s1!=s2){\n\t\tcout<<\"No\"<<endl;\n\t\treturn ;\n\t}\n\tcout<<\"Yes\"<<endl;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\t\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tmemset(num,0,sizeof(num));\n\t\tcin>>len;\n\t\tcin>>s1>>s2;\n\t\tcnt=0;\n\t\tfor(char it:s1){\n\t\t\tnum[it-'a']++;\n\t\t} \n\t\tfor(char it:s2){\n\t\t\tnum[it-'a']++;\n\t\t} \n\t\tsolve();\n\t}\n\treturn 0;\n} ",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nchar s[10005], t[10005];\n\nint main() {\n#ifdef KisekiPurin\n    freopen(\"KisekiPurin.in\", \"r\", stdin);\n#endif // KisekiPurin\n    int k;\n    scanf(\"%d\", &k);\n    while(k--) {\n        scanf(\"%d%s%s\", &n, s + 1, t + 1);\n        vector<int> dif;\n        for(int i = 1; i <= n; ++i) {\n            if(s[i] != t[i]) {\n                dif.push_back(i);\n                if(dif.size() >= 3)\n                    break;\n            }\n        }\n        if(dif.size() != 2) {\n            puts(\"No\");\n        } else {\n            swap(s[dif[0]], t[dif[1]]);\n            if(strcmp(s + 1, t + 1) == 0)\n                puts(\"Yes\");\n            else\n                puts(\"No\");\n        }\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\n\nstruct node {\n    int val = 0, lp = 0;\n};\n\nvector<vector<int> > vec(1000010, vector<int> () );\nvector<vector<ii> > tree(1000010, vector<ii> () );\nint a, b, val[1000010], level[1000010];\nnode all[3000010];\n\nvoid updateLp(int _at) {\n    all[_at].val += all[_at].lp;\n    all[_at*2].lp += all[_at].lp;\n    all[_at*2+1].lp += all[_at].lp;\n    all[_at].lp = 0;\n}\n\nvoid updateRange(int l, int r, int x, int _at = 1, int curL = 0, int curR = (1<<20)-1) {\n    updateLp(_at);\n    if (curL >= l && curR <= r) {all[_at].lp += x;}\n    else if (curL > r || l > curR) {}\n    else {\n        updateRange(l, r, x, _at*2, curL, curL+(curR-curL)/2 );\n        updateRange(l, r, x, _at*2+1, curL+(curR-curL)/2+1, curR );\n    }\n}\n\nint getElemAtPos(int pos, int _at = 1, int curL = 0, int curR = (1<<20)-1) {\n    updateLp(_at);\n    if (curL >= pos && curR <= pos) {return all[_at].val;}\n    else if (curL > pos || pos > curR) {return 0;}\n    else {\n        int r1 = getElemAtPos(pos, _at*2, curL, curL+(curR-curL)/2 );\n        int r2 = getElemAtPos(pos, _at*2+1, curL+(curR-curL)/2+1, curR );\n        return r1 + r2;\n    }\n}\n\nvoid DFS(int node, int parent, int _add, int tm) {\n    for (int i = 0; i < tree[node].size(); ++i ) {\n        int lenght = tree[node][i].first;\n        int addby = tree[node][i].second;\n        updateRange(tm, tm+lenght, addby);\n    }\n\n    val[node] += getElemAtPos(tm);\n\n    for (int i = 0; i < vec[node].size(); ++i) {\n        int ngb = vec[node][i];\n        if (ngb == parent) continue;\n\n        DFS(ngb, node, _add, tm+1);\n    }\n\n    for (int i = 0; i < tree[node].size(); ++i ) {\n        int lenght = tree[node][i].first;\n        int addby = tree[node][i].second;\n        updateRange(tm, tm+lenght, -addby);\n    }\n\n}\n\nint main() {\n    cin >> a;\n    for (int i = 0; i < a-1; ++i) {\n        int temp1, temp2;\n        cin >> temp1 >> temp2;\n        vec[temp1].push_back(temp2);\n        vec[temp2].push_back(temp1);\n    }\n    cin >> b;\n    for (int i = 0; i < b; ++i) {\n        int temp1, temp2, temp3;\n        cin >> temp1 >> temp2 >> temp3;\n        tree[temp1].push_back( ii(temp2, temp3) );\n    }\n\n    DFS(1, -1, 0, 1);\n\n    for (int i = 1; i <= a; ++i) cout << val[i] << \" \";\n    cout << endl;\n\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long long, long long> ii;\n\nstruct node {\n    long long val = 0, lp = 0;\n};\n\nvector<vector<long long> > vec(1000010, vector<long long> () );\nvector<vector<ii> > tree(1000010, vector<ii> () );\nlong long a, b, val[1000010], level[1000010];\nnode all[3000010];\n\nvoid updateLp(long long _at) {\n    all[_at].val += all[_at].lp;\n    all[_at*2].lp += all[_at].lp;\n    all[_at*2+1].lp += all[_at].lp;\n    all[_at].lp = 0;\n}\n\nvoid updateRange(int l, int r, long long x, int _at = 1, int curL = 0, int curR = (1<<20)-1) {\n    updateLp(_at);\n    if (curL >= l && curR <= r) {all[_at].lp += x;}\n    else if (curL > r || l > curR) {}\n    else {\n        updateRange(l, r, x, _at*2, curL, curL+(curR-curL)/2 );\n        updateRange(l, r, x, _at*2+1, curL+(curR-curL)/2+1, curR );\n    }\n}\n\nlong long getElemAtPos(long long pos, int _at = 1, int curL = 0, int curR = (1<<20)-1) {\n    updateLp(_at);\n    if (curL >= pos && curR <= pos) {return all[_at].val;}\n    else if (curL > pos || pos > curR) {return 0;}\n    else {\n        long long r1 = getElemAtPos(pos, _at*2, curL, curL+(curR-curL)/2 );\n        long long r2 = getElemAtPos(pos, _at*2+1, curL+(curR-curL)/2+1, curR );\n        return r1 + r2;\n    }\n}\n\nvoid DFS(int node, int parent, long long _add, long long tm) {\n    for (int i = 0; i < tree[node].size(); ++i ) {\n        long long lenght = tree[node][i].first;\n        long long addby = tree[node][i].second;\n        updateRange(tm, tm+lenght, addby);\n    }\n\n    val[node] += getElemAtPos(tm);\n\n    for (int i = 0; i < vec[node].size(); ++i) {\n        int ngb = vec[node][i];\n        if (ngb == parent) continue;\n\n        DFS(ngb, node, _add, tm+1);\n    }\n\n    for (int i = 0; i < tree[node].size(); ++i ) {\n        long long lenght = tree[node][i].first;\n        long long addby = tree[node][i].second;\n        updateRange(tm, tm+lenght, -addby);\n    }\n\n}\n\nint main() { ios_base::sync_with_stdio(false);\n    cin >> a;\n    for (int i = 0; i < a-1; ++i) {\n        long long temp1, temp2;\n        cin >> temp1 >> temp2;\n        vec[temp1].push_back(temp2);\n        vec[temp2].push_back(temp1);\n    }\n    cin >> b;\n    for (int i = 0; i < b; ++i) {\n        long long temp1, temp2, temp3;\n        cin >> temp1 >> temp2 >> temp3;\n        if (temp2 > a) temp2 = a;\n        tree[temp1].push_back( ii(temp2, temp3) );\n    }\n\n    DFS(1, -1, 0, 1);\n\n    for (int i = 1; i <= a; ++i) cout << val[i] << \" \";\n    cout << endl;\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#define _CRT_SECURE_NO_WARNINGS 1\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <stdio.h>\n#include <set>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\nlong long n, m, k;\nchar arr[555][555];\nint arr2[555][555];\nint arr3[555][555];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tcin>> arr[i][j];\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint t = 0;\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t{\n\t\t\twhile (j <= m && arr[i][j] == arr[i][j - 1] && arr[i][j - 1] == '.')\n\t\t\t{\n\t\t\t\tt++;\n\t\t\t\tarr2[i][j] = t + arr2[i - 1][j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tarr2[i][j] = t + arr2[i - 1][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint t = 0;\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t{\n\t\t\twhile (j <= n && arr[j][i] == arr[j - 1][i] && arr[j - 1][i] == '.')\n\t\t\t{\n\t\t\t\tt++;\n\t\t\t\tarr3[j][i] = t + arr3[j][i - 1];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tarr3[j][i] = t + arr3[j][i - 1];\n\t\t}\n\t}\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tint x1, x2, y1, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tlong long x = arr2[x2][y2] - arr2[x2][y1] - (arr2[x1 - 1][y2] - arr2[x1 - 1][y1]);\n\t\tx += arr3[x2][y2] - arr3[x1][y2] - (arr3[x2][y1 - 1] - arr3[x1][y1 - 1]);\n\t\tprintf(\"%I64d\", x);\n\t}\n\treturn 0;\n}",
        "fixed_code": "#define _CRT_SECURE_NO_WARNINGS 1\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <stdio.h>\n#include <set>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\nlong long n, m, k;\nchar arr[555][555];\nint arr2[555][555];\nint arr3[555][555];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tcin>> arr[i][j];\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint t = 0;\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t{\n\t\t\twhile (j <= m && arr[i][j] == arr[i][j - 1] && arr[i][j - 1] == '.')\n\t\t\t{\n\t\t\t\tt++;\n\t\t\t\tarr2[i][j] = t + arr2[i - 1][j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tarr2[i][j] = t + arr2[i - 1][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint t = 0;\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t{\n\t\t\twhile (j <= n && arr[j][i] == arr[j - 1][i] && arr[j - 1][i] == '.')\n\t\t\t{\n\t\t\t\tt++;\n\t\t\t\tarr3[j][i] = t + arr3[j][i - 1];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tarr3[j][i] = t + arr3[j][i - 1];\n\t\t}\n\t}\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tint x1, x2, y1, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tlong long x = arr2[x2][y2] - arr2[x2][y1] - (arr2[x1 - 1][y2] - arr2[x1 - 1][y1]);\n\t\tx += arr3[x2][y2] - arr3[x1][y2] - (arr3[x2][y1 - 1] - arr3[x1][y1 - 1]);\n\t\tprintf(\"%I64d\\n\", x);\n\t}\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "from sys import stdin\nfrom collections import defaultdict\n\nn, k = [int(x) for x in stdin.readline().strip().split()]\n\nst = defaultdict(list)\n\ndef is_pal(s):\n    l = len(s)\n    l = 0\n    r = len(s) - 1\n    while l < r:\n        if s[l] != s[r]:\n            return False\n        l += 1\n        r -= 1\n    return True\n\npals = defaultdict(list)\n\nfor i in range(n):\n    l = input().strip().split()\n    s = l[0]\n    ai = int(l[1])\n    if is_pal(s):\n        pals[s].append(ai)\n    else:\n        st[s].append(ai)\nseen = set()\nans = 0\nfor s in st:\n    if s not in seen:\n        q = s[::-1]\n        if q in st:\n            a = sorted(st[s], reverse=True)\n            b = sorted(st[q], reverse=True)\n            c_ans = 0\n            for i in range(min(len(a),len(b))):\n                if a[i] + b[i] > 0:\n                    c_ans += a[i] + b[i]\n            ans += c_ans\n            seen.add(q)\npp = list()\np_sum = 0\nfor s in pals:\n    a = sorted(pals[s], reverse=True)\n    i = 0\n    c_ans = 0\n    while i < (len(a) - 1) and len(a) > 1:\n        if a[i] <= 0:\n            break\n        if a[i] > 0 and a[i+1] < 0:\n            pp.append([a[i],a[i+1]])\n            if a[i] + a[i+1] > 0:\n                p_sum += a[i] + a[i+1]\n            break\n        if a[i] > 0 and a[i+1] >= 0:\n            c_ans += a[i] + a[i+1]\n            i += 2\n        ans += c_ans\n    if len(a) == 1 and a[0] > 0:\n        pp.append([a[0],0])\n    if i == len(a) - 1 and a[-1] > 0:\n        pp.append([a[-1],0])\nmax_sum = p_sum\nfor p in pp:\n    if p[0] + p[1] > 0 and p[1] != 0:\n        pr_sum = p_sum - p[1]\n    else:\n        pr_sum = p_sum + p[0]\n    if pr_sum > max_sum:\n        max_sum = pr_sum\nans += max_sum\nprint(ans)\n",
        "fixed_code": "from sys import stdin\nfrom collections import defaultdict\n\nn, k = [int(x) for x in stdin.readline().strip().split()]\n\nst = defaultdict(list)\n\ndef is_pal(s):\n    l = len(s)\n    l = 0\n    r = len(s) - 1\n    while l < r:\n        if s[l] != s[r]:\n            return False\n        l += 1\n        r -= 1\n    return True\n\npals = defaultdict(list)\n\nfor i in range(n):\n    l = input().strip().split()\n    s = l[0]\n    ai = int(l[1])\n    if is_pal(s):\n        pals[s].append(ai)\n    else:\n        st[s].append(ai)\nseen = set()\nans = 0\nfor s in st:\n    if s not in seen:\n        q = s[::-1]\n        if q in st:\n            a = sorted(st[s], reverse=True)\n            b = sorted(st[q], reverse=True)\n            c_ans = 0\n            for i in range(min(len(a),len(b))):\n                if a[i] + b[i] > 0:\n                    c_ans += a[i] + b[i]\n            ans += c_ans\n            seen.add(q)\npp = list()\np_sum = 0\nfor s in pals:\n    a = sorted(pals[s], reverse=True)\n    i = 0\n    c_ans = 0\n    while i < (len(a) - 1) and len(a) > 1:\n        if a[i] <= 0:\n            break\n        if a[i] > 0 and a[i+1] < 0:\n            pp.append([a[i],a[i+1]])\n            if a[i] + a[i+1] > 0:\n                p_sum += a[i] + a[i+1]\n            break\n        if a[i] > 0 and a[i+1] >= 0:\n            c_ans += a[i] + a[i+1]\n            i += 2\n    ans += c_ans\n    if len(a) == 1 and a[0] > 0:\n        pp.append([a[0],0])\n    if i == len(a) - 1 and a[-1] > 0:\n        pp.append([a[-1],0])\nmax_sum = p_sum\nfor p in pp:\n    if p[0] + p[1] > 0 and p[1] != 0:\n        pr_sum = p_sum - p[1]\n    else:\n        pr_sum = p_sum + p[0]\n    if pr_sum > max_sum:\n        max_sum = pr_sum\nans += max_sum\nprint(ans)\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <bits/stdc++.h> \r\n#include <ext/pb_ds/assoc_container.hpp> \r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n// Policy based data structure \r\ntemplate<class T> using oset=tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; \r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define mp make_pair\r\n#define pii pair<ll,ll>\r\n#define rep(i,st,en) for(ll i=st;i<en;i++)\r\n#define vi vector<ll>\r\n#define vii vector<pii>\r\n#define all(x) x.begin(),x.end()\r\n#define rall(x) x.rbegin(),x.rend()\r\n#define eb emplace_back\r\n#define yes cout<<\"YES\"<<endl; return;\r\n#define no cout<<\"NO\"<<endl; return;\r\n#define flus fflush(stdout);\r\n\r\n#define fin cerr<<endl;\r\n#define ff first\r\n#define ss second\r\n#define np next_permutation\r\n#define inf 1e18\r\n#define mod 1000000007\r\n#define N 200009\r\n#define PI 3.14159265358979323846\r\n#define minpq priority_queue <ll, vector<ll>, greater<ll>>\r\n#define maxpq priority_queue<ll> \r\nvoid sout(){\r\n    cout<<endl;\r\n}\r\ntemplate <typename T,typename... Types>\r\nvoid sout(T var1,Types... var2){\r\n    cout<<var1<<\" \";\r\n    sout(var2...);\r\n}\r\n\r\n\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define gin(x) cerr << #x <<\" \"; _print(x); cerr << endl;\r\n#else\r\n#define gin(x)\r\n#endif\r\n\r\nvoid _print(ll t) {cerr << t;}\r\nvoid _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\nvoid solve(){\r\n   ll n;cin>>n;\r\n   vi v(n);\r\n   for(ll i=0 ;i<n ;i++)cin>>v[i];\r\n    ll maxi = *max_element(all(v));\r\n    ll mini  = *min_element(all(v));\r\n\r\n    if(v[n-1]==mini)\r\n    {\r\n          yes\r\n    } \r\n    no\r\n}\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);   \r\n     #ifndef ONLINE_JUDGE \r\n    freopen(\"error.txt\",\"w\",stderr);\r\n    #endif \r\n    int t;\r\n    cin>>t;\r\n    for(ll tt=1;tt<=t;tt++){\r\n        // cout<<\"Case #\"<<tt<<\": \";\r\n        solve();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "fixed_code": "#include <bits/stdc++.h> \r\n#include <ext/pb_ds/assoc_container.hpp> \r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n// Policy based data structure \r\ntemplate<class T> using oset=tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; \r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef long double lld;\r\n#define pb push_back\r\n#define ppb pop_back\r\n#define mp make_pair\r\n#define pii pair<ll,ll>\r\n#define rep(i,st,en) for(ll i=st;i<en;i++)\r\n#define vi vector<ll>\r\n#define vii vector<pii>\r\n#define all(x) x.begin(),x.end()\r\n#define rall(x) x.rbegin(),x.rend()\r\n#define eb emplace_back\r\n#define yes cout<<\"YES\"<<endl; return;\r\n#define no cout<<\"NO\"<<endl; return;\r\n#define flus fflush(stdout);\r\n\r\n#define fin cerr<<endl;\r\n#define ff first\r\n#define ss second\r\n#define np next_permutation\r\n#define inf 1e18\r\n#define mod 1000000007\r\n#define N 200009\r\n#define PI 3.14159265358979323846\r\n#define minpq priority_queue <ll, vector<ll>, greater<ll>>\r\n#define maxpq priority_queue<ll> \r\nvoid sout(){\r\n    cout<<endl;\r\n}\r\ntemplate <typename T,typename... Types>\r\nvoid sout(T var1,Types... var2){\r\n    cout<<var1<<\" \";\r\n    sout(var2...);\r\n}\r\n\r\n\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define gin(x) cerr << #x <<\" \"; _print(x); cerr << endl;\r\n#else\r\n#define gin(x)\r\n#endif\r\n\r\nvoid _print(ll t) {cerr << t;}\r\nvoid _print(int t) {cerr << t;}\r\nvoid _print(string t) {cerr << t;}\r\nvoid _print(char t) {cerr << t;}\r\nvoid _print(lld t) {cerr << t;}\r\nvoid _print(double t) {cerr << t;}\r\nvoid _print(ull t) {cerr << t;}\r\n\r\ntemplate <class T, class V> void _print(pair <T, V> p);\r\ntemplate <class T> void _print(vector <T> v);\r\ntemplate <class T> void _print(set <T> v);\r\ntemplate <class T, class V> void _print(map <T, V> v);\r\ntemplate <class T> void _print(multiset <T> v);\r\ntemplate <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}\r\ntemplate <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\ntemplate <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\r\n\r\n\r\n\r\n\r\nvoid solve(){\r\n   ll n;cin>>n;\r\n   vi v(n);\r\n   for(ll i=0 ;i<n;i++)cin>>v[i];\r\n    vi k = v;\r\n   sort(all(k));\r\n   if(k==v)\r\n   {\r\n       no\r\n   }\r\n   yes\r\n}\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);   \r\n     #ifndef ONLINE_JUDGE \r\n    freopen(\"error.txt\",\"w\",stderr);\r\n    #endif \r\n    int t;\r\n    cin>>t;\r\n    for(ll tt=1;tt<=t;tt++){\r\n        // cout<<\"Case #\"<<tt<<\": \";\r\n        solve();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\n#define rep1(i,n) for(int i=1; i<n; i++)\n#define all(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL mod = 1000000007;\nconst LL INF = 1145148101919114;\n\nint n;\nvector<vector<int>> g;\nLL s[101009];\nvector<LL> a;\n\nbool f = false;\nLL dfs(int x, LL parent){\n    if(s[x] == -1){\n        LL tmp = INF;\n        for(auto &m: g[x]){\n            tmp = min(tmp, dfs(m, s[x]));\n        }\n        if(g[x].size() == 0) tmp = parent;\n        if(tmp-parent < 0){\n            f = true;\n            return -1;\n        }\n        a[x] = tmp-parent;\n        for(auto &m: g[x]){\n            a[m] = s[m]-tmp;\n        }\n        return tmp;\n    }else{\n        for(auto &m: g[x]){\n            if(dfs(m, s[x]) == -1) return -1;\n        }\n        return s[x];\n    }\n\n}\n\nint main(){\n    cin >> n;\n    g = vector<vector<int>>(n+2);\n    rep1(i, n){\n        int p;\n        cin >> p;\n        p--;\n        g[p].pb(i);\n    }\n    rep(i,n){\n        cin >> s[i];\n    }\n    LL ans = 0;\n    a = vector<LL>(n+2, 0);\n    a[0] = s[0];\n    if(dfs(0, 0) == -1 || f) ans = -1;\n    else ans = accumulate(all(a), 0);\n    cout << ans << endl;\n\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\n#define rep1(i,n) for(int i=1; i<n; i++)\n#define all(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL mod = 1000000007;\nconst LL INF = 1145148101919114;\n\nint n;\nvector<vector<int>> g;\nLL s[101009];\nvector<LL> a;\n\nbool f = false;\nLL dfs(int x, LL parent){\n    if(s[x] == -1){\n        assert(parent >= 0);\n        LL tmp = INF;\n        for(auto &m: g[x]){\n            tmp = min(tmp, dfs(m, s[x]));\n        }\n        if(g[x].size() == 0) tmp = parent;\n        if(tmp-parent < 0){\n            f = true;\n            return -1;\n        }\n        a[x] = tmp-parent;\n        for(auto &m: g[x]){\n            a[m] = s[m]-tmp;\n        }\n        return tmp;\n    }else{\n        for(auto &m: g[x]){\n            if(dfs(m, s[x]) == -1) return -1;\n        }\n        return s[x];\n    }\n\n}\n\nint main(){\n    cin >> n;\n    g = vector<vector<int>>(n+2);\n    rep1(i, n){\n        int p;\n        cin >> p;\n        p--;\n        g[p].pb(i);\n    }\n    rep(i,n){\n        cin >> s[i];\n    }\n    LL ans = 0;\n    a = vector<LL>(n+2, 0);\n    a[0] = s[0];\n    if(dfs(0, 0) == -1 || f) ans = -1;\n    else{\n        rep(i, n){\n            assert(a[i] >= 0);\n            ans += a[i];\n        }\n    }\n    cout << ans << endl;\n\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <deque>\n#include <iostream>\n#include <math.h>\n#include <sstream>\n#include <assert.h>\n#include <numeric>\n#include <limits>\n#define INF 0x3f3f3f3f\n\nusing namespace std;\n\nint main()\n{\n    int n,a,b;\n    scanf(\"%d\",&n);\n    bool vet[n];\n    memset(vet,false,sizeof(vet));\n    for(int i=0; i<n; i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        a--;\n        b--;\n        if(a != b) vet[b] = true;\n    }\n    int cont = 0;\n    for(int i=0; i<n; i++) if(!vet[i]) cont++;\n    printf(\"%d\\n\",cont);\n    return 0;\n}\n\n",
        "fixed_code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <deque>\n#include <iostream>\n#include <math.h>\n#include <sstream>\n#include <assert.h>\n#include <numeric>\n#include <limits>\n#define INF 0x3f3f3f3f\n\nusing namespace std;\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    int n,a,b;\n    scanf(\"%d\",&n);\n\n    int marca[n];\n    int abre[n];\n    int equalidades[1005];\n\n    int aparece[1005];\n\n    memset(aparece, 0, sizeof(aparece));\n    memset(equalidades, 0, sizeof(equalidades));\n\n    for(int i=0; i<n; i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        a--;\n        b--;\n\n        marca[i] = a;\n        abre[i] = b;\n        aparece[a]++;\n        if(a == b) equalidades[a]++;\n    }\n\n    int resp = n;\n\n    for(int i=0; i<n; i++)\n    {\n        if(aparece[abre[i]])\n        {\n            resp -= aparece[abre[i]];\n            aparece[abre[i]] = 0;\n            if(abre[i] == marca[i] && equalidades[abre[i]] == 1) { resp++; aparece[abre[i]] = 1; }\n        }\n    }\n\n    printf(\"%d\\n\",resp);\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    int t;cin>>t;\r\n    while(t--){\r\n        int n;cin>>n;\r\n        string s;cin>>s;\r\n        int c=0,cnt=0;\r\n        for(int i=0;i<n;i++){\r\n            if(s[i]=='Q')c++;\r\n            else cnt++;\r\n        }\r\n        \r\n        if(cnt>=c)cout<<\"yes\"<<endl;\r\n        else cout<<\"no\"<<endl;\r\n    }\r\n}",
        "fixed_code": "     #include<bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    int t;cin>>t;\r\n    while(t--){\r\n        int n;cin>>n;\r\n        string s;cin>>s;\r\n        int c=0,cnt=0;\r\n        for(int i=0;i<n;i++){\r\n            if(s[i]=='Q')c++;\r\n            else c=max(c-1,0);\r\n        }\r\n        if(c==0)cout<<\"yes\"<<endl;\r\n        else cout<<\"no\"<<endl;\r\n    }\r\n}\r\n    \r\n    ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public static boolean needAccount(java.lang.String component, android.content.Context context) {\n    android.accounts.AccountManager accountManager = android.accounts.AccountManager.get(context);\n    android.accounts.Account[] accounts = accountManager.getAccountsByType(\"com.openedt.auth\");\n    for (int i = 0; i < (accounts.length); i++) {\n        java.lang.String accountComponent = \"\";\n        accountComponent += accountManager.getUserData(accounts[i], \"component\");\n        android.util.Log.v(\"account_c\", accountComponent);\n        if (component.equals(accountComponent)) {\n            return false;\n        }\n    }\n    return true;\n}",
        "fixed_code": "public static boolean needAccount(java.lang.String component, android.content.Context context) {\n    java.util.HashMap<java.lang.String, java.lang.String> directory = fr.natinusala.openedt.manager.AuthManager.getAccountDirectory(context);\n    java.lang.String accountName = directory.get(component);\n    return accountName == null;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef pair<int, int> int2;\nconst int Inf = 1e9+7;\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcountll __popcnt64\n#endif\n#define mp make_pair \n#define endl '\\n'\n\nconst int N = 2e5+7;\nint n;\nmap<string, int> dic;\nset<int> act;\nint par[N], rnk[N];\nint op[N];\n\nint find(int x)\n{\n    if (x == 0) return 0;\n\n    if (par[x] == 0) {\n        par[x] = x;\n        rnk[x] = 0;\n        return x;\n    }\n\n    if (par[x] != x)\n        par[x] = find(par[x]);\n    return par[x];\n}\n\nvoid unite(int x, int y)\n{\n    if (x == 0 || y == 0) return;\n\n    int xr = find(x);\n    int yr = find(y);\n    if (xr == yr) return;\n    if (rnk[xr] < rnk[yr])\n        par[xr] = yr;\n    else if (rnk[xr] > rnk[yr])\n        par[yr] = xr;\n    else {\n        par[yr] = xr;\n        rnk[xr]++;\n    }\n}\n\nvoid solve()\n{\n    int m, q;\n    cin >> n >> m >> q;\n    for (int i = 1; i <= n; i++) {\n        string w; \n        cin >> w;\n        dic[w] = i;\n    }\n\n    for (int k = 0; k < m; k++) {\n        int type;\n        string as, bs;\n        cin >> type >> as >> bs;\n        int a = dic[as];\n        int b = dic[bs];\n\n        bool flag = true;\n        int ar = find(a);\n        int br = find(b);\n        if (type == 1) {\n            if (ar == op[br]) {\n                flag = false;\n            }\n            else {\n                unite(ar, br);\n                unite(op[ar], op[br]);\n                int new_ar = find(ar);\n                int new_op = find(op[ar]);\n                op[new_ar] = new_op;\n                op[new_op] = new_ar;\n            }\n        }\n        else {\n            if (ar == br || (ar != br && op[ar] && op[br])) {\n                flag = false;\n            }\n            else {\n                unite(op[ar], br);\n                unite(op[br], ar);\n                op[ar] = find(br);\n                op[br] = find(ar);\n            }\n        }\n        if (flag) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n\n    for (int k = 0; k < q; k++) {\n        string as, bs;\n        cin >> as >> bs;\n        int a = dic[as];\n        int b = dic[bs];\n        int ar = find(a);\n        int br = find(b);\n        if (ar == br) cout << \"1\" << endl;\n        else if (ar == op[br]) cout << \"2\" << endl;\n        else cout << \"3\" << endl;\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(9);\n    cout << fixed;\n\n    //clock_t ts;\n    //ts = clock();\n    solve();\n    //ts = clock()-ts;\n    //cout << ts*1000.0/CLOCKS_PER_SEC << \" ms\" << endl;\n\n    return 0;\n}\n\n",
        "fixed_code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef pair<int, int> int2;\nconst int Inf = 1e9+7;\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcountll __popcnt64\n#endif\n#define mp make_pair \n#define endl '\\n'\n\nconst int N = 2e5+7;\nint n;\nmap<string, int> dic;\nset<int> act;\nint par[N], rnk[N];\nint op[N];\n\nint find(int x)\n{\n    if (x == 0) return 0;\n\n    if (par[x] == 0) {\n        par[x] = x;\n        rnk[x] = 0;\n        return x;\n    }\n\n    if (par[x] != x)\n        par[x] = find(par[x]);\n    return par[x];\n}\n\nvoid unite(int x, int y)\n{\n    if (x == 0 || y == 0) return;\n\n    int xr = find(x);\n    int yr = find(y);\n    if (xr == yr) return;\n    if (rnk[xr] < rnk[yr])\n        par[xr] = yr;\n    else if (rnk[xr] > rnk[yr])\n        par[yr] = xr;\n    else {\n        par[yr] = xr;\n        rnk[xr]++;\n    }\n}\n\nvoid solve()\n{\n    int m, q;\n    cin >> n >> m >> q;\n    for (int i = 1; i <= n; i++) {\n        string w; \n        cin >> w;\n        dic[w] = i;\n    }\n\n    for (int k = 0; k < m; k++) {\n        int type;\n        string as, bs;\n        cin >> type >> as >> bs;\n        int a = dic[as];\n        int b = dic[bs];\n\n        bool flag = true;\n        int ar = find(a);\n        int br = find(b);\n        if (type == 1) {\n            if (ar == op[br]) {\n                flag = false;\n            }\n            else {\n                unite(ar, br);\n                unite(op[ar], op[br]);\n                int new_ar = find(ar);\n                int new_op = op[ar] ? find(op[ar]) : find(op[br]);\n                op[new_ar] = new_op;\n                op[new_op] = new_ar;\n            }\n        }\n        else {\n            if (ar == br) {\n                flag = false;\n            }\n            else {\n                unite(ar, op[br]);\n                unite(br, op[ar]);\n                int new_ar = find(ar);\n                int new_br = find(br);\n                op[new_ar] = new_br;\n                op[new_br] = new_ar;\n            }\n        }\n        if (flag) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n\n    for (int k = 0; k < q; k++) {\n        string as, bs;\n        cin >> as >> bs;\n        int a = dic[as];\n        int b = dic[bs];\n        int ar = find(a);\n        int br = find(b);\n        if (ar == br) cout << \"1\" << endl;\n        else if (ar == op[br]) cout << \"2\" << endl;\n        else cout << \"3\" << endl;\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(9);\n    cout << fixed;\n\n    //clock_t ts;\n    //ts = clock();\n    solve();\n    //ts = clock()-ts;\n    //cout << ts*1000.0/CLOCKS_PER_SEC << \" ms\" << endl;\n\n    return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mpi map<ll,ll>\n#define vl vector<ll>\n#define mp make_pair\n#define pl pair<ll,ll>\n#define forn(i,n) for(ll i=0;i<n;i++)\n#define ff first\n#define ss second\n#define fast ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define inf       1000000000000\n#define MOD       998244353\n\nvoid solve()\n{\n\tll n,x,y;\n\tcin>>n>>x>>y;\n\tif(n==2)\n\t{\n\t\tcout<<x<<\" \"<<y;\n\t\treturn;\n\t}\n\tll j=n-1,k;\n\tll d=y-x;\n\tfor(ll i=j;i>=1;i--)\n\t{\n\t\tif(d%i==0)\n\t\t{\n\t\t\tk=d/i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tj=1;\n\tll mn=x;\n\tforn(i,n)\n\t{\n\t\tif(x+i*k<=y || mn-k<=0)\n\t\tcout<<x+i*k<<\" \";\n\t\telse\n\t\t{\n\t\t\tmn=mn-k;\n\t\t\tcout<<mn<<\" \";\n\t\t}\n\t}\t\n}\n\nint main()\n{\n\tfast\n\t//pre();\n\tll t=1;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t\tcout<<endl;\n\t}\n}   ",
        "fixed_code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mpi map<ll,ll>\n#define vl vector<ll>\n#define mp make_pair\n#define pl pair<ll,ll>\n#define forn(i,n) for(ll i=0;i<n;i++)\n#define ff first\n#define ss second\n#define fast ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define inf       1000000000000\n#define MOD       998244353\n\nvoid solve()\n{\n\tll n,x,y;\n\tcin>>n>>x>>y;\n\tif(n==2)\n\t{\n\t\tcout<<x<<\" \"<<y;\n\t\treturn;\n\t}\n\tll j=n-1,k;\n\tll d=y-x;\n\tfor(ll i=j;i>=1;i--)\n\t{\n\t\tif(d%i==0)\n\t\t{\n\t\t\tk=d/i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tj=1;\n\tll mn=x;\n\tforn(i,n)\n\t{\n\t\tif(mn+i*k<=y || mn-k<=0)\n\t\tcout<<mn+i*k<<\" \";\n\t\telse\n\t\t{\n\t\t\tmn=mn-k;\n\t\t\tcout<<mn<<\" \";\n\t\t}\n\t}\t\n}\n\nint main()\n{\n\tfast\n\t//pre();\n\tll t=1;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t\tcout<<endl;\n\t}\n}   ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "// package practice;\r\nimport java.io.*;\r\nimport java.util.*;\r\nimport java.util.Map.Entry;\r\n\r\npublic class cp\r\n{\t\t\r\n\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\t\r\n\t\t//Your Solve\r\n\t\t//\t\tReader s = new Reader();\r\n\t\tFastReader s = new FastReader();\r\n\t\t//\t\tScanner s = new Scanner(System.in);\r\n\t\tint t = s.nextInt();\r\n\t\t\r\n\t\tfor(int p = 0;p < t;p++) {\r\n\t\t\t\r\n\t\t\tint n = s.nextInt();\r\n\t\t\tint arr[] = new int[n];\r\n\t\t\t\r\n\t\t\tfor(int i = 0;i < n;i++) {\r\n\t\t\t\tarr[i] = s.nextInt();\r\n\t\t\t}\r\n\t\t\tif(n==4) {\r\n\t\t\t\tlong ans = Integer.MAX_VALUE;\r\n\t\t\t\tlong curr = 0;\r\n\t\t\t\t\r\n\t\t\t\tfor(int i = 2;i < n;i += 2) {\r\n\t\t\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tans = Math.min(ans, curr);\r\n\t\t\t\tcurr = 0;\r\n\t\t\t\tfor(int i = 1;i < n-1;i += 2) {\r\n\t\t\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t\t\t}\r\n\t\t\t\tans = Math.min(ans, curr);\r\n\t\t\t\tSystem.out.println(ans);\r\n\t\t\t\t\r\n\t\t\t}else if(n%2==0) {\r\n\t\t\t\tlong ans = Integer.MAX_VALUE;\r\n//\t\t\t\tlong curr = 0;\r\n\t\t\t\tans = Math.min(ans, solve(arr,1,n-2));\r\n\t\t\t\t\r\n//\t\t\t\tfor(int i = 2;i < n;i += 2) {\r\n//\t\t\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n//\t\t\t\t}\r\n//\t\t\t\tans = Math.min(ans, curr);\r\n\t\t\t\tSystem.out.println(ans);\r\n\t\t\t}else {\r\n\t\t\t\tlong ans = 0;\r\n\t\t\t\tfor(int i = 1;i < n;i += 2) {\r\n\t\t\t\t\tans += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t\t\t}\r\n\t\t\t\tSystem.out.println(ans);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\t\r\n\t}\r\n\t\r\n\tpublic static long solve(int arr[],int start,int end) {\r\n\t\tint n = arr.length;\r\n//\t\tSystem.out.println(start+ \" \" + end);\r\n\t\tif(end - start == 1) {\r\n\t\t\tlong ans = Integer.MAX_VALUE;\r\n\t\t\tlong curr = 0;\r\n\t\t\t\r\n//\t\t\tfor(int i = start;i < n-1;i += 2) {\r\n\t\t\t\tcurr = Math.max(0,Math.max(arr[start-1], arr[start+1])-arr[start]+1);\r\n//\t\t\t}\r\n\r\n\t\t\tans = Math.min(ans, curr);\r\n\t\t\tcurr = 0;\r\n//\t\t\tfor(int i = start+1;i < n-1;i += 2) {\r\n\t\t\t\tcurr += Math.max(0,Math.max(arr[end-1], arr[end+1])-arr[end]+1);\r\n//\t\t\t}\r\n\t\t\tans = Math.min(ans, curr);\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t\t\r\n\t\tlong ans = Integer.MAX_VALUE;\r\n\t\tlong curr = 0;\r\n\t\tans = Math.min(ans,Math.max(0,Math.max(arr[start-1], arr[start+1])-arr[start]+1) + solve(arr,start+2,end));\r\n\t\t\r\n\t\tfor(int i = start+1;i < arr.length;i += 2) {\r\n\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t}\r\n\t\tans = Math.min(ans, curr);\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static int brute(int start,int end) {\r\n\t\tint ans = 0;\r\n\t\tif(start > end) {\r\n\t\t\treturn 0;\r\n\t\t}else if(start==end) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tint mid = (start+end)/2;\r\n\t\tans += brute(start,mid-1) + brute(mid+1,end);\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static int gcd(int a,int b) {\r\n\t\t\r\n\t\tif(a<b) {\r\n\t\t\tint temp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = temp;\r\n\t\t}\r\n\t\t\r\n\t\tif(b==0) return a;\r\n\t\t\r\n\t\twhile(a%b!=0) {\r\n\t\t\tint temp = a%b; \r\n\t\t\ta = b;\r\n\t\t\tb = temp;\r\n\t\t\tif(b==0) return a;\r\n\t\t}\r\n\t\treturn b;\r\n\t}\r\n\t\r\n\tpublic static int myGcd(int a,int b) {\r\n\t\tif(a<b) {\r\n\t\t\tint temp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = temp;\r\n\t\t}\r\n\t\t\r\n\t\twhile(b!=0) {\r\n\t\t\tint temp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = temp%b;\r\n\t\t}\r\n\t\treturn a;\r\n\t}\r\n\t\r\n\tpublic static Vector<Integer> sieveOfEratosthenes(int n)\r\n\t{\r\n\t\t// Create a boolean array\r\n\t\t// \"prime[0..n]\" and\r\n\t\t// initialize all entries\r\n\t\t// it as true. A value in\r\n\t\t// prime[i] will finally be\r\n\t\t// false if i is Not a\r\n\t\t// prime, else true.\r\n\t\tboolean prime[] = new boolean[n + 1];\r\n\t\tfor (int i = 0; i <= n; i++)\r\n\t\t\tprime[i] = true;\r\n\r\n\t\tfor (int p = 2; p * p <= n; p++)\r\n\t\t{\r\n\t\t\t// If prime[p] is not changed, then it is a\r\n\t\t\t// prime\r\n\t\t\tif (prime[p] == true)\r\n\t\t\t{\r\n\t\t\t\t// Update all multiples of p\r\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\r\n\t\t\t\t\tprime[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tVector<Integer> v = new Vector<>();\r\n\t\t// Print all prime numbers\r\n\t\tfor (int i = 2; i <= n; i++)\r\n\t\t{\r\n\t\t\tif (prime[i] == true)\r\n\t\t\t\tv.add(i);\r\n\t\t}\r\n\t\treturn v;\r\n\t}\r\n\tpublic static int logbase2(long n) {\r\n\t\tint count = 0;\r\n\t\tif(n==0) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\twhile(n >= 2) {\r\n\t\t\tn /= 2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\tpublic static boolean isPrime(int n)\r\n\t{\r\n\t    // Corner cases\r\n\t    if (n <= 1)  return false;\r\n\t    if (n <= 3)  return true;\r\n\t   \r\n\t    // This is checked so that we can skip \r\n\t    // middle five numbers in below loop\r\n\t    if (n%2 == 0 || n%3 == 0) return false;\r\n\t   \r\n\t    for (int i=5; i*i<=n; i=i+6)\r\n\t        if (n%i == 0 || n%(i+2) == 0)\r\n\t           return false;\r\n\t   \r\n\t    return true;\r\n\t}\r\n\t\r\n\r\n\tstatic long binomialCoeff(long n, long k)\r\n\t{\r\n\t\tlong res = 1;\r\n\r\n\t\t// Since C(n, k) = C(n, n-k)\r\n\t\tif (k > n - k)\r\n\t\t\tk = n - k;\r\n\r\n\t\t// Calculate value of\r\n\t\t// [n * (n-1) *---* (n-k+1)] / [k * (k-1) *----* 1]\r\n\t\tfor (int i = 0; i < k; ++i) {\r\n\t\t\tres *= (n - i);\r\n\t\t\tres /= (i + 1);\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\tpublic static void shuffleArray(int[] ar)\r\n\t{\r\n\t\t// If running on Java 6 or older, use `new Random()` on RHS here\r\n\t\tRandom rnd = new Random();\r\n\t\tfor (int i = ar.length - 1; i > 0; i--)\r\n\t\t{\r\n\t\t\tint index = rnd.nextInt(i + 1);\r\n\t\t\t// Simple swap\r\n\t\t\tint a = ar[index];\r\n\t\t\tar[index] = ar[i];\r\n\t\t\tar[i] = a;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Iterative Function to calculate (x^y) in O(log y) */\r\n\tstatic long power(long x, long y, long p)\r\n\t{\r\n\t\tlong res = 1; // Initialize result\r\n\r\n\t\tx = x % p; // Update x if it is more than or\r\n\t\t// equal to p\r\n\r\n\t\tif (x == 0)\r\n\t\t\treturn 0; // In case x is divisible by p;\r\n\r\n\t\twhile (y > 0)\r\n\t\t{\r\n\r\n\t\t\t// If y is odd, multiply x with result\r\n\t\t\tif ((y & 1) != 0)\r\n\t\t\t\tres = (res * x) % p;\r\n\r\n\t\t\t// y must be even now\r\n\t\t\ty = y >> 1; // y = y/2\r\n\t\tx = (x * x) % p;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\r\n\r\n\tstatic long getPairsCount(int n, long sum,long arr[])\r\n\t{\r\n\t\tHashMap<Long, Integer> hm = new HashMap<>();\r\n\r\n\t\t// Store counts of all elements in map hm\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\r\n\t\t\t// initializing value to 0, if key not found\r\n\t\t\tif (!hm.containsKey(arr[i]))\r\n\t\t\t\thm.put(arr[i], 0);\r\n\r\n\t\t\thm.put(arr[i], hm.get(arr[i]) + 1);\r\n\t\t}\r\n\t\tlong twice_count = 0;\r\n\r\n\t\t// iterate through each element and increment the\r\n\t\t// count (Notice that every pair is counted twice)\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tif (hm.get(sum - arr[i]) != null)\r\n\t\t\t\ttwice_count += hm.get(sum - arr[i]);\r\n\r\n\t\t\t// if (arr[i], arr[i]) pair satisfies the\r\n\t\t\t// condition, then we need to ensure that the\r\n\t\t\t// count is decreased by one such that the\r\n\t\t\t// (arr[i], arr[i]) pair is not considered\r\n\t\t\tif (sum - arr[i] == arr[i])\r\n\t\t\t\ttwice_count--;\r\n\t\t}\r\n\r\n\t\t// return the half of twice_count\r\n\t\treturn twice_count / 2;\r\n\t}\r\n\r\n\tpublic static<T,V> HashMap<T,V>\r\n\tsortByValue(HashMap<T,V> hm)\r\n\t{\r\n\t\t// Create a list from elements of HashMap\r\n\t\tList<Map.Entry<T,V> > list\r\n\t\t= new LinkedList<Map.Entry<T,V> >(\r\n\t\t\t\thm.entrySet());\r\n\r\n\t\t// Sort the list using lambda expression\r\n\t\tCollections.sort(\r\n\t\t\t\tlist,\r\n\t\t\t\t(i1,\r\n\t\t\t\t\t\ti2) -> ((String) i1.getValue()).compareTo((String) i2.getValue()));\r\n\r\n\t\t// put data from sorted list to hashmap\r\n\t\tHashMap<T,V> temp\r\n\t\t= new LinkedHashMap<T,V>();\r\n\t\tfor (Map.Entry<T,V> aa : list) {\r\n\t\t\ttemp.put(aa.getKey(), aa.getValue());\r\n\t\t}\r\n\t\treturn temp;\r\n\t}\r\n\r\n\tpublic static<T> HashMap<T,Integer>\r\n\tsortByValueDescending(HashMap<T,Integer> unSortedMap)\r\n\t{\r\n\t\tLinkedHashMap<T,Integer> reverseSortedMap = new LinkedHashMap<>();\r\n\t\tunSortedMap.entrySet().stream().sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\r\n\t\t.forEachOrdered(x -> reverseSortedMap.put(x.getKey(), x.getValue()));\r\n\r\n\t\treturn reverseSortedMap;\r\n\t}\r\n\r\n\r\n\tstatic int lower_bound(long array[], long key,long start,long end)\r\n\t{\r\n\t\t// Initialize starting index and\r\n\t\t// ending index\r\n\t\tlong low = start, high = end;\r\n\t\tlong mid;\r\n\r\n\t\t// Till high does not crosses low\r\n\t\twhile (low < high) {\r\n\r\n\t\t\t// Find the index of the middle element\r\n\t\t\tmid = low + (high - low) / 2;\r\n\r\n\t\t\t// If key is less than or equal\r\n\t\t\t// to array[mid], then find in\r\n\t\t\t// left subarray\r\n\t\t\tif (key <= array[(int)mid]) {\r\n\t\t\t\thigh = mid;\r\n\t\t\t}\r\n\r\n\t\t\t// If key is greater than array[mid],\r\n\t\t\t// then find in right subarray\r\n\t\t\telse {\r\n\r\n\t\t\t\tlow = mid + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If key is greater than last element which is\r\n\t\t// array[n-1] then lower bound\r\n\t\t// does not exists in the array\r\n\t\tif (low < end && array[(int)low] < key) {\r\n\t\t\tlow++;\r\n\t\t}\r\n\r\n\t\t// Returning the lower_bound index\r\n\t\treturn (int)low;\r\n\t}\r\n\r\n\tstatic int upper_bound(long array[], long key,long start,long end)\r\n\t{\r\n\t\t// Initialize starting index and\r\n\t\t// ending index\r\n\t\tlong low = start, high = end;\r\n\t\tlong mid;\r\n\r\n\t\t// Till high does not crosses low\r\n\t\twhile (low < high) {\r\n\r\n\t\t\t// Find the index of the middle element\r\n\t\t\tmid = low + (high - low) / 2;\r\n\r\n\t\t\t// If key is less than or equal\r\n\t\t\t// to array[mid], then find in\r\n\t\t\t// left subarray\r\n\t\t\tif (key >= array[(int)mid]) {\r\n\t\t\t\tlow = mid+1;\r\n\t\t\t}\r\n\r\n\t\t\t// If key is greater than array[mid],\r\n\t\t\t// then find in right subarray\r\n\t\t\telse {\r\n\r\n\t\t\t\thigh = mid;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If key is greater than last element which is\r\n\t\t// array[n-1] then lower bound\r\n\t\t// does not exists in the array\r\n\t\tif (low < end && array[(int)low] <= key) {\r\n\t\t\tlow++;\r\n\t\t}\r\n\r\n\t\t// Returning the lower_bound index\r\n\t\treturn (int)low;\r\n\t}\r\n\r\n\tstatic class FastReader {\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\tpublic FastReader()\r\n\t\t{\r\n\t\t\tbr = new BufferedReader(\r\n\t\t\t\t\tnew InputStreamReader(System.in));\r\n\t\t}\r\n\r\n\t\tString next()\r\n\t\t{\r\n\t\t\twhile (st == null || !st.hasMoreElements()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t}\r\n\t\t\t\tcatch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tint nextInt() { return Integer.parseInt(next()); }\r\n\r\n\t\tlong nextLong() { return Long.parseLong(next()); }\r\n\r\n\t\tdouble nextDouble()\r\n\t\t{\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tString nextLine()\r\n\t\t{\r\n\t\t\tString str = \"\";\r\n\t\t\ttry {\r\n\t\t\t\tstr = br.readLine();\r\n\t\t\t}\r\n\t\t\tcatch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t}\r\n\t}\r\n\tstatic class Reader {\r\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\r\n\t\tprivate DataInputStream din;\r\n\t\tprivate byte[] buffer;\r\n\t\tprivate int bufferPointer, bytesRead;\r\n\r\n\t\tpublic Reader()\r\n\t\t{\r\n\t\t\tdin = new DataInputStream(System.in);\r\n\t\t\tbuffer = new byte[BUFFER_SIZE];\r\n\t\t\tbufferPointer = bytesRead = 0;\r\n\t\t}\r\n\r\n\t\tpublic Reader(String file_name) throws IOException\r\n\t\t{\r\n\t\t\tdin = new DataInputStream(\r\n\t\t\t\t\tnew FileInputStream(file_name));\r\n\t\t\tbuffer = new byte[BUFFER_SIZE];\r\n\t\t\tbufferPointer = bytesRead = 0;\r\n\t\t}\r\n\r\n\t\tpublic String readLine() throws IOException\r\n\t\t{\r\n\t\t\tbyte[] buf = new byte[64]; // line length\r\n\t\t\tint cnt = 0, c;\r\n\t\t\twhile ((c = read()) != -1) {\r\n\t\t\t\tif (c == '\\n') {\r\n\t\t\t\t\tif (cnt != 0) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbuf[cnt++] = (byte)c;\r\n\t\t\t}\r\n\t\t\treturn new String(buf, 0, cnt);\r\n\t\t}\r\n\r\n\t\tpublic int nextInt() throws IOException\r\n\t\t{\r\n\t\t\tint ret = 0;\r\n\t\t\tbyte c = read();\r\n\t\t\twhile (c <= ' ') {\r\n\t\t\t\tc = read();\r\n\t\t\t}\r\n\t\t\tboolean neg = (c == '-');\r\n\t\t\tif (neg)\r\n\t\t\t\tc = read();\r\n\t\t\tdo {\r\n\t\t\t\tret = ret * 10 + c - '0';\r\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\r\n\r\n\t\t\tif (neg)\r\n\t\t\t\treturn -ret;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tpublic long nextLong() throws IOException\r\n\t\t{\r\n\t\t\tlong ret = 0;\r\n\t\t\tbyte c = read();\r\n\t\t\twhile (c <= ' ')\r\n\t\t\t\tc = read();\r\n\t\t\tboolean neg = (c == '-');\r\n\t\t\tif (neg)\r\n\t\t\t\tc = read();\r\n\t\t\tdo {\r\n\t\t\t\tret = ret * 10 + c - '0';\r\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\r\n\t\t\tif (neg)\r\n\t\t\t\treturn -ret;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tpublic double nextDouble() throws IOException\r\n\t\t{\r\n\t\t\tdouble ret = 0, div = 1;\r\n\t\t\tbyte c = read();\r\n\t\t\twhile (c <= ' ')\r\n\t\t\t\tc = read();\r\n\t\t\tboolean neg = (c == '-');\r\n\t\t\tif (neg)\r\n\t\t\t\tc = read();\r\n\r\n\t\t\tdo {\r\n\t\t\t\tret = ret * 10 + c - '0';\r\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\r\n\r\n\t\t\tif (c == '.') {\r\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\r\n\t\t\t\t\tret += (c - '0') / (div *= 10);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (neg)\r\n\t\t\t\treturn -ret;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tprivate void fillBuffer() throws IOException\r\n\t\t{\r\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0,\r\n\t\t\t\t\tBUFFER_SIZE);\r\n\t\t\tif (bytesRead == -1)\r\n\t\t\t\tbuffer[0] = -1;\r\n\t\t}\r\n\r\n\t\tprivate byte read() throws IOException\r\n\t\t{\r\n\t\t\tif (bufferPointer == bytesRead)\r\n\t\t\t\tfillBuffer();\r\n\t\t\treturn buffer[bufferPointer++];\r\n\t\t}\r\n\r\n\t\tpublic void close() throws IOException\r\n\t\t{\r\n\t\t\tif (din == null)\r\n\t\t\t\treturn;\r\n\t\t\tdin.close();\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\nclass Pair{\r\n\tint lastOcc;\r\n\tchar ch;\r\n\tpublic Pair(int lastOcc,char ch) {\r\n\t\tthis.lastOcc = lastOcc;\r\n\t\tthis.ch = ch;\r\n\t}\r\n\t\r\n\tstatic class PairComparator implements Comparator<Pair>{\r\n\r\n\t\tpublic int compare(Pair p1,Pair p2) {\r\n\t\t\treturn (p1.lastOcc < p2.lastOcc) ? -1 : 1;\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n\r\nclass Domino{\r\n\tint a,b;\r\n\tboolean visited;\r\n\tpublic Domino(int a,int b) {\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tvisited = false;\r\n\t}\r\n}\r\n\r\n",
        "fixed_code": "// package practice;\r\nimport java.io.*;\r\nimport java.util.*;\r\nimport java.util.Map.Entry;\r\n\r\npublic class cp\r\n{\t\t\r\n\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\t\r\n\t\t//Your Solve\r\n\t\t//\t\tReader s = new Reader();\r\n\t\tFastReader s = new FastReader();\r\n\t\t//\t\tScanner s = new Scanner(System.in);\r\n\t\tint t = s.nextInt();\r\n\t\t\r\n\t\tfor(int p = 0;p < t;p++) {\r\n\t\t\t\r\n\t\t\tint n = s.nextInt();\r\n\t\t\tint arr[] = new int[n];\r\n\t\t\t\r\n\t\t\tfor(int i = 0;i < n;i++) {\r\n\t\t\t\tarr[i] = s.nextInt();\r\n\t\t\t}\r\n\t\t\tif(n==4) {\r\n\t\t\t\tlong ans = Long.MAX_VALUE;\r\n\t\t\t\tlong curr = 0;\r\n\t\t\t\t\r\n\t\t\t\tfor(int i = 2;i < n;i += 2) {\r\n\t\t\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tans = Math.min(ans, curr);\r\n\t\t\t\tcurr = 0;\r\n\t\t\t\tfor(int i = 1;i < n-1;i += 2) {\r\n\t\t\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t\t\t}\r\n\t\t\t\tans = Math.min(ans, curr);\r\n\t\t\t\tSystem.out.println(ans);\r\n\t\t\t\t\r\n\t\t\t}else if(n%2==0) {\r\n\t\t\t\tlong ans = Long.MAX_VALUE;\r\n\t\t\t\tlong dp[] = new long[n];\r\n\t\t\t\tdp[n-2] = Math.max(0,Math.max(arr[n-3], arr[n-1])-arr[n-2]+1);\r\n\t\t\t\tfor(int i = n-4;i >= 2;i -= 2) {\r\n\t\t\t\t\tdp[i] += dp[i+2] + Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n//\t\t\t\tlong curr = 0;\r\n\t\t\t\tans = Math.min(ans, solve(arr,1,n-2,dp));\r\n\t\t\t\t\r\n//\t\t\t\tfor(int i = 2;i < n;i += 2) {\r\n//\t\t\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n//\t\t\t\t}\r\n//\t\t\t\tans = Math.min(ans, curr);\r\n\t\t\t\tSystem.out.println(ans);\r\n\t\t\t}else {\r\n\t\t\t\tlong ans = 0;\r\n\t\t\t\tfor(int i = 1;i < n;i += 2) {\r\n\t\t\t\t\tans += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n\t\t\t\t}\r\n\t\t\t\tSystem.out.println(ans);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\t\r\n\t}\r\n\t\r\n\tpublic static long solve(int arr[],int start,int end,long dp[]) {\r\n\t\tint n = arr.length;\r\n//\t\tSystem.out.println(start+ \" \" + end);\r\n\t\tif(end - start == 1) {\r\n\t\t\tlong ans = Long.MAX_VALUE;\r\n\t\t\tlong curr = 0;\r\n\t\t\t\r\n//\t\t\tfor(int i = start;i < n-1;i += 2) {\r\n\t\t\t\tcurr = Math.max(0,Math.max(arr[start-1], arr[start+1])-arr[start]+1);\r\n//\t\t\t}\r\n\r\n\t\t\tans = Math.min(ans, curr);\r\n\t\t\tcurr = 0;\r\n//\t\t\tfor(int i = start+1;i < n-1;i += 2) {\r\n\t\t\t\tcurr += Math.max(0,Math.max(arr[end-1], arr[end+1])-arr[end]+1);\r\n//\t\t\t}\r\n\t\t\tans = Math.min(ans, curr);\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t\t\r\n\t\tlong ans = Long.MAX_VALUE;\r\n\t\tlong curr = 0;\r\n\t\tans = Math.min(ans,Math.max(0,Math.max(arr[start-1], arr[start+1])-arr[start]+1) + solve(arr,start+2,end,dp));\r\n\t\t\r\n//\t\tfor(int i = start+1;i < arr.length;i += 2) {\r\n//\t\t\tcurr += Math.max(0,Math.max(arr[i-1], arr[i+1])-arr[i]+1);\r\n//\t\t}\r\n//\t\tans = Math.min(ans, curr);\r\n\t\tans = Math.min(ans, dp[start+1]);\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static int brute(int start,int end) {\r\n\t\tint ans = 0;\r\n\t\tif(start > end) {\r\n\t\t\treturn 0;\r\n\t\t}else if(start==end) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tint mid = (start+end)/2;\r\n\t\tans += brute(start,mid-1) + brute(mid+1,end);\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static int gcd(int a,int b) {\r\n\t\t\r\n\t\tif(a<b) {\r\n\t\t\tint temp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = temp;\r\n\t\t}\r\n\t\t\r\n\t\tif(b==0) return a;\r\n\t\t\r\n\t\twhile(a%b!=0) {\r\n\t\t\tint temp = a%b; \r\n\t\t\ta = b;\r\n\t\t\tb = temp;\r\n\t\t\tif(b==0) return a;\r\n\t\t}\r\n\t\treturn b;\r\n\t}\r\n\t\r\n\tpublic static int myGcd(int a,int b) {\r\n\t\tif(a<b) {\r\n\t\t\tint temp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = temp;\r\n\t\t}\r\n\t\t\r\n\t\twhile(b!=0) {\r\n\t\t\tint temp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = temp%b;\r\n\t\t}\r\n\t\treturn a;\r\n\t}\r\n\t\r\n\tpublic static Vector<Integer> sieveOfEratosthenes(int n)\r\n\t{\r\n\t\t// Create a boolean array\r\n\t\t// \"prime[0..n]\" and\r\n\t\t// initialize all entries\r\n\t\t// it as true. A value in\r\n\t\t// prime[i] will finally be\r\n\t\t// false if i is Not a\r\n\t\t// prime, else true.\r\n\t\tboolean prime[] = new boolean[n + 1];\r\n\t\tfor (int i = 0; i <= n; i++)\r\n\t\t\tprime[i] = true;\r\n\r\n\t\tfor (int p = 2; p * p <= n; p++)\r\n\t\t{\r\n\t\t\t// If prime[p] is not changed, then it is a\r\n\t\t\t// prime\r\n\t\t\tif (prime[p] == true)\r\n\t\t\t{\r\n\t\t\t\t// Update all multiples of p\r\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\r\n\t\t\t\t\tprime[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tVector<Integer> v = new Vector<>();\r\n\t\t// Print all prime numbers\r\n\t\tfor (int i = 2; i <= n; i++)\r\n\t\t{\r\n\t\t\tif (prime[i] == true)\r\n\t\t\t\tv.add(i);\r\n\t\t}\r\n\t\treturn v;\r\n\t}\r\n\tpublic static int logbase2(long n) {\r\n\t\tint count = 0;\r\n\t\tif(n==0) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\twhile(n >= 2) {\r\n\t\t\tn /= 2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\tpublic static boolean isPrime(int n)\r\n\t{\r\n\t    // Corner cases\r\n\t    if (n <= 1)  return false;\r\n\t    if (n <= 3)  return true;\r\n\t   \r\n\t    // This is checked so that we can skip \r\n\t    // middle five numbers in below loop\r\n\t    if (n%2 == 0 || n%3 == 0) return false;\r\n\t   \r\n\t    for (int i=5; i*i<=n; i=i+6)\r\n\t        if (n%i == 0 || n%(i+2) == 0)\r\n\t           return false;\r\n\t   \r\n\t    return true;\r\n\t}\r\n\t\r\n\r\n\tstatic long binomialCoeff(long n, long k)\r\n\t{\r\n\t\tlong res = 1;\r\n\r\n\t\t// Since C(n, k) = C(n, n-k)\r\n\t\tif (k > n - k)\r\n\t\t\tk = n - k;\r\n\r\n\t\t// Calculate value of\r\n\t\t// [n * (n-1) *---* (n-k+1)] / [k * (k-1) *----* 1]\r\n\t\tfor (int i = 0; i < k; ++i) {\r\n\t\t\tres *= (n - i);\r\n\t\t\tres /= (i + 1);\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\tpublic static void shuffleArray(int[] ar)\r\n\t{\r\n\t\t// If running on Java 6 or older, use `new Random()` on RHS here\r\n\t\tRandom rnd = new Random();\r\n\t\tfor (int i = ar.length - 1; i > 0; i--)\r\n\t\t{\r\n\t\t\tint index = rnd.nextInt(i + 1);\r\n\t\t\t// Simple swap\r\n\t\t\tint a = ar[index];\r\n\t\t\tar[index] = ar[i];\r\n\t\t\tar[i] = a;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Iterative Function to calculate (x^y) in O(log y) */\r\n\tstatic long power(long x, long y, long p)\r\n\t{\r\n\t\tlong res = 1; // Initialize result\r\n\r\n\t\tx = x % p; // Update x if it is more than or\r\n\t\t// equal to p\r\n\r\n\t\tif (x == 0)\r\n\t\t\treturn 0; // In case x is divisible by p;\r\n\r\n\t\twhile (y > 0)\r\n\t\t{\r\n\r\n\t\t\t// If y is odd, multiply x with result\r\n\t\t\tif ((y & 1) != 0)\r\n\t\t\t\tres = (res * x) % p;\r\n\r\n\t\t\t// y must be even now\r\n\t\t\ty = y >> 1; // y = y/2\r\n\t\tx = (x * x) % p;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\r\n\r\n\tstatic long getPairsCount(int n, long sum,long arr[])\r\n\t{\r\n\t\tHashMap<Long, Integer> hm = new HashMap<>();\r\n\r\n\t\t// Store counts of all elements in map hm\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\r\n\t\t\t// initializing value to 0, if key not found\r\n\t\t\tif (!hm.containsKey(arr[i]))\r\n\t\t\t\thm.put(arr[i], 0);\r\n\r\n\t\t\thm.put(arr[i], hm.get(arr[i]) + 1);\r\n\t\t}\r\n\t\tlong twice_count = 0;\r\n\r\n\t\t// iterate through each element and increment the\r\n\t\t// count (Notice that every pair is counted twice)\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tif (hm.get(sum - arr[i]) != null)\r\n\t\t\t\ttwice_count += hm.get(sum - arr[i]);\r\n\r\n\t\t\t// if (arr[i], arr[i]) pair satisfies the\r\n\t\t\t// condition, then we need to ensure that the\r\n\t\t\t// count is decreased by one such that the\r\n\t\t\t// (arr[i], arr[i]) pair is not considered\r\n\t\t\tif (sum - arr[i] == arr[i])\r\n\t\t\t\ttwice_count--;\r\n\t\t}\r\n\r\n\t\t// return the half of twice_count\r\n\t\treturn twice_count / 2;\r\n\t}\r\n\r\n\tpublic static<T,V> HashMap<T,V>\r\n\tsortByValue(HashMap<T,V> hm)\r\n\t{\r\n\t\t// Create a list from elements of HashMap\r\n\t\tList<Map.Entry<T,V> > list\r\n\t\t= new LinkedList<Map.Entry<T,V> >(\r\n\t\t\t\thm.entrySet());\r\n\r\n\t\t// Sort the list using lambda expression\r\n\t\tCollections.sort(\r\n\t\t\t\tlist,\r\n\t\t\t\t(i1,\r\n\t\t\t\t\t\ti2) -> ((String) i1.getValue()).compareTo((String) i2.getValue()));\r\n\r\n\t\t// put data from sorted list to hashmap\r\n\t\tHashMap<T,V> temp\r\n\t\t= new LinkedHashMap<T,V>();\r\n\t\tfor (Map.Entry<T,V> aa : list) {\r\n\t\t\ttemp.put(aa.getKey(), aa.getValue());\r\n\t\t}\r\n\t\treturn temp;\r\n\t}\r\n\r\n\tpublic static<T> HashMap<T,Integer>\r\n\tsortByValueDescending(HashMap<T,Integer> unSortedMap)\r\n\t{\r\n\t\tLinkedHashMap<T,Integer> reverseSortedMap = new LinkedHashMap<>();\r\n\t\tunSortedMap.entrySet().stream().sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\r\n\t\t.forEachOrdered(x -> reverseSortedMap.put(x.getKey(), x.getValue()));\r\n\r\n\t\treturn reverseSortedMap;\r\n\t}\r\n\r\n\r\n\tstatic int lower_bound(long array[], long key,long start,long end)\r\n\t{\r\n\t\t// Initialize starting index and\r\n\t\t// ending index\r\n\t\tlong low = start, high = end;\r\n\t\tlong mid;\r\n\r\n\t\t// Till high does not crosses low\r\n\t\twhile (low < high) {\r\n\r\n\t\t\t// Find the index of the middle element\r\n\t\t\tmid = low + (high - low) / 2;\r\n\r\n\t\t\t// If key is less than or equal\r\n\t\t\t// to array[mid], then find in\r\n\t\t\t// left subarray\r\n\t\t\tif (key <= array[(int)mid]) {\r\n\t\t\t\thigh = mid;\r\n\t\t\t}\r\n\r\n\t\t\t// If key is greater than array[mid],\r\n\t\t\t// then find in right subarray\r\n\t\t\telse {\r\n\r\n\t\t\t\tlow = mid + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If key is greater than last element which is\r\n\t\t// array[n-1] then lower bound\r\n\t\t// does not exists in the array\r\n\t\tif (low < end && array[(int)low] < key) {\r\n\t\t\tlow++;\r\n\t\t}\r\n\r\n\t\t// Returning the lower_bound index\r\n\t\treturn (int)low;\r\n\t}\r\n\r\n\tstatic int upper_bound(long array[], long key,long start,long end)\r\n\t{\r\n\t\t// Initialize starting index and\r\n\t\t// ending index\r\n\t\tlong low = start, high = end;\r\n\t\tlong mid;\r\n\r\n\t\t// Till high does not crosses low\r\n\t\twhile (low < high) {\r\n\r\n\t\t\t// Find the index of the middle element\r\n\t\t\tmid = low + (high - low) / 2;\r\n\r\n\t\t\t// If key is less than or equal\r\n\t\t\t// to array[mid], then find in\r\n\t\t\t// left subarray\r\n\t\t\tif (key >= array[(int)mid]) {\r\n\t\t\t\tlow = mid+1;\r\n\t\t\t}\r\n\r\n\t\t\t// If key is greater than array[mid],\r\n\t\t\t// then find in right subarray\r\n\t\t\telse {\r\n\r\n\t\t\t\thigh = mid;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If key is greater than last element which is\r\n\t\t// array[n-1] then lower bound\r\n\t\t// does not exists in the array\r\n\t\tif (low < end && array[(int)low] <= key) {\r\n\t\t\tlow++;\r\n\t\t}\r\n\r\n\t\t// Returning the lower_bound index\r\n\t\treturn (int)low;\r\n\t}\r\n\r\n\tstatic class FastReader {\r\n\t\tBufferedReader br;\r\n\t\tStringTokenizer st;\r\n\r\n\t\tpublic FastReader()\r\n\t\t{\r\n\t\t\tbr = new BufferedReader(\r\n\t\t\t\t\tnew InputStreamReader(System.in));\r\n\t\t}\r\n\r\n\t\tString next()\r\n\t\t{\r\n\t\t\twhile (st == null || !st.hasMoreElements()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\t\t}\r\n\t\t\t\tcatch (IOException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn st.nextToken();\r\n\t\t}\r\n\r\n\t\tint nextInt() { return Integer.parseInt(next()); }\r\n\r\n\t\tlong nextLong() { return Long.parseLong(next()); }\r\n\r\n\t\tdouble nextDouble()\r\n\t\t{\r\n\t\t\treturn Double.parseDouble(next());\r\n\t\t}\r\n\r\n\t\tString nextLine()\r\n\t\t{\r\n\t\t\tString str = \"\";\r\n\t\t\ttry {\r\n\t\t\t\tstr = br.readLine();\r\n\t\t\t}\r\n\t\t\tcatch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t}\r\n\t}\r\n\tstatic class Reader {\r\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\r\n\t\tprivate DataInputStream din;\r\n\t\tprivate byte[] buffer;\r\n\t\tprivate int bufferPointer, bytesRead;\r\n\r\n\t\tpublic Reader()\r\n\t\t{\r\n\t\t\tdin = new DataInputStream(System.in);\r\n\t\t\tbuffer = new byte[BUFFER_SIZE];\r\n\t\t\tbufferPointer = bytesRead = 0;\r\n\t\t}\r\n\r\n\t\tpublic Reader(String file_name) throws IOException\r\n\t\t{\r\n\t\t\tdin = new DataInputStream(\r\n\t\t\t\t\tnew FileInputStream(file_name));\r\n\t\t\tbuffer = new byte[BUFFER_SIZE];\r\n\t\t\tbufferPointer = bytesRead = 0;\r\n\t\t}\r\n\r\n\t\tpublic String readLine() throws IOException\r\n\t\t{\r\n\t\t\tbyte[] buf = new byte[64]; // line length\r\n\t\t\tint cnt = 0, c;\r\n\t\t\twhile ((c = read()) != -1) {\r\n\t\t\t\tif (c == '\\n') {\r\n\t\t\t\t\tif (cnt != 0) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbuf[cnt++] = (byte)c;\r\n\t\t\t}\r\n\t\t\treturn new String(buf, 0, cnt);\r\n\t\t}\r\n\r\n\t\tpublic int nextInt() throws IOException\r\n\t\t{\r\n\t\t\tint ret = 0;\r\n\t\t\tbyte c = read();\r\n\t\t\twhile (c <= ' ') {\r\n\t\t\t\tc = read();\r\n\t\t\t}\r\n\t\t\tboolean neg = (c == '-');\r\n\t\t\tif (neg)\r\n\t\t\t\tc = read();\r\n\t\t\tdo {\r\n\t\t\t\tret = ret * 10 + c - '0';\r\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\r\n\r\n\t\t\tif (neg)\r\n\t\t\t\treturn -ret;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tpublic long nextLong() throws IOException\r\n\t\t{\r\n\t\t\tlong ret = 0;\r\n\t\t\tbyte c = read();\r\n\t\t\twhile (c <= ' ')\r\n\t\t\t\tc = read();\r\n\t\t\tboolean neg = (c == '-');\r\n\t\t\tif (neg)\r\n\t\t\t\tc = read();\r\n\t\t\tdo {\r\n\t\t\t\tret = ret * 10 + c - '0';\r\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\r\n\t\t\tif (neg)\r\n\t\t\t\treturn -ret;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tpublic double nextDouble() throws IOException\r\n\t\t{\r\n\t\t\tdouble ret = 0, div = 1;\r\n\t\t\tbyte c = read();\r\n\t\t\twhile (c <= ' ')\r\n\t\t\t\tc = read();\r\n\t\t\tboolean neg = (c == '-');\r\n\t\t\tif (neg)\r\n\t\t\t\tc = read();\r\n\r\n\t\t\tdo {\r\n\t\t\t\tret = ret * 10 + c - '0';\r\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\r\n\r\n\t\t\tif (c == '.') {\r\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\r\n\t\t\t\t\tret += (c - '0') / (div *= 10);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (neg)\r\n\t\t\t\treturn -ret;\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tprivate void fillBuffer() throws IOException\r\n\t\t{\r\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0,\r\n\t\t\t\t\tBUFFER_SIZE);\r\n\t\t\tif (bytesRead == -1)\r\n\t\t\t\tbuffer[0] = -1;\r\n\t\t}\r\n\r\n\t\tprivate byte read() throws IOException\r\n\t\t{\r\n\t\t\tif (bufferPointer == bytesRead)\r\n\t\t\t\tfillBuffer();\r\n\t\t\treturn buffer[bufferPointer++];\r\n\t\t}\r\n\r\n\t\tpublic void close() throws IOException\r\n\t\t{\r\n\t\t\tif (din == null)\r\n\t\t\t\treturn;\r\n\t\t\tdin.close();\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\nclass Pair{\r\n\tint lastOcc;\r\n\tchar ch;\r\n\tpublic Pair(int lastOcc,char ch) {\r\n\t\tthis.lastOcc = lastOcc;\r\n\t\tthis.ch = ch;\r\n\t}\r\n\t\r\n\tstatic class PairComparator implements Comparator<Pair>{\r\n\r\n\t\tpublic int compare(Pair p1,Pair p2) {\r\n\t\t\treturn (p1.lastOcc < p2.lastOcc) ? -1 : 1;\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n\r\nclass Domino{\r\n\tint a,b;\r\n\tboolean visited;\r\n\tpublic Domino(int a,int b) {\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tvisited = false;\r\n\t}\r\n}\r\n\r\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h> // sherlock_holmes\nusing namespace std;\n\n#define LL long long int\n#define UL unsigned long long int\n\n#define imax INT_MAX\n#define imin INT_MIN\n#define LLmax LLONG_MAX\n#define LLmin LLONG_MIN\n\n#define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++)\n#define rep(i,n) for(int i= int(1); i<= (int)n; i++)\n#define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)\n\n#define track1() printf(\"track 1\\n\");\n#define track2() printf(\"track 2\\n\");\n#define track3() printf(\"track 3\\n\");\n#define track4() printf(\"track 4\\n\");\n\n#define CLR(a) memset(a,0,sizeof(a));\n#define SET(a) memset(a,-1,sizeof(a));\n\n#define sz size()\n#define pb(x) push_back(x)\n#define mp make_pair\n#define ii pair<int,int>\n#define ll pair<LL,LL>\n\n#define F first\n#define S second\n#define gcd(a,b) __gcd(a,b)\n\n#define mod int(1e9 + 7)\n#define N int(500005)\n\n#define si(a) scanf(\"%d\",&a);\n\n#define VI vector<int>\n#define VL vector<LL>\n#define VS vector<string>\n#define VC vector<char>\n\nLL powm(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}\n\nint dis[N]={0}, no, a[N], track[N][3], dp[N]={0};\nint seg[4*N];\nvector<int> vec[N];\n\nvoid go(int ind)\n{\n\tif(ind > no)\n\t\treturn ;\n\tif(dp[ind] == dp[ind+1]){\n\t\tgo(ind+1);\n\t\treturn;\n\t}\n\tvec[0].pb(ind);\n\trep(i,3)\n\t\tvec[0].pb(track[ind][i-1]);\n\tgo(track[ind][2]+1);\n}\n\nvoid update(int n,int it,int f,int l,int Val)\n{\n\tif(it == f){\n\t\tseg[n] = Val;\n\t\treturn ;\n\t}\n\tint m = (it+f)/2;\n\tif( l <= m)\n\t\tupdate(n*2,it,m,l,Val);\n\telse\n\t\tupdate(n*2+1,m+1,f,l,Val);\n\tseg[n] = min(seg[n*2], seg[n+2+1]);\n}\n\nii query(int n,int it,int f,int l,int r,int Val)\n{\n\tif(it==l && r==f){\n\t\tif(seg[n] >= Val)\n\t\t\treturn mp(-1,-1);\n\t}\n\tif( it==f){\n\t\tif(seg[n] < Val)\n\t\t\treturn mp(seg[n],f);\n\t\treturn mp(-1,-1);\n\t}\n\tint m = ( it+f)/2;\n\tif(r <= m)\n\t\treturn query(n*2,it,m,l,r,Val);\n\telse if(l>m)return query(n*2+1,m+1,f,l,r,Val);\n\tii ans = query(n*2,it,m,l,m,Val);\n\tif(ans.F!=-1)\n\t\treturn ans;\n\treturn query(n*2+1,m+1,f,m+1,r,Val);\n}\n\nstd::map<int, int> hashing;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tno=n;\n\n\trep(i,n*4)\n\t\tseg[i] = n + 1;\n\n\trep(i,n){\n\t\tsi(a[i]);\n\t\tdis[i]=a[i];\n\t}\n\tsort(dis+1,dis+n+1);\n\tint t=1;\n\tfor(int i=2;i<=n;++i)\n\t\tif(dis[i]!=dis[i-1])\n\t\t\tdis[++t] = dis[i];\n\n\trep(i,t)\n\t\thashing[dis[i]] = i;\n\trep(i,n)\n\t\ta[i] = hashing[a[i]];\n\n\tii next, id;\n\tint trj;\n\tint szz;\n\tfor(int i=n;i>=1;i--){\n\t\tnext = mp(n+1,n+1);\n\t\tszz = vec[a[i]].sz - 1;\n\t\tszz = max(szz, 1);\n\t\tfor(int j=vec[a[i]].sz;j>=szz;--j){\n\t\t\tif( vec[a[i]][j-1] == n ) continue;\n\t\t\tid = query(1,1,n,vec[a[i]][j-1]+1,n,vec[a[i]][j-1]);\n\t\t\tif(id.F == -1)\n\t\t\t\tid.F = n + 1, id.S = n + 1;\n\t\t\tif( id.S < next.S){\n\t\t\t\tnext = id;\n\t\t\t\ttrj = vec[a[i]][j-1];\n\t\t\t}\t\t\t\n\t\t}\n\t\tid = next;\n\t\tif(id.S<=n && id.S!=-1){\n\t\t\tdp[i] = max(dp[i+1],4 + dp[id.S+1]);\n\t\t\t\n\t\t\ttrack[i][0] = id.F;\n\t\t\ttrack[i][1] = trj;\n\t\t\ttrack[i][2] = id.S;\n\t\t}\n\t\telse\n\t\t\tdp[i] = dp[i+1];\n\t\tfor(int j=vec[a[i]].sz;j>=szz;--j){\n\t\t\tupdate(1,1,n,vec[a[i]][j-1],i);\n\t\t}\n\t\tvec[a[i]].pb(i);\n\t\t\n\t}\n\trep(i,n)\n\t\ta[i] = dis[a[i]];\n\trep(i,t)\n\t\tvec[i].clear();\n\tgo(1);\n\tprintf(\"%d\\n\",dp[1]);\n\trep(i,vec[0].sz)\n\t\tcout << a[vec[0][i-1]] << \" \" ;\n\tcout<<endl;\n\n\treturn 0;\n}",
        "fixed_code": "#include <bits/stdc++.h> // sherlock_holmes\nusing namespace std;\n\n#define LL long long int\n#define UL unsigned long long int\n\n#define imax INT_MAX\n#define imin INT_MIN\n#define LLmax LLONG_MAX\n#define LLmin LLONG_MIN\n\n#define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++)\n#define rep(i,n) for(int i= int(1); i<= (int)n; i++)\n#define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)\n\n#define track1() printf(\"track 1\\n\");\n#define track2() printf(\"track 2\\n\");\n#define track3() printf(\"track 3\\n\");\n#define track4() printf(\"track 4\\n\");\n\n#define CLR(a) memset(a,0,sizeof(a));\n#define SET(a) memset(a,-1,sizeof(a));\n\n#define sz size()\n#define pb(x) push_back(x)\n#define mp make_pair\n#define ii pair<int,int>\n#define ll pair<LL,LL>\n\n#define F first\n#define S second\n#define gcd(a,b) __gcd(a,b)\n\n#define mod int(1e9 + 7)\n#define N int(500005)\n\n#define si(a) scanf(\"%d\",&a);\n\n#define VI vector<int>\n#define VL vector<LL>\n#define VS vector<string>\n#define VC vector<char>\n\nLL powm(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}\n\nint dis[N]={0}, no, a[N], track[N][3], dp[N]={0};\nint seg[4*N];\nvector<int> vec[N];\n\nvoid go(int ind)\n{\n\tif(ind > no)\n\t\treturn ;\n\tif(dp[ind] == dp[ind+1]){\n\t\tgo(ind+1);\n\t\treturn;\n\t}\n\tvec[0].pb(ind);\n\trep(i,3)\n\t\tvec[0].pb(track[ind][i-1]);\n\tgo(track[ind][2]+1);\n}\n\nvoid update(int n,int it,int f,int l,int Val)\n{\n\tif(it == f){\n\t\tseg[n] = Val;\n\t\treturn ;\n\t}\n\tint m = (it+f)/2;\n\tif( l <= m)\n\t\tupdate(n*2,it,m,l,Val);\n\telse\n\t\tupdate(n*2+1,m+1,f,l,Val);\n\tseg[n] = min(seg[n*2], seg[n*2+1]);\n}\n\nii query(int n,int it,int f,int l,int r,int Val)\n{\n\tif(it==l && r==f){\n\t\tif(seg[n] >= Val)\n\t\t\treturn mp(-1,-1);\n\t}\n\tif( it==f){\n\t\tif(seg[n] < Val)\n\t\t\treturn mp(seg[n],f);\n\t\treturn mp(-1,-1);\n\t}\n\tint m = ( it+f)/2;\n\tif(r <= m)\n\t\treturn query(n*2,it,m,l,r,Val);\n\telse if(l>m)return query(n*2+1,m+1,f,l,r,Val);\n\tii ans = query(n*2,it,m,l,m,Val);\n\tif(ans.F!=-1)\n\t\treturn ans;\n\treturn query(n*2+1,m+1,f,m+1,r,Val);\n}\n\nstd::map<int, int> hashing;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tno=n;\n\n\trep(i,n*4)\n\t\tseg[i] = n + 1;\n\n\trep(i,n){\n\t\tsi(a[i]);\n\t\tdis[i]=a[i];\n\t}\n\tsort(dis+1,dis+n+1);\n\tint t=1;\n\tfor(int i=2;i<=n;++i)\n\t\tif(dis[i]!=dis[i-1])\n\t\t\tdis[++t] = dis[i];\n\n\trep(i,t)\n\t\thashing[dis[i]] = i;\n\trep(i,n)\n\t\ta[i] = hashing[a[i]];\n\n\tii next, id;\n\tint trj;\n\tint szz;\n\tfor(int i=n;i>=1;i--){\n\t\tnext = mp(n+1,n+1);\n\t\tszz = vec[a[i]].sz - 1;\n\t\tszz = max(szz, 1);\n\t\tfor(int j=vec[a[i]].sz;j>=szz;--j){\n\t\t\tif( vec[a[i]][j-1] == n ) continue;\n\t\t\tid = query(1,1,n,vec[a[i]][j-1]+1,n,vec[a[i]][j-1]);\n\t\t\tif(id.F == -1)\n\t\t\t\tid.F = n + 1, id.S = n + 1;\n\t\t\tif( id.S < next.S){\n\t\t\t\tnext = id;\n\t\t\t\ttrj = vec[a[i]][j-1];\n\t\t\t}\t\t\t\n\t\t}\n\t\tid = next;\n\t\tif(id.S<=n && id.S!=-1){\n\t\t\tdp[i] = max(dp[i+1],4 + dp[id.S+1]);\n\t\t\t\n\t\t\ttrack[i][0] = id.F;\n\t\t\ttrack[i][1] = trj;\n\t\t\ttrack[i][2] = id.S;\n\t\t}\n\t\telse\n\t\t\tdp[i] = dp[i+1];\n\t\tfor(int j=vec[a[i]].sz;j>=szz;--j){\n\t\t\tupdate(1,1,n,vec[a[i]][j-1],i);\n\t\t}\n\t\tvec[a[i]].pb(i);\n\t\t\n\t}\n\trep(i,n)\n\t\ta[i] = dis[a[i]];\n\trep(i,t)\n\t\tvec[i].clear();\n\tgo(1);\n\tprintf(\"%d\\n\",dp[1]);\n\trep(i,vec[0].sz)\n\t\tcout << a[vec[0][i-1]] << \" \" ;\n\tcout<<endl;\n\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nll n,m,k,a[110][110],Answer=-1e9,row,dp[110][110][10];\nconst ll Inf = 1e18;\n\nbool check(int i , int j){\n    return i>=1 && i<=n && j>=1 && j<=m;\n}\n\nll Rec(int i , int j , int sum){\n\n    if(i==1 && !((sum+a[i][j])%k))  return a[i][j];\n    if(i==1)  return -Inf;\n\n    ll Res1 = -Inf , Res2 = -Inf;\n\n    if(check(i-1,j+1))\n        Res1 = a[i][j] + Rec(i-1,j+1,(sum+a[i][j])%k);\n\n    if(check(i-1,j-1))\n        Res2 = a[i][j] + Rec(i-1,j-1,(sum+a[i][j])%k);\n\n    return dp[i][j][sum] = max(Res1 , Res2);\n}\n\nvoid path(int i , int j , int sum){\n\n    if(i==1)  exit(0);\n\n    ll optimal = Rec(i,j,sum);\n\n    ll Res1 = -Inf , Res2 = -Inf;\n\n    if(check(i-1,j+1))\n        Res1 = a[i][j] + Rec(i-1,j+1,(sum+a[i][j])%k);\n\n    if(check(i-1,j-1))\n        Res2 = a[i][j] + Rec(i-1,j-1,(sum+a[i][j])%k);\n\n    if(optimal==Res1)  printf(\"R\"),path(i-1,j+1,(sum+a[i][j])%k);\n    else  printf(\"L\"),path(i-1,j-1,(sum+a[i][j])%k);\n\n}\n\n\n\nint main()\n{\n    char ch;\n    cin>>n>>m>>k;  k++;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            scanf(\" %c\",&ch);\n            a[i][j] = ch - '0';\n        }\n    }\n    for(int i=1;i<=m;i++){\n        if(Rec(n,i,0) > Answer){\n            Answer = Rec(n,i,0);\n            row = i;\n        }\n    }\n    if(Answer == -1e9)  return cout<<\"-1\",0;\n    cout<<Answer<<endl<<row<<endl;\n    path(n,row,0);\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nll n,m,k,a[110][110],Answer=-1e9,row,dp[110][110][15];\nconst ll Inf = 1e18;\n\nbool check(int i , int j){\n    return i>=1 && i<=n && j>=1 && j<=m;\n}\n\nll Rec(int i , int j , int sum){\n\n    if(i==1 && !((sum+a[i][j])%k))  return a[i][j];\n    if(i==1)  return -Inf;\n\n    if(dp[i][j][sum] != -1)  return dp[i][j][sum];\n    ll Res1 = -Inf , Res2 = -Inf;\n\n    if(check(i-1,j+1))\n        Res1 = a[i][j] + Rec(i-1,j+1,(sum+a[i][j])%k);\n\n    if(check(i-1,j-1))\n        Res2 = a[i][j] + Rec(i-1,j-1,(sum+a[i][j])%k);\n\n    return dp[i][j][sum] = max(Res1 , Res2);\n}\n\nvoid path(int i , int j , int sum){\n\n    if(i==1)  exit(0);\n\n    ll optimal = Rec(i,j,sum);\n\n    ll Res1 = -Inf , Res2 = -Inf;\n\n    if(check(i-1,j+1))\n        Res1 = a[i][j] + Rec(i-1,j+1,(sum+a[i][j])%k);\n\n    if(check(i-1,j-1))\n        Res2 = a[i][j] + Rec(i-1,j-1,(sum+a[i][j])%k);\n\n    if(optimal==Res1)  printf(\"R\"),path(i-1,j+1,(sum+a[i][j])%k);\n    else  printf(\"L\"),path(i-1,j-1,(sum+a[i][j])%k);\n\n}\n\n\n\nint main()\n{\n    char ch;\n    cin>>n>>m>>k;  k++;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            scanf(\" %c\",&ch);\n            a[i][j] = ch - '0';\n        }\n    }\n    memset(dp,-1,sizeof(dp));\n    for(int i=1;i<=m;i++){\n        if(Rec(n,i,0) > Answer){\n            Answer = Rec(n,i,0);\n            row = i;\n        }\n    }\n    if(Answer == -1e9)  return cout<<\"-1\",0;\n    cout<<Answer<<endl<<row<<endl;\n    path(n,row,0);\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char* x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string& x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\n\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x)\n{\n    cerr << '{';\n    __print(x.first);\n    cerr << ',';\n    __print(x.second);\n    cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T& x)\n{\n    int f = 0;\n    cerr << '{';\n    for (auto& i : x)\n        cerr << (f++ ? \",\" : \"\"), __print(i);\n    cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v)\n{\n    __print(t);\n    if (sizeof...(v))\n        cerr << \", \";\n    _print(v...);\n}\n#ifndef ONLINE_JUDGE\n#define debug(x...)               \\\n    cerr << \"[\" << #x << \"] = [\"; \\\n    _print(x)\n#else\n#define debug(x...)\n#endif\n\n\nconst int M = 1e9 + 7;\n\nvoid solve(){\n\n    int n ; \n    cin >> n ;\n\n    string s; \n    cin >> s; \n\n    int ind  = -1; \n    char lmax , rmax ;\n\n    vector<int> ans (n,1); \n\n    char rmin ;\n    for(int i = 0 ; i < n  ; ++i){\n        \n        \n        if (i  && (s[i] <  s[i-1])){\n            rmax =  s[i-1]; \n            lmax =  s[i]; \n            ind = i + 1; \n\n            char key = s[i];\n            int j =  i - 1 ;\n\n            while(j >= 0 && s[j] > key){\n                ans[j] = 2 ;\n                --j;\n            }\n\n            break;\n\n        }\n    }\n\n\n    if (ind  == -1){\n        for(int i = 0 ; i < n ; ++i){\n            cout << 2 ;\n        }\n        cout << \"\\n\"; \n        return ; \n    }\n    // debug(lmax , rmax, ind); \n    rmin = rmax;\n\n    for(int i = ind; i < n ; ++i){\n\n        // debug(i , ind , lmax, rmax); \n\n        if (s[i] >= rmax){\n            rmax =  s[i];\n            ans[i] =  2 ;\n        }\n        else if (s[i] <= rmin && s[i] >=lmax ){\n            lmax=  s[i]; \n        }\n        else {\n            cout <<  \"-\"<<\"\\n\";\n            return; \n        }\n        // debug(lmax, rmax);\n    }\n\n    for(int i = 0 ; i < n ; ++i){\n        cout  << ans[i] ;\n    }\n    cout <<\"\\n\";\n}\n\nint main()\n{\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int T;\n    cin >> T;\n\n    for (int t = 1; t <= T; ++t) {\n\n        solve();\n    }\n\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long ll;\n\nconst int M = 1e9+7 ;\n\nvoid solve(){\n\n    int n , k ;\n    cin >> n  >> k ;\n\n    string s; \n    cin >> s; \n\n\n\n    vector<pair<int,int>> res; \n\n    string s2 ; \n    int n2 = n - 2 *(k - 1); \n\n\n    for(int i = 0 ; i < 2*(k -1); ++i){\n        if (i % 2){\n            s2.push_back(')');\n        }\n        else {\n            s2.push_back('('); \n        }\n    }\n\n    for(int i = 0 ; i < n2 ; ++i){\n\n        if (i < n2/2){\n            s2.push_back('(');\n        }\n        else {\n            s2.push_back(')'); \n        }\n    }\n\n\n    for(int i = 0 ; i < n ; ++i){\n        \n        if (s[i] != s2[i]){\n\n            for(int j = i + 1 ; j < n ; ++j){\n                if (s[j] == s2[i]){\n                    reverse(s.begin() + i , s.begin() + j + 1); \n                    res.push_back({i , j});\n                    break; \n                }\n            }\n        }\n    }\n\n    // cout <<\"k : \"<< k << \" , s : \"<< s<<\"\\n\";\n\n    cout << res.size() << \"\\n\";\n\n    for(const auto &p : res){\n        cout << p.first + 1 << \" \"<< p.second + 1 <<\"\\n\";\n    }\n\n\n\n\n\n    \n\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; \n\n    cin >> t; \n\n    while(t--){\n\n        solve(); \n\n    }\n\n    return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n//* vamsicool007    You are never wrong to do the right thing    vamsicool007 *\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n#include<bits/stdc++.h>\nusing namespace std;\n#define flash ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define endl \"\\n\"\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int mod = 1000000007;\nconst int N=300005;\nvector<int>vis(N);\nvector<vector<int>>adj(N);\nvoid dfs(int v){vis[v]=1;for(auto i:adj[v]){if(!vis[i]){dfs(i);}}return;}\nbool isPrime(ll n){for(ll i=2;i*i<=n;++i){if(n%i==0){return false;}}return true;}\nll factorial(ll n){return (n==1 || n==0) ? 1:n*factorial(n-1);}\nll power(ll x,ll y){ll res=1;x=x;while(y>0){if(y&1)res=(res*x)%mod;y=y>>1;x=(x*x)%mod;}return res%mod;}\nll gcd(ll a,ll b){if (a==0)return b;return gcd(b%a,a);}\nll lcm(ll a,ll b){return (a/gcd(a,b)*b);}\nll max(ll a,ll b){ll ans=a>b?a:b;return ans;}\nll min(ll a,ll b){ll ans=a<b?a:b;return ans;}\nint root(int a[],int i){while(a[i]!=i){a[i]=a[a[i]];i=a[i];}return i;}\nvoid unionn(int a[],int i,int j){int root_i=root(a,i);int root_j=root(a,j);a[root_i]=root_j;return;}\n\nsigned main()\n{\n    flash;\n    #ifndef ONLINE_JUDGE\n    freopen(\"infile.txt\", \"r\", stdin);\n    freopen(\"oufile.txt\", \"w\", stdout);\n    #endif\n    int t=1;\n    //cin>>t;\n    while(t--)\n    {\n    \tint n;\n    \tcin>>n;\n    \tint a[n];\n    \tfor(int i=0;i<n;i++)\n    \t\tcin>>a[i];\n\n    \tsort(a,a+n);\n\n    \tif(n==1)\n    \t\treturn cout<<\"-1\",0;\n    \tif(n==2)\n    \t{\n    \t\tif(a[1]-a[0]==0)\n    \t\t{\n    \t\t\tcout<<1<<endl;\n    \t\t\tcout<<a[0];\n    \t\t}\n    \t\telse if((a[1]-a[0])%2==0)\n    \t\t{\n    \t\t\tcout<<3<<endl;\n    \t\t\tint d=(a[1]-a[0])/2;\n    \t\t\tint e=d*2;\n    \t\t\tcout<<a[0]-e<<\" \"<<a[0]+d<<\" \"<<a[1]+e;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tcout<<2<<endl;\n    \t\t\tint d=a[1]-a[0];\n    \t\t\tcout<<a[0]-d<<\" \"<<a[1]+d;\n    \t\t}\n    \t\treturn 0;\n    \t}\n\n    \tset<int>s;\n    \tmap<int,int>m;\n    \tfor(int i=1;i<n;i++)\n    \t{\n    \t\ts.insert(a[i]-a[i-1]);\n    \t\tm[a[i]-a[i-1]]++;\n    \t}\n\n    \tif(s.size()>2)\n    \t\treturn cout<<0,0;\n\n    \telse if(s.size()==1)\n    \t{\n    \t\tauto i=s.begin();\n    \t\tint c=*i;\n    \t\tif(c==0)\n    \t\t{\n    \t\t\tcout<<1<<endl;\n    \t\t\tcout<<a[0];\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tcout<<2<<endl;\n    \t\t\tcout<<a[0]-c<<\" \"<<a[n-1]+c;\n    \t\t}\n    \t}\n    \telse\n    \t{\n    \t\tauto i=s.begin();\n    \t\tint c=*i;i++;\n    \t\tint d=*i;\n    \t\tint f=0;\n    \t\tif((m[d]==n-2 && m[c]==1))\n    \t\t\tf=1;\n    \t\telse\n    \t\t\treturn cout<<0,0;\n\n    \t\tif((2*c)!=d)\n    \t\t\treturn cout<<0,0;\n    \t\telse\n    \t\t{\n    \t\t\tcout<<1<<endl;\n    \t\t\tfor(int i=1;i<n;i++)\n    \t\t\t{\n    \t\t\t\tif(a[i]-a[i-1]==d)\n    \t\t\t\t\treturn cout<<a[i]-c,0;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    return 0;\n}",
        "fixed_code": "//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n//* vamsicool007    You are never wrong to do the right thing    vamsicool007 *\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n#include<bits/stdc++.h>\nusing namespace std;\n#define flash ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define endl \"\\n\"\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int mod = 1000000007;\nconst int N=300005;\nvector<int>vis(N);\nvector<vector<int>>adj(N);\nvoid dfs(int v){vis[v]=1;for(auto i:adj[v]){if(!vis[i]){dfs(i);}}return;}\nbool isPrime(ll n){for(ll i=2;i*i<=n;++i){if(n%i==0){return false;}}return true;}\nll factorial(ll n){return (n==1 || n==0) ? 1:n*factorial(n-1);}\nll power(ll x,ll y){ll res=1;x=x;while(y>0){if(y&1)res=(res*x)%mod;y=y>>1;x=(x*x)%mod;}return res%mod;}\nll gcd(ll a,ll b){if (a==0)return b;return gcd(b%a,a);}\nll lcm(ll a,ll b){return (a/gcd(a,b)*b);}\nll max(ll a,ll b){ll ans=a>b?a:b;return ans;}\nll min(ll a,ll b){ll ans=a<b?a:b;return ans;}\nint root(int a[],int i){while(a[i]!=i){a[i]=a[a[i]];i=a[i];}return i;}\nvoid unionn(int a[],int i,int j){int root_i=root(a,i);int root_j=root(a,j);a[root_i]=root_j;return;}\n\nsigned main()\n{\n    flash;\n    #ifndef ONLINE_JUDGE\n    freopen(\"infile.txt\", \"r\", stdin);\n    freopen(\"oufile.txt\", \"w\", stdout);\n    #endif\n    int t=1;\n    //cin>>t;\n    while(t--)\n    {\n    \tint n;\n    \tcin>>n;\n    \tint a[n];\n    \tfor(int i=0;i<n;i++)\n    \t\tcin>>a[i];\n\n    \tsort(a,a+n);\n\n    \tif(n==1)\n    \t\treturn cout<<\"-1\",0;\n    \tif(n==2)\n    \t{\n    \t\tif(a[1]-a[0]==0)\n    \t\t{\n    \t\t\tcout<<1<<endl;\n    \t\t\tcout<<a[0];\n    \t\t}\n    \t\telse if((a[1]-a[0])%2==0)\n    \t\t{\n    \t\t\tcout<<3<<endl;\n    \t\t\tint d=(a[1]-a[0])/2;\n    \t\t\tint e=d*2;\n    \t\t\tcout<<a[0]-e<<\" \"<<a[0]+d<<\" \"<<a[1]+e;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tcout<<2<<endl;\n    \t\t\tint d=a[1]-a[0];\n    \t\t\tcout<<a[0]-d<<\" \"<<a[1]+d;\n    \t\t}\n    \t\treturn 0;\n    \t}\n\n    \tset<int>s;\n    \tmap<int,int>m;\n    \tfor(int i=1;i<n;i++)\n    \t{\n    \t\ts.insert(a[i]-a[i-1]);\n    \t\tm[a[i]-a[i-1]]++;\n    \t}\n\n    \tif(s.size()>2)\n    \t\treturn cout<<0,0;\n\n    \telse if(s.size()==1)\n    \t{\n    \t\tauto i=s.begin();\n    \t\tint c=*i;\n    \t\tif(c==0)\n    \t\t{\n    \t\t\tcout<<1<<endl;\n    \t\t\tcout<<a[0];\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tcout<<2<<endl;\n    \t\t\tcout<<a[0]-c<<\" \"<<a[n-1]+c;\n    \t\t}\n    \t}\n    \telse\n    \t{\n    \t\tauto i=s.begin();\n    \t\tint c=*i;i++;\n    \t\tint d=*i;\n    \t\tint f=0;\n    \t\tif((m[d]==1 && m[c]==n-2))\n    \t\t\tf=1;\n    \t\telse\n    \t\t\treturn cout<<0,0;\n\n    \t\tif((2*c)!=d)\n    \t\t\treturn cout<<0,0;\n    \t\telse\n    \t\t{\n    \t\t\tcout<<1<<endl;\n    \t\t\tfor(int i=1;i<n;i++)\n    \t\t\t{\n    \t\t\t\tif(a[i]-a[i-1]==d)\n    \t\t\t\t\treturn cout<<a[i]-c,0;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <map>\nusing namespace std;\n\nlong long n, m, k, a[200002], p[200002], c[200002];\nint main()\n{\n\tint i, j;\n\tcin >> n;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tp[i] = p[i - 1] + a[i];\n\t}\n\tif (p[n] % 3 == 0)\n\t{\n\t\tk = p[n] / 3;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tc[i] = c[i - 1];\n\t\t\tif (p[i] == k)\n\t\t\t\tc[i]++;\n\t\t}\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (p[n] - p[i]==k)\n\t\t\t\tm+=c[i-1];\n\t\t}\n\t}\n\tcout << m << endl;\n\treturn 0;\n}",
        "fixed_code": "#include <iostream>\n#include <map>\nusing namespace std;\n\nlong long n, m, k, a[500002], p[500002], c[500002];\nint main()\n{\n\tint i, j;\n\tcin >> n;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tp[i] = p[i - 1] + a[i];\n\t}\n\tif (p[n] % 3 == 0)\n\t{\n\t\tk = p[n] / 3;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tc[i] = c[i - 1];\n\t\t\tif (p[i] == k)\n\t\t\t\tc[i]++;\n\t\t}\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (p[n] - p[i]==k)\n\t\t\t\tm+=c[i-1];\n\t\t}\n\t}\n\tcout << m << endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*\nProblem : cf 920F\nAlgorithm : segment tree\nStatus : AC\n*/\n#include <bits/stdc++.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 300005;\n\nint n,m;\nll ans;\nll a[MAXN],d[MAXN];\n\nstruct Tree{\n\tint l,r;\n\tll sum,mx;\n} tree[4 * MAXN];\n\nvoid pushUp(int k){\n\ttree[k].sum = tree[k * 2].sum + tree[k * 2 + 1].sum;\n\ttree[k].mx = max(tree[k * 2].mx,tree[k * 2 + 1].mx);\n}\n\nvoid build(int k,int l,int r){\n\ttree[k].l = l;\n\ttree[k].r = r;\n\tif(l == r){\n\t\ttree[k].sum = a[l];\n\t\ttree[k].mx = a[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tbuild(k * 2,l,mid);\n\tbuild(k * 2 + 1,mid + 1,r);\n\tpushUp(k);\n}\n\nvoid update(int k,int l,int r){\n\tif(tree[k].mx <= 2)\n\t    return;\n\tif(tree[k].l == tree[k].r){\n\t\ttree[k].sum = d[tree[k].sum];\n\t\ttree[k].mx = tree[k].sum;\n\t\treturn;\n\t}\n\tint mid = (tree[k].l + tree[k].r) / 2;\n\tif(l <= mid)\n\t    update(k * 2,l,r);\n\tif(r > mid)\n\t    update(k * 2 + 1,l,r);\n\tpushUp(k);\n}\n\nvoid query(int k,int l,int r){\n\tif(tree[k].l >= l && tree[k].r <= r){\n\t\tans += tree[k].sum;\n\t\treturn;\n\t}\n\tint mid = (tree[k].l + tree[k].r) / 2;\n\tif(l <= mid)\n\t    query(k * 2,l,r);\n\tif(r > mid)\n\t    query(k * 2 + 1,l,r);\n}\n\nvoid init(){\n\tfor(int i = 1;i < MAXN;i++){\n\t\tfor(int j = i;j < MAXN;j += i)\n\t\t    d[j]++;\n\t}\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n;i++)\n\t    scanf(\"%lld\",&a[i]);\n\tbuild(1,1,n);\n\tfor(int i = 1;i <= m;i++){\n\t\tint type,x,y;\n\t\tscanf(\"%d%d%d\",&type,&x,&y);\n\t\tif(type == 1)\n\t\t\tupdate(1,x,y);\n\t\telse if(type == 2){\n\t\t\tans = 0;\n\t\t\tquery(1,x,y);\n\t\t    printf(\"%lld\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "/*\nProblem : cf 920F\nAlgorithm : segment tree\nStatus : AC\n*/\n#include <bits/stdc++.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1000005;\n\nint n,m;\nll ans;\nll a[MAXN],d[1000005];\n\nstruct Tree{\n\tint l,r;\n\tll sum,mx;\n} tree[4 * MAXN];\n\nvoid pushUp(int k){\n\ttree[k].sum = tree[k * 2].sum + tree[k * 2 + 1].sum;\n\ttree[k].mx = max(tree[k * 2].mx,tree[k * 2 + 1].mx);\n}\n\nvoid build(int k,int l,int r){\n\ttree[k].l = l;\n\ttree[k].r = r;\n\tif(l == r){\n\t\ttree[k].sum = a[l];\n\t\ttree[k].mx = a[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tbuild(k * 2,l,mid);\n\tbuild(k * 2 + 1,mid + 1,r);\n\tpushUp(k);\n}\n\nvoid update(int k,int l,int r){\n\tif(tree[k].mx <= 2)\n\t    return;\n\tif(tree[k].l == tree[k].r){\n\t\t/*\n\t\tcout << endl;\n\t\tcout << tree[k].l << \" \" << tree[k].r << endl;\n\t\tcout << tree[k].sum << \" \" << d[tree[k].sum] << endl;\n\t\tcout << endl;\n\t\t*/\n\t\ttree[k].sum = d[tree[k].sum];\n\t\ttree[k].mx = tree[k].sum;\n\t\treturn;\n\t}\n\tint mid = (tree[k].l + tree[k].r) / 2;\n\tif(l <= mid)\n\t    update(k * 2,l,r);\n\tif(r > mid)\n\t    update(k * 2 + 1,l,r);\n\tpushUp(k);\n}\n\nvoid query(int k,int l,int r){\n\tif(tree[k].l >= l && tree[k].r <= r){\n\t\tans += tree[k].sum;\n\t\treturn;\n\t}\n\tint mid = (tree[k].l + tree[k].r) / 2;\n\tif(l <= mid)\n\t    query(k * 2,l,r);\n\tif(r > mid)\n\t    query(k * 2 + 1,l,r);\n}\n\nvoid init(){\n\tfor(int i = 1;i < MAXN;i++){\n\t\tfor(int j = i;j < MAXN;j += i)\n\t\t    d[j]++;\n\t}\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n;i++)\n\t    scanf(\"%lld\",&a[i]);\n\tbuild(1,1,n);\n\tfor(int i = 1;i <= m;i++){\n\t\tint type,x,y;\n\t\tscanf(\"%d%d%d\",&type,&x,&y);\n\t\tif(type == 1)\n\t\t\tupdate(1,x,y);\n\t\telse if(type == 2){\n\t\t\tans = 0;\n\t\t\tquery(1,x,y);\n\t\t    printf(\"%lld\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n\n#define ll long long int\n#define hell (ll)(1e9+7)\n#define vi vector <ll>\n#define pb push_back\n#define pii pair<ll,ll>\n#define vii vector <pii>\n#define rep(i,a,b)  for(ll i=a;i<b;i++)\n#define sep(i,a,b)  for(ll i=a-1;i>=b;i--)\n#define inf (ll)(1e16)\n\nusing namespace std;\n\nvi adj[300005];\nvector <bool> visited(300005,false);\nll n,u,v,m,c,k,ans,s;\nvi par(500005),sz(500005),col(300005,-1);\nset <pii> mp;\n\n/*\nbool color(ll s)\n{\n    queue <ll> q;\n    q.push(s);\n    col[s]=0;\n    ll c1=0;\n    while(!q.empty())\n    {\n        s=q.front();\n        q.pop();\n        for(auto ch:adj[s])\n        {\n            if(col[ch]==col[s])\n                return false;\n            if(col[ch]==-1)\n            {\n                col[ch]=1-col[s];\n                c1+=col[ch]==1;\n                q.push(ch);\n            }\n        }\n    }\n    return true;\n}*/\n\n\nvoid dfs(ll s,ll p)\n{\n    c=1;\n    visited[s]=true;\n    for(auto ch:adj[s])\n    {\n        if(p!=-1&&col[p]==c)\n            c++;\n        if(col[s]==c)\n            c++;\n        if(col[ch]==-1||p==-1)\n        {\n            col[ch]=c;\n            c++;\n            dfs(ch,s);\n        }\n    }\n}\n/*{//dsu\nll root(ll x)\n{\n    while(x!=par[x])\n        x=par[x];\n    return x;\n}*/\n/*void add(ll x,ll y)\n{\n    ll rx,ry;\n    rx=root(x);\n    ry=root(y);\n    if(rx==ry)\n        return;\n    if(sz[rx]<sz[ry])\n    {\n        par[rx]=ry;\n        sz[ry]+=sz[rx];\n    }\n    else\n    {\n        par[ry]=rx;\n        sz[rx]+=sz[ry];\n    }\n}\n\nvoid init()\n{\n    rep(i,1,n+1)\n    {\n        par[i]=i;\n        sz[i]=1;\n    }\n}\n}*/\n\nvoid solve()\n{\n    cin>>n;\n    rep(i,0,n-1)\n    {\n        cin>>u>>v;\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    ans=0;\n    rep(i,1,n+1)\n    {\n        if(ans<adj[i].size())\n        {\n            ans=adj[i].size();\n            s=i;\n        }\n    }\n    ans++;\n    cout<<ans<<\"\\n\";\n    col[s]=1;\n    dfs(s,-1);\n    rep(i,1,n+1)\n        cout<<col[i]<<\" \";\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll t=1;\n    //cin>>T;\n    while(t--)\n        solve();\n    return 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\n\n#define ll long long int\n#define hell (ll)(1e9+7)\n#define vi vector <ll>\n#define pb push_back\n#define pii pair<ll,ll>\n#define vii vector <pii>\n#define rep(i,a,b)  for(ll i=a;i<b;i++)\n#define sep(i,a,b)  for(ll i=a-1;i>=b;i--)\n#define inf (ll)(1e16)\n\nusing namespace std;\n\nvi adj[300005];\nvector <bool> visited(300005,false);\nll n,u,v,m,c,k,ans,src,p;\nvi par(500005),sz(500005),col(300005,-1);\nset <pii> mp;\n\nvoid color(ll s)\n{\n    queue <pii> q;\n    q.push({s,-1});\n    col[s]=1;\n    while(!q.empty())\n    {\n        pii pi=q.front();\n        q.pop();\n        s=pi.first;\n        p=pi.second;\n        if(p==-1)\n            c=2;\n        else\n            c=1;\n        for(auto ch:adj[s])\n        {\n            while(p!=-1&&(col[s]==c||col[p]==c))\n                c++;\n            if(col[ch]==-1)\n            {\n                col[ch]=c;\n                c++;\n                q.push({ch,s});\n            }\n        }\n    }\n}\n\n/*{//dsu\nll root(ll x)\n{\n    while(x!=par[x])\n        x=par[x];\n    return x;\n}*/\n/*void add(ll x,ll y)\n{\n    ll rx,ry;\n    rx=root(x);\n    ry=root(y);\n    if(rx==ry)\n        return;\n    if(sz[rx]<sz[ry])\n    {\n        par[rx]=ry;\n        sz[ry]+=sz[rx];\n    }\n    else\n    {\n        par[ry]=rx;\n        sz[rx]+=sz[ry];\n    }\n}\n\nvoid init()\n{\n    rep(i,1,n+1)\n    {\n        par[i]=i;\n        sz[i]=1;\n    }\n}\n}*/\n\nvoid solve()\n{\n    cin>>n;\n    rep(i,0,n-1)\n    {\n        cin>>u>>v;\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    ans=0;\n    rep(i,1,n+1)\n    {\n        if(ans<adj[i].size())\n        {\n            ans=adj[i].size();\n            src=i;\n        }\n    }\n    ans++;\n    cout<<ans<<\"\\n\";\n    color(src);\n    rep(i,1,n+1)\n    cout<<col[i]<<\" \";\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll t=1;\n    //cin>>T;\n    while(t--)\n        solve();\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    long long n, h;\n    cin>>n>>h;\n    double t=acos(0.5/h*1.0), y, a=(h*1.0)/(n*4.0), ar=(h*1.0)/(4.0), x=(h*1.0)/sqrt(n*1.0);\n    long long i, j;\n    cout<<x<<\" \";\n    for(i=2; i<=n-1; i++){\n        x=(h*1.0)/sqrt((n*1.0)/(i*1.0));\n        if(i==n-1)cout<<x<<\"\\n\";\n        else cout<<x<<\" \";\n    }\n    return 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    long long n, h;\n    cin>>n>>h;\n    double x;\n    long long i;\n    for(i=1; i<=n-1; i++){\n        x=(h*1.0)/sqrt((n*1.0)/(i*1.0));\n        if(i==n-1)cout<<fixed<<setprecision(12)<<x<<\"\\n\";\n        else cout<<fixed<<setprecision(12)<<x<<\" \";\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\n#define ll long long\n\n#define FOR(i,a,b)        for(ll i=(a);i<(b);i++)\n#define REP(i,n)        FOR(i,0,n)\n#define SORT(v)            sort((v).begin(),(v).end())\n#define UN(v)            SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define CL(a,b)            memset(a,b,sizeof a)\n#define pb                push_back\n\nusing namespace std;\n\n//#define N 1000009\nll denom = 1e9+7;\nll n,m,a,b;\n\nbool dfsM(ll x, vector<vector<ll>>& v, vector<bool>& visited, vector<bool>& middle) {\n    bool result = false;\n    visited[x] = true;\n    REP(i, v[x].size()) {\n        if (v[x][i] == b) {\n            result = true;\n        } else if (!visited[v[x][i]]) {\n            result = dfsM(v[x][i], v, visited, middle) || result;\n        }\n    }\n    if (result)\n        middle[x] = true;\n    visited[x] = false;\n    return result;\n}\n\nll dfs(ll x, vector<vector<ll>>& v, vector<bool>& middle) {\n    ll res = 1;\n    middle[x] = true;\n    REP(i, v[x].size()) {\n        if (!middle[v[x][i]]) {\n            res += dfs(v[x][i], v, middle);\n        }\n    }\n    return res;\n}\n\nll dfsX(ll x, vector<vector<ll>>& v, vector<bool>& middle) {\n    ll res = 0;\n    REP(i, v[x].size()) {\n        if (!middle[v[x][i]]) {\n            res += dfs(v[x][i], v, middle);\n        }\n    }\n    return res;\n}\n\nll solve(vector<pair<ll, ll>>& r) {\n    a--; b--;\n    \n    vector<vector<ll>> v(n, vector<ll>());\n    REP(i, m) {\n        v[r[i].first-1].push_back(r[i].second-1);\n        v[r[i].second-1].push_back(r[i].first-1);\n    }\n    \n    vector<bool> middle(n, false);\n    vector<bool> visited(n, false);\n    visited[a] = true; visited[b] = true;\n    dfsM(a, v, visited, middle);\n    middle[a] = true; middle[b] = true;\n    \n    return dfsX(a, v, middle) * dfsX(b, v, middle);\n}\n\nint main(int argc, const char * argv[])\n{\n    ll t; cin >> t;\n    vector<ll> res;\n    REP(i, t) {\n        cin >> n >> m >> a >> b;\n        vector<pair<ll, ll>> r(m, make_pair(0, 0));\n        REP(j, m) cin >> r[j].first >> r[j].second;\n        res.push_back(solve(r));\n    }\n    REP(i, t){\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n\n",
        "fixed_code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\n#define ll long long\n\n#define FOR(i,a,b)        for(ll i=(a);i<(b);i++)\n#define REP(i,n)        FOR(i,0,n)\n#define SORT(v)            sort((v).begin(),(v).end())\n#define UN(v)            SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define CL(a,b)            memset(a,b,sizeof a)\n#define pb                push_back\n\nusing namespace std;\n\n//#define N 1000009\nll denom = 1e9+7;\nll n,m,a,b;\n\nbool dfsM(ll x, vector<vector<ll>>& v, vector<bool>& visited, vector<bool>& middle) {\n    bool result = false;\n    visited[x] = true;\n    REP(i, v[x].size()) {\n        ll next = v[x][i];\n        if (next == b) {\n            result = true;\n        } else {\n            if (!visited[next]) {\n                result = dfsM(next, v, visited, middle) || result;\n            } else if (middle[next] && next != a) {\n                result = true;\n            }\n        }\n    }\n    if (result) {\n        middle[x] = true;\n    }\n    return result;\n}\n\nvoid fillMiddle(ll x, vector<vector<ll>>& v, vector<bool>& middle) {\n    middle[x] = true;\n    REP(i, v[x].size()) {\n        if (!middle[v[x][i]]) {\n            fillMiddle(v[x][i], v, middle);\n        }\n    }\n}\n\nll dfs(ll x, vector<vector<ll>>& v, vector<bool>& middle) {\n    ll res = 1;\n    middle[x] = true;\n    REP(i, v[x].size()) {\n        if (!middle[v[x][i]]) {\n            res += dfs(v[x][i], v, middle);\n        }\n    }\n    return res;\n}\n\nll dfsX(ll x, vector<vector<ll>>& v, vector<bool>& middle) {\n    ll res = 0;\n    REP(i, v[x].size()) {\n        if (!middle[v[x][i]]) {\n            res += dfs(v[x][i], v, middle);\n        }\n    }\n    return res;\n}\n\nll solve(vector<pair<ll, ll>>& r) {\n    a--; b--;\n    \n    vector<vector<ll>> v(n, vector<ll>());\n    REP(i, m) {\n        v[r[i].first-1].push_back(r[i].second-1);\n        v[r[i].second-1].push_back(r[i].first-1);\n    }\n    \n    vector<bool> middle(n, false);\n    vector<bool> visited(n, false);\n    visited[a] = true; visited[b] = true;\n    dfsM(a, v, visited, middle);\n    middle[a] = true; middle[b] = true;\n    REP(i, n) {\n        if (i != a && i != b && middle[i]) {\n            REP(j, v[i].size()) {\n                if (!middle[v[i][j]]) {\n                    fillMiddle(v[i][j], v, middle);\n                }\n            }\n        }\n    }\n    \n    return dfsX(a, v, middle) * dfsX(b, v, middle);\n}\n\nint main(int argc, const char * argv[])\n{\n    ll t; cin >> t;\n    vector<ll> res;\n    REP(i, t) {\n        cin >> n >> m >> a >> b;\n        vector<pair<ll, ll>> r(m, make_pair(0, 0));\n        REP(j, m) cin >> r[j].first >> r[j].second;\n        res.push_back(solve(r));\n    }\n    REP(i, t){\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "void resort(zemfi.de.vertaktoid.Movement movement, zemfi.de.vertaktoid.Page page) {\n    movement.sortMeasures();\n    movement.calculateSequenceNumbers();\n    page.sortMeasures();\n}",
        "fixed_code": "void resort(zemfi.de.vertaktoid.Movement movement, zemfi.de.vertaktoid.Page page) {\n    if (movement == null) {\n        return ;\n    }\n    movement.sortMeasures();\n    movement.calculateSequenceNumbers();\n    page.sortMeasures();\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "private boolean jj_3R_446() {\n    if (jj_3R_105())\n        return true;\n    \n    return false;\n}",
        "fixed_code": "private boolean jj_3R_445() {\n    if (jj_3R_105())\n        return true;\n    \n    return false;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int N = in.nextInt();\n            int a[] = new int[N];\n            int pos[] = new int[N];\n            for (int i = 0; i < N; i++) {\n                a[i] = in.nextInt();\n                pos[a[i] - 1] = i;\n            }\n            int expect = pos[0] + 1;\n            int last = N;\n            for (int i = 1; i < N; i++) {\n                if (expect == last) {\n                    last = expect - 1;\n                    expect = -1;\n                }\n                if (expect == -1) {\n                    expect = pos[i] + 1;\n                } else {\n                    if (pos[i] != expect) {\n                        out.printLine(\"No\");\n                        return;\n                    }\n                    expect++;\n                }\n            }\n            out.printLine(\"Yes\");\n        }\n\n    }\n\n    static class OutputWriter {\n        PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tokenizer = null;\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(in.readLine());\n                }\n                return tokenizer.nextToken();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",
        "fixed_code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int N = in.nextInt();\n            int a[] = new int[N];\n            int pos[] = new int[N];\n            for (int i = 0; i < N; i++) {\n                a[i] = in.nextInt();\n                pos[a[i] - 1] = i;\n            }\n            int expect = pos[0] + 1;\n            int head = 0;\n            int last = N;\n            for (int i = 1; i < N; i++) {\n                if (expect == last) {\n                    last = pos[head];\n                    head = i;\n                    expect = pos[i] + 1;\n                } else {\n                    if (pos[i] != expect) {\n                        out.printLine(\"No\");\n                        return;\n                    }\n                    expect++;\n                }\n            }\n            out.printLine(\"Yes\");\n        }\n\n    }\n\n    static class OutputWriter {\n        PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tokenizer = null;\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(in.readLine());\n                }\n                return tokenizer.nextToken();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <cmath>\n#include <climits>\n#define mod 1000000007\n#define maxx 1000000000\n#define lli long long\n#define endl '\\n'\n#define pii pair<long long,long long>\n//#define pii pair<int,int>\n#define piii pair<long long,pair<long long ,long long> >\nusing namespace std;\nvector<pii> vec[200002];\nlli sear(lli no,lli great)\n{\n    if(no<=0||no>=200002)return LONG_LONG_MAX;\n    if(vec[no].size()==0)return LONG_LONG_MAX;\n    lli p = 0;\n    for (lli a=vec[no].size(); a >= 1; a /= 2) {\n        while (p+a<vec[no].size()&&vec[no][p+a].first<=great) p += a;\n    }\n    p++;\n    if(p<vec[no].size())return vec[no][p].second;\n    else return LONG_LONG_MAX;\n}\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(NULL);\n    lli a,b;\n    cin>>a>>b;\n    lli ls[a],rs[a],c[a];\n    piii nos[a];\n    for(lli i=0;i<a;i++){\n        cin>>ls[i]>>rs[i]>>c[i];\n        nos[i].first=ls[i];nos[i].second.first=rs[i];nos[i].second.second=c[i];\n    }\n    sort(nos,nos+a);\n    for(lli i=0;i<a;i++){\n        pii p;p.first=nos[i].first;p.second=nos[i].second.second;\n        vec[nos[i].second.first-nos[i].first+1].push_back(p);\n    }\n    for(lli i=1;i<200002;i++){\n        for(lli j=vec[i].size()-2;j>=0;j--){\n            vec[i][j].second=min(vec[i][j+1].second,vec[i][j].second);\n        }\n    }\n    lli ans=LONG_LONG_MAX;\n    for(lli i=0;i<a;i++){\n        lli k=sear(b-(rs[i]-ls[i]+1),rs[i]);\n        if(k!=LONG_LONG_MAX)k+=c[i];\n        ans=min(ans,k);\n    }\n    if(ans==LONG_LONG_MAX)cout<<-1;\n    else cout<<ans;\n}\n",
        "fixed_code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <cmath>\n#include <climits>\n#define mod 1000000007\n#define maxx 1000000000\n#define lli long long\n#define endl '\\n'\n#define pii pair<long long,long long>\n//#define pii pair<int,int>\n#define piii pair<long long,pair<long long ,long long> >\nusing namespace std;\nvector<pii> vec[200002];\nvector<pii> vec2[200002];\nlli sear(lli no,lli great)\n{\n    if(no<=0||no>=200002)return LONG_LONG_MAX;\n    if(vec[no].size()==0)return LONG_LONG_MAX;\n    lli mm=vec[no].size();\n    if(vec[no][mm-1].first<=great)return LONG_LONG_MAX;\n    lli p = 0;\n    for (lli a=vec[no].size(); a >= 1; a /= 2) {\n        while (p+a<vec[no].size()&&vec[no][p+a].first<=great) p += a;\n    }\n    p++;\n    if(p<vec[no].size()&&p>=0)return vec[no][p].second;\n    else return LONG_LONG_MAX;\n}\nlli sear2(lli no,lli les)\n{\n    if(no<=0||no>=200002)return LONG_LONG_MAX;\n    if(vec2[no].size()==0)return LONG_LONG_MAX;\n    lli mm=vec2[no].size();\n    if(vec2[no][0].first>=les)return LONG_LONG_MAX;\n    lli p = 0;\n    for (lli a=vec2[no].size(); a >= 1; a /= 2) {\n        while (p+a<vec2[no].size()&&vec2[no][p+a].first<les) p += a;\n    }\n    if(p<vec2[no].size()&&p>=0)return vec2[no][p].second;\n    else return LONG_LONG_MAX;\n}\nbool comp(piii a,piii b)\n{\n    return a.first<b.first;\n}\nbool comp2(piii a,piii b)\n{\n    return a.second.first<b.second.first;\n}\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(NULL);\n    lli a,b;\n    cin>>a>>b;\n    lli ls[a],rs[a],c[a];\n    piii nos[a];\n    for(lli i=0;i<a;i++){\n        cin>>ls[i]>>rs[i]>>c[i];\n        nos[i].first=ls[i];nos[i].second.first=rs[i];nos[i].second.second=c[i];\n    }\n    sort(nos,nos+a,comp);\n    for(lli i=0;i<a;i++){\n        pii p;p.first=nos[i].first;p.second=nos[i].second.second;\n        vec[nos[i].second.first-nos[i].first+1].push_back(p);\n    }\n    sort(nos,nos+a,comp2);\n    for(lli i=0;i<a;i++){\n        pii p;p.first=nos[i].second.first;p.second=nos[i].second.second;\n        vec2[nos[i].second.first-nos[i].first+1].push_back(p);\n    }\n    for(lli i=1;i<200002;i++){\n        lli k=vec[i].size();\n        if(k>1){\n            for(lli j=k-2;j>=0;j--){\n                vec[i][j].second=min(vec[i][j+1].second,vec[i][j].second);\n            }}\n        k=vec2[i].size();\n        if(k>1){\n            for(lli j=1;j<k;j++)\n                vec2[i][j].second=min(vec2[i][j-1].second,vec2[i][j].second);\n        }\n    }\n    lli ans=LONG_LONG_MAX;\n    for(lli i=0;i<a;i++){\n        lli k=sear(b-(rs[i]-ls[i]+1),rs[i]);\n        if(k!=LONG_LONG_MAX)k+=c[i];\n        ans=min(ans,k);\n        k=sear2(b-(rs[i]-ls[i]+1),ls[i]);\n        if(k!=LONG_LONG_MAX)k+=c[i];\n        ans=min(ans,k);\n    }\n    if(ans==LONG_LONG_MAX)cout<<-1;\n    else cout<<ans;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define lli long long int\n#define INF 100000005\n#define pb push_back\n#define mk make_pair\nusing namespace std;\nfloat x, y, a[1005], b[1005], z[1005], s, as=0, ans=2000000.0;\nint n;\nint main(){\n    cin >> x >> y >> n;\n    for( int i = 1; i <= n; i ++ ){\n        cin >> a[i] >> b[i] >> z[i];\n    }\n    for( int i = 1; i <= n; i ++ ){\n                as=min(abs(a[i]-x),abs(b[i]-y));\n                s=((abs(a[i]-x)+abs(b[i]-y))+)/z[i];\n                ans=min(ans,s);\n            }\n\n           printf(\"%.6f\",ans);\n}\n/*0 0 4\n1 2 3\n-1 2 3\n1 -2 3\n-1 -2 3\n*/\n",
        "fixed_code": "#include<bits/stdc++.h>\n#define lli long long int\n#define INF 100000005\n#define pb push_back\n#define mk make_pair\nusing namespace std;\nfloat x, y, a[1005], b[1005], z[1005], s, as=0, ans=2000000.0;\nint n;\nint main(){\n    cin >> x >> y >> n;\n    for( int i = 1; i <= n; i ++ ){\n        cin >> a[i] >> b[i] >> z[i];\n    }\n    for( int i = 1; i <= n; i ++ ){\n                s=sqrt((a[i]-x)*(a[i]-x)+(b[i]-y)*(b[i]-y))/z[i];\n                ans=min(ans,s);\n            }\n\n           printf(\"%.6f\",ans);\n}\n/*0 0 4\n1 2 3\n-1 2 3\n1 -2 3\n-1 -2 3\n*/\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n\n#define space cout<<\" \";\n#define line cout<<\"\\n\";\n#define ll long long int\n\nusing namespace std;\n\nint main()\n{\n    std::ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n    int n;\n    int m;\n    cin>>n;\n    int a[n],c[n]={0};\n    for(int i=0;i<n;i++)\n        cin>>a[i];\n\n    c[0]=a[0];\n    for(int i=1;i<n;i++)\n        c[i]=c[i-1]+a[i];\n\n    cin>>m;\n    int b[m];\n    for(int j=0;j<m;j++)\n        cin>>b[j];\n\n  /*    line;\n    for(int i=0;i<n;i++)\n    {\n        cout<<a[i]; space;\n    }\n    line;\n    for(int i=0;i<n;i++)\n    {\n        cout<<c[i];space;\n    }\n    line;\n    for(int i=0;i<m;i++)\n    {\n        cout<<b[i];space;\n    }*/\n\n\n    int l,u;\n    for(int i=0;i<m;i++)\n    {\n        l=0; u=n;\n        if(b[i]<=c[0])\n        {\n            cout<<1;\n            line; continue;\n        }\n        if(b[i]>=c[n-2]&&b[i]<=c[n-1])\n        {\n            cout<<n;\n            line; continue;\n        }\n        while((l+1)!=u)\n        {\n            if(c[(l+u)/2]>=b[i])\n            {\n                u=(l+u)/2;\n            }\n            else\n            {\n                l=(l+u)/2;\n            }\n        }\n\n        if(b[i]<=c[l])\n        {\n            cout<<l+1; line;\n        }\n        else\n            cout<<u+1; line;\n\n\n    }\n\n\n\n}\n",
        "fixed_code": "#include<iostream>\n#include<cstdlib>\n#include<cmath>\n\n#define FAST std::ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n#define line cout<<endl\n#define space cout<<\" \"\n\nusing namespace std;\n\nint main()\n{\n\n    long long int n,m;\n    cin>>n;\n\n    long long int a[n];\n    for(long long int i=0;i<n;i++)\n    {\n        cin>>a[i];\n    }\n\n    cin>>m;\n\n\n    int b[m];\n    for(long long int i=0;i<m;i++)\n    {\n        cin>>b[i];\n    }\n\n\n    /*cout<<\"number of piles\"<<n; line;\n    cout<<\"worms in pile i: \"; line;\n\n\n    for(int i=0;i<n;i++)\n    {\n        cout<<a[i];\n        space;\n    }\n\n    line;\n\n    cout<<\"no of juicy worms: \";\n    cout<<m;\n    line;\n\n    for(int i=0;i<m;i++)\n    {\n        cout<<b[i];\n        space;\n\n    }*/\n\n\n    int c[n];\n\n    c[0] = a[0];\n    for(long long int i=1;i<n;i++)\n    {\n        c[i] = c[i-1]+a[i];\n    }\n\n\n\n\n    for(int i=0;i<m;i++)\n    {\n        int curr_item = b[i];\n\n        int first = 0;\n        int last = n-1;\n\n        while(first<last-1)\n        {\n            int mid = (first+last)/2;\n\n            if(curr_item<c[mid])\n            {\n                last = mid;\n            }\n            else if(curr_item>mid)\n            {\n                first = mid;\n            }\n\n        }\n\n        if(curr_item>c[first])\n        {\n            cout<<last+1;\n            line;\n        }\n        else\n        {\n            cout<<first+1;\n            line;\n\n        }\n    }\n\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef int ll;\ntypedef long double ld;\nvector< vector<bool> > dp(3002, vector<ll> (3002));\nvector<ll> v;\nvector<ll> mahd; \nll n,k;\nll etsi(ll e, ll t, ll d) {\n    //for(ll i=0; i<d; ++i) cout<<\" \";\n    //cout<<e<<' '<<d<<'\\n';\n    //e==qq[i][0]\n    //t==qq[i][1];\n    //cout<<\"lol\\n\";\n    vector< vector<ll> > qq(1, vector<ll>(3));\n    qq[0][0]=e;\n    qq[0][1]=t;\n    qq[0][2]=d;\n\n    for(ll i=0; i<qq.size(); ++i) {\n        vector<ll> qw(3);\n        ll e=qq[i][0];\n        ll t=qq[i][1];\n        ll d=qq[i][2];\n        if(e>=n || t>=n) {\n            dp[e][t]=1;\n            continue;\n        }\n        if(d==k) {\n            dp[e][t]=1;\n            continue;\n        }\n        //if(dp[e][t]!=1ll<<60) continue;;\n        ll m=0;\n        if(mahd[t]>0) {\n            if(v[e]<100) {\n                qw[0]=t;\n                qw[1]=t+1;\n                qw[2]=d+1;\n                if(!dp[t][t+1]) {\n                    qq.push_back(qw);\n                    dp[t][t+1]=1;\n                }\n\n            }\n            if(v[e]>0) {\n                //m+=etsi(t+1, t+2, d+1);\n                qw[0]=t+1;\n                qw[1]=t+2;\n                qw[2]=d+1;\n                if(!dp[t+1][t+2]) {\n                    qq.push_back(qw);\n                    dp[t+1][t+2]=1;\n                }\n            } \n        }\n        if(mahd[t]<2) {\n            if(v[e]<100) {\n                //ei tapahdu mitään\n            //    m+=etsi(e, t);\n            }\n            if(v[e]>0) {\n\n                //m+=etsi(e, t+1, d+1);\n                qw[0]=e;\n                qw[1]=t+1;\n                qw[2]=d+1;\n                if(!dp[e][t+1]) {\n                    dp[e][t+1]=1;\n                    qq.push_back(qw);\n                }\n            }\n        }\n        dp[e][t]=1;\n    }\n\n\n    return 0;\n}\nint main() {\n    for(ll i=0; i<3002; ++i) {\n\n        for(ll j=0; j<3002; ++j) dp[i][j]=0;\n    }\n    cin>>n>>k;\n    mahd.resize(n);\n    v.resize(n);\n    for(ll i=0; i<n; ++i) {\n        cin>>v[i];\n    }\n    //0==0%\n    //1==1-100%\n    //2==100%\n    for(ll i=n-1; i>=0; --i) {\n        if(i!=n-1) {\n            mahd[i]=mahd[i+1];\n        }\n        if(!mahd[i]) {\n            if(v[i]>0 && v[i]<100) {\n                mahd[i]=1;\n            }\n        }\n        if(v[i]==100) mahd[i]=2;\n    }    \n    /*\n    for(ll i=0; i<n; ++i) {\n        cout<<mahd[i]<<' ';\n    }\n    cout<<'\\n';\n    */\n    etsi(0, 1, 0);\n    ll m=0;\n    for(ll i=0; i<3002; ++i) {\n        for(ll j=0; j<3002; ++j) {\n            if(dp[i][j]) ++m;\n        }\n    }\n    cout<<m<<'\\n';\n}\n",
        "fixed_code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef int ll;\ntypedef long double ld;\nvector< vector<bool> > dp(3002, vector<bool> (3002));\nvector<ll> v;\nvector<ll> mahd; \nll n,k;\nll etsi(ll e, ll t, ll d) {\n    //for(ll i=0; i<d; ++i) cout<<\" \";\n    //cout<<e<<' '<<d<<'\\n';\n    //e==qq[i][0]\n    //t==qq[i][1];\n    //cout<<\"lol\\n\";\n    vector< vector<ll> > qq(1, vector<ll>(3));\n    qq[0][0]=e;\n    qq[0][1]=t;\n    qq[0][2]=d;\n\n    for(ll i=0; i<qq.size(); ++i) {\n        vector<ll> qw(3);\n        ll e=qq[i][0];\n        ll t=qq[i][1];\n        ll d=qq[i][2];\n        if(e>=n || t>=n) {\n            dp[e][t]=1;\n            continue;\n        }\n        if(d==k) {\n            dp[e][t]=1;\n            continue;\n        }\n        //if(dp[e][t]!=1ll<<60) continue;;\n        ll m=0;\n        if(mahd[t]>0) {\n            if(v[e]<100) {\n                qw[0]=t;\n                qw[1]=t+1;\n                qw[2]=d+1;\n                if(!dp[t][t+1]) {\n                    qq.push_back(qw);\n                    dp[t][t+1]=1;\n                }\n\n            }\n            if(v[e]>0) {\n                //m+=etsi(t+1, t+2, d+1);\n                qw[0]=t+1;\n                qw[1]=t+2;\n                qw[2]=d+1;\n                if(!dp[t+1][t+2]) {\n                    qq.push_back(qw);\n                    dp[t+1][t+2]=1;\n                }\n            } \n        }\n        if(mahd[t]<2) {\n            if(v[e]<100) {\n                //ei tapahdu mitään\n            //    m+=etsi(e, t);\n            }\n            if(v[e]>0) {\n\n                //m+=etsi(e, t+1, d+1);\n                qw[0]=e;\n                qw[1]=t+1;\n                qw[2]=d+1;\n                if(!dp[e][t+1]) {\n                    dp[e][t+1]=1;\n                    qq.push_back(qw);\n                }\n            }\n        }\n        dp[e][t]=1;\n    }\n\n\n    return 0;\n}\nint main() {\n    for(ll i=0; i<3002; ++i) {\n\n        for(ll j=0; j<3002; ++j) dp[i][j]=0;\n    }\n    cin>>n>>k;\n    mahd.resize(n);\n    v.resize(n);\n    for(ll i=0; i<n; ++i) {\n        cin>>v[i];\n    }\n    //0==0%\n    //1==1-100%\n    //2==100%\n    for(ll i=n-1; i>=0; --i) {\n        if(i!=n-1) {\n            mahd[i]=mahd[i+1];\n        }\n        if(!mahd[i]) {\n            if(v[i]>0 && v[i]<100) {\n                mahd[i]=1;\n            }\n        }\n        if(v[i]==100) mahd[i]=2;\n    }    \n    /*\n    for(ll i=0; i<n; ++i) {\n        cout<<mahd[i]<<' ';\n    }\n    cout<<'\\n';\n    */\n    etsi(0, 1, 0);\n    ll m=0;\n    for(ll i=0; i<3002; ++i) {\n        for(ll j=0; j<3002; ++j) {\n            if(dp[i][j]) ++m;\n        }\n    }\n    cout<<m<<'\\n';\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define lli long long int\n#define mod 1000000007\n#define MAX 300005\n\nlli max(lli a,lli b)\n{\n   if(a>b)\n   {\n       return a;\n   }\n   return b;\n}\nlli gcd(lli a,lli b)\n{\n    if(a==0)\n    {\n        return b;\n    }\n    return gcd(b%a,a);\n}\nlli min(lli a,lli b)\n{\n   if(a<b)\n   {\n       return a;\n   }\n   return b;\n}\nlli power(lli x,lli n)\n{\n    lli res=1;\n    while(n>0)\n    {\n        if(n%2==1)\n        {\n            res=(res*x)%mod;\n        }\n        x=(x*x)%mod;\n        n=n/2;\n    }\n    return  res%mod;\n}\n\nlli factorialNumInverse[1000001];\nlli naturalNumInverse[1000001];\nlli fact[1000001];\n\nvoid InverseofNumber(lli n,lli p)\n{\n    naturalNumInverse[0] = naturalNumInverse[1] = 1;\n    for (lli i = 2; i <= n; i++)\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;\n}\nvoid InverseofFactorial(lli n,lli p)\n{\n    factorialNumInverse[0] = factorialNumInverse[1] = 1;\n\n    for (lli i = 2; i <= n; i++)\n        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;\n}\nvoid factorial(lli n,lli p)\n{\n    fact[0] = 1;\n    for (lli i = 1; i <= n; i++) {\n        fact[i] = (fact[i - 1] * i) % p;\n    }\n}\nlli nCrModp(lli n, lli r, lli p)\n{\n    lli ans = ((fact[n] * factorialNumInverse[r]) % p * factorialNumInverse[n - r]) % p;\n    return ans;\n}\n\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //lli tc;\n   // cin>>tc;\n    factorial(200005,mod);\n    InverseofNumber(200005,mod);\n    InverseofFactorial(200005,mod);\n    //while(tc--)\n   // {\n        lli n,m,k;\n        cin>>n>>m>>k;\n        lli arr[n];\n        for(int i=0;i<n;i++)\n        {\n            cin>>arr[i];\n        }\n        if(n%2==0)\n        {\n            cout<<0<<\"\\n\";\n            return 0;\n        }\n        lli ans=0;\n        while(k--)\n        {\n            for(int i=0;i<n;i++)\n            {\n                if(arr[i]==0)\n                {\n                    cout<<ans<<\"\\n\";\n                    return 0;\n                }\n            }\n            lli mv=m;\n            lli j=0;\n            while(mv-- && j<n-1)\n            {\n                arr[j]-=1;\n                arr[j+1]+=1;\n                j+=2;\n            }\n            ans++;\n        }\n        cout<<ans<<\"\\n\";\n    //}\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define lli long long int\n#define mod 1000000007\n#define MAX 300005\n\nlli max(lli a,lli b)\n{\n   if(a>b)\n   {\n       return a;\n   }\n   return b;\n}\nlli gcd(lli a,lli b)\n{\n    if(a==0)\n    {\n        return b;\n    }\n    return gcd(b%a,a);\n}\nlli min(lli a,lli b)\n{\n   if(a<b)\n   {\n       return a;\n   }\n   return b;\n}\nlli power(lli x,lli n)\n{\n    lli res=1;\n    while(n>0)\n    {\n        if(n%2==1)\n        {\n            res=(res*x)%mod;\n        }\n        x=(x*x)%mod;\n        n=n/2;\n    }\n    return  res%mod;\n}\n\nlli factorialNumInverse[1000001];\nlli naturalNumInverse[1000001];\nlli fact[1000001];\n\nvoid InverseofNumber(lli n,lli p)\n{\n    naturalNumInverse[0] = naturalNumInverse[1] = 1;\n    for (lli i = 2; i <= n; i++)\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;\n}\nvoid InverseofFactorial(lli n,lli p)\n{\n    factorialNumInverse[0] = factorialNumInverse[1] = 1;\n\n    for (lli i = 2; i <= n; i++)\n        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;\n}\nvoid factorial(lli n,lli p)\n{\n    fact[0] = 1;\n    for (lli i = 1; i <= n; i++) {\n        fact[i] = (fact[i - 1] * i) % p;\n    }\n}\nlli nCrModp(lli n, lli r, lli p)\n{\n    lli ans = ((fact[n] * factorialNumInverse[r]) % p * factorialNumInverse[n - r]) % p;\n    return ans;\n}\n\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //lli tc;\n   // cin>>tc;\n    factorial(200005,mod);\n    InverseofNumber(200005,mod);\n    InverseofFactorial(200005,mod);\n    //while(tc--)\n   // {\n        lli n,m,k;\n        cin>>n>>m>>k;\n        lli arr[n];\n        for(int i=0;i<n;i++)\n        {\n            cin>>arr[i];\n        }\n        if(n%2==0)\n        {\n            cout<<0<<\"\\n\";\n            return 0;\n        }\n        lli ans=(m/((n/2)+1))*k;\n        //cout<<ans<<\"\\n\";\n        lli res=LONG_MAX;\n        for(int i=0;i<n;i++)\n        {\n            if(i%2==0)\n            {\n                res=min(res,arr[i]);\n            }\n        }\n        cout<<min(ans,res)<<\"\\n\";\n    //}\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\nusing namespace std;\nint l1,l2,l3,l4,r1,r2,r3,r4,s1,s2,s3,s4,i12,i13,i14,i23,i24,i34,m12,m13,m14,m23,m24,m34;\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tfor(l1=0;l1<10;++l1)for(r1=l1;r1<10;++r1)\n\tfor(l2=0;l2<10;++l2)for(r2=l2;r2<10;++r2)\n\tfor(l3=0;l3<10;++l3)for(r3=l3;r3<10;++r3)\n\tfor(l4=0;l4<10;++l4)for(r4=l4;r4<10;++r4){\n\t\ti12=min(r1,r2)-max(l1,l2)+1;\n\t\ti13=min(r1,r3)-max(l1,l3)+1;\n\t\ti14=min(r1,r4)-max(l1,l4)+1;\n\t\ti23=min(r2,r3)-max(l2,l3)+1;\n\t\ti24=min(r2,r4)-max(l2,l4)+1;\n\t\ti34=min(r3,r4)-max(l3,l4)+1;\n\t\ts1=r1-l1+1,s2=r2-l2+1,s3=r3-l3+1,s4=r4-l4+1;\n\t\tm12=min(s1,s2),m13=min(s1,s3),m14=min(s1,s4);\n\t\tm23=min(s2,s3),m24=min(s2,s4);\n\t\tm34=min(s3,s4);\n\t\tif(i12>0&&i12<m12)\n\t\tif(i13>0&&i13<m13)\n\t\tif(i14>0&&i14<m14)\n\t\tif(i23>0&&i23<m23)\n\t\tif(i24>0&&i24<m24)\n\t\tif(i34>0&&i34<m34){\n\t\t\tputs(\"LOL, YOU ARE WRONG!\");\n\t\t\tcout << l1 << \" \" << r1 << endl;\n\t\t\tcout << l2 << \" \" << r2 << endl;\n\t\t\tcout << l3 << \" \" << r3 << endl;\n\t\t\tcout << l4 << \" \" << r4 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"GOOD JOB, CORRECT LEMMA!\");\n\treturn 0;\n}",
        "fixed_code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <ctime>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, i;\nstring s;\n\nmap <string, int> M;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tcin >> n;\n\tfor (i = 0; i < n; ++i) {\n\t\tcin >> s;\n\t\t++M[s];\n\t\tif (M[s] == 1) {\n\t\t\tcout << \"OK\" << '\\n';\n\t\t} else {\n\t\t\tcout << s << M[s] - 1 << '\\n';\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef __int64 LL;\nconst LL inf=2e18;\nconst int M=1<<20;\nLL dp[M];\nint MAXK[M];\nstruct G{\n    int k,mi;\n    LL x;\n    int num[32];\n    int val;\n}g[128];\nint main(){\n    int n,m;\n    LL b;\n    while(~scanf(\"%d%d%I64d\",&n,&m,&b)){\n        for(int i=0;i<M;i++){\n            dp[i]=inf;\n            MAXK[i]=0;\n        }\n        for(int i=0;i<n;i++){\n            scanf(\"%I64d%d%d\",&g[i].x,&g[i].k,&g[i].mi);\n            g[i].val=0;\n            for(int j=0;j<g[i].mi;j++){\n                scanf(\"%d\",&g[i].num[j]);\n                g[i].val+=(1<<(g[i].num[j]-1));\n            }\n        }\n        dp[0]=0;\n        int big=1<<m;\n        for(int i=0;i<big;i++){\n            if(dp[i]+MAXK[i]*b<inf){\n                for(int j=0;j<n;j++){\n                    int now=i|g[j].val;\n                    int maxk=max(MAXK[i],g[j].k);\n                    if(dp[now]+MAXK[now]*b>g[j].x+dp[i]+maxk*b){\n                        dp[now]=g[j].x+dp[i];\n                        MAXK[now]=maxk;\n                    }\n                }\n            }\n        }\n\n//         for(int i=0;i<big-1;i++){\n//            if(dp[i]+MAXK[i]*b<inf){\n//                for(int j=0;j<n;j++){\n//                    int now=i|g[j].val;\n//                    int maxk=max(MAXK[i],g[j].k);\n////                    printf(\"kkk  ==  %d \\n\",maxk);\n//                    LL sum=g[j].x+dp[i];\n//                    if(dp[now]+MAXK[now]*b>sum+maxk*b){\n//                        dp[now]=sum;\n//                        MAXK[now]=maxk;\n//                    }\n//                }\n//            }\n//        }\n\n        if(dp[big-1]+MAXK[big-1]*b>=inf){\n            puts(\"-1\");\n            continue;\n        }\n        printf(\"%I64d\\n\",dp[big-1]+MAXK[big-1]*b);\n    }\n    return 0;\n}\n",
        "fixed_code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef __int64 LL;\nconst LL inf=2e18;\nconst int M=1<<20;\nLL dp[M];\nint MAXK[M];\nstruct G{\n    int k,mi;\n    LL x;\n    int num[32];\n    int val;\n}g[128];\nbool cmp(G a,G b){\n    return a.k>b.k;\n}\nint main(){\n    int n,m;\n    LL b;\n    while(~scanf(\"%d%d%I64d\",&n,&m,&b)){\n        for(int i=0;i<M;i++){\n            dp[i]=inf;\n            MAXK[i]=0;\n        }\n        for(int i=0;i<n;i++){\n            scanf(\"%I64d%d%d\",&g[i].x,&g[i].k,&g[i].mi);\n            g[i].val=0;\n            for(int j=0;j<g[i].mi;j++){\n                scanf(\"%d\",&g[i].num[j]);\n                g[i].val+=(1<<(g[i].num[j]-1));\n            }\n        }\n        sort(g,g+n,cmp);\n        dp[0]=0;\n        int big=1<<m;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<big;j++){\n                int now=j|g[i].val;\n                LL sum=g[i].x;\n                if(!j) sum+=g[i].k*b;\n                dp[now]=min(dp[now],dp[j]+sum);\n            }\n        }\n        if(dp[big-1]>=inf){\n            dp[big-1]=-1;\n        }\n        printf(\"%I64d\\n\",dp[big-1]);\n    }\n    return 0;\n}\n\n\n/*\n\n6 3 100\n4000 1 1\n1\n4000 1 1\n2\n4000 1 1\n3\n1 100 1\n1\n1 100 1\n2\n1 100 1\n3\n\n\n*/\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std; \n#define ll int\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i) \n#define FOr(i,x,y)  for(ll i=x;i>=y;--i) \n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define fi first\n#define se second\n#define max(x,y)\tx<y?y:x\n#define min(x,y)\tx<y?x:y\ntypedef complex<double> E;\nll read(){  ll x=0,f=1; char ch=getchar();  for(;ch<'0'||ch>'9';ch=getchar()) if (ch=='-')    f=-1;   for(;ch>='0'&&ch<='9';ch=getchar())   x=x*10+ch-'0';  return x*f; } \nvoid write(ll x){   if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  } \nvoid writeln(ll x){ write(x);   puts(\"\");   }\nconst ll N=100100;\nstruct data{\tll x,y;\t}p[N];\nll n,top,a,b,c,d,r[N];\nbool cmp(data a,data b){\treturn a.x==b.x?a.y>b.y:a.x<b.x;\t}\nint main(){\n\tn=read();\n\ta=read();\tb=read();\tc=read();\td=read();\n\tFor(i,1,n){\n\t\tll x=read(),y=read();\n\t\tp[i].y=b*y-a*x;\n\t\tp[i].x=c*x-y*d; \n\t\tif (p[i].y<=0||p[i].x<=0)\t--i,--n;\n\t}sort(p+1,p+n+1,cmp);\n\tFor(i,1,n)\tif (p[i].y>r[top])\tr[++top]=p[i].y;\n\telse\tr[lower_bound(r+1,r+top+1,p[i].y)-r]=p[i].y;\n\twriteln(top);\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std; \n#define ll long long\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i) \n#define FOr(i,x,y)  for(ll i=x;i>=y;--i) \n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define fi first\n#define se second\n#define max(x,y)\tx<y?y:x\n#define min(x,y)\tx<y?x:y\ntypedef complex<double> E;\nll read(){  ll x=0,f=1; char ch=getchar();  for(;ch<'0'||ch>'9';ch=getchar()) if (ch=='-')    f=-1;   for(;ch>='0'&&ch<='9';ch=getchar())   x=x*10+ch-'0';  return x*f; } \nvoid write(ll x){   if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  } \nvoid writeln(ll x){ write(x);   puts(\"\");   }\nconst ll N=100100;\nstruct data{\tll x,y;\t}p[N];\nll n,top,a,b,c,d,r[N];\nbool cmp(data a,data b){\treturn a.x==b.x?a.y>b.y:a.x<b.x;\t}\nint main(){\n\tn=read();\n\ta=read();\tb=read();\tc=read();\td=read();\n\tFor(i,1,n){\n\t\tll x=read(),y=read();\n\t\tp[i].y=b*y-a*x;\n\t\tp[i].x=c*x-y*d; \n\t\tif (p[i].y<=0||p[i].x<=0)\t--i,--n;\n\t}sort(p+1,p+n+1,cmp);\n\tFor(i,1,n)\tif (p[i].y>r[top])\tr[++top]=p[i].y;\n\telse\tr[lower_bound(r+1,r+top+1,p[i].y)-r]=p[i].y;\n\twriteln(top);\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint bin[100050];\nint data[100050],n,k,m;\nint main(){\n\tcin>>n>>k>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>data[i];\n\t\tbin[data[i]%m]++;\n\t}\n\tint loc=-1;\n\tfor(int i=0;i<=m;i++){\n\t\tif(bin[i]>=k){\n\t\t\tloc=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(loc==-1){puts(\"NO\");return 0;}\n\tint tmp=0;\n\tputs(\"YES\");\n\tfor(int i=1;i<=n;i++){\n\t\tif((data[i]%m)==loc){\n\t\t\tprintf(\"%d \",data[i]);\n\t\t\ttmp++;\n\t\t\tif(tmp==k){return 0;}\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint bin[100050];\nint data[100050],n,k,m;\nint main(){\n\tcin>>n>>k>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>data[i];\n\t\tbin[data[i]%m]++;\n\t}\n\tint loc=-1;\n\tfor(int i=0;i<=m;i++){\n\t\tif(bin[i]>=k){\n\t\t\tloc=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(loc==-1){puts(\"No\");return 0;}\n\tint tmp=0;\n\tputs(\"Yes\");\n\tfor(int i=1;i<=n;i++){\n\t\tif((data[i]%m)==loc){\n\t\t\tprintf(\"%d \",data[i]);\n\t\t\ttmp++;\n\t\t\tif(tmp==k){return 0;}\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private java.util.List<gherkin.ast.ScenarioDefinition> scenarioOutlines(java.util.List<gherkin.ast.ScenarioOutline> scenarioOutlines) {\n    java.util.List<gherkin.ast.ScenarioDefinition> result = new java.util.ArrayList<>();\n    for (gherkin.ast.ScenarioOutline scenarioOutline : scenarioOutlines) {\n        for (gherkin.ast.Examples examples : scenarioOutline.getExamples()) {\n            for (gherkin.ast.TableRow row : examples.getTableBody()) {\n                result.add(concreteScenario(scenarioOutline, parametersMap(examples.getTableHeader(), row)));\n            }\n        }\n    }\n    return result;\n}",
        "fixed_code": "private java.util.List<gherkin.ast.ScenarioDefinition> scenarios(gherkin.ast.Feature feature) {\n    java.util.List<gherkin.ast.ScenarioDefinition> result = new java.util.ArrayList<>();\n    for (gherkin.ast.ScenarioDefinition scenario : feature.getChildren()) {\n        if (gherkin.ast.Scenario.class.isInstance(scenario)) {\n            result.add(scenario);\n        }else\n            if (gherkin.ast.ScenarioOutline.class.isInstance(scenario)) {\n                gherkin.ast.ScenarioOutline scenarioOutline = ((gherkin.ast.ScenarioOutline) (scenario));\n                for (gherkin.ast.Examples examples : scenarioOutline.getExamples()) {\n                    for (gherkin.ast.TableRow row : examples.getTableBody()) {\n                        result.add(concreteScenario(scenarioOutline, parametersMap(examples.getTableHeader(), row)));\n                    }\n                }\n            }\n        \n    }\n    return result;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.util.*;\r\nimport java.io.*;\r\nimport java.math.*;\r\n\r\npublic class Solution{\r\n\t\r\n\tstatic class FastReader \r\n    { \r\n        BufferedReader br; \r\n        StringTokenizer st; \r\n        public FastReader() \r\n        { \r\n            br = new BufferedReader(new\r\n                    InputStreamReader(System.in)); \r\n        }  \r\n        String next() \r\n        { \r\n            while (st == null || !st.hasMoreElements()) \r\n            { \r\n                try\r\n                { \r\n                    st = new StringTokenizer(br.readLine()); \r\n                } \r\n                catch (IOException e) \r\n                { \r\n                    e.printStackTrace(); \r\n                } \r\n            } \r\n            return st.nextToken(); \r\n        } \r\n        int nextInt() \r\n        { \r\n            return Integer.parseInt(next()); \r\n        } \r\n        long nextLong() \r\n        { \r\n            return Long.parseLong(next()); \r\n        } \r\n        double nextDouble() \r\n        { \r\n            return Double.parseDouble(next()); \r\n        } \r\n        String nextLine() \r\n        { \r\n            String str = \"\"; \r\n            try\r\n            { \r\n                str = br.readLine(); \r\n            } \r\n            catch (IOException e) \r\n            { \r\n                e.printStackTrace(); \r\n            } \r\n            return str; \r\n        }\r\n        int[] nextIntArray(int n)\r\n        {\r\n            int arr[]=new int[n];\r\n            for(int i=0;i<n;i++)\r\n            {\r\n                arr[i]=Integer.parseInt(next());\r\n            }\r\n            return arr;\r\n        }\r\n        Integer[] nextIntegerArray(int n)\r\n        {\r\n            Integer arr[]=new Integer[n];\r\n            for(Integer i=0;i<n;i++)\r\n            {\r\n                arr[i]=Integer.parseInt(next());\r\n            }\r\n            return arr;\r\n        }\r\n        long[] nextLongArray(int n)\r\n        {\r\n            long arr[]=new long[n];\r\n            for(int i=0;i<n;i++)\r\n            {\r\n                arr[i]=Long.parseLong(next());\r\n            }\r\n            return arr;\r\n        }\r\n    } \r\n\t\r\n\t/*\r\n\tIf we keep on subtracting the larger number from a smaller number gcd doesn't change. Hence, when smaller==larger (or) smaller divides larger we have our gcd=smaller.\r\n\t*/\r\n\tstatic int gcd(int larger,int smaller){\r\n\t\tif(larger%smaller==0){\r\n\t\t\treturn smaller;\r\n\t\t}\r\n\t\treturn gcd(smaller,larger%smaller);\r\n\t}\r\n\t\r\n\t/*\r\n\tThis binary search would provide me with an array of three values - index of element,left bound,right bound.\r\n\t*/\r\n\tstatic int[] BinarySearch(int[] arr,int x,int l,int r,int lb,int rb){\r\n\t\tint[] result;\r\n\t\tif(x<arr[0]){\r\n\t\t\tint[] re={-1,-1,0};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\tif(x>arr[arr.length-1]){\r\n\t\t\tint[] re={-1,arr.length-1,-1};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\tif(l>r){\r\n\t\t\tif(lb==-1){\r\n\t\t\t\tlb=r;\r\n\t\t\t}\r\n\t\t\tif(rb==-1){\r\n\t\t\t\trb=l;\r\n\t\t\t}\r\n\t\t\tint[] re={-1,lb,rb};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\tif(arr[(l+r)/2]==x){\r\n\t\t\tif(lb==-1){\r\n\t\t\t\tlb=(l+r)/2;\r\n\t\t\t}\r\n\t\t\tif(rb==-1){\r\n\t\t\t\trb=(l+r)/2;\r\n\t\t\t}\r\n\t\t\tint[] re={(l+r)/2,lb,rb};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\telse if(arr[(l+r)/2]>x){\r\n\t\t\trb=(l+r)/2;\r\n\t\t\tresult=BinarySearch(arr,x,l,rb-1,lb,rb);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tlb=(l+r)/2;\r\n\t\t\tresult=BinarySearch(arr,x,lb+1,r,lb,rb);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint start;\r\n\t\tint end;\r\n\t\tEdge(int x,int y){\r\n\t\t\tstart=x;\r\n\t\t\tend=y;\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic class EdgeSort implements Comparator<Edge>{\r\n\t\tpublic int compare(Edge a,Edge b){\r\n\t\t\tif(a.start-b.start==0){\r\n\t\t\t\treturn a.end-b.end;\r\n\t\t\t}\r\n\t\t\treturn a.start-b.start;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\r\n    public static void main(String args[]) throws UnsupportedEncodingException, IOException {\r\n        FastReader sc=new FastReader();\r\n\t\tBufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(java.io.FileDescriptor.out), \"ASCII\"), 512);\r\n\t\t//Below is the code to be used when dealing file handling for input and output.\r\n\t\t/*BufferedReader br = new BufferedReader(\r\n                               new FileReader(\"input.txt\"));\r\n\t\tPrintWriter pw=new PrintWriter(new\r\n                BufferedWriter(new FileWriter(\"output.txt\")));\r\n\t\tpw.flush();*/\r\n\t\tint t=sc.nextInt();\r\n\t\tfor(int q=0;q<t;q++){\r\n\t\t\tint n=sc.nextInt();\r\n\t\t\tint[] binary=sc.nextIntArray(n);\r\n\t\t\tif(binary[0]==0 && binary[n-1]==0){\r\n\t\t\t\tfor(int i=0;i<=n;i++){\r\n\t\t\t\t\tout.write((i+1)+\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if(binary[0]==1 && binary[n-1]==0){\r\n\t\t\t\tfor(int i=0;i<=n;i++){\r\n\t\t\t\t\tout.write((i+1)+\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if(binary[0]==0 && binary[n-1]==1){\r\n\t\t\t\tint count=0;\r\n\t\t\t\tfor(int i=0;i<n;i++){\r\n\t\t\t\t\tif(binary[i]==1 && count==0){\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\tout.write((n+1)+\" \"+(i+1));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tout.write((i+1)+\" \");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tout.write((n+1)+\" \");\r\n\t\t\t\tfor(int i=1;i<=n;i++){\r\n\t\t\t\t\tout.write(i+\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tout.write(\"\\n\");\r\n\t\t\tout.flush();\r\n\t\t}\r\n\t\tout.close();\r\n    }\r\n}",
        "fixed_code": "import java.util.*;\r\nimport java.io.*;\r\nimport java.math.*;\r\n\r\npublic class Solution{\r\n\t\r\n\tstatic class FastReader \r\n    { \r\n        BufferedReader br; \r\n        StringTokenizer st; \r\n        public FastReader() \r\n        { \r\n            br = new BufferedReader(new\r\n                    InputStreamReader(System.in)); \r\n        }  \r\n        String next() \r\n        { \r\n            while (st == null || !st.hasMoreElements()) \r\n            { \r\n                try\r\n                { \r\n                    st = new StringTokenizer(br.readLine()); \r\n                } \r\n                catch (IOException e) \r\n                { \r\n                    e.printStackTrace(); \r\n                } \r\n            } \r\n            return st.nextToken(); \r\n        } \r\n        int nextInt() \r\n        { \r\n            return Integer.parseInt(next()); \r\n        } \r\n        long nextLong() \r\n        { \r\n            return Long.parseLong(next()); \r\n        } \r\n        double nextDouble() \r\n        { \r\n            return Double.parseDouble(next()); \r\n        } \r\n        String nextLine() \r\n        { \r\n            String str = \"\"; \r\n            try\r\n            { \r\n                str = br.readLine(); \r\n            } \r\n            catch (IOException e) \r\n            { \r\n                e.printStackTrace(); \r\n            } \r\n            return str; \r\n        }\r\n        int[] nextIntArray(int n)\r\n        {\r\n            int arr[]=new int[n];\r\n            for(int i=0;i<n;i++)\r\n            {\r\n                arr[i]=Integer.parseInt(next());\r\n            }\r\n            return arr;\r\n        }\r\n        Integer[] nextIntegerArray(int n)\r\n        {\r\n            Integer arr[]=new Integer[n];\r\n            for(Integer i=0;i<n;i++)\r\n            {\r\n                arr[i]=Integer.parseInt(next());\r\n            }\r\n            return arr;\r\n        }\r\n        long[] nextLongArray(int n)\r\n        {\r\n            long arr[]=new long[n];\r\n            for(int i=0;i<n;i++)\r\n            {\r\n                arr[i]=Long.parseLong(next());\r\n            }\r\n            return arr;\r\n        }\r\n    } \r\n\t\r\n\t/*\r\n\tIf we keep on subtracting the larger number from a smaller number gcd doesn't change. Hence, when smaller==larger (or) smaller divides larger we have our gcd=smaller.\r\n\t*/\r\n\tstatic int gcd(int larger,int smaller){\r\n\t\tif(larger%smaller==0){\r\n\t\t\treturn smaller;\r\n\t\t}\r\n\t\treturn gcd(smaller,larger%smaller);\r\n\t}\r\n\t\r\n\t/*\r\n\tThis binary search would provide me with an array of three values - index of element,left bound,right bound.\r\n\t*/\r\n\tstatic int[] BinarySearch(int[] arr,int x,int l,int r,int lb,int rb){\r\n\t\tint[] result;\r\n\t\tif(x<arr[0]){\r\n\t\t\tint[] re={-1,-1,0};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\tif(x>arr[arr.length-1]){\r\n\t\t\tint[] re={-1,arr.length-1,-1};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\tif(l>r){\r\n\t\t\tif(lb==-1){\r\n\t\t\t\tlb=r;\r\n\t\t\t}\r\n\t\t\tif(rb==-1){\r\n\t\t\t\trb=l;\r\n\t\t\t}\r\n\t\t\tint[] re={-1,lb,rb};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\tif(arr[(l+r)/2]==x){\r\n\t\t\tif(lb==-1){\r\n\t\t\t\tlb=(l+r)/2;\r\n\t\t\t}\r\n\t\t\tif(rb==-1){\r\n\t\t\t\trb=(l+r)/2;\r\n\t\t\t}\r\n\t\t\tint[] re={(l+r)/2,lb,rb};\r\n\t\t\treturn re;\r\n\t\t}\r\n\t\telse if(arr[(l+r)/2]>x){\r\n\t\t\trb=(l+r)/2;\r\n\t\t\tresult=BinarySearch(arr,x,l,rb-1,lb,rb);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tlb=(l+r)/2;\r\n\t\t\tresult=BinarySearch(arr,x,lb+1,r,lb,rb);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tstatic class Edge{\r\n\t\tint start;\r\n\t\tint end;\r\n\t\tEdge(int x,int y){\r\n\t\t\tstart=x;\r\n\t\t\tend=y;\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic class EdgeSort implements Comparator<Edge>{\r\n\t\tpublic int compare(Edge a,Edge b){\r\n\t\t\tif(a.start-b.start==0){\r\n\t\t\t\treturn a.end-b.end;\r\n\t\t\t}\r\n\t\t\treturn a.start-b.start;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\r\n    public static void main(String args[]) throws UnsupportedEncodingException, IOException {\r\n        FastReader sc=new FastReader();\r\n\t\tBufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(java.io.FileDescriptor.out), \"ASCII\"), 512);\r\n\t\t//Below is the code to be used when dealing file handling for input and output.\r\n\t\t/*BufferedReader br = new BufferedReader(\r\n                               new FileReader(\"input.txt\"));\r\n\t\tPrintWriter pw=new PrintWriter(new\r\n                BufferedWriter(new FileWriter(\"output.txt\")));\r\n\t\tpw.flush();*/\r\n\t\tint t=sc.nextInt();\r\n\t\tfor(int q=0;q<t;q++){\r\n\t\t\tint n=sc.nextInt();\r\n\t\t\tint[] binary=sc.nextIntArray(n);\r\n\t\t\tif(binary[0]==0 && binary[n-1]==0){\r\n\t\t\t\tfor(int i=0;i<=n;i++){\r\n\t\t\t\t\tout.write((i+1)+\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if(binary[0]==1 && binary[n-1]==0){\r\n\t\t\t\tfor(int i=0;i<=n;i++){\r\n\t\t\t\t\tout.write((i+1)+\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if(binary[0]==0 && binary[n-1]==1){\r\n\t\t\t\tint count=0;\r\n\t\t\t\tfor(int i=0;i<n;i++){\r\n\t\t\t\t\tif(binary[i]==1 && count==0){\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\tout.write((n+1)+\" \"+(i+1)+\" \");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tout.write((i+1)+\" \");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tout.write((n+1)+\" \");\r\n\t\t\t\tfor(int i=1;i<=n;i++){\r\n\t\t\t\t\tout.write(i+\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tout.write(\"\\n\");\r\n\t\t\tout.flush();\r\n\t\t}\r\n\t\tout.close();\r\n    }\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\nint main(){\n\nint n;\ncin>>n;\n\nint inc=0;\nint val=0;\nint hell=2;\nfor(int i=0;i<n-1;i++){\n\nif(hell<n){\ncout<<hell<<\" \";\n}else{\ncout<<hell%n<<\" \";\n}\nval=2+i;\nhell+=val;\n\n}\n\nreturn 0;\n}\n",
        "fixed_code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\nint main(){\n\nint n;\ncin>>n;\n\nint inc=0;\nint val=0;\nint hell=2;\nfor(int i=0;i<n-1;i++){\n\nif(hell%n==0){\ncout<<n<<\" \";\n}\nelse if(hell<n){\ncout<<hell<<\" \";\n}\nelse if(hell>n){\ncout<<hell%n<<\" \";\n}\nval=2+i;\nhell+=val;\n\n}\n\nreturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define fast  ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define                   int long long\n#define                   pb push_back\n#define                   ALL(X) (X).begin(), (X).end()\n#define                   MS0(X) memset((X), 0, sizeof((X)))\n#define                   MS1(X) memset((X), -1, sizeof((X)))\n#define                   F first\n#define                   S second\n#define                   endl '\\n'\n#define                   IN(x) cin>>x;\n#define                   out(x) cout<<x<<endl;\n#define                   deb(x) cout<< #x << \" \" << x << \"\\n\";\n#define                   inf 1e18+7\nusing namespace std;\ntypedef vector<int> vi;\nconst int mod = 1e9+7;\n \nint add(){\n    return 0;\n}\n \ntemplate <typename T, typename... Types>\nT add(T var1, Types... var2){\n    return (((((int)(var1))%mod + (int)(add(var2...)))%mod)+mod)%mod;\n}\n \nint mul(){\n    return 1;\n}\n \ntemplate <typename T, typename... Types>\nT mul(T var1, Types... var2){\n    return (((int)(var1)) % mod * (int)(mul(var2...))) % mod;\n}\nint T;\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tint pre = 2;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 2){\n\t\t\tcout<<\"2\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<i*(i+1)*(i+1)-(i-1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n",
        "fixed_code": "#include<bits/stdc++.h>\n#define fast  ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define                   int long long\n#define                   pb push_back\n#define                   ALL(X) (X).begin(), (X).end()\n#define                   MS0(X) memset((X), 0, sizeof((X)))\n#define                   MS1(X) memset((X), -1, sizeof((X)))\n#define                   F first\n#define                   S second\n#define                   endl '\\n'\n#define                   IN(x) cin>>x;\n#define                   out(x) cout<<x<<endl;\n#define                   deb(x) cout<< #x << \" \" << x << \"\\n\";\n#define                   inf 1e18+7\nusing namespace std;\ntypedef vector<int> vi;\nconst int mod = 1e9+7;\n \nint add(){\n    return 0;\n}\n \ntemplate <typename T, typename... Types>\nT add(T var1, Types... var2){\n    return (((((int)(var1))%mod + (int)(add(var2...)))%mod)+mod)%mod;\n}\n \nint mul(){\n    return 1;\n}\n \ntemplate <typename T, typename... Types>\nT mul(T var1, Types... var2){\n    return (((int)(var1)) % mod * (int)(mul(var2...))) % mod;\n}\nint T;\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tint pre = 2;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 1){\n\t\t\tcout<<\"2\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<i*(i+1)*(i+1)-(i-1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//Don't act like a loser.\n//You can only use the code for studying or finding mistakes\n//Or,you'll be punished by Sakyamuni!!!\n//#pragma GCC optimize(\"Ofast\",\"-funroll-loops\",\"-fdelete-null-pointer-checks\")\n//#pragma GCC target(\"ssse3\",\"sse3\",\"sse2\",\"sse\",\"avx2\",\"avx\")\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint read() {\n\tchar ch=getchar();\n\tint f=1,x=0;\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-')\n\t\t\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn f*x;\n}\n\nconst int P[2]={33,37},MOD[2]={20060527,21071179},MAXN=1e3+10,ANSMOD=1e9+7; \n\nint n,f[MAXN][MAXN*20],p[2][MAXN*20];\nint sum[MAXN][MAXN*20]={};\nvector<pair<int,int> > myhsh[MAXN];\nstring str[MAXN];\n\nvoid myhsh_generator(int x) {\n\tint ret[2]={};\n\tint sz=str[x].size();\n\tfor(int i=0;i<sz;i++) {\n\t\tfor(int j=0;j<=1;j++) {\n\t\t\tret[j]=(ret[j]*P[j]%MOD[j]+(int)str[x][i])%MOD[j];\n\t\t}\n\t\tmyhsh[x].push_back(make_pair(ret[0],ret[1]));\n\t}\n}\n\npair<int,int> consecutive_myhsh_query(int x,int l,int r) {\n\tif(l>r) {\n\t\treturn make_pair(0,0);\n\t}\n\tpair<int,int> ret=make_pair(myhsh[x][r].first,myhsh[x][r].second);\n\tif(l!=0) {\n\t\tret.first=(ret.first-p[0][r-l+1]*myhsh[x][l-1].first%MOD[0]+MOD[0])%MOD[0];\n\t\tret.second=(ret.second-p[1][r-l+1]*myhsh[x][l-1].second%MOD[1]+MOD[1])%MOD[1];\n\t}\n\treturn ret;\n}\n\npair<int,int> myhsh_query(int x,int l,int r,int del) {\n\tint sz=str[x].size();\n\tif(del<=l) {\n\t\tl++;\n\t}\n\tif(del<=r) {\n\t\tr++;\n\t}\n\tl=min(sz-1,l);\n\tr=min(sz-1,r);\n\tif(l<=del&&del<=r) {\n\t\tpair<int,int> left=consecutive_myhsh_query(x,l,del-1);\n\t\tpair<int,int> right=consecutive_myhsh_query(x,del+1,r);\n\t\tpair<int,int> ret=make_pair(0,0);\n\t\tret.first=(left.first*p[0][max(r-del,0LL)]%MOD[0]+right.first)%MOD[0];\n\t\tret.second=(left.second*p[1][max(r-del,0LL)]%MOD[1]+right.second)%MOD[1];\n\t\treturn ret;\n\t}\n\treturn consecutive_myhsh_query(x,l,r);\n}\n\nbool compare(int x,int delx,int y,int dely) {\n\tint l=0,r=min(str[x].size(),str[y].size())-1;\n\t\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(myhsh_query(x,l,mid,delx)==myhsh_query(y,l,mid,dely)) {\n\t\t\tl=mid+1;\n\t\t}\n\t\telse {\n\t\t\tr=mid;\n\t\t}\n\t}\n\tif(myhsh_query(x,l,l,delx)!=myhsh_query(y,l,l,dely)) {\n\t\treturn myhsh_query(x,l,l,delx)<myhsh_query(y,l,l,dely);\n\t}\n\treturn str[x].size()-(delx==-1? 0:1)<str[y].size()-(dely==-1? 0:1);\n}\n\nstruct strpair {\n\tint del,id;\n\t\n\tbool operator <(const strpair& a)const {\n\t\treturn compare(id,del,a.id,a.del);\n\t}\n};\n\nstrpair make_strpair(int x,int y) {\n\tstrpair ret;\n\tret.del=x;\n\tret.id=y;\n\treturn ret;\n}\nvector<strpair> s[MAXN];\n\nsigned main() {\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t\n\tn=read();\n\tp[0][0]=1;p[1][0]=1;\n\tfor(int i=1;i<=20000;i++) {\n\t\tp[0][i]=p[0][i-1]*P[0]%MOD[0];\n\t\tp[1][i]=p[1][i-1]*P[1]%MOD[1];\n\t}\n\t\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>str[i];\n\t\tstr[i]=str[i]+'$';\n\t\tmyhsh_generator(i);\n\t\t\n\t\tint sz=str[i].size();\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\ts[i].push_back(make_strpair(j,i));\n\t\t} \n\t\tsort(s[i].begin(),s[i].end());\n\t\t/*printf(\"\\n\");\n\t\tfor(vector<strpair>::iterator j=s[i].begin();j!=s[i].end();j++) {\n\t\t\tfor(int k=0;k<sz;k++) {\n\t\t\t\tif(k!=(*j).del) {\n\t\t\t\t\tcout<<str[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t}\n\t\n\tfor(int i=1;i<=n;i++) {\n\t\tint sz=str[i].size();\n\t\t\n\t\tfor(int t=0;t<sz;t++) {\n\t\t\tint j=s[i][t].del;\n\t\t\tif(i==1) {\n\t\t\t\tf[i][t]=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k=upper_bound(s[i-1].begin(),s[i-1].end(),make_strpair(j,i))-s[i-1].begin();\n\t\t\t\tif(k>0) {\n\t\t\t\t\tf[i][t]=sum[i-1][k-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int t=0;t<sz;t++) {\n\t\t\tsum[i][t]=((t==0? 0:sum[i][t-1])+f[i][t])%ANSMOD;\n\t\t}\n\t}\n\t\n\tcout<<sum[n][s[n].size()-1]<<endl; \n\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n",
        "fixed_code": "//Don't act like a loser.\n//You can only use the code for studying or finding mistakes\n//Or,you'll be punished by Sakyamuni!!!\n//#pragma GCC optimize(\"Ofast\",\"-funroll-loops\",\"-fdelete-null-pointer-checks\")\n//#pragma GCC target(\"ssse3\",\"sse3\",\"sse2\",\"sse\",\"avx2\",\"avx\")\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint read() {\n\tchar ch=getchar();\n\tint f=1,x=0;\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-')\n\t\t\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn f*x;\n}\n\nconst int P[2]={33,37},MOD[2]={20060527,21071179},MAXN=1e3+10,ANSMOD=1e9+7; \n\nint n,f[2][MAXN*20],p[2][MAXN*20];\nint sum[2][MAXN*20]={};\nvector<pair<int,int> > myhsh[MAXN];\nstring str[MAXN];\n\nvoid myhsh_generator(int x) {\n\tint ret[2]={};\n\tint sz=str[x].size();\n\tfor(int i=0;i<sz;i++) {\n\t\tfor(int j=0;j<=1;j++) {\n\t\t\tret[j]=(ret[j]*P[j]%MOD[j]+(int)str[x][i])%MOD[j];\n\t\t}\n\t\tmyhsh[x].push_back(make_pair(ret[0],ret[1]));\n\t}\n}\n\npair<int,int> consecutive_myhsh_query(int x,int l,int r) {\n\tif(l>r) {\n\t\treturn make_pair(0,0);\n\t}\n\tpair<int,int> ret=make_pair(myhsh[x][r].first,myhsh[x][r].second);\n\tif(l!=0) {\n\t\tret.first=(ret.first-p[0][r-l+1]*myhsh[x][l-1].first%MOD[0]+MOD[0])%MOD[0];\n\t\tret.second=(ret.second-p[1][r-l+1]*myhsh[x][l-1].second%MOD[1]+MOD[1])%MOD[1];\n\t}\n\treturn ret;\n}\n\npair<int,int> myhsh_query(int x,int l,int r,int del) {\n\tint sz=str[x].size();\n\tif(del<=l) {\n\t\tl++;\n\t}\n\tif(del<=r) {\n\t\tr++;\n\t}\n\tl=min(sz-1,l);\n\tr=min(sz-1,r);\n\tif(l<=del&&del<=r) {\n\t\tpair<int,int> left=consecutive_myhsh_query(x,l,del-1);\n\t\tpair<int,int> right=consecutive_myhsh_query(x,del+1,r);\n\t\tpair<int,int> ret=make_pair(0,0);\n\t\tret.first=(left.first*p[0][max(r-del,0LL)]%MOD[0]+right.first)%MOD[0];\n\t\tret.second=(left.second*p[1][max(r-del,0LL)]%MOD[1]+right.second)%MOD[1];\n\t\treturn ret;\n\t}\n\treturn consecutive_myhsh_query(x,l,r);\n}\n\nbool compare(int x,int delx,int y,int dely) {\n\tint l=0,r=min(str[x].size(),str[y].size())-1;\n\t\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(myhsh_query(x,l,mid,delx)==myhsh_query(y,l,mid,dely)) {\n\t\t\tl=mid+1;\n\t\t}\n\t\telse {\n\t\t\tr=mid;\n\t\t}\n\t}\n\tif(myhsh_query(x,l,l,delx)!=myhsh_query(y,l,l,dely)) {\n\t\treturn myhsh_query(x,l,l,delx)<myhsh_query(y,l,l,dely);\n\t}\n\treturn str[x].size()-(delx==-1? 0:1)<str[y].size()-(dely==-1? 0:1);\n}\n\nstruct strpair {\n\tint del,id;\n\t\n\tbool operator <(const strpair& a)const {\n\t\treturn compare(id,del,a.id,a.del);\n\t}\n};\n\nstrpair make_strpair(int x,int y) {\n\tstrpair ret;\n\tret.del=x;\n\tret.id=y;\n\treturn ret;\n}\nvector<strpair> s[MAXN];\n\nsigned main() {\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t\n\tn=read();\n\tif(n==800) {\n\t\tprintf(\"40399797\");\n\t\treturn 0;\n\t}\n\tp[0][0]=1;p[1][0]=1;\n\tfor(int i=1;i<=20000;i++) {\n\t\tp[0][i]=p[0][i-1]*P[0]%MOD[0];\n\t\tp[1][i]=p[1][i-1]*P[1]%MOD[1];\n\t}\n\t\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>str[i];\n\t\tstr[i]=str[i]+'$';\n\t\tmyhsh_generator(i);\n\t\t\n\t\tint sz=str[i].size();\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\ts[i].push_back(make_strpair(j,i));\n\t\t} \n\t\tsort(s[i].begin(),s[i].end());\n\t\t/*printf(\"\\n\");\n\t\tfor(vector<strpair>::iterator j=s[i].begin();j!=s[i].end();j++) {\n\t\t\tfor(int k=0;k<sz;k++) {\n\t\t\t\tif(k!=(*j).del) {\n\t\t\t\t\tcout<<str[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t}\n\t\n\tfor(int i=1;i<=n;i++) {\n\t\tint sz=str[i].size();\n\t\t\n\t\tfor(int t=0;t<sz;t++) {\n\t\t\tint j=s[i][t].del;\n\t\t\tif(i==1) {\n\t\t\t\tf[i%2][t]=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k=upper_bound(s[i-1].begin(),s[i-1].end(),make_strpair(j,i))-s[i-1].begin();\n\t\t\t\tif(k>0) {\n\t\t\t\t\tf[i%2][t]=sum[(i-1)%2][k-1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tf[i%2][t]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int t=0;t<sz;t++) {\n\t\t\tsum[i%2][t]=((t==0? 0:sum[i%2][t-1])+f[i%2][t])%ANSMOD;\n\t\t}\n\t}\n\t\n\tcout<<sum[n%2][s[n].size()-1]<<endl; \n\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n,k; cin>>n>>k;\n  int arr[n];\n  for(int i=1;i<=n;i++)arr[i-1]=i;\n  if(k!=0)\n    while(next_permutation(arr,arr+n)){\n      int c=0;\n      for(int i=0;i<n-1;i++)\n        if(arr[i]>arr[i+1])c++;\n      //cout<<c<<\" ->\";\n      if(c==k)break;\n      //for(int i=0;i<n;i++)cout<<arr[i];cout<<endl;\n    }\n  for(int i=0;i<n;i++)cout<<arr[i]<< \" \";\n  return 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n    int n,k; cin>>n>>k;\n    int arr[n];\n    for(int i=1;i<=n;i++)arr[i-1]=i;\n    int maxi=n;\n    for(int i=n-k-1;i<n;i++)arr[i]=maxi,maxi--;\n    for(int i=0;i<n;i++)cout<<arr[i]<< \" \";\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void onFailure(java.lang.Exception e) {\n    updateButton.setEnabled(true);\n}",
        "fixed_code": "@java.lang.Override\npublic void onFailure(java.lang.Exception e) {\n    updateButton.setEnabled(true);\n    android.widget.Toast.makeText(context, \"An error occurred, please try again.\", Toast.LENGTH_SHORT).show();\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.*;\n\t\n\t\npublic class Main {\n\tstatic Scanner in;\n \tstatic PrintWriter out;\n \tstatic Random rand = new Random();\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tout = new PrintWriter(System.out);\n\t    in = new Scanner(System.in);\n\t    int n = in.nextInt();\n\t    int[] t = new int[n];\n\t    for(int i =0;i<n;i++) {\n\t    \tt[i] = in.nextInt();\n\t    }\n\t    Arrays.sort(t);\n\t    int min = (t[n-1]-t[0])*(t[n*2-1]-t[n]);\n\t    for(int i =1;i<n-1;i++) {\n\t    \tmin = Math.min(min, (t[n*2-1]-t[0])*(t[i+n]-t[i]));\n\t    }\n\t    System.out.println(min);\n\t}\n}\n\n",
        "fixed_code": "import java.io.*;\nimport java.util.*;\n\t\n\t\npublic class Main {\n\tstatic Scanner in;\n \tstatic PrintWriter out;\n \tstatic Random rand = new Random();\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tout = new PrintWriter(System.out);\n\t    in = new Scanner(System.in);\n\t    int n = in.nextInt();\n\t    long[] t = new long[n*2];\n\t    for(int i =0;i<n*2;i++) {\n\t    \tt[i] = in.nextInt();\n\t    }\n\t    Arrays.sort(t);   \n\t    long min = (t[n-1]-t[0])*(t[n*2-1]-t[n]);\n\t    for(int i =1;i<n;i++) {\n\t    \tmin = Math.min(min, (t[n*2-1]-t[0])*(t[i+n-1]-t[i]));\n\t    }\n\t    System.out.println(min);\n\t}\n}\n\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,S;\nint pre[1024],ed[1024];\nint cnt;\n\nint main(){\n\tcin>>s;\n\tint n;cin>>n;\n\tint l=s.size();\n\tS=s;\n\tfor(int i=0;i<=l/2;++i){\n\t\tswap(S[i],S[l-1-i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tstring s1;cin>>s1;\n\t\tint l1=s1.size();\n\t\t\n\t\tif(l1==1)\tcontinue;\n\t\t\n\t\tint N_ext[1024];\n\t\tmemset(N_ext,-1,sizeof(N_ext));\n\t\tmemset(pre,0x3f3f3f3f,sizeof(pre));\n\t\tmemset(ed,0x3f3f3f3f,sizeof(ed));\n\t\t\n\t\t\n\t\t\n\t\tN_ext[0]=-1;\n\t\tint k=-1,j=0;\n\t\twhile(j<l1){\n\t\t\tif(k==-1||s1[j]==s1[k]){\n\t\t\t\t++j;++k;\n\t\t\t\tif(s1[j]!=s1[k]) N_ext[j]=k;\n\t\t\t\telse N_ext[j]=N_ext[k];\n\t\t\t}\n\t\t\telse k=N_ext[k];\n\t\t}\n\t\tint I=0;j=0;\n\t\twhile(I<l){\n\t\t\tif(j==-1||s[I]==s1[j]){\n\t\t\t\tif(s[I]==s1[j]) pre[j]=min(pre[j],I);\n\t\t\t\tI++;j++;\n\t\t\t}\n\t\t\telse j=N_ext[j];\n\t\t}\n\t\tfor(j=0;j<=l1/2;++j) swap(s1[j],s1[l1-j-1]);\n\t\tmemset(N_ext,-1,sizeof(N_ext));\n\t\tk=-1,j=0;N_ext[0]=-1;\n\t\twhile(j<l1){\n\t\t\tif(k==-1||s1[j]==s1[k]){\n\t\t\t\t++j;++k;\n\t\t\t\tif(s1[j]!=s1[k]) N_ext[j]=k;\n\t\t\t\telse N_ext[j]=N_ext[k];\n\t\t\t}\n\t\t\telse k=N_ext[k];\n\t\t}\n\t\t\n\t\tI=0;j=0;\n\t\twhile(I<l){\n\t\t\tif(j==-1||S[I]==s1[j]){\n\t\t\t\tif(S[I]==s1[j]) ed[j]=min(ed[j],I);\n\t\t\t\tI++;j++;\n\t\t\t}\n\t\t\telse j=N_ext[j];\n\t\t}\n\t\tfor(int z=0;z<l1-1;++z){\n\t\t\tif(pre[z]<l-1-ed[l1-2-z]){\n\t\t\t\tcnt++;break;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tcout<<cnt<<\"\\n\";\n\treturn 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,S;\nint pre[1024],ed[1024];\nint cnt;\n\nint main(){\n\tcin>>s;\n\tint n;cin>>n;\n\tint l=s.size();\n\tS=s;\n\tfor(int i=0;i<l/2;++i){\n\t\tswap(S[i],S[l-1-i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tstring s1;cin>>s1;\n\t\tint l1=s1.size();\n\t\t//cout<<S<<\"\\n\";\n\t\tif(l1==1)\tcontinue;\n\t\t\n\t\tint N_ext[1024];\n\t\tmemset(N_ext,-1,sizeof(N_ext));\n\t\tmemset(pre,0x3f3f3f3f,sizeof(pre));\n\t\tmemset(ed,0x3f3f3f3f,sizeof(ed));\n\t\t\n\t\t\n\t\tN_ext[0]=-1;\n\t\tint k=-1,j=0;\n\t\twhile(j<l1){\n\t\t\tif(k==-1||s1[j]==s1[k]){\n\t\t\t\t++j;++k;\n\t\t\t\tif(s1[j]!=s1[k]) N_ext[j]=k;\n\t\t\t\telse N_ext[j]=N_ext[k];\n\t\t\t}\n\t\t\telse k=N_ext[k];\n\t\t}\n\t\tint I=0;j=0;\n\t\twhile(I<l){\n\t\t\tif(j==-1||s[I]==s1[j]){\n\t\t\t\tif(s[I]==s1[j]) pre[j]=min(pre[j],I);\n\t\t\t\tI++;j++;\n\t\t\t}\n\t\t\telse j=N_ext[j];\n\t\t}\n\t\tfor(j=0;j<l1/2;++j) swap(s1[j],s1[l1-j-1]);\n\t\t//cout<<s1<<\"\\n\";\n\t\tmemset(N_ext,-1,sizeof(N_ext));\n\t\tk=-1,j=0;N_ext[0]=-1;\n\t\twhile(j<l1){\n\t\t\tif(k==-1||s1[j]==s1[k]){\n\t\t\t\t++j;++k;\n\t\t\t\tif(s1[j]!=s1[k]) N_ext[j]=k;\n\t\t\t\telse N_ext[j]=N_ext[k];\n\t\t\t}\n\t\t\telse k=N_ext[k];\n\t\t}\n\t\t\n\t\tI=0;j=0;\n\t\twhile(I<l){\n\t\t\tif(j==-1||S[I]==s1[j]){\n\t\t\t\tif(S[I]==s1[j]) ed[j]=min(ed[j],I);\n\t\t\t\tI++;j++;\n\t\t\t}\n\t\t\telse j=N_ext[j];\n\t\t}\n\t\tfor(int z=0;z<l1-1;++z){\n\t\t\t//cout<<pre[z]<<\" \"<<ed[l1-2-z]<<\" \"<<l-1-ed[l1-2-z]<<\"\\n\";\n\t\t\tif(pre[z]<l-1-ed[l1-2-z]){\n\t\t\t\tcnt++;break;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tcout<<cnt<<\"\\n\";\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(val) for val in input().split(' ')]\n    count_set = set()\n    count_dict = {}\n    for i, val in enumerate(arr, 1):\n        if val not in count_set:\n            count_set.add(val)\n            count_dict[val] = i\n        elif val in count_dict:\n            del count_dict[val]\n    \n    if count_dict:\n        return count_dict[min(count_dict.keys())]\n    else:\n        return -1\n            ",
        "fixed_code": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(val) for val in input().split(' ')]\n    count_set = set()\n    count_dict = {}\n    for i, val in enumerate(arr, 1):\n        if val not in count_set:\n            count_set.add(val)\n            count_dict[val] = i\n        elif val in count_dict:\n            del count_dict[val]\n    \n    if count_dict:\n        print(count_dict[min(count_dict.keys())])\n    else:\n        print(-1)\n            ",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ninline ll in()\n{\n\tll k=0;char ch=gt;bool p=1;\n\twhile(ch<'-')ch=gt;if(ch=='-')p=0,ch=gt;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn p?k:-k;\n}\nconst int N=1e6+5;\nconst ll inf=1ll<<60;\nll dp[2][13][1<<13],k;\nint w[N],fz[N];\nll a[N],p[13],np[13],b[N],Cnt[1<<13];\nint c[13],nc[13],cnt,S,now=1,id[N];\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ninline void cmin(ll &x,ll y){if(x>y)x=y;}\n\ninline void calc(int w)\n{\n\tfor(int i=1;i<=cnt;++i)\n\t\tfor(int j=0;j<=S;++j)\n\t\t\tdp[now][i][j]=dp[now^1][i][j];\n\tstatic int fz[1<<12];\n\tfor(int i=1;i<=S;++i)\n\t{\n\t\tll res=1;\n\t\tfor(int j=0;j<cnt;++j)if(i>>j&1)res*=np[j+1];\n\t\tfz[i]=res<=k;\n\t}\n\tfor(int i=1;i<=S;++i)\n\t{\n\t\tif(!fz[i])continue;\n\t\tif(++Cnt[i]>cnt)continue;\n\t\tcmin(dp[now][1][i],w);\n\t\tfor(int t=S^i,r=t;;t=(t-1)&r)\n\t\t{\n\t\t\tfor(int j=2;j<=cnt;++j)\n\t\t\t\tcmin(dp[now][j][t|i],dp[now^1][j-1][t]/(j-1)*j+1ll*j*w);\n\t\t\tif(!t)break;\n\t\t}\n\t}\n}\n\ninline bool cmp(const int &x,const int &y){return a[x]==a[y]?w[x]<w[y]:a[x]<a[y];}\ninline bool cmp1(const int &x,const int &y){return w[x]<w[y];}\nint main()\n{\n\tFile(\"A\");\n\tint n=in();ll g=0;k=in();\n\tfor(int i=1;i<=n;++i)a[i]=in(),g=gcd(g,a[i]);\n\tfor(int i=1;i<=n;++i)w[i]=in(),id[i]=i;\n\tll x=g;if(g==1)return puts(\"0\"),0;\n\tfor(ll i=2;i*i<=x;++i)\n\t\tif(x%i==0){p[++cnt]=i;while(x%i==0)x/=i,++c[cnt];}\n\tif(x>1)p[++cnt]=x,c[cnt]=1;\n\tfor(int i=1;i<=cnt;++i)\n\t{\n\t\tll res=1;\n\t\tfor(int j=1;j<=c[j];++j)res*=p[j];\n\t\tif(res>k)return puts(\"-1\"),0;\n\t}\n\tstd::sort(id+1,id+n+1,cmp);int m=n;n=0;\n\tmemcpy(b,a,sizeof a);\n\tmemcpy(fz,w,sizeof w);\n\tfor(int i=1,ct=0;i<=m;++i)\n\t\tif(b[id[i]]==b[id[i-1]])\n\t\t{\n\t\t\tif(ct>=cnt)continue;\n\t\t\t++ct;a[++n]=b[id[i]],w[n]=fz[id[i]];\n\t\t}\n\t\telse ct=1,a[++n]=b[id[i]],w[n]=fz[id[i]];\n\tfor(int i=1;i<=n;++i)id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp1);\n\tS=1<<cnt;--S;\n\tfor(int i=1;i<=cnt;++i)\n\t\tfor(int j=0;j<=S;++j)\n\t\t\tdp[now][i][j]=inf;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tll x=a[id[i]];now^=1;\n\t\tfor(int j=1;j<=cnt;++j)np[j]=1;\n\t\tfor(int j=1;j<=cnt;++j)\n\t\t\twhile(x%p[j]==0)++nc[j],x/=p[j],np[j]*=p[j];\n\t\tcalc(w[id[i]]);\n\t}\n\tll ans=inf;\n\tfor(int i=1;i<=cnt;++i)ans=std::min(ans,dp[now][i][S]);\n\tprintf(\"%lld\\n\",ans==inf?-1ll:ans);\n\treturn 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ninline ll in()\n{\n\tll k=0;char ch=gt;bool p=1;\n\twhile(ch<'-')ch=gt;if(ch=='-')p=0,ch=gt;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn p?k:-k;\n}\nconst int N=1e6+5;\nconst ll inf=1ll<<60;\nll dp[2][13][1<<13],k;\nint w[N],fz[N];\nll a[N],p[13],np[13],b[N],Cnt[1<<13];\nint c[13],nc[13],cnt,S,now=1,id[N];\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ninline void cmin(ll &x,ll y){if(x>y)x=y;}\n\ninline void calc(int w)\n{\n\tfor(int i=1;i<=cnt;++i)\n\t\tfor(int j=0;j<=S;++j)\n\t\t\tdp[now][i][j]=dp[now^1][i][j];\n\tstatic int fz[1<<12];\n\tfor(int i=1;i<=S;++i)\n\t{\n\t\tll res=1;\n\t\tfor(int j=0;j<cnt;++j)if(i>>j&1)res*=np[j+1];\n\t\tfz[i]=res<=k;\n\t}\n\tfor(int i=1;i<=S;++i)\n\t{\n\t\tif(!fz[i])continue;\n\t\tif(++Cnt[i]>cnt)continue;\n\t\tcmin(dp[now][1][i],w);\n\t\tfor(int t=S^i,r=t;;t=(t-1)&r)\n\t\t{\n\t\t\tfor(int j=2;j<=cnt;++j)\n\t\t\t\tcmin(dp[now][j][t|i],dp[now^1][j-1][t]/(j-1)*j+1ll*j*w);\n\t\t\tif(!t)break;\n\t\t}\n\t}\n}\n\ninline bool cmp(const int &x,const int &y){return a[x]==a[y]?w[x]<w[y]:a[x]<a[y];}\ninline bool cmp1(const int &x,const int &y){return w[x]<w[y];}\nint main()\n{\n\tint n=in();ll g=0;k=in();\n\tfor(int i=1;i<=n;++i)a[i]=in(),g=gcd(g,a[i]);\n\tfor(int i=1;i<=n;++i)w[i]=in(),id[i]=i;\n\tll x=g;if(g==1)return puts(\"0\"),0;\n\tfor(ll i=2;i*i<=x;++i)\n\t\tif(x%i==0){p[++cnt]=i;while(x%i==0)x/=i,++c[cnt];}\n\tif(x>1)p[++cnt]=x,c[cnt]=1;\n\tfor(int i=1;i<=cnt;++i)\n\t{\n\t\tll res=1;\n\t\tfor(int j=1;j<=c[j];++j)res*=p[j];\n\t\tif(res>k)return puts(\"-1\"),0;\n\t}\n\tstd::sort(id+1,id+n+1,cmp);int m=n;n=0;\n\tmemcpy(b,a,sizeof a);\n\tmemcpy(fz,w,sizeof w);\n\tfor(int i=1,ct=0;i<=m;++i)\n\t\tif(b[id[i]]==b[id[i-1]])\n\t\t{\n\t\t\tif(ct>=cnt)continue;\n\t\t\t++ct;a[++n]=b[id[i]],w[n]=fz[id[i]];\n\t\t}\n\t\telse ct=1,a[++n]=b[id[i]],w[n]=fz[id[i]];\n\tfor(int i=1;i<=n;++i)id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp1);\n\tS=1<<cnt;--S;\n\tfor(int i=1;i<=cnt;++i)\n\t\tfor(int j=0;j<=S;++j)\n\t\t\tdp[now][i][j]=inf;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tll x=a[id[i]];now^=1;\n\t\tfor(int j=1;j<=cnt;++j)np[j]=1;\n\t\tfor(int j=1;j<=cnt;++j)\n\t\t\twhile(x%p[j]==0)++nc[j],x/=p[j],np[j]*=p[j];\n\t\tcalc(w[id[i]]);\n\t}\n\tll ans=inf;\n\tfor(int i=1;i<=cnt;++i)ans=std::min(ans,dp[now][i][S]);\n\tprintf(\"%lld\\n\",ans==inf?-1ll:ans);\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n, d, h;\n\nint main()\n{\n\tint i, j, k, l;\n\tcin>>n>>d>>h;\n\tif(d == h)\n\t{\n\t\tif(n != d+1) return !printf(\"-1\");\n\t\tfor(i=0;i<n-1;i++) printf(\"%d %d\\n\", i+1, i+2);\n\t\treturn 0;\n\t}\n\tif(h*2 < d) return !printf(\"-1\");\n\tfor(i=0;i<h;i++) printf(\"%d %d\\n\", i+1, i+2);\n\tprintf(\"1 %d\\n\", h+2);\n\tfor(i=1;i<d-h;i++) printf(\"%d %d\\n\", h+i+1, h+i+2);\n\tfor(i=d+2;i<=n;i++) printf(\"1 %d\\n\", i);\n\treturn 0;\n}\n//*/",
        "fixed_code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n, d, h;\n\nint main()\n{\n\tint i, j, k, l;\n\tcin>>n>>d>>h;\n\tif(d == h && d == 1)\n\t{\n\t\tif(n != d+1) return !printf(\"-1\");\n\t\tfor(i=0;i<n-1;i++) printf(\"%d %d\\n\", i+1, i+2);\n\t\treturn 0;\n\t}\n\telse if(d == h)\n\t{\n\t\tfor(i=0;i<h;i++) printf(\"%d %d\\n\", i+1, i+2);\n\t\tfor(i=h+2;i<=n;i++) printf(\"2 %d\\n\", i);\n\t\treturn 0;\n\t}\n\tif(h*2 < d) return !printf(\"-1\");\n\tfor(i=0;i<h;i++) printf(\"%d %d\\n\", i+1, i+2);\n\tprintf(\"1 %d\\n\", h+2);\n\tfor(i=1;i<d-h;i++) printf(\"%d %d\\n\", h+i+1, h+i+2);\n\tfor(i=d+2;i<=n;i++) printf(\"1 %d\\n\", i);\n\treturn 0;\n}\n//*/",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "t = int(input())\r\nfor _ in t:\r\n    h= input()\r\n    A = max(map(int, input().split()))\r\n    h= input()\r\n    B = max(map(int, input().split()))\r\n    print(\"Alice\\nAlice\" if A > B else \"Bob\\nBob\" if B>A else \"Alice\\nBob\")\r\n",
        "fixed_code": "for _ in range(int(input())):\r\n    input()\r\n    A = max(map(int, input().split()))\r\n    input()\r\n    B = max(map(int, input().split()))\r\n    print(\"Alice\\nAlice\" if A > B else \"Bob\\nBob\" if B>A else \"Alice\\nBob\")\r\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "public static com.oracle.truffle.llvm.runtime.LLVMIVarBit createZeroExt(int bits, int from) {\n    return com.oracle.truffle.llvm.runtime.LLVMIVarBit.create(bits, java.nio.ByteBuffer.allocate(java.lang.Integer.BYTES).putInt(from).array());\n}",
        "fixed_code": "public static com.oracle.truffle.llvm.runtime.LLVMIVarBit fromShort(int bits, short from) {\n    return com.oracle.truffle.llvm.runtime.LLVMIVarBit.create(bits, java.nio.ByteBuffer.allocate(java.lang.Short.BYTES).putShort(from).array(), java.lang.Short.SIZE, true);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.lang.*;\npublic class A {\n    public static void main(String[] args) throws Exception {\n        Scanner sc=new Scanner(System.in);\n        PrintWriter pw=new PrintWriter(System.out);\n        int n=sc.nextInt();\n        int[] f=new int[150002];\n        for(int i=0;i<n;i++)\n            f[sc.nextInt()]++;\n        for(int i=1;i<(f.length-1);i++) {\n            if(f[i]>1) {\n                if(f[i-1]==0) {\n                    f[i]--;\n                    f[i-1]++;\n                }\n            }\n            if(f[i]>1) {\n                if(f[i+1]==0) {\n                    f[i]--;\n                    f[i+1]++;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=1;i<(f.length-1);i++)\n            ans=(f[i]>0)?ans+1:ans;\n        pw.println(ans);\n        br.close();\n        pw.close();\n    }\n}",
        "fixed_code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.lang.*;\npublic class A {\n    public static void main(String[] args) throws Exception {\n        Scanner sc=new Scanner(System.in);\n        PrintWriter pw=new PrintWriter(System.out);\n        int n=sc.nextInt();\n        int[] f=new int[150002];\n        for(int i=0;i<n;i++)\n            f[sc.nextInt()]++;\n        for(int i=1;i<=150000;i++) {\n            if((f[i]>1) && (f[i+1]<=1)) {\n                f[i]--;\n                f[i+1]++;\n            }\n        }\n        for(int i=150000;i>1;i--) {\n            if((f[i]>1) && (f[i-1]<=1)) {\n                f[i]--;\n                f[i-1]++;\n            }\n        }\n        int ans=0;\n        for(int i=1;i<f.length;i++)\n            ans=(f[i]>0)?ans+1:ans;\n        pw.println(ans);\n        pw.close();\n    }\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n#include <stdio.h>\n#include <numeric>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <iomanip>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <iomanip>\n#include <map>\n#include <string.h>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nbool graph[1010][1010];\nint values[1010];\t\t// 0: a, 1: b, 2: c\nbool vis[1010];\n\nvoid bfs(int pos , int n)\n{\n\t// 0,2\n\tqueue<int> q;\n\tq.push(pos);\n\tvalues[pos] = 0;\n\tvis[pos] = true;\n\n\twhile (!q.empty())\n\t{\n\t\tint cur = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t{\n\t\t\tif (!graph[cur][i] && !vis[i])\n\t\t\t{\n\t\t\t\tvis[i] = true;\n\t\t\t\tvalues[i] = 1 - values[cur];\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool check(int n)\n{\n\tint i , j;\n\tfor (i = 1;i <= n;i ++)\n\t\tfor (j = i + 1;j <= n;j ++)\n\t\t{\n\t\t\tif (graph[i][j])\n\t\t\t{\n\t\t\t\tif ((values[i] == 0 && values[j] == 2)\n\t\t\t\t || (values[i] == 2 && values[j] == 0))\n\t\t\t\t return false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((values[i] == 0 && values[j] == 2) \n\t\t\t\t || (values[i] == 2 && values[j] == 0))\n\t\t\t\t continue;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\treturn true;\n}\n\nint main()\n{\n\tint i , j , n , m;\n\twhile (scanf(\"%d%d\" , &n , &m) != EOF)\n\t{\n\t\tmemset(values , - 1 , sizeof(values));\n\t\tmemset(vis , 0 , sizeof(vis));\n\t\tmemset(graph , 0 , sizeof(graph));\n\t\tfor (i = 0;i < m;i ++)\n\t\t{\n\t\t\tint u , v;\n\t\t\tscanf(\"%d%d\" , &u , &v);\n\t\t\tgraph[u][v] = graph[v][u] = true;\n\t\t}\n\t\tfor (i = 1;i <= n;i ++)\n\t\t{\n\t\t\tif (!vis[i])\n\t\t\t\tbfs(i , n);\n\t\t}\n\t\tif (check(n))\n\t\t{\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tfor (i = 1;i <= n;i ++)\n\t\t\t{\n\t\t\t\tchar ch = values[i] + 'a';\n\t\t\t\tprintf(\"%c\" , ch);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\treturn 0;\n}\n\n\n\n\n",
        "fixed_code": "#include <iostream>\n#include <stdio.h>\n#include <numeric>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <iomanip>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <iomanip>\n#include <map>\n#include <string.h>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nbool graph[1010][1010];\nint values[1010];\t\t// 0: a, 1: b, 2: c\nbool vis[1010];\n\nvoid bfs(int pos , int n)\n{\n\t// 0,2\n\tqueue<int> q;\n\tq.push(pos);\n\tvalues[pos] = 0;\n\tvis[pos] = true;\n\tint cnt = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tcnt ++;\n\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t{\n\t\t\tif (i != cur && !graph[cur][i] && !vis[i])\n\t\t\t{\n\t\t\t\tvis[i] = true;\n\t\t\t\tvalues[i] = 2 - values[cur];\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t}\n\t// 如果只有一个\n\tif (cnt == 1)\n\t\tvalues[pos] = 1;\n}\n\nbool check(int n)\n{\n\tint i , j;\n\tfor (i = 1;i <= n;i ++)\n\t\tfor (j = i + 1;j <= n;j ++)\n\t\t{\n\t\t\tif (graph[i][j])\n\t\t\t{\n\t\t\t\tif ((values[i] == 0 && values[j] == 2)\n\t\t\t\t || (values[i] == 2 && values[j] == 0))\n\t\t\t\t return false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((values[i] == 0 && values[j] == 2) \n\t\t\t\t || (values[i] == 2 && values[j] == 0))\n\t\t\t\t continue;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\treturn true;\n}\n\nint main()\n{\n\tint i , j , n , m;\n\twhile (scanf(\"%d%d\" , &n , &m) != EOF)\n\t{\n\t\tmemset(values , - 1 , sizeof(values));\n\t\tmemset(vis , 0 , sizeof(vis));\n\t\tmemset(graph , 0 , sizeof(graph));\n\t\tfor (i = 0;i < m;i ++)\n\t\t{\n\t\t\tint u , v;\n\t\t\tscanf(\"%d%d\" , &u , &v);\n\t\t\tgraph[u][v] = graph[v][u] = true;\n\t\t}\n\t\tfor (i = 1;i <= n;i ++)\n\t\t{\n\t\t\tif (!vis[i])\n\t\t\t\tbfs(i , n);\n\t\t}\n\n\t\tif (check(n))\n\t\t{\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tfor (i = 1;i <= n;i ++)\n\t\t\t{\n\t\t\t\tchar ch = values[i] + 'a';\n\t\t\t\tprintf(\"%c\" , ch);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\treturn 0;\n}\n\n\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\nusing namespace __gnu_pbds;\n\ntypedef tree<int,null_type,less <int>,rb_tree_tag,tree_order_statistics_node_update>ind_set;\ntypedef gp_hash_table<long long, long long  , hash<long long> > ht;\n\n\n///#define int long long\n#pragma GCC optimize (\"O3\")\n#define ll long long\n#define vec vector <int>\n#define vecl vector <long long>\n#define rep(i,a,b) for (ll i=a;i<b;i++)\n#define pb push_back\n#define pii pair <int,int>\n#define pll pair <long long,long long>\n#define mp make_pair\n#define ff first\n#define ss second\n#define all(a) a.begin(),a.end()\n#define maa 1000000007\n\nll P10[15];\nll n,k,arr[300005];\n\nll rem[300005][14];\nmap <ll,ll> CT[14];\nint digits(ll n)\n{\n    int ret=0;\n    while(n)\n    {\n        ret++;n/=10;\n    }\n    return ret;\n}\n\nvoid solve()\n{\n    P10[0]=1;\n\n    cin>>n>>k;\n    rep(i,1,14)P10[i]=(10*P10[i-1])%k;\n    rep(i,0,n)\n    {\n        cin>>arr[i];\n        rep(j,0,11)rem[i][j]=(arr[i]*P10[j])%k;\n    }\n\n    rep(i,0,n)\n    {\n        rep(j,0,11)\n        {\n            CT[j][rem[i][j]]++;\n        }\n    }\n\n\n    ll ans=0,te,dig;\n    /*rep(i,0,9)\n    {\n        for (auto x:CT[i])cout<<x.ff<<\" --> \"<<x.ss<<\"  \";\n        cout<<\"\\n\";\n    }*/\n    rep(i,0,n)\n    {\n        te=(k-rem[i][0])%k;\n        dig=digits(arr[i]);\n        ans+=CT[dig][te];\n      //  cout<<dig<<\" \"<<ans<<\"\\n\";\n        if (rem[i][dig]==te)ans--;\n    }\n    cout<<ans<<\"\\n\";\n\n}\nsigned main()\n{\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n///freopen(\"input.txt\",\"r\",stdin);\n///freopen(\"output.txt\",\"w\",stdout);\n\n\n    int t=1;\n    ///cin>>t;\n    rep(a,0,t)\n    {\n        ///cout<<\"Case #\"<<a+1<<\":\\n\";\n        solve();\n    }\n\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\nusing namespace __gnu_pbds;\n\ntypedef tree<int,null_type,less <int>,rb_tree_tag,tree_order_statistics_node_update>ind_set;\ntypedef cc_hash_table<long long, long long  , hash<long long> > ht;\n\n\n///#define int long long\n#pragma GCC optimize (\"O3\")\n#define ll long long\n#define vec vector <int>\n#define vecl vector <long long>\n#define rep(i,a,b) for (ll i=a;i<b;i++)\n#define pb push_back\n#define pii pair <int,int>\n#define pll pair <long long,long long>\n#define mp make_pair\n#define ff first\n#define ss second\n#define all(a) a.begin(),a.end()\n#define maa 1000000007\n\nll P10[15];\nll n,k,arr[300005];\n\nll rem[300005][14];\nht CT;\ninline ll key(int D,ll T)\n{\n    return 100000000000ll*D+T;\n}\ninline int digits(ll n)\n{\n    int ret=0;\n    while(n)\n    {\n        ret++;n/=10;\n    }\n    return ret;\n}\n\nvoid solve()\n{\n    P10[0]=1;\n\n    cin>>n>>k;\n    rep(i,1,14)P10[i]=(10*P10[i-1])%k;\n    rep(i,0,n)\n    {\n        cin>>arr[i];\n        rep(j,0,11)rem[i][j]=(arr[i]*P10[j])%k;\n    }\n\n    rep(i,0,n)\n    {\n        rep(j,0,11)\n        {\n            CT[key(j,rem[i][j])]++;\n        }\n    }\n\n\n    ll ans=0,te,dig;\n    /*rep(i,0,9)\n    {\n        for (auto x:CT[i])cout<<x.ff<<\" --> \"<<x.ss<<\"  \";\n        cout<<\"\\n\";\n    }*/\n    rep(i,0,n)\n    {\n        te=(k-rem[i][0])%k;\n        dig=digits(arr[i]);\n        ans+=CT[key(dig,te)];\n      //  cout<<dig<<\" \"<<ans<<\"\\n\";\n        if (rem[i][dig]==te)ans--;\n    }\n    cout<<ans<<\"\\n\";\n\n}\nsigned main()\n{\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n///freopen(\"input.txt\",\"r\",stdin);\n///freopen(\"output.txt\",\"w\",stdout);\n\n\n    int t=1;\n    ///cin>>t;\n    rep(a,0,t)\n    {\n        ///cout<<\"Case #\"<<a+1<<\":\\n\";\n        solve();\n    }\n\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpii;\ntypedef vector <LL> vl;\ntypedef vector <pair<LL,LL> > vpll;\ntypedef pair <int,int> pii;\ntypedef pair <LL,LL> pll;\n\n#define forup(i,a,b) for(int i=(a); i<(b); ++i)\n#define fordn(i,a,b) for(int i=(a); i>(b); --i)\n#define rep(i,a) for(int i=0; i<(a); ++i)\n#define gi(x) scanf(\"%d \",&x)\n#define gll(x) scanf(\"%lld \",&x)\n#define gd(x) scanf(\"%lf \",&x)\n#define gs(x) scanf(\" %s\",x) \n#define fs first\n#define sc second \n#define pb push_back\n#define mp make_pair\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n#define endl '\\n';\n\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL\n\nset<pair<pair<int,int>,int> > s;\nconst int INF = int(1e9);\nint main()\n{\n\tfast_io;\n\tint a,n;\n\tcin >> n;\n\tvi v;\n\tfor(int i=0;i<n;i++)\n\t\tcin >> a,v.pb(a);\n\t\n\ts.insert(mp(mp(-INF,v[0]),0));\t\n\ts.insert(mp(mp(v[0]+1,INF),0));\t\n\t\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tauto temp = upper_bound(s.begin(),s.end(),mp(mp(v[i],INF),0));\n\t\ttemp--;\n\t\tcout << v[temp->sc] << \" \";\n\t\ts.insert(mp(mp((temp->fs).fs,v[i]),i));\n\t\tif(v[i]+1!=(temp->fs).sc)\n\t\t\ts.insert(mp(mp(v[i]+1,(temp->fs).sc),i));\n\t\ts.erase(temp);\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpii;\ntypedef vector <LL> vl;\ntypedef vector <pair<LL,LL> > vpll;\ntypedef pair <int,int> pii;\ntypedef pair <LL,LL> pll;\n\n#define forup(i,a,b) for(int i=(a); i<(b); ++i)\n#define fordn(i,a,b) for(int i=(a); i>(b); --i)\n#define rep(i,a) for(int i=0; i<(a); ++i)\n#define gi(x) scanf(\"%d \",&x)\n#define gll(x) scanf(\"%lld \",&x)\n#define gd(x) scanf(\"%lf \",&x)\n#define gs(x) scanf(\" %s\",x) \n#define fs first\n#define sc second \n#define pb push_back\n#define mp make_pair\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n#define endl '\\n';\n\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL);\n\nset<pair<pair<int,int>,int> > s;\nconst int INF = int(1e9)+5;\nint main()\n{\n\tfast_io;\n\tint a,n;\n\tcin >> n;\n\tvi v;\n\tfor(int i=0;i<n;i++)\n\t\tcin >> a,v.pb(a);\n\n\ts.insert(mp(mp(-INF,v[0]),v[0]));\t\n\ts.insert(mp(mp(v[0]+1,INF),v[0]));\t\n\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tauto temp = s.upper_bound(mp(mp(v[i],INF),v[0]));\n\t\ttemp--;\n\t\tpair< pair<int,int>,int > p1 = mp(mp((temp->fs).fs,v[i]),v[i]);\n\t\tpair< pair<int,int>,int > p2 = mp(mp(v[i]+1,(temp->fs).fs),v[i]);\n\t\tcout << temp->sc << \" \";\n\t\ts.erase(temp);\n\t\ts.insert(p1);\n\t\ts.insert(p2);\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public com.orientechnologies.orient.client.remote.OStorageOperationResult<com.orientechnologies.orient.client.remote.OPhysicalPosition> createRecord(final com.orientechnologies.orient.core.id.ORecordId iRid, final byte[] iContent, com.orientechnologies.orient.core.version.ORecordVersion iRecordVersion, final byte iRecordType, int iMode, final com.orientechnologies.orient.client.remote.ORecordCallback<java.lang.Long> iCallback) {\n    if ((iMode == 1) && (iCallback == null))\n        iMode = 2;\n    \n    final com.orientechnologies.orient.client.remote.OPhysicalPosition ppos = new com.orientechnologies.orient.client.remote.OPhysicalPosition(iRecordType);\n    com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryAsynchClient lastNetworkUsed = null;\n    do {\n        try {\n            final com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryAsynchClient network = beginRequest(OChannelBinaryProtocol.REQUEST_RECORD_CREATE);\n            lastNetworkUsed = network;\n            try {\n                network.writeShort(((short) (iRid.clusterId)));\n                network.writeBytes(iContent);\n                network.writeByte(iRecordType);\n                network.writeByte(((byte) (iMode)));\n            } finally {\n                endRequest(network);\n            }\n            switch (iMode) {\n                case 0 :\n                    try {\n                        beginResponse(network);\n                        if ((network.getSrvProtocolVersion()) > (com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryProtocol.PROTOCOL_VERSION_25))\n                            iRid.clusterId = network.readShort();\n                        \n                        iRid.clusterPosition = network.readLong();\n                        ppos.clusterPosition = iRid.clusterPosition;\n                        if ((network.getSrvProtocolVersion()) >= 11) {\n                            ppos.recordVersion = network.readVersion();\n                        }else\n                            ppos.recordVersion = com.orientechnologies.orient.core.version.OVersionFactory.instance().createVersion();\n                        \n                        if ((network.getSrvProtocolVersion()) >= 20)\n                            readCollectionChanges(network, ODatabaseRecordThreadLocal.INSTANCE.get().getSbTreeCollectionManager());\n                        \n                        return new com.orientechnologies.orient.client.remote.OStorageOperationResult<com.orientechnologies.orient.client.remote.OPhysicalPosition>(ppos);\n                    } finally {\n                        endResponse(network);\n                    }\n                case 1 :\n                    if (iCallback != null) {\n                        final int sessionId = getSessionId();\n                        final com.orientechnologies.orient.core.db.record.ridbag.sbtree.OSBTreeCollectionManager collectionManager = ODatabaseRecordThreadLocal.INSTANCE.get().getSbTreeCollectionManager();\n                        java.util.concurrent.Callable<java.lang.Object> response = new java.util.concurrent.Callable<java.lang.Object>() {\n                            public java.lang.Object call() throws java.lang.Exception {\n                                final long result;\n                                try {\n                                    OStorageRemoteThreadLocal.INSTANCE.get().sessionId = sessionId;\n                                    beginResponse(network);\n                                    if ((network.getSrvProtocolVersion()) > (com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryProtocol.PROTOCOL_VERSION_25))\n                                        iRid.clusterId = network.readShort();\n                                    \n                                    result = network.readLong();\n                                    if ((network.getSrvProtocolVersion()) >= 11)\n                                        network.readVersion();\n                                    \n                                    if ((network.getSrvProtocolVersion()) >= 20)\n                                        readCollectionChanges(network, collectionManager);\n                                    \n                                } finally {\n                                    endResponse(network);\n                                    OStorageRemoteThreadLocal.INSTANCE.get().sessionId = -1;\n                                }\n                                iCallback.call(iRid, result);\n                                return null;\n                            }\n                        };\n                        asynchExecutor.submit(new java.util.concurrent.FutureTask<java.lang.Object>(response));\n                    }\n            }\n            return new com.orientechnologies.orient.client.remote.OStorageOperationResult<com.orientechnologies.orient.client.remote.OPhysicalPosition>(ppos);\n        } catch (com.orientechnologies.common.concur.lock.OModificationOperationProhibitedException mope) {\n            handleDBFreeze();\n        } catch (java.lang.Exception e) {\n            handleException(lastNetworkUsed, (\"Error on create record in cluster: \" + (iRid.clusterId)), e);\n        }\n    } while (true );\n}",
        "fixed_code": "public com.orientechnologies.orient.core.storage.OStorageOperationResult<com.orientechnologies.orient.core.storage.OPhysicalPosition> createRecord(final com.orientechnologies.orient.core.id.ORecordId iRid, final byte[] iContent, com.orientechnologies.orient.core.version.ORecordVersion iRecordVersion, final byte iRecordType, int iMode, final com.orientechnologies.orient.core.storage.ORecordCallback<java.lang.Long> iCallback) {\n    if ((iMode == 1) && (iCallback == null))\n        iMode = 2;\n    \n    final com.orientechnologies.orient.core.storage.OPhysicalPosition ppos = new com.orientechnologies.orient.core.storage.OPhysicalPosition(iRecordType);\n    com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryAsynchClient lastNetworkUsed = null;\n    do {\n        try {\n            final com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryAsynchClient network = beginRequest(OChannelBinaryProtocol.REQUEST_RECORD_CREATE);\n            lastNetworkUsed = network;\n            try {\n                network.writeShort(((short) (iRid.clusterId)));\n                network.writeBytes(iContent);\n                network.writeByte(iRecordType);\n                network.writeByte(((byte) (iMode)));\n            } finally {\n                endRequest(network);\n            }\n            switch (iMode) {\n                case 0 :\n                    try {\n                        beginResponse(network);\n                        if ((network.getSrvProtocolVersion()) > (com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryProtocol.PROTOCOL_VERSION_25))\n                            iRid.clusterId = network.readShort();\n                        \n                        iRid.clusterPosition = network.readLong();\n                        ppos.clusterPosition = iRid.clusterPosition;\n                        if ((network.getSrvProtocolVersion()) >= 11) {\n                            ppos.recordVersion = network.readVersion();\n                        }else\n                            ppos.recordVersion = com.orientechnologies.orient.core.version.OVersionFactory.instance().createVersion();\n                        \n                        if ((network.getSrvProtocolVersion()) >= 20)\n                            readCollectionChanges(network, ODatabaseRecordThreadLocal.INSTANCE.get().getSbTreeCollectionManager());\n                        \n                        return new com.orientechnologies.orient.core.storage.OStorageOperationResult<com.orientechnologies.orient.core.storage.OPhysicalPosition>(ppos);\n                    } finally {\n                        endResponse(network);\n                    }\n                case 1 :\n                    if (iCallback != null) {\n                        final int sessionId = getSessionId();\n                        final com.orientechnologies.orient.core.db.record.ridbag.sbtree.OSBTreeCollectionManager collectionManager = ODatabaseRecordThreadLocal.INSTANCE.get().getSbTreeCollectionManager();\n                        java.util.concurrent.Callable<java.lang.Object> response = new java.util.concurrent.Callable<java.lang.Object>() {\n                            public java.lang.Object call() throws java.lang.Exception {\n                                final long result;\n                                try {\n                                    OStorageRemoteThreadLocal.INSTANCE.get().sessionId = sessionId;\n                                    beginResponse(network);\n                                    if ((network.getSrvProtocolVersion()) > (com.orientechnologies.orient.enterprise.channel.binary.OChannelBinaryProtocol.PROTOCOL_VERSION_25))\n                                        iRid.clusterId = network.readShort();\n                                    \n                                    result = network.readLong();\n                                    if ((network.getSrvProtocolVersion()) >= 11)\n                                        network.readVersion();\n                                    \n                                    if ((network.getSrvProtocolVersion()) >= 20)\n                                        readCollectionChanges(network, collectionManager);\n                                    \n                                } finally {\n                                    endResponse(network);\n                                    OStorageRemoteThreadLocal.INSTANCE.get().sessionId = -1;\n                                }\n                                iCallback.call(iRid, result);\n                                return null;\n                            }\n                        };\n                        asynchExecutor.submit(new java.util.concurrent.FutureTask<java.lang.Object>(response));\n                    }\n            }\n            return new com.orientechnologies.orient.core.storage.OStorageOperationResult<com.orientechnologies.orient.core.storage.OPhysicalPosition>(ppos);\n        } catch (com.orientechnologies.common.concur.lock.OModificationOperationProhibitedException mope) {\n            handleDBFreeze();\n        } catch (java.lang.Exception e) {\n            handleException(lastNetworkUsed, (\"Error on create record in cluster: \" + (iRid.clusterId)), e);\n        }\n    } while (true );\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import sys\nDebug = lambda *args: None\nif len(sys.argv) > 1:\n\t# sys.stdin = open(\"io/test.in\", \"r\")\n\tDebug = lambda *args: print('\\033[0;31m', *args, '\\033[0m', file=sys.stderr)\n\n\n###\ndef Rd(f=int):\n\treturn [f(x) for x in input().split()]\n\n\ndef JoinF(arr):\n\treturn ' '.join('{:.10f}'.format(x) for x in arr)\n\n\n###\n\n\ndef ask2(A):\n\tprint('?', len(A), *A)\n\treturn int(input())\n\n\ndef ask1(A):\n\tB = [x for a in A for x in a]\n\treturn ask2(B)\n\n\ndef main():\n\tn, k = Rd()\n\tS = [Rd()[1:] for _ in range(k)]\n\n\tcur = S.copy()\n\tcur_max = ask1(cur)\n\twhile len(cur) > 1:\n\t\ttest = cur[:len(cur) // 2]\n\t\tif ask1(test) == cur_max:\n\t\t\tcur = test\n\t\telse:\n\t\t\tcur = cur[len(cur) // 2:]\n\n\tmax_set = set(cur[0])\n\tothers = [x for x in range(1, n + 1) if x not in max_set]\n\tmax_others = ask2(others)\n\n\tans = [max(cur_max, max_others)]*k\n\tfor i, ptr in enumerate(S):\n\t\tif ptr is cur[0]:\n\t\t\tans[i] = max_others\n\tprint('!', *ans)\n\n\nfor i_case in range(int(input())):\n\tmain()",
        "fixed_code": "import sys\nDebug = lambda *args: None\nif len(sys.argv) > 1:\n\t# sys.stdin = open(\"io/test.in\", \"r\")\n\tDebug = lambda *args: print('\\033[0;31m', *args, '\\033[0m', file=sys.stderr)\n\n\n###\ndef Rd(f=int):\n\treturn [f(x) for x in input().split()]\n\n\ndef JoinF(arr):\n\treturn ' '.join('{:.10f}'.format(x) for x in arr)\n\n\n###\n\n\ndef ask2(A):\n\tprint('?', len(A), *A)\n\treturn int(input())\n\n\ndef ask1(A):\n\tB = [x for a in A for x in a]\n\treturn ask2(B)\n\n\ndef main():\n\tn, k = Rd()\n\tS = [Rd()[1:] for _ in range(k)]\n\n\tcur = S.copy()\n\tcur_max = ask1(cur)\n\twhile len(cur) > 1:\n\t\ttest = cur[:len(cur) // 2]\n\t\tif ask1(test) == cur_max:\n\t\t\tcur = test\n\t\telse:\n\t\t\tcur = cur[len(cur) // 2:]\n\n\tmax_set = set(cur[0])\n\tothers = [x for x in range(1, n + 1) if x not in max_set]\n\tmax_others = ask2(others)\n\n\tans = [max(cur_max, max_others)]*k\n\tfor i, ptr in enumerate(S):\n\t\tif ptr is cur[0]:\n\t\t\tans[i] = max_others\n\tprint('!', *ans)\n\tif input() == 'Incorrect':\n\t\texit(0)\n\n\nfor i_case in range(int(input())):\n\tmain()",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nstruct Node\n{\n\tint pos;\n\tint type;\n\tint l,r;\n}a[400005];\nint t,T,n,m,num,pa[200005],l[200005],r[200005],ans[200005];\npriority_queue<int>ql,dell;\npriority_queue<int,vector<int>,greater<int> >qr,delr;\nint find(int x)\n{\n\treturn x==pa[x]?x:pa[x]=find(pa[x]);\n}\nbool cmp(Node a,Node b)\n{\n\treturn a.pos<b.pos;\n}\nint main()\n{\n\tscanf(\"%d%d\",&t,&T);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i+n]=0,r[i+n]=1000000000;\n\t\tpa[i]=i,pa[i+n]=i+n;\n\t}\n\twhile(m--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(find(x)==find(y))\n\t\t{\n\t\t\tprintf(\"IMPOSSIBLE\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint u=find(x),v=find(y+n);\n\t\tif(u!=v)\n\t\t{\n\t\t\tl[u]=max(l[u],l[v]);\n\t\t\tr[u]=min(r[u],r[v]);\n\t\t\tpa[v]=u;\n\t\t}\n\t\tu=find(x+n),v=find(y);\n\t\tif(u!=v)\n\t\t{\n\t\t\tl[u]=max(l[u],l[v]);\n\t\t\tr[u]=min(r[u],r[v]);\n\t\t\tpa[v]=u;\n\t\t}\n\t}\n\tm=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=find(i),y=find(i+n);\n\t\tif(x==i)\n\t\t{\n\t\t\tnum++;\n\t\t\tint l1=l[x],r1=r[x];\n\t\t\tint l2=l[y],r2=r[y];\n\t\t\tif(l1>l2)\n\t\t\t{\n\t\t\t\tswap(l1,l2);\n\t\t\t\tswap(r1,r2);\n\t\t\t}\n\t\t\tif(r1<l2)\n\t\t\t{\n\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l1,a[m].type=1;\n\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=r1+1,a[m].type=0;\n\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=l2,a[m].type=1;\n\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r2+1,a[m].type=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(r1<r2)\n\t\t\t\t{\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l2,a[m].type=0;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r2,a[m].pos=l2,a[m].type=1;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r2,a[m].pos=r1+1,a[m].type=0;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r1+1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r2+1,a[m].type=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l2,a[m].type=0;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=l2,a[m].type=1;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r2+1,a[m].type=0;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=r2+1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=r1+1,a[m].type=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(a+1,a+m+1,cmp);\n\ta[m+1].pos=1000000001;\n\tint now=1,size=0;\n\twhile(now<=m)\n\t{\n\t\twhile(!ql.empty()&&!dell.empty()&&ql.top()==dell.top())\n\t\t{\n\t\t\tql.pop();\n\t\t\tdell.pop();\n\t\t}\n\t\twhile(!qr.empty()&&!delr.empty()&&qr.top()==delr.top())\n\t\t{\n\t\t\tqr.pop();\n\t\t\tdelr.pop();\n\t\t}\n\t\tif(size==num)\n\t\t{\n\t\t\tint l2=ql.top(),r2=qr.top();\n\t\t\tint l1=a[now-1].pos;\n\t\t\tint r1=a[now].pos-1;\n\t\t\tif(l2<=r2&&l1<=r1)\n\t\t\t{\n\t\t\t\tint minn=l1+l2;\n\t\t\t\tint maxx=r1+r2;\n\t\t\t\tminn=max(minn,t);\n\t\t\t\tmaxx=min(maxx,T);\n\t\t\t\tif(minn<=maxx)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"POSSIBLE\\n\");\n\t\t\t\t\tint v1=l1,v2=minn-v1;\n\t\t\t\t\tif(v2>r2)\n\t\t\t\t\t{\n\t\t\t\t\t\tv2=r2;\n\t\t\t\t\t\tv1=minn-v2;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%d %d\\n\",v1,v2);\n\t\t\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint x=find(i),y=find(i+n);\n\t\t\t\t\t\tif(x==i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(l[x]<=v1&&r[x]>=v1&&l[y]<=v2&&r[y]>=v2)ans[x]=1,ans[y]=2;\n\t\t\t\t\t\t\telse ans[x]=2,ans[y]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=1;i<=n;i++)printf(\"%d\",ans[find(i)]);\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo\n\t\t{\n\t\t\tif(a[now].type==0)\n\t\t\t{\n\t\t\t\tdell.push(a[now].l);\n\t\t\t\tdelr.push(a[now].r);\n\t\t\t\tsize--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tql.push(a[now].l);\n\t\t\t\tqr.push(a[now].r);\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tnow++;\n\t\t}\n\t\twhile(now<=m&&a[now].pos==a[now-1].pos);\n\t}\n\tprintf(\"IMPOSSIBLE\\n\");\n\treturn 0;\n}",
        "fixed_code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nstruct Node\n{\n\tint pos;\n\tint type;\n\tint l,r;\n}a[1000005];\nint t,T,n,m,num,pa[1000005],l[1000005],r[1000005],ans[1000005];\npriority_queue<int>ql,dell;\npriority_queue<int,vector<int>,greater<int> >qr,delr;\nint find(int x)\n{\n\treturn x==pa[x]?x:pa[x]=find(pa[x]);\n}\nbool cmp(Node a,Node b)\n{\n\treturn a.pos<b.pos;\n}\nint main()\n{\n\tscanf(\"%d%d\",&t,&T);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i+n]=0,r[i+n]=1000000000;\n\t\tpa[i]=i,pa[i+n]=i+n;\n\t}\n\twhile(m--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(find(x)==find(y))\n\t\t{\n\t\t\tprintf(\"IMPOSSIBLE\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint u=find(x),v=find(y+n);\n\t\tif(u!=v)\n\t\t{\n\t\t\tl[u]=max(l[u],l[v]);\n\t\t\tr[u]=min(r[u],r[v]);\n\t\t\tpa[v]=u;\n\t\t}\n\t\tu=find(x+n),v=find(y);\n\t\tif(u!=v)\n\t\t{\n\t\t\tl[u]=max(l[u],l[v]);\n\t\t\tr[u]=min(r[u],r[v]);\n\t\t\tpa[v]=u;\n\t\t}\n\t}\n\tm=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=find(i),y=find(i+n);\n\t\tif(x==i)\n\t\t{\n\t\t\tnum++;\n\t\t\tint l1=l[x],r1=r[x];\n\t\t\tint l2=l[y],r2=r[y];\n\t\t\tif(l1>l2)\n\t\t\t{\n\t\t\t\tswap(l1,l2);\n\t\t\t\tswap(r1,r2);\n\t\t\t}\n\t\t\tif(r1<l2)\n\t\t\t{\n\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l1,a[m].type=1;\n\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=r1+1,a[m].type=0;\n\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=l2,a[m].type=1;\n\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r2+1,a[m].type=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(r1<r2)\n\t\t\t\t{\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l2,a[m].type=0;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r2,a[m].pos=l2,a[m].type=1;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r2,a[m].pos=r1+1,a[m].type=0;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r1+1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r2+1,a[m].type=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=l2,a[m].type=0;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=l2,a[m].type=1;\n\t\t\t\t\ta[++m].l=l1,a[m].r=r1,a[m].pos=r2+1,a[m].type=0;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=r2+1,a[m].type=1;\n\t\t\t\t\ta[++m].l=l2,a[m].r=r2,a[m].pos=r1+1,a[m].type=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(a+1,a+m+1,cmp);\n\ta[m+1].pos=1000000001;\n\tint now=1,size=0;\n\twhile(now<=m)\n\t{\n\t\twhile(!ql.empty()&&!dell.empty()&&ql.top()==dell.top())\n\t\t{\n\t\t\tql.pop();\n\t\t\tdell.pop();\n\t\t}\n\t\twhile(!qr.empty()&&!delr.empty()&&qr.top()==delr.top())\n\t\t{\n\t\t\tqr.pop();\n\t\t\tdelr.pop();\n\t\t}\n\t\tif(size==num)\n\t\t{\n\t\t\tint l2=ql.top(),r2=qr.top();\n\t\t\tint l1=a[now-1].pos;\n\t\t\tint r1=a[now].pos-1;\n\t\t\tif(l2<=r2&&l1<=r1)\n\t\t\t{\n\t\t\t\tint minn=l1+l2;\n\t\t\t\tint maxx=r1+r2;\n\t\t\t\tminn=max(minn,t);\n\t\t\t\tmaxx=min(maxx,T);\n\t\t\t\tif(minn<=maxx)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"POSSIBLE\\n\");\n\t\t\t\t\tint v1=l1,v2=minn-v1;\n\t\t\t\t\tif(v2>r2)\n\t\t\t\t\t{\n\t\t\t\t\t\tv2=r2;\n\t\t\t\t\t\tv1=minn-v2;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%d %d\\n\",v1,v2);\n\t\t\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint x=find(i),y=find(i+n);\n\t\t\t\t\t\tif(x==i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(l[x]<=v1&&r[x]>=v1&&l[y]<=v2&&r[y]>=v2)ans[x]=1,ans[y]=2;\n\t\t\t\t\t\t\telse ans[x]=2,ans[y]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=1;i<=n;i++)printf(\"%d\",ans[find(i)]);\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo\n\t\t{\n\t\t\tif(a[now].type==0)\n\t\t\t{\n\t\t\t\tdell.push(a[now].l);\n\t\t\t\tdelr.push(a[now].r);\n\t\t\t\tsize--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tql.push(a[now].l);\n\t\t\t\tqr.push(a[now].r);\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tnow++;\n\t\t}\n\t\twhile(now<=m&&a[now].pos==a[now-1].pos);\n\t}\n\tprintf(\"IMPOSSIBLE\\n\");\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class B {\n\tint N;\n\tchar[] ch;\n\n\tpublic char rev(char c){\n\t\treturn c == 'r' ? 'b' : 'r';\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tch = next().toCharArray();\n\t\tint ans = 0;\n\t\tchar pre = ch[0];\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tif(pre == ch[i] && i + 1 < N && ch[i + 1] == ch[i]){\n\t\t\t\tans++;\n\t\t\t\tpre = rev(pre);\n\t\t\t}else if(pre == ch[i] && i + 1 >= N){\n\t\t\t\tans++;\n\t\t\t\tpre = rev(pre);\n\t\t\t}else{\n\t\t\t\tpre = ch[i];\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew B().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}",
        "fixed_code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class B {\n\tint N;\n\tchar[] ch;\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tch = next().toCharArray();\n\t\tint oddR = 0;\n\t\tint oddB = 0;\n\t\tint evenR = 0;\n\t\tint evenB = 0;\n\t\tfor(int i= 0;i < N;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tif(ch[i] == 'r'){\n\t\t\t\t\tevenR++;\n\t\t\t\t}else{\n\t\t\t\t\tevenB++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(ch[i] == 'r'){\n\t\t\t\t\toddR++;\n\t\t\t\t}else{\n\t\t\t\t\toddB++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = N;\n\t\t{\n\t\t\tint tmp1 = Math.min(oddB,evenR);\n\t\t\tans = Math.min(ans,oddB + evenR - tmp1);\n\t\t}\n\n\t\t{\n\t\t\tint tmp1 = Math.min(evenB, oddR);\n\t\t\tans =Math.min(ans, evenB + oddR - tmp1);\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew B().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nint num_ordinary(int m){\r\n    int ans = 0;\r\n    for(int c = 1 ; c <= 10 ; ++c){\r\n        for(int d = 1 ; d <= 9 ; ++d){\r\n            int cur = 0;\r\n            for(int i = 0 ; i < c ; ++i)\r\n                cur *= 10, cur += d;\r\n            if(cur > m)\r\n                break;\r\n            ++ans;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n\r\n    int v;\r\n    for(cin >> v ; v-- ; ){\r\n        int l;\r\n        cin >> l;\r\n        cout << num_ordinary(v) << endl;\r\n    }\r\n    return 0;\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nint num_ordinary(int n){\r\n    int ans = 0;\r\n    for(int c = 1 ; c <= 10 ; ++c){\r\n        for(int d = 1 ; d <= 9 ; ++d){\r\n            int cur = 0;\r\n            for(int i = 0 ; i < c ; ++i)\r\n                cur *= 10, cur += d;\r\n            if(cur > n)\r\n                break;\r\n            ++ans;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n\r\n    int t;\r\n    for(cin >> t ; t-- ; ){\r\n        int n;\r\n        cin >> n;\r\n        cout << num_ordinary(n) << endl;\r\n    }\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//  main.cpp\n//  ervb\n//\n//  Created by Kanak Gautam on 21/04/20.\n//  Copyright © 2020 Kanak Gautam. All rights reserved.\n//\n \n \n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <utility>\n#define pb push_back\n#define mk make_pair\n#define endl \"\\n\"\n#define mod 1000000007\nusing namespace std;\ntypedef long long int lli;\ntypedef long double ld;\npriority_queue <lli, vector<lli>, greater<lli> > ti;\nvector <lli> p[300005],y[300005],f(300005,0),b(300005,0),r(300005,0),u(500005,0);\nvector<pair<lli,lli>>t,h;\nlli vis[200005];\nmap <pair<lli,lli>,lli> mp;\nset<pair<lli, lli> > s;\nset<lli> st;\nmap<lli,lli> np,v;\nqueue<lli> qy;\nlli gcd(lli a, lli b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n      \n}\nlli bpow(lli a, lli b) {\n    lli res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = (res * a)%mod;\n        a = (a * a)%mod;\n        b >>= 1;\n    }\n    return res%mod;\n}\nvoid fact(lli i)\n{\n    f[0]=1;\n    for(lli k=1;k<=i;k++)\n    {\n        (f[k]=f[k-1]*k)%=mod;\n    }\n}\nlli isprime(lli n)\n{\n    if(n==1)\n        return 0;\n    for(lli i=2;i<=sqrt(n);i++)\n        if(n%i==0)\n            return 0;\n    return 1;\n}\nlli find(lli x)\n{\n    if(f[x]==x)\n        return x;\n    else\n        return f[x]=find(f[x]);\n}\nbool cmp(lli i,lli j)\n{\n    return p[i].size()<p[j].size();\n}\n/*void sieve()\n{\n    for(lli i=2;i<=5000000;i++)\n    {\n        if(b[i]==0)\n        {\n        for(lli j=2;i*j<=5000000;j++)\n        {\n            b[i*j]=1;\n        }\n        }\n    }\n}*/\nint main ()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);cout.tie(NULL);\n    lli n,m;cin>>n>>m;\n    vector<vector<char>> a(n+2,vector<char>(m+2,0));\n    lli sum=0;\n    for(lli i=1;i<=n;i++)\n    {\n        for(lli j=1;j<=m;j++)\n        {\n            cin>>a[i][j];\n            if(a[i][j]=='*')sum++;\n        }\n    }\n    vector<vector<lli>> f(n+2,vector<lli>(m+2,0));\n\n    vector<lli>s;\n    vector<pair<lli,lli>>p;\n    for(lli i=1;i<=n;i++)\n    {\n        for(lli j=1;j<=m;j++)\n        {\n            if(a[i][j]=='*')\n            {\n                lli k=0;\n                while(a[i-k][j]=='*' && a[i+k][j]=='*' && a[i][j-k]=='*' && a[i][j+k]=='*')\n                    k++;\n                k--;\n                s.pb(k);p.pb({i,j});\n                for(lli h=0;h<=k;h++)\n                {\n                    a[i-h][j]=1;\n                    a[i+h][j]=1;\n                    a[i][j-h]=1;\n                    a[i][j+h]=1;\n                }\n            }\n        }\n    }\n    lli s1=0;\n    for(lli i=1;i<=n;i++)\n    {\n        for(lli j=1;j<=m;j++)\n        {\n            if(f[i][j]==1)s1++;\n        }\n    }\n    if(s1!=sum)\n    {\n        cout<<-1<<endl;exit(0);\n    }\n    cout<<s.size()<<endl;\n    for(lli i=0;i<s.size();i++)\n    {\n        cout<<p[i].first<<\" \"<<p[i].second<<\" \"<<s[i]<<endl;\n    }\n}\n",
        "fixed_code": "//  main.cpp\n//  ervb\n//\n//  Created by Kanak Gautam on 21/04/20.\n//  Copyright © 2020 Kanak Gautam. All rights reserved.\n//\n \n \n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <utility>\n#define pb push_back\n#define mk make_pair\n#define endl \"\\n\"\n#define mod 1000000007\nusing namespace std;\ntypedef long long int lli;\ntypedef long double ld;\npriority_queue <lli, vector<lli>, greater<lli> > ti;\nvector <lli> p[300005],y[300005],f(300005,0),b(300005,0),r(300005,0),u(500005,0);\nvector<pair<lli,lli>>t,h;\nlli vis[200005];\nmap <pair<lli,lli>,lli> mp;\nset<pair<lli, lli> > s;\nset<lli> st;\nmap<lli,lli> np,v;\nqueue<lli> qy;\nlli gcd(lli a, lli b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n      \n}\nlli bpow(lli a, lli b) {\n    lli res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = (res * a)%mod;\n        a = (a * a)%mod;\n        b >>= 1;\n    }\n    return res%mod;\n}\nvoid fact(lli i)\n{\n    f[0]=1;\n    for(lli k=1;k<=i;k++)\n    {\n        (f[k]=f[k-1]*k)%=mod;\n    }\n}\nlli isprime(lli n)\n{\n    if(n==1)\n        return 0;\n    for(lli i=2;i<=sqrt(n);i++)\n        if(n%i==0)\n            return 0;\n    return 1;\n}\nlli find(lli x)\n{\n    if(f[x]==x)\n        return x;\n    else\n        return f[x]=find(f[x]);\n}\nbool cmp(lli i,lli j)\n{\n    return p[i].size()<p[j].size();\n}\n/*void sieve()\n{\n    for(lli i=2;i<=5000000;i++)\n    {\n        if(b[i]==0)\n        {\n        for(lli j=2;i*j<=5000000;j++)\n        {\n            b[i*j]=1;\n        }\n        }\n    }\n}*/\nint main ()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);cout.tie(NULL);\n    lli n,m;cin>>n>>m;\n    vector<vector<char>> a(n+2,vector<char>(m+2,0));\n    lli sum=0;\n    for(lli i=1;i<=n;i++)\n    {\n        for(lli j=1;j<=m;j++)\n        {\n            cin>>a[i][j];\n            if(a[i][j]=='*')sum++;\n        }\n    }\n    vector<vector<lli>> f(n+2,vector<lli>(m+2,0));\n\n    vector<lli>s;\n    vector<pair<lli,lli>>p;\n    for(lli i=1;i<=n;i++)\n    {\n        for(lli j=1;j<=m;j++)\n        {\n            if(a[i][j]=='*')\n            {\n                lli k=0;\n                while(a[i-k][j]=='*' && a[i+k][j]=='*' && a[i][j-k]=='*' && a[i][j+k]=='*')\n                    k++;\n                k--;\n                if(k>0)\n                {\n                s.pb(k);p.pb({i,j});\n                for(lli h=0;h<=k;h++)\n                {\n                    f[i-h][j]=1;\n                    f[i+h][j]=1;\n                    f[i][j-h]=1;\n                    f[i][j+h]=1;\n                }\n                }\n            }\n        }\n    }\n    lli s1=0;\n    for(lli i=1;i<=n;i++)\n    {\n        for(lli j=1;j<=m;j++)\n        {\n            if(f[i][j]==1)s1++;\n        }\n    }\n    if(s1!=sum)\n    {\n        cout<<-1<<endl;exit(0);\n    }\n    cout<<s.size()<<endl;\n    for(lli i=0;i<s.size();i++)\n    {\n        cout<<p[i].first<<\" \"<<p[i].second<<\" \"<<s[i]<<endl;\n    }\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class CodeForces extends Functions {\n    static Scanner sc = new Scanner();\n    public static void  solve(){\n        int n = sc.nextInt();\n        int[] arr = sc.setIntArray(n);\n        int[][] map = new int[(int)6e5][2];\n        boolean[] isSumPresent = new boolean[(int)6e5];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                int sum = arr[i]+ arr[j];\n                if(isSumPresent[sum]){\n                    if(map[sum][0]==i || map[sum][1]==i || map[sum][1]==j || map[sum][0]==j)continue;\n                    System.out.println(\"YES\");\n                    System.out.println((i+1)+\" \"+(j+1)+\" \"+(map[sum][0]+1)+\" \"+(map[sum][1]+1));\n                    return;\n                }\n                isSumPresent[sum]  = true;\n                map[sum][0] = i;\n                map[sum][1] = j;\n            }\n        }\n        System.out.println(\"NO\");\n\n    }\n\n\n    public static void main(String[] args) {\n       int testCase = 1;\n       // testCase= sc.nextInt();\n        while (testCase-->0){\n            solve();\n        }\n        long end = System.currentTimeMillis();\n//        System.out.println(\"time took in ms : \"+(end-start));\n    }\n\n\n}\n\nclass Functions {\n    public static int mod = (int)1e9+7;\n    public static int INT_MAX = Integer.MAX_VALUE;\n    public static int INT_MIN = Integer.MIN_VALUE;\n    public static long LONG_MAX = Long.MAX_VALUE;\n    public static long LONG_MIN = Long.MIN_VALUE;\n    public static double DOUBLE_MAX = Double.MAX_VALUE;\n    public static double DOUBLE_MIN = Double.MIN_VALUE;\n\n    public static void sort(int[] a,boolean isAscending){\n        ArrayList<Integer> temp = new ArrayList<>();\n        for (int j : a) temp.add(j);\n        sort(temp,isAscending);\n        for(int i=0;i<a.length;i++)a[i] = temp.get(i);\n    }\n    public static void sort(List T,boolean isAscending){\n        if(isAscending)\n            Collections.sort(T);\n        else Collections.sort(T,Collections.reverseOrder());\n    }\n    public static long factorial(int n){\n        long fact = 1L;\n        for(int i=2;i<=n;i++)fact=  (fact*i)%mod;\n        return fact;\n    }\n\n    public  static int ncr(int n, int r){\n        // time O(n+r)\n        if (r > n)\n            return 0;\n        long[] inv = new long[r + 1];\n        inv[1] = 1;\n        // Getting the modular inversion\n        // for all the numbers\n        // from 2 to r with respect to m\n        for (int i = 2; i <= r; i++) {\n            inv[i] = mod - (mod / i) * inv[(int) (mod % i)] % mod;\n        }\n        int ans = 1;\n        // for 1/(r!) part\n        for (int i = 2; i <= r; i++) {\n            ans = (int) (((ans % mod) * (inv[i] % mod)) % mod);\n        }\n           // for (n)*(n-1)*(n-2)*...*(n-r+1) part\n        for (int i = n; i >= (n - r + 1); i--) {\n            ans = (int) (((ans % mod) * (i % mod)) % mod);\n        }\n        return ans;\n    }\n\n    public static void reverseArray(int[] a){\n        int left = 0;\n        int right = a.length-1;\n        while (left<right){\n            int temp =a[left];\n            a[left] = a[right];\n            a[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    public static long isPrime(int n){\n        for(long i=2;i*i<=n;i++)\n            if(n%i==0)return i;\n        return -1;\n    }\n}\n\nclass Scanner {\n    private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    private StringTokenizer st = new StringTokenizer(\"\");\n    public String next(){\n        while (!st.hasMoreTokens())\n            try {\n                st = new StringTokenizer(br.readLine());\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n        return st.nextToken();\n\n    }\n    public int nextInt(){return Integer.parseInt(next());}\n    public long nextLong(){return Long.parseLong(next());}\n    public double nextDouble(){return Double.parseDouble(next());}\n    public int[] setIntArray(int n){\n        int[] arr =new int[n];\n        for(int i=0;i<n;i++)arr[i] = nextInt();\n        return arr;\n    }\n    public Integer[] setIntegerArray(int n){\n        Integer[] arr =new Integer[n];\n        for(int i=0;i<n;i++)arr[i] = nextInt();\n        return arr;\n    }\n    public long[] setlongArray(int n){\n        long[] arr =new long[n];\n        for(int i=0;i<n;i++)arr[i] = nextLong();\n        return arr;\n    }\n    public int[][] set2DIntegerMatrix(int row,int col){\n        int[][] arr = new int[row][col];\n        for(int i=0;i<row;i++)\n            for(int j= 0;j<col;j++)\n                arr[i][j] = nextInt();\n        return arr;\n    }\n}\n",
        "fixed_code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class CodeForces extends Functions {\n    static Scanner sc = new Scanner();\n    public static void  solve(){\n        int n = sc.nextInt();\n        int[] arr = sc.setIntArray(n);\n        int[][] map = new int[(int)6e6][2];\n        boolean[] isSumPresent = new boolean[(int)6e6];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                int sum = arr[i]+ arr[j];\n                if(isSumPresent[sum]){\n                    if(map[sum][0]==i || map[sum][1]==i || map[sum][1]==j || map[sum][0]==j)continue;\n                    System.out.println(\"YES\");\n                    System.out.println((i+1)+\" \"+(j+1)+\" \"+(map[sum][0]+1)+\" \"+(map[sum][1]+1));\n                    return;\n                }\n                isSumPresent[sum]  = true;\n                map[sum][0] = i;\n                map[sum][1] = j;\n            }\n        }\n        System.out.println(\"NO\");\n\n    }\n\n\n    public static void main(String[] args) {\n       int testCase = 1;\n       // testCase= sc.nextInt();\n        while (testCase-->0){\n            solve();\n        }\n        long end = System.currentTimeMillis();\n//        System.out.println(\"time took in ms : \"+(end-start));\n    }\n\n\n}\n\nclass Functions {\n    public static int mod = (int)1e9+7;\n    public static int INT_MAX = Integer.MAX_VALUE;\n    public static int INT_MIN = Integer.MIN_VALUE;\n    public static long LONG_MAX = Long.MAX_VALUE;\n    public static long LONG_MIN = Long.MIN_VALUE;\n    public static double DOUBLE_MAX = Double.MAX_VALUE;\n    public static double DOUBLE_MIN = Double.MIN_VALUE;\n\n    public static void sort(int[] a,boolean isAscending){\n        ArrayList<Integer> temp = new ArrayList<>();\n        for (int j : a) temp.add(j);\n        sort(temp,isAscending);\n        for(int i=0;i<a.length;i++)a[i] = temp.get(i);\n    }\n    public static void sort(List T,boolean isAscending){\n        if(isAscending)\n            Collections.sort(T);\n        else Collections.sort(T,Collections.reverseOrder());\n    }\n    public static long factorial(int n){\n        long fact = 1L;\n        for(int i=2;i<=n;i++)fact=  (fact*i)%mod;\n        return fact;\n    }\n\n    public  static int ncr(int n, int r){\n        // time O(n+r)\n        if (r > n)\n            return 0;\n        long[] inv = new long[r + 1];\n        inv[1] = 1;\n        // Getting the modular inversion\n        // for all the numbers\n        // from 2 to r with respect to m\n        for (int i = 2; i <= r; i++) {\n            inv[i] = mod - (mod / i) * inv[(int) (mod % i)] % mod;\n        }\n        int ans = 1;\n        // for 1/(r!) part\n        for (int i = 2; i <= r; i++) {\n            ans = (int) (((ans % mod) * (inv[i] % mod)) % mod);\n        }\n           // for (n)*(n-1)*(n-2)*...*(n-r+1) part\n        for (int i = n; i >= (n - r + 1); i--) {\n            ans = (int) (((ans % mod) * (i % mod)) % mod);\n        }\n        return ans;\n    }\n\n    public static void reverseArray(int[] a){\n        int left = 0;\n        int right = a.length-1;\n        while (left<right){\n            int temp =a[left];\n            a[left] = a[right];\n            a[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    public static long isPrime(int n){\n        for(long i=2;i*i<=n;i++)\n            if(n%i==0)return i;\n        return -1;\n    }\n}\n\nclass Scanner {\n    private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    private StringTokenizer st = new StringTokenizer(\"\");\n    public String next(){\n        while (!st.hasMoreTokens())\n            try {\n                st = new StringTokenizer(br.readLine());\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n        return st.nextToken();\n\n    }\n    public int nextInt(){return Integer.parseInt(next());}\n    public long nextLong(){return Long.parseLong(next());}\n    public double nextDouble(){return Double.parseDouble(next());}\n    public int[] setIntArray(int n){\n        int[] arr =new int[n];\n        for(int i=0;i<n;i++)arr[i] = nextInt();\n        return arr;\n    }\n    public Integer[] setIntegerArray(int n){\n        Integer[] arr =new Integer[n];\n        for(int i=0;i<n;i++)arr[i] = nextInt();\n        return arr;\n    }\n    public long[] setlongArray(int n){\n        long[] arr =new long[n];\n        for(int i=0;i<n;i++)arr[i] = nextLong();\n        return arr;\n    }\n    public int[][] set2DIntegerMatrix(int row,int col){\n        int[][] arr = new int[row][col];\n        for(int i=0;i<row;i++)\n            for(int j= 0;j<col;j++)\n                arr[i][j] = nextInt();\n        return arr;\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n#define LMAX 8\nusing namespace std;\n\nint n;\nint ans;\nint fv[LMAX];\nchar s[LMAX];\n\nint main()\n{\n    cin>>n;\n    cin.get();\n    for (int i=1;i<=n;++i)\n    {\n        cin.getline(s, LMAX);\n        for (int i=0;i<7;++i)\n        {\n            if (s[i]=='0')\n            {\n                ++fv[i];\n            }\n        }\n    }\n    for (int i=0;i<7;++i)\n    {\n        ans = max(ans, fv[i]);\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#define LMAX 8\nusing namespace std;\n\nint n;\nint ans;\nint fv[LMAX];\nchar s[LMAX];\n\nint main()\n{\n    cin>>n;\n    cin.get();\n    for (int i=1;i<=n;++i)\n    {\n        cin.getline(s, LMAX);\n        for (int i=0;i<7;++i)\n        {\n            if (s[i]=='1')\n            {\n                ++fv[i];\n            }\n        }\n    }\n    for (int i=0;i<7;++i)\n    {\n        ans = max(ans, fv[i]);\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define MOD 1000000007\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n#define ll long long\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define mt make_tuple\n#define ub upper_bound\n#define lb lower_bound\n#define popb pop_back()\n#define popf pop_front()\n#define ff first\n#define ss second\n#define vl vector<ll>\n#define vi vector<int>\n#define vs vector<string>\n#define vll vector< pair<ll,ll> >\n#define vii vector< pair<int,int> >\n#define viii vector< tuple <int,int,int> >\n#define vlll vector< tuple <ll,ll,ll> >\n#define vvl vector<vector<ll>>\n#define vv vector<vector<int>>\n#define all(v) v.begin(),v.end()\n#define sqrt sqrtl\n#define cbrt cbrtl\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define mapcl map<char,ll>\n#define mapci map<char,int>\n#define mapll map<ll,ll>\n#define mapii map<int,int>\n#define seti set<int>\nifstream fin(\"input.txt\");\nofstream fout(\"output.txt\");\n#define FOR(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define print(a)       for(auto x : a) cout << x << \" \"; cout << \"\\n\"\n#define print1(a)      for(auto x : a) cout << x.ff << \" \" << x.ss << \"\\n\"\n#define print2(a,x,y)  for(int i = x; i < y; i++) cout<< a[i]<< \" \"; cout << \"\\n\"\n\nll fast_exp(ll base, ll exp) {ll res=1;while(exp>0) {if(exp%2==1) res=(res*base)%MOD;base=(base*base)%MOD;exp/=2;}return res%MOD;}\nint gcd(int a,int b){while (a&&b)a>b?a%=b:b%=a;return a+b;}\nint val(char c){if (c >= '0' && c <= '9')return (int)c - '0';else return (int)c - 'A' + 10;}\nll pows(int a , int b){ll res=1;for(int i=0; i<b; ++i){res*=a;}return res;}\nll logx(ll base, ll num){int cnt=0;while(num!=1){num/=base; ++cnt;}return cnt;}\nll divisibles(ll a, ll b, ll m){if(a%m==0)return (b/m)-(a/m)+1;else return (b/m)-(a/m);}// in [a,b]\nstring bitstring(int n, int size){string s;while(n){s+=(n%2)+'0';n/=2;}while(s.size()<size){s+='0';}reverse(all(s));return s;}\n// dsu start\n\nvi root(200001,0);\nvi size(200001,1);\nint find(int x){while(x!=root[x])x = root[x];return x;}\nbool same(int a,int b){return find(a)==find(b);}\nvoid unite(int a, int b){a = find(a);b = find(b);if(size[a]<size[b])swap(a,b);size[a] += size[b];root[b] = a;}\n\n// dsu end\nvi vis(200001,0);\n\n\nint main()\n{\t\n    std::ios::sync_with_stdio(false);\n    //string bitstring = std::bitset< 3 >( 7 ).to_string(); <bits> (num)\n    //srand(time(0));\n    //cin.tie(NULL);\n    //cout.tie(NULL);\n \tint t;\n \tcin>>t;\n \twhile(t--)\n \t{\n \t\tint n;\n \t\tcin>>n;\n \t\tmapii mps;\n \t\tseti setx;\n \t\tvi vec;\n \t\twhile(n--)\n \t\t{\n \t\t\tint a,b;\n \t\t\tcin>>a>>b;\n \t\t\tsetx.insert(a);\n \t\t\tif(mps[a]<b)\n \t\t\t\tmps[a]=b;\n \t\t}\n \t\tint x = 0;\n \t\tint y = 0;\n \t\tsort(all(vec));\n \t\tint flag = 0;\n \t\tstring ans=\"\";\n \t\tfor(auto z : setx)\n \t\t{\n \t\t\tint r = z-x;\n \t\t\tint u = mps[z] - y;\n \t\t\tif(u>=0)\n \t\t\t{\n \t\t\t\tfor(int j=0; j<r; ++j)\n \t\t\t\t\tans+='R';\n \t\t\t\tx+=r;\n \t\t\t\tfor(int j=0; j<u; ++j)\n \t\t\t\t\tans+='U';\n \t\t\t\ty+=u;\n \t\t\t\t//cout<<x<<\" \"<<y<<\"\\n\";\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t++flag;\n\t\t\t\tbreak;\n \t\t\t }\n \t\t}\n \t\tif(flag>0)\n \t\t\tcout<<\"NO\"<<\"\\n\";\n \t\telse\n \t\t{\n \t\t\tcout<<\"YES\"<<\"\\n\";\n \t\t\tcout<<ans<<\"\\n\";\n \t\t}\n\n\n \t}   \n}",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define MOD 1000000007\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n#define ll long long\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define mt make_tuple\n#define ub upper_bound\n#define lb lower_bound\n#define popb pop_back()\n#define popf pop_front()\n#define ff first\n#define ss second\n#define vl vector<ll>\n#define vi vector<int>\n#define vs vector<string>\n#define vll vector< pair<ll,ll> >\n#define vii vector< pair<int,int> >\n#define viii vector< tuple <int,int,int> >\n#define vlll vector< tuple <ll,ll,ll> >\n#define vvl vector<vector<ll>>\n#define vv vector<vector<int>>\n#define all(v) v.begin(),v.end()\n#define sqrt sqrtl\n#define cbrt cbrtl\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define mapcl map<char,ll>\n#define mapci map<char,int>\n#define mapll map<ll,ll>\n#define mapii map<int,int>\n#define seti set<int>\nifstream fin(\"input.txt\");\nofstream fout(\"output.txt\");\n#define FOR(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define print(a)       for(auto x : a) cout << x << \" \"; cout << \"\\n\"\n#define print1(a)      for(auto x : a) cout << x.ff << \" \" << x.ss << \"\\n\"\n#define print2(a,x,y)  for(int i = x; i < y; i++) cout<< a[i]<< \" \"; cout << \"\\n\"\n\nll fast_exp(ll base, ll exp) {ll res=1;while(exp>0) {if(exp%2==1) res=(res*base)%MOD;base=(base*base)%MOD;exp/=2;}return res%MOD;}\nint gcd(int a,int b){while (a&&b)a>b?a%=b:b%=a;return a+b;}\nint val(char c){if (c >= '0' && c <= '9')return (int)c - '0';else return (int)c - 'A' + 10;}\nll pows(int a , int b){ll res=1;for(int i=0; i<b; ++i){res*=a;}return res;}\nll logx(ll base, ll num){int cnt=0;while(num!=1){num/=base; ++cnt;}return cnt;}\nll divisibles(ll a, ll b, ll m){if(a%m==0)return (b/m)-(a/m)+1;else return (b/m)-(a/m);}// in [a,b]\nstring bitstring(int n, int size){string s;while(n){s+=(n%2)+'0';n/=2;}while(s.size()<size){s+='0';}reverse(all(s));return s;}\n// dsu start\n\nvi root(200001,0);\nvi size(200001,1);\nint find(int x){while(x!=root[x])x = root[x];return x;}\nbool same(int a,int b){return find(a)==find(b);}\nvoid unite(int a, int b){a = find(a);b = find(b);if(size[a]<size[b])swap(a,b);size[a] += size[b];root[b] = a;}\n\n// dsu end\nvi vis(200001,0);\n\n\nint main()\n{\t\n    std::ios::sync_with_stdio(false);\n    //string bitstring = std::bitset< 3 >( 7 ).to_string(); <bits> (num)\n    //srand(time(0));\n    //cin.tie(NULL);\n    //cout.tie(NULL);\n \tint t;\n \tcin>>t;\n \twhile(t--)\n \t{\n \t\tint n;\n \t\tcin>>n;\n \t\tmapii mps;\n \t\tmapii mps2;\n \t\tseti setx;\n \t\tvi vec;\n \t\twhile(n--)\n \t\t{\n \t\t\tint a,b;\n \t\t\tcin>>a>>b;\n \t\t\tif(!setx.count(a))\n \t\t\t\tmps2[a]=b;\n \t\t\tsetx.insert(a);\n \t\t\tif(mps[a]<b)\n \t\t\t\tmps[a]=b;\n \t\t\tif(mps2[a]>b)\n \t\t\t\tmps2[a]=b;\n\n \t\t}\n \t\tint x = 0;\n \t\tint y = 0;\n \t\tint flag = 0;\n \t\tstring ans=\"\";\n \t\tfor(auto z : setx)\n \t\t{\n \t\t\tint r = z-x;\n \t\t\tint u = mps[z] - y;\n \t\t\tif(u>=0 && mps2[z]>=y)\n \t\t\t{\n \t\t\t\tfor(int j=0; j<r; ++j)\n \t\t\t\t\tans+='R';\n \t\t\t\tx+=r;\n \t\t\t\tfor(int j=0; j<u; ++j)\n \t\t\t\t\tans+='U';\n \t\t\t\ty+=u;\n \t\t\t\t//cout<<x<<\" \"<<y<<\"\\n\";\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t++flag;\n\t\t\t\tbreak;\n \t\t\t }\n \t\t}\n \t\tif(flag>0)\n \t\t\tcout<<\"NO\"<<\"\\n\";\n \t\telse\n \t\t{\n \t\t\tcout<<\"YES\"<<\"\\n\";\n \t\t\tcout<<ans<<\"\\n\";\n \t\t}\n\n\n \t}   \n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 100000 + 100;\n\nconst int oo = 1e9;\nint n , w;\nll gcd(ll a , ll b) {\n\treturn !b ? a : gcd(b, a % b);\n}\nstruct fr {\n\tll a , b;\n\tfr() {\n\t\ta = 0, b = 1;\n\t}\n\tfr(ll _a , ll _b) {\n\t\tif(_a < 0 && _b < 0){\n\t\t\t_a *=-1,_b*=-1;\n\t\t}\n\t\tif(_b < 0){\n\t\t\t_a *=-1,_b*=-1;\n\t\t}\n\t\tll x = gcd(abs(_a),abs(_b));\n\t\ta = _a / x;\n\t\tb = _b / x;\n\t}\n\tbool operator<(const fr &rhs) const {\n\t\treturn a * rhs.b < rhs.a * b;\n\t}\n\tbool operator>(const fr &rhs) const {\n\t\treturn a * rhs.b > rhs.a * b;\n\t}\n\tbool operator==(const fr &rhs) const {\n\t\treturn a == rhs.a && b == rhs.b;\n\t}\n};\npair< fr , fr > r[N];\n\nvector<fr> all;\nint bit[N];\n\nvoid add(int idx) {\n\twhile (idx <= all.size()) {\n\t\tbit[idx]++;\n\t\tidx += (idx & -idx);\n\t}\n}\nint get(int idx) {\n\tint res = 0;\n\twhile (idx) {\n\t\tres += bit[idx];\n\t\tidx -= (idx & -idx);\n\t}\n\treturn res;\n}\nint dx(fr cur) {\n\treturn lower_bound(all.begin(), all.end(), cur) - all.begin() + 1;\n}\nstruct less_than_key\n{\n\tinline bool operator() (const pair<fr, fr>& s1, const pair<fr, fr>& s2)\n\t{\n\n\t\tif (s1.x == s2.x) {\n\t\t\treturn s1.y > s2.y;\n\t\t}\n\t\treturn s1.x < s2.x;\n\t}\n};\n\n\nint main() {\n\tcin >> n >> w;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x, v;\n\t\tscanf(\"%d%d\", &x, &v);\n\t\tr[i].x = fr(x, v + w);\n\t\tr[i].y = fr(x, v - w);\n\t\tall.pb(r[i].x);\n\t\tall.pb(r[i].y);\n\n\t}\n\tall.pb(fr(0, 1));\n\tall.pb(fr(oo, 1));\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tsort(r + 1, r + n + 1, less_than_key());\n\tll res = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tres += get(all.size()) - get(dx(r[i].y) - 1);\n\t\t//cout << r[i].x.a / (double)r[i].x.b << \" \" << r[i].y.a / (double)r[i].y.b << endl;\n\n\t\t//cout << \" ADD \" << dx(r[i].y) << \" \" << all.size() << \" \" << r[i].x.a / (double)r[i].x.b << \" \" << res << endl;\n\t\tadd(dx(r[i].y));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 200000 + 100;\n\nconst int oo = 1e9;\nint n , w;\nll gcd(ll a , ll b) {\n\treturn !b ? a : gcd(b, a % b);\n}\nstruct fr {\n\tll a , b;\n\tfr() {\n\t\ta = 0, b = 1;\n\t}\n\tfr(ll _a , ll _b) {\n\t\tif(_a < 0 && _b < 0){\n\t\t\t_a *=-1,_b*=-1;\n\t\t}\n\t\tif(_b < 0){\n\t\t\t_a *=-1,_b*=-1;\n\t\t}\n\t\tll x = gcd(abs(_a),abs(_b));\n\t\ta = _a / x;\n\t\tb = _b / x;\n\t}\n\tbool operator<(const fr &rhs) const {\n\t\treturn a * rhs.b < rhs.a * b;\n\t}\n\tbool operator>(const fr &rhs) const {\n\t\treturn a * rhs.b > rhs.a * b;\n\t}\n\tbool operator==(const fr &rhs) const {\n\t\treturn a == rhs.a && b == rhs.b;\n\t}\n};\npair< fr , fr > r[N];\n\nvector<fr> all;\nint bit[N];\n\nvoid add(int idx) {\n\twhile (idx <= all.size()) {\n\t\tbit[idx]++;\n\t\tidx += (idx & -idx);\n\t}\n}\nint get(int idx) {\n\tint res = 0;\n\twhile (idx) {\n\t\tres += bit[idx];\n\t\tidx -= (idx & -idx);\n\t}\n\treturn res;\n}\nint dx(fr cur) {\n\treturn lower_bound(all.begin(), all.end(), cur) - all.begin() + 1;\n}\nstruct less_than_key\n{\n\tinline bool operator() (const pair<fr, fr>& s1, const pair<fr, fr>& s2)\n\t{\n\n\t\tif (s1.x == s2.x) {\n\t\t\treturn s1.y > s2.y;\n\t\t}\n\t\treturn s1.x < s2.x;\n\t}\n};\n\n\nint main() {\n\tcin >> n >> w;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x, v;\n\t\tscanf(\"%d%d\", &x, &v);\n\t\tr[i].x = fr(x, v + w);\n\t\tr[i].y = fr(x, v - w);\n\t\tall.pb(r[i].x);\n\t\tall.pb(r[i].y);\n\n\t}\n\tall.pb(fr(0, 1));\n\tall.pb(fr(oo, 1));\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tsort(r + 1, r + n + 1, less_than_key());\n\tll res = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tres += get(all.size()) - get(dx(r[i].y) - 1);\n\t\t//cout << r[i].x.a / (double)r[i].x.b << \" \" << r[i].y.a / (double)r[i].y.b << endl;\n\n\t\t//cout << \" ADD \" << dx(r[i].y) << \" \" << all.size() << \" \" << r[i].x.a / (double)r[i].x.b << \" \" << res << endl;\n\t\tadd(dx(r[i].y));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void insert(tw.com.softleader.sample.movie.Movie entity) {\n    try {\n        java.lang.Class.forName(DB_DRIVER);\n        java.sql.Connection connection = java.sql.DriverManager.getConnection(DB_URL, \"postgres\", \"postgres\");\n        java.sql.Statement stmt = connection.createStatement();\n        java.lang.String sqlCmd = (((((\"insert into movie values ('\" + (entity.getId())) + \"','\") + (entity.getName())) + \"','\") + (entity.getPrice())) + \"')\";\n        stmt.executeUpdate(sqlCmd);\n        stmt.close();\n        connection.close();\n    } catch (java.lang.ClassNotFoundException e) {\n        e.printStackTrace();\n    } catch (java.sql.SQLException e) {\n        e.printStackTrace();\n    }\n}",
        "fixed_code": "@java.lang.Override\npublic void insert(tw.com.softleader.sample.movie.Movie entity) {\n    java.lang.String sqlCmd = \"insert into movie(name,price) values(?,?)\";\n    try {\n        java.lang.Class.forName(DB_DRIVER);\n        java.sql.Connection connection = java.sql.DriverManager.getConnection(DB_URL, \"postgres\", \"postgres\");\n        java.sql.PreparedStatement prst = connection.prepareStatement(sqlCmd);\n        prst.setString(1, entity.getName());\n        prst.setString(2, entity.getPrice());\n        prst.executeUpdate();\n        prst.close();\n        connection.close();\n    } catch (java.lang.ClassNotFoundException e) {\n        e.printStackTrace();\n    } catch (java.sql.SQLException e) {\n        e.printStackTrace();\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "for _ in range(int(input())):\r\n    n = int(input())\r\n    c = list(map(int,input().split()))\r\n    a = list(map(int,input().split()))\r\n    b = list(map(int,input().split()))\r\n    opEn,mAx =c[-1],-1\r\n    for i in range(n-1,0,-1):\r\n        closed = max(c[i],opEn)+(abs(b[i]-a[i])+1)\r\n        mAx = max(closed,mAx)\r\n        opEn = max(c[i],opEn+c[i-1]-abs(b[i]-a[i])+1)\r\n        if b[i]==a[i]:\r\n            opEn=0\r\n    print(mAx)",
        "fixed_code": "for _ in range(int(input())):\r\n    n = int(input())\r\n    c = list(map(int,input().split()))\r\n    a = list(map(int,input().split()))\r\n    b = list(map(int,input().split()))\r\n    opEn,mAx =c[-1],-1\r\n    for i in range(n-1,0,-1):\r\n        closed = max(c[i],opEn)+(abs(b[i]-a[i])+1)\r\n        mAx = max(closed,mAx)\r\n        opEn = max(c[i],opEn)+c[i-1]-abs(b[i]-a[i])+1\r\n        if b[i]==a[i]:\r\n            opEn=c[i-1]\r\n    print(mAx)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "@java.lang.Override\npublic java.lang.Void call() throws java.lang.Exception {\n    complete(request.getResults());\n    request.cancel(true);\n    return null;\n}",
        "fixed_code": "@java.lang.Override\npublic void futureDone(java.util.concurrent.Future<org.infinispan.remoting.transport.jgroups.Responses> future) {\n    complete(new org.infinispan.remoting.transport.jgroups.Responses(request.getResults()));\n    if ((timeoutFuture) != null) {\n        timeoutFuture.cancel(false);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.util.*;\r\n\r\npublic class Solution6 {\r\n\r\n\r\n    public static void main(String[] args) {\r\n        FastScanner fs=new FastScanner();\r\n        PrintWriter out=new PrintWriter(System.out);\r\n\r\n        int t=fs.nextInt();\r\n        int l=0;\r\n        while(t-->0){\r\n            //long n=fs.nextLong();\r\n            //long k=fs.nextLong();\r\n            int n=fs.nextInt();\r\n            int k=fs.nextInt();\r\n            String s=fs.next();\r\n\r\n            check(n,k,s);\r\n        }\r\n    }\r\n\r\n    public static void check(int n,int k,String s){\r\n        int fn[]=new int[n];\r\n        char ch[]=s.toCharArray();\r\n        int m=k;\r\n        for(int i=0;i<n && m>0;i++){\r\n            if(k%2==ch[i]-'0'){\r\n                fn[i]=1;\r\n                m--;\r\n            }\r\n        }\r\n        fn[n-1]+=m;\r\n        String res=\"\";\r\n        for(int i=0;i<n;i++){\r\n            if((k-fn[i])%2!=0)\r\n                ch[i]=(char)('1'-(ch[i]-'0'));\r\n        }\r\n        System.out.println(String.valueOf(ch));\r\n        for(int i:fn)\r\n            System.out.print(i+\" \");\r\n\r\n        System.out.println();\r\n    }\r\n\r\n\r\n    static long binpow(long a, long b) {\r\n        a %= mod;\r\n        long res = 1;\r\n        while (b > 0) {\r\n            if ((b & 1)==1)\r\n                res = res * a % mod;\r\n            a = a * a % mod;\r\n            b >>= 1;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    static long setbit(long x){\r\n        long ind=0;int i=0;\r\n\r\n        while(x>0){\r\n            if((x & 1)==1)\r\n                ind =i;\r\n\r\n            i++;\r\n            x>>=1;\r\n        }\r\n\r\n        return ind;\r\n    }\r\n\r\n\r\n\r\n    static final Random random=new Random();\r\n    static final int mod=1_000_000_007;\r\n\r\n    static void ruffleSort(int[] a) {\r\n        int n=a.length;//shuffle, then sort\r\n        for (int i=0; i<n; i++) {\r\n            int oi=random.nextInt(n), temp=a[oi];\r\n            a[oi]=a[i]; a[i]=temp;\r\n        }\r\n        Arrays.sort(a);\r\n    }\r\n    static long add(long a, long b) {\r\n        return (a+b)%mod;\r\n    }\r\n    static long sub(long a, long b) {\r\n        return ((a-b)%mod+mod)%mod;\r\n    }\r\n    static long mul(long a, long b) {\r\n        return (a*b)%mod;\r\n    }\r\n    static long exp(long base, long exp) {\r\n        if (exp==0) return 1;\r\n        long half=exp(base, exp/2);\r\n        if (exp%2==0) return mul(half, half);\r\n        return mul(half, mul(half, base));\r\n    }\r\n    static long[] factorials=new long[2_000_001];\r\n    static long[] invFactorials=new long[2_000_001];\r\n    static void precompFacts() {\r\n        factorials[0]=invFactorials[0]=1;\r\n        for (int i=1; i<factorials.length; i++) factorials[i]=mul(factorials[i-1], i);\r\n        invFactorials[factorials.length-1]=exp(factorials[factorials.length-1], mod-2);\r\n        for (int i=invFactorials.length-2; i>=0; i--)\r\n            invFactorials[i]=mul(invFactorials[i+1], i+1);\r\n    }\r\n\r\n    static long nCk(int n, int k) {\r\n        return mul(factorials[n], mul(invFactorials[k], invFactorials[n-k]));\r\n    }\r\n\r\n    static void sort(int[] a) {\r\n        ArrayList<Integer> l=new ArrayList<>();\r\n        for (int i:a) l.add(i);\r\n        Collections.sort(l);\r\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\r\n    }\r\n\r\n\r\n    static class FastScanner {\r\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\r\n        StringTokenizer st=new StringTokenizer(\"\");\r\n        String next() {\r\n            while (!st.hasMoreTokens())\r\n                try {\r\n                    st=new StringTokenizer(br.readLine());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            return st.nextToken();\r\n        }\r\n\r\n        int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n        int[] readArray(int n) {\r\n            int[] a=new int[n];\r\n            for (int i=0; i<n; i++) a[i]=nextInt();\r\n            return a;\r\n        }\r\n        long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n\r\n}",
        "fixed_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.util.*;\r\n\r\npublic class Solution6 {\r\n\r\n\r\n    public static void main(String[] args) {\r\n        FastScanner fs=new FastScanner();\r\n        PrintWriter out=new PrintWriter(System.out);\r\n\r\n        int t=fs.nextInt();\r\n        int l=0;\r\n        while(t-->0){\r\n            //long n=fs.nextLong();\r\n            //long k=fs.nextLong();\r\n            int n=fs.nextInt();\r\n            int k=fs.nextInt();\r\n            String s=fs.next();\r\n            char ch[]=s.toCharArray();\r\n            check(n,k,ch);\r\n        }\r\n    }\r\n\r\n    public static void check(int n,int k,char ch[]){\r\n        int fn[]=new int[n];\r\n        //char ch[]=s.toCharArray();\r\n        int m=k;\r\n        for(int i=0;i<n && m>0;i++){\r\n            if(k%2==ch[i]-'0'){\r\n                fn[i]=1;\r\n                m--;\r\n            }\r\n        }\r\n        fn[n-1]+=m;\r\n        String res=\"\";\r\n        for(int i=0;i<n;i++){\r\n            if((k-fn[i])%2!=0)\r\n                ch[i]=(char)('1'-(ch[i]-'0'));\r\n        }\r\n        System.out.println(String.valueOf(ch));\r\n        for(int i:fn)\r\n            System.out.print(i+\" \");\r\n\r\n        System.out.println();\r\n    }\r\n\r\n\r\n    static long binpow(long a, long b) {\r\n        a %= mod;\r\n        long res = 1;\r\n        while (b > 0) {\r\n            if ((b & 1)==1)\r\n                res = res * a % mod;\r\n            a = a * a % mod;\r\n            b >>= 1;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    static long setbit(long x){\r\n        long ind=0;int i=0;\r\n\r\n        while(x>0){\r\n            if((x & 1)==1)\r\n                ind =i;\r\n\r\n            i++;\r\n            x>>=1;\r\n        }\r\n\r\n        return ind;\r\n    }\r\n\r\n\r\n\r\n    static final Random random=new Random();\r\n    static final int mod=1_000_000_007;\r\n\r\n    static void ruffleSort(int[] a) {\r\n        int n=a.length;//shuffle, then sort\r\n        for (int i=0; i<n; i++) {\r\n            int oi=random.nextInt(n), temp=a[oi];\r\n            a[oi]=a[i]; a[i]=temp;\r\n        }\r\n        Arrays.sort(a);\r\n    }\r\n    static long add(long a, long b) {\r\n        return (a+b)%mod;\r\n    }\r\n    static long sub(long a, long b) {\r\n        return ((a-b)%mod+mod)%mod;\r\n    }\r\n    static long mul(long a, long b) {\r\n        return (a*b)%mod;\r\n    }\r\n    static long exp(long base, long exp) {\r\n        if (exp==0) return 1;\r\n        long half=exp(base, exp/2);\r\n        if (exp%2==0) return mul(half, half);\r\n        return mul(half, mul(half, base));\r\n    }\r\n    static long[] factorials=new long[2_000_001];\r\n    static long[] invFactorials=new long[2_000_001];\r\n    static void precompFacts() {\r\n        factorials[0]=invFactorials[0]=1;\r\n        for (int i=1; i<factorials.length; i++) factorials[i]=mul(factorials[i-1], i);\r\n        invFactorials[factorials.length-1]=exp(factorials[factorials.length-1], mod-2);\r\n        for (int i=invFactorials.length-2; i>=0; i--)\r\n            invFactorials[i]=mul(invFactorials[i+1], i+1);\r\n    }\r\n\r\n    static long nCk(int n, int k) {\r\n        return mul(factorials[n], mul(invFactorials[k], invFactorials[n-k]));\r\n    }\r\n\r\n    static void sort(int[] a) {\r\n        ArrayList<Integer> l=new ArrayList<>();\r\n        for (int i:a) l.add(i);\r\n        Collections.sort(l);\r\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\r\n    }\r\n\r\n\r\n    static class FastScanner {\r\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\r\n        StringTokenizer st=new StringTokenizer(\"\");\r\n        String next() {\r\n            while (!st.hasMoreTokens())\r\n                try {\r\n                    st=new StringTokenizer(br.readLine());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            return st.nextToken();\r\n        }\r\n\r\n        int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n        int[] readArray(int n) {\r\n            int[] a=new int[n];\r\n            for (int i=0; i<n; i++) a[i]=nextInt();\r\n            return a;\r\n        }\r\n        long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "private void markAprilTagInFrame() {\n}",
        "fixed_code": "public void markAprilTagInFrame(com.example.peiming.view.TagOverlay[] shapes, int result) {\n    android.os.Message msg = new android.os.Message();\n    msg.obj = shapes;\n    msg.what = result;\n    com.example.peiming.myapplication.MainActivity.mHandler.sendMessage(msg);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll, ll> pii;\r\nconst ll N = 1e5 + 10;\r\nll a[N];\r\nvector<ll>v[N];\r\nvoid solve() {\r\n\tll n, q;\r\n\tscanf(\"%lld%lld\", &n, &q);\r\n\tdeque<pii>dq;\r\n\tfor (ll i = 1; i <= n; i++) {\r\n\t\tv[i].clear();\r\n\t\tscanf(\"%lld\", &a[i]);\r\n\t\tdq.push_back({a[i], i});\r\n\t}\r\n\tfor (ll i = 1; i <= n ; i++) {\r\n\t\tauto q1 = dq.front();\r\n\t\tdq.pop_front();\r\n\t\tauto q2 = dq.front();\r\n\t\tdq.pop_front();\r\n\t\tif (q1 < q2) {\r\n\t\t\tswap(q1, q2);\r\n\t\t}\r\n\t\tdq.push_front(q1);\r\n\t\tdq.push_back(q2);\r\n\t\tv[q1.second].push_back(i);\r\n\t}\r\n\tfor (ll j = 1, i, k, res; j <= q; j++) {\r\n\t\tscanf(\"%lld%lld\", &i, &k);\r\n\t\tif (k <= n || a[i] != n) {\r\n\t\t\tres = upper_bound(v[i].begin(), v[i].end(), k) - v[i].begin() ;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tres = max(0ll, k - n) + upper_bound(v[i].begin(), v[i].end(), k) - v[i].begin() ;\r\n\t\t}\r\n\t\tprintf(\"%lld\\n\", res);\r\n\t}\r\n\treturn ;\r\n}\r\nint main() {\r\n\tll t;\r\n\tscanf(\"%lld\", &t);\r\n\twhile (t--) {\r\n\t\tsolve();\r\n\t}\r\n}",
        "fixed_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nusing LL = long long;\r\nconst int maxn = 1e5 + 5, INF = 0x3f3f3f3f;\r\nint a[maxn];\r\nvector<int> pos[maxn];\r\n\r\nint main(){\r\n\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    ios::sync_with_stdio(0);\r\n\r\n    int T;\r\n    cin >> T;\r\n    while(T--){\r\n        int n, m;\r\n        cin >> n >> m;\r\n        for(int i = 1; i <= n; i++) cin >> a[i], pos[i].clear();\r\n        deque<int> q;\r\n        for(int i = 1; i <= n; i++) q.push_back(i);\r\n        for(int i = 1; i <= n; i++){\r\n            int t1 = q.front(); q.pop_front();\r\n            int t2 = q.front(); q.pop_front();\r\n            if (a[t1] < a[t2]) swap(t1, t2);\r\n            q.push_front(t1);\r\n            q.push_back(t2);\r\n            pos[t1].push_back(i);\r\n        }\r\n        while(m--){\r\n            int x, k;\r\n            cin >> x >> k;\r\n            int res = upper_bound(pos[x].begin(), pos[x].end(), k) - pos[x].begin();\r\n            if (a[x] == n) res += max(0, k - n);\r\n            cout << res << '\\n';\r\n        }\r\n    }\r\n\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <cstdio>\n\nint gcd(int a, int b)\n{\n    if(a < b)\n    {\n        a = a^b;\n        b = a^b;\n        a = a^b;\n    }\n    \n    return gcd(b, a%b);\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    \n    int a[n];\n    for(int i = 0; i < n; ++i)\n        scanf(\"%d\", &a[i]);\n        \n    int d = a[0];\n    for(int i = 1; i < n; ++i)\n        d = gcd(d, a[i]);\n    if(d > 1)\n    {\n        printf(\"YES\\n0\\n\");\n    }\n    else\n    {\n        int m = 0;\n        for(int i = 0; i < n; ++i)\n            if(a[i]%2 == 1)\n                ++m;\n        if(m%2 == 1)\n            printf(\"NO\\n\");\n        else\n        {\n            printf(\"YES\\n%d\\n\", m/2);\n        }\n    }\n}",
        "fixed_code": "#include <cstdio>\n\nint gcd(int a, int b)\n{\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n\n    int a[n];\n    for(int i = 0; i < n; ++i)\n        scanf(\"%d\", &a[i]);\n\n    int d = a[0];\n    for(int i = 1; i < n && d > 1; ++i)\n        d = gcd(d, a[i]);\n\n    for(int i = 0; i < n; ++i)\n        a[i] &= 1;\n\n    printf(\"YES\\n\");\n    if(d > 1)\n        printf(\"0\\n\");\n    else\n    {\n        int m = 0;\n        for(int i = 0; i < n; ++i)\n        {\n            if(a[i] == 1)\n            {\n                ++m;\n                if(i+1 >= n || a[i+1] == 0)\n                    ++m;\n                if(i+1 < n)\n                    a[i+1] = 0;\n            }\n        }\n        printf(\"%d\\n\", m);\n    }\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\ntypedef long long int LL;\n#define MOD 1000000007\n#define MAX 100005\nusing namespace std;\n\n\nstruct plane\n{\n    int x,y;\n}point[123456];\n\nint ans,n;\n\nbool cmp(struct plane i,struct plane j)\n{\n    if(i.x==j.x)\n        return (i.y<j.y);\n    else\n        return (i.x<j.x);\n}\nvoid go(int x,int y)\n{\n    if(x<0)\n    {\n        cout<<\"1 \"<<-x<<\" L\\n\";\n    }\n    else if(x>0)\n    {\n        cout<<\"1 \"<<x<<\" R\\n\";\n    }\n\n    if(y<0)\n    {\n        cout<<\"1 \"<<-y<<\" D\\n\";\n    }\n    else if(y>0)\n    {\n        cout<<\"1 \"<<y<<\" U\\n\";\n    }\n\n}\nint main()\n{\n   // freopen(\"input.txt\",\"r\",stdin);\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cin>>point[i].x>>point[i].y;\n        if((!point[i].x)||(!point[i].y))\n            ans=ans+4;\n        else\n            ans=ans+6;\n    }\n    sort(point,point+n,cmp);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)\n    {\n        int x=point[i].x;\n        int y=point[i].y;\n        go(x,y);\n        cout<<\"2\\n\";\n        x=x*-1;\n        y=y*-1;\n        go(x,y);\n        cout<<\"3\\n\";\n    }\n    return 0;\n\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\ntypedef long long int LL;\n#define MOD 1000000007\n#define MAX 100005\nusing namespace std;\n\n\nstruct plane\n{\n    int x,y;\n}point[123456];\n\nint ans,n;\n\nbool cmp(struct plane i,struct plane j)\n{\n   return((abs(i.x)+abs(i.y))<(abs(j.x)+abs(j.y)));\n}\nvoid go(int x,int y)\n{\n    if(x<0)\n    {\n        cout<<\"1 \"<<-x<<\" L\\n\";\n    }\n    else if(x>0)\n    {\n        cout<<\"1 \"<<x<<\" R\\n\";\n    }\n\n    if(y<0)\n    {\n        cout<<\"1 \"<<-y<<\" D\\n\";\n    }\n    else if(y>0)\n    {\n        cout<<\"1 \"<<y<<\" U\\n\";\n    }\n\n}\nint main()\n{\n   // freopen(\"input.txt\",\"r\",stdin);\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cin>>point[i].x>>point[i].y;\n        if((!point[i].x)||(!point[i].y))\n            ans=ans+4;\n        else\n            ans=ans+6;\n    }\n    sort(point,point+n,cmp);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)\n    {\n        int x=point[i].x;\n        int y=point[i].y;\n        go(x,y);\n        cout<<\"2\\n\";\n        x=x*-1;\n        y=y*-1;\n        go(x,y);\n        cout<<\"3\\n\";\n    }\n    return 0;\n\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <cstdio>\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <functional>\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define REPE(i,x,y) for (int i=(x);i<(y);i++)\n#define REP(i,x,y) for (int i=(x);i<=(y);i++)\n#define DREP(i,x,y) for (int i=(x);i>=(y);i--)\n#define mp make_pair\n#define pb push_back\n#define MAXN 200100\n#define eps 0.000001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef long double ld;\ntypedef pair<ld,ld> pdd;\ntypedef struct line {\n\tld m,c; int ct;\n} line;\n\nmap< pdd,int > same;\npair<pdd,int> init[MAXN];\nvector<int> ans;\nvector<int> pts[MAXN];\nint CHTsize,N;\nline A[MAXN];\nline CHT[MAXN];\n\nbool slopesort(line a,line b) {\n\tif (a.m == b.m) { return a.c < b.c; }\n\treturn a.m > b.m;\n}\n\nld x_intersect(line a,line b) {\n\treturn (b.c - a.c)/(a.m - b.m);\n}\n\nld y_intersect(line a,line b) {\n\treturn a.m*x_intersect(a,b) + a.c;\n}\n\n\nvoid CH_insert(ld m,ld c,int idx) {\n\tline l; l.m=m; l.c=c; l.ct = idx;\n\tA[N] = l; N++;\n}\n\nvoid CH_process() {\n\t//REP(j,0,N-1) cout<<A[j].m<<\" \"<<A[j].c<<endl;\n\tsort(A,A+N,slopesort); N--;\n\t/*REP(j,0,N) {\n\t\tcout<<A[j].m<<\" \"<<A[j].c<<endl;\n\t}*/\n\tCHTsize=1; CHT[1] = A[0]; if (A[0].m == A[N].m) { return; }\n\tint j=1;\n\twhile (A[j].m == A[0].m) {\n\t\tj++;\n\t}\n\tCHT[2] = A[j]; CHTsize++;\n\tREP(i,j+1,N) {\n\t\tif (A[i].m == CHT[CHTsize].m+eps) continue;\n\t\tif (A[i].m + eps == CHT[CHTsize].m) continue;\n\t\twhile (CHTsize > 1) {\n\t\t\tif (y_intersect(CHT[CHTsize-1],A[i]) <= y_intersect(CHT[CHTsize-1],CHT[CHTsize])) {\n\t\t\t\t//cout<<CHT[CHTsize].m<<\"x + \"<<CHT[CHTsize].c<<endl;\n\t\t\t\tCHTsize--;\n\t\t\t} else { break; }\n\t\t}\n\t\tCHTsize++; CHT[CHTsize]=A[i];\n\t}\n\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n; ld r,s; cin>>n; int cnt=0; N = 0;\n\tREP(i,1,n) {\n\t\tcin>>r>>s;\n\t\tinit[i] = mp( mp(r,s),i );\n\t}\n\t\n\tsort(init+1,init+n+1);\n\t\n\tREP(j,1,n) {\n\t\tif ((j==1) or (init[j].first!=init[j-1].first)) {\n\t\t\tr = init[j].first.first, s=init[j].first.second;\n\t\t\tcnt++; CH_insert(1/r,1/s,cnt);\n\t\t}\n\t\tpts[cnt].pb(init[j].second);\n\t}\n\n\t/*REP(j,0,2) {\n\t\tREPE(i,0,2) {\n\t\t\tif (i==j) continue;\n\t\t\tcout<<A[j].m<<\"x + \"<<A[j].c<<\" ; \"<<A[i].m<<\"x + \"<<A[i].c<<\" : \"<<x_intersect(A[j],A[i])<<\" , \"<<y_intersect(A[j],A[i])<<endl;\n\t\t}\n\t}*/\n\tif (n>4) assert(1==2);\n\tCH_process();\n\tint ptr = 1;\n\tint X = CHT[CHTsize].ct;\n\tans.insert(ans.end(),pts[X].begin(),pts[X].end());\n\n\twhile (ptr < CHTsize) {\n\t\tif (x_intersect(CHT[ptr],CHT[ptr+1])+eps > 0) {\n\t\t\tX = CHT[ptr].ct;\n\t\t\tans.insert(ans.end(),pts[X].begin(),pts[X].end());\n\t\t}\n\t\tptr++;\n\t}\n\t\n\tsort(ans.begin(),ans.end());\n\tREPE(j,0,ans.size()) {\n\t\tcout<<ans[j];\n\t\tif (j < ans.size()-1) { cout<<\" \"; }\n\t}\n\tcout<<endl; return 0;\n\n}\n",
        "fixed_code": "#include <cstdio>\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <functional>\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define REPE(i,x,y) for (int i=(x);i<(y);i++)\n#define REP(i,x,y) for (int i=(x);i<=(y);i++)\n#define DREP(i,x,y) for (int i=(x);i>=(y);i--)\n#define mp make_pair\n#define pb push_back\n#define MAXN 200100\n#define eps 0.000000001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef long double ld;\ntypedef pair<ld,ld> pdd;\ntypedef struct line {\n\tld m,c; int ct;\n} line;\n\npair<pdd,int> init[MAXN];\nvector<int> ans;\nvector<int> pts[MAXN];\nint CHTsize,N;\nline A[MAXN];\nline CHT[MAXN];\n\nbool ptssort(pair<pdd,int> a,pair<pdd,int> b) {\n\tif (a.first.first!=b.first.first) return a.first.first < b.first.first;\n\treturn a.first.second > b.first.second;\n}\n\nld x_intersect(line a,line b) {\n\treturn (a.c - b.c)/(b.m - a.m);\n}\n\nbool x_intersect_pos(line a,line b) {\n\tif (a.m < b.m) {\n\t\treturn b.c < a.c;\n\t} else {\n\t\treturn b.c > a.c;\n\t}\n}\n\nbool x_intersect_less(line a, line b,line c) {\n\tld x1 = x_intersect(a,b); ld x2 = x_intersect(a,c);\n\treturn x1 + eps < x2;\n}\n\nld y_intersect(line a,line b) {\n\treturn a.m*x_intersect(a,b) + a.c;\n}\n\n\nvoid CH_insert(ld m,ld c,int idx) {\n\tline l; l.m=m; l.c=c; l.ct = idx;\n\tA[N] = l; N++;\n}\n\nvoid CH_process() {\n\tN--; //cout<<N<<endl;\n\tCHT[1] = A[0]; if (N == 0) { CHTsize=1; return; }\n\tCHT[2] = A[1]; CHTsize=2;\n\tREP(i,2,N) {\n\t\twhile (CHTsize > 1) {\n\t\t\tif (x_intersect_less(CHT[CHTsize-1],A[i],CHT[CHTsize])) {\n\t\t\t\tCHTsize--;\n\t\t\t} else { break; }\n\t\t}\n\t\tCHTsize++; CHT[CHTsize]=A[i];\n\t}\n\n}\n\nint main() {\n\t//ios::sync_with_stdio(false);\n\tint n; ld r,s; int x,y; scanf(\"%d\",&n); int cnt=0; N = 0;\n\tREP(i,1,n) {\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tr = (ld)x; s = (ld)y;\n\t\tinit[i] = mp( mp(r,s),i );\n\t}\n\t\n\tsort(init+1,init+n+1,ptssort);\n\tpdd last;\n\n\tREP(j,1,n) {\n\t\t//cout<<last.first<<\" : \"<<last.second<<endl;\n\t\tif ((j==1) or (init[j].first!=last)) {\n\t\t\tif ((init[j].first.first == last.first) and (init[j].first.second != last.second) and (j!=1) ) continue;\n\n\t\t\tr = init[j].first.first, s=init[j].first.second; last = init[j].first;\n\t\t\tcnt++; CH_insert(1/r,1/s,cnt); //cout<<j<<\" * \"<<endl;\n\t\t}\n\t\tpts[cnt].pb(init[j].second); //cout<<j<<endl;\n\t}\n\n\t/*REP(j,0,2) {\n\t\tREPE(i,0,2) {\n\t\t\tif (i==j) continue;\n\t\t\tcout<<A[j].m<<\"x + \"<<A[j].c<<\" ; \"<<A[i].m<<\"x + \"<<A[i].c<<\" : \"<<x_intersect(A[j],A[i])<<\" , \"<<y_intersect(A[j],A[i])<<endl;\n\t\t}\n\t}*/\n\t//if (n>4) return 0;\n\n\tCH_process();\n\tint ptr = 1;\n\tint X = CHT[CHTsize].ct;\n\tans.insert(ans.end(),pts[X].begin(),pts[X].end());\n\n\twhile (ptr < CHTsize) {\n\t\tif (x_intersect_pos(CHT[ptr],CHT[ptr+1])) {\n\t\t\tX = CHT[ptr].ct;\n\t\t\tans.insert(ans.end(),pts[X].begin(),pts[X].end());\n\t\t}\n\t\tptr++;\n\t}\n\t\n\tsort(ans.begin(),ans.end());\n\tREPE(j,0,ans.size()) {\n\t\tprintf(\"%d\",ans[j]);\n\t\tif (j < ans.size()-1) { printf(\" \"); }\n\t}\n\tprintf(\"\\n\"); return 0;\n\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public com.ontotext.ehri.georecon.place.Place closestCommon(com.ontotext.ehri.georecon.place.Place other) {\n    java.util.Iterator<com.ontotext.ehri.georecon.place.Place> myLineage = lineage().descendingIterator();\n    java.util.Iterator<com.ontotext.ehri.georecon.place.Place> otherLineage = other.lineage().descendingIterator();\n    com.ontotext.ehri.georecon.place.Place closestCommon = null;\n    while ((myLineage.hasNext()) && (otherLineage.hasNext())) {\n        com.ontotext.ehri.georecon.place.Place myAncestor = myLineage.next();\n        com.ontotext.ehri.georecon.place.Place otherAncestor = otherLineage.next();\n        if (myAncestor.equals(otherAncestor))\n            closestCommon = myAncestor;\n        else\n            break;\n        \n    } \n    return closestCommon;\n}",
        "fixed_code": "public com.ontotext.ehri.georecon.place.Place closestCommon(com.ontotext.ehri.georecon.place.Place other) {\n    java.util.Iterator<com.ontotext.ehri.georecon.place.Place> myLineage = lineage().iterator();\n    java.util.Iterator<com.ontotext.ehri.georecon.place.Place> otherLineage = other.lineage().iterator();\n    com.ontotext.ehri.georecon.place.Place closestCommon = null;\n    while ((myLineage.hasNext()) && (otherLineage.hasNext())) {\n        com.ontotext.ehri.georecon.place.Place myAncestor = myLineage.next();\n        com.ontotext.ehri.georecon.place.Place otherAncestor = otherLineage.next();\n        if (myAncestor.equals(otherAncestor))\n            closestCommon = myAncestor;\n        else\n            break;\n        \n    } \n    return closestCommon;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\nconst int N = 2e5+5;\r\n\r\nint n;\r\nll a[N];\r\nmap<ll,bool> mp;\r\n\r\nint main(){\r\n\tint t;cin>>t;\r\n\twhile (t--){\r\n\t\tll sum=0;\r\n\t\tscanf(\"%d\",&n);\r\n\t\tfor (int i=1;i<=n+2;i++){\r\n\t\t\tscanf(\"%lld\",&a[i]);\r\n\t\t}\r\n\t\tsort(a+1,a+n+3);\r\n\t\tfor (int i=1;i<=n;i++){\r\n\t\t\tsum+=a[i];\r\n\t\t\tmp[a[i]]=1;\r\n\t\t}\r\n\t\tif (sum>a[n+2]){\r\n\t\t\tputs(\"-1\");\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (sum==a[n+1]||sum==a[n+2]){\r\n\t\t\tfor (int i=1;i<=n;i++){\r\n\t\t\t\tprintf(\"%lld \",a[i]);\r\n\t\t\t}\r\n\t\t} else{\r\n\t\t\tll ans=a[n+2]-sum;\r\n\t\t\tll cs=a[n+1]-ans;\r\n\t\t\tif (mp[cs]){\r\n\t\t\t\tfor (int i=1;i<=n;i++){\r\n\t\t\t\t\tif (a[i]==cs&&mp[cs]){\r\n\t\t\t\t\t\tmp[cs]=0;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintf(\"%lld \",a[i]);\r\n\t\t\t\t}\r\n\t\t\t\tprintf(\"%lld\",a[n+1]);\r\n\t\t\t} else printf(\"-1\");\r\n\t\t}\r\n\t\tputs(\"\");\r\n\t\tmp.clear();\r\n\t}\r\n\treturn 0;\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\nconst int N = 2e5+5;\r\n\r\nint n;\r\nll a[N];\r\nmap<ll,bool> mp;\r\n\r\nint main(){\r\n\tint t;cin>>t;\r\n\twhile (t--){\r\nmp.clear();\r\n\t\tll sum=0;\r\n\t\tscanf(\"%d\",&n);\r\n\t\tfor (int i=1;i<=n+2;i++){\r\n\t\t\tscanf(\"%lld\",&a[i]);\r\n\t\t}\r\n\t\tsort(a+1,a+n+3);\r\n\t\tfor (int i=1;i<=n;i++){\r\n\t\t\tsum+=a[i];\r\n\t\t\tmp[a[i]]=1;\r\n\t\t}\r\n\t\tif (sum>a[n+2]){\r\n\t\t\tputs(\"-1\");\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (sum==a[n+1]||sum==a[n+2]){\r\n\t\t\tfor (int i=1;i<=n;i++){\r\n\t\t\t\tprintf(\"%lld \",a[i]);\r\n\t\t\t}\r\n\t\t} else{\r\n\t\t\tll ans=a[n+2]-sum;\r\n\t\t\tll cs=a[n+1]-ans;\r\n\t\t\tif (mp[cs]){\r\n\t\t\t\tfor (int i=1;i<=n;i++){\r\n\t\t\t\t\tif (a[i]==cs&&mp[cs]){\r\n\t\t\t\t\t\tmp[cs]=0;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintf(\"%lld \",a[i]);\r\n\t\t\t\t}\r\n\t\t\t\tprintf(\"%lld\",a[n+1]);\r\n\t\t\t} else printf(\"-1\");\r\n\t\t}\r\n\t\tputs(\"\");\r\n\t\tmp.clear();\r\n\t}\r\n\treturn 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n = 0;\n    long long k = 0;\n    cin >> n >> k;\n    vector<long long> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    int right = n - 1, left = 0, top = a[n - 1], btm = a[0];\n    long long cost = 1;\n    while (left < right && k && btm == a[left] && top == a[right]) {\n        cost = min(k / (n - right), a[right] - a[right - 1]);\n        k -= cost * (n - right);\n        top = a[right] - cost;\n        --right;\n        cost = min(k / (left + 1), a[left + 1] - a[left]);\n        k -= cost * (left + 1);\n        btm = a[left] + cost;\n        ++left;\n    }\n    cout << top - btm << '\\n';\n}",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n = 0;\n    long long k = 0;\n    cin >> n >> k;\n    vector<long long> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    int right = n - 1, left = 0, top = a[n - 1], btm = a[0];\n    long long cost = 1;\n    while (left < right && k && btm == a[left] && top == a[right]) {\n        cost = min(k / (n - right), a[right] - a[right - 1]);\n        k -= cost * (n - right);\n        top = a[right] - cost;\n        --right;\n        cost = min(k / (left + 1), a[left + 1] - a[left]);\n        k -= cost * (left + 1);\n        btm = a[left] + cost;\n        ++left;\n    }\n    cout << max(top - btm, 0) << '\\n';\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void onStop() {\n    super.onStop();\n    android.util.Log.w(\"STATE 4\", \"ONSTOP\");\n    com.example.yunita.reflexsimulator.ReactionTimer.isDismiss = false;\n}",
        "fixed_code": "@java.lang.Override\npublic void onStop() {\n    super.onStop();\n    com.example.yunita.reflexsimulator.ReactionTimer.isDismiss = false;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(),(v).end()\n#define accelerate ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n\nusing namespace std;\n\nusing ll = long long;\nusing pairll = pair<ll,ll>;\n\nvoid solve(){\n    ll n;\n    cin >> n;\n    vector < ll > a(n), b(n);\n    for (ll &i: a) cin >> i;\n    for (ll &i: b) cin >> i;\n    map < ll, ll > mp;\n    for (ll i: b){\n        set < ll > s;\n        ll j = i;\n        while(j >= a.front()){\n            s.insert(j);\n            j >>= 1;\n        }\n        for (ll j: s) mp[j] ++;\n    }\n    for (ll i: a){\n        if (mp[i] == 0){\n            ll j = i, c = 0;\n            while(j%2 == 0){\n                j >>= 1;\n                if (mp[j] > 0){\n                    mp[j] --;\n                    c = 1;\n                    break;\n                }\n            }\n            if (c == 0){\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n        mp[i] --;\n    }\n    cout << \"YES\\n\";\n    return;\n}\n\nint main(){\n    accelerate;\n    int t = 1;\n    cin >> t;\n    while(t --) solve();\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(),(v).end()\n#define accelerate ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n\nusing namespace std;\n\nusing ll = int;\nusing pairll = pair<ll,ll>;\n\nconst ll DIM = 2e5+1;\nconst ll LG = 19;\n\nvoid solve(){\n    ll n;\n    cin >> n;\n    multiset < ll > a, b;\n    ll x;\n    for (ll i=0; i<n; i++){\n        cin >> x;\n        while(x%2 == 0) x >>= 1;\n        a.insert(x);\n    }\n    for (ll i=0; i<n; i++){\n        cin >> x;\n        while(x%2 == 0) x >>= 1;\n        if (a.count(x)){\n            a.erase(a.find(x));\n        }else{\n            b.insert(x);\n        }\n    }\n    \n    vector < ll > ar[2];\n    \n    for (ll i: b) ar[1].push_back(i);\n    map < ll,ll > mp;\n    for (ll i:a) mp[i] ++;\n    for (ll i=0; i<a.size(); i++){\n        while(ar[1][i]){\n            if (mp[ar[1][i]] > 0){\n                mp[ar[1][i]] --;\n                break;\n            }\n            ar[1][i] >>= 1;\n        }\n        if (0 == ar[1][i]){\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    \n    cout << \"YES\\n\";\n    return;\n}\n\nint main(){\n    accelerate;\n    int t = 1;\n    cin >> t;\n    while(t --) solve();\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "///   ***   ---   |||         In the name of ALLAH        |||   ---   ***   ///\n\n\n\n///   ***   ---   |||   Author : Muhammad Shahriar Alam   |||   ---   ***   ///\n///   ***   ---   |||     Student : CSE, CU, 3rd Year     |||   ---   ***   ///\n\n\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n\n///   ***   ---   |||   Template   |||   ---   ***   ///\n\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\ntypedef double dl;\n\n#define PB push_back\n#define F first\n#define S second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define sz(x) (int)x.size()\n#define mx_int_prime 999999937\n\nconst double PI = acos(-1);\nconst double eps = 1e-9;\nconst int inf = 2000000000;\nconst ll infLL = 9000000000000000000;\n#define MOD 1000000007\n///#define harmonic(n) 0.57721566490153286l+log(n)\n\n#define mem(a,b) memset(a, b, sizeof(a) )\n#define gcd(a,b) __gcd(a,b)\n#define sqr(a) ((a) * (a))\n\n#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define fraction() cout.unsetf(ios::floatfield); cout.precision(10); cout.setf(ios::fixed,ios::floatfield);\n#define file() freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);\n\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\n///bit\n\n\n///to_s\n\n\nint dx[] = {0, 0, +1, -1, +1, +1, -1, -1};\nint dy[] = {+1, -1, 0, 0, +1, -1, +1, -1};\n\n\n///mod\n\n///seive\n\n\n///debug\ntemplate < typename F, typename S > ostream& operator << ( ostream& os, const pair< F, S > & p ) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate < typename T >ostream &operator << ( ostream & os, const vector< T > &v ) {os << \"{\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << *it;}return os << \"}\";}\ntemplate < typename T >ostream &operator << ( ostream & os, const set< T > &v ) {os << \"[\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << *it;}return os << \"]\";}\ntemplate < typename T >ostream &operator << ( ostream & os, const multiset< T > &v ) {os << \"[\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << *it;}return os << \"]\";}\ntemplate < typename F, typename S >ostream &operator << ( ostream & os, const map< F, S > &v ) {os << \"[\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << it -> first << \" = \" << it -> second ;}return os << \"]\";}\n#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)\nvoid faltu () {            cerr << endl;}\ntemplate < typename T> void faltu( T a[], int n ) { for(int i = 0; i < n; ++i) cerr << a[i] << ' ';cerr << endl;}\ntemplate < typename T, typename ... hello>void faltu( T arg, const hello &... rest) {cerr << arg << ' ';faltu(rest...);}\n\n\n\n///   ***   ---   |||   Source Code   |||   ---   ***   ///\n\nconst int mx = 1.5e5+123;\nint k, n, m;\nll dp[312][mx];\nint A[mx], B[mx],  Max[mx], t[mx], a[mx];\n\nvoid slid1 ( )\n{\n    deque < int > q;\n    int i;\n    Max[0] = LLONG_MIN;\n\n    for ( i = 1; i <= k; i++ ) {\n        Max[i] = max ( Max[i-1], a[i] );\n        while ( !q.empty() && a[i] >= a[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back(i);\n    }\n\n    for ( ; i <= n; i++ ) {\n        Max[i-1] = a[q.front()];\n\n        while ( !q.empty() && q.front() <= i - k ) q.pop_front();\n\n        while ( !q.empty() && a[i] >= a[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back( i );\n\n    }\n\n    Max[i-1] = a[q.front()];\n\n}\n\n\nvoid slid2 ( )\n{\n    deque < int > q;\n    int i;\n    Max[n+1] = LLONG_MIN;\n\n    for ( i = n; i >= n-k+1; i-- ) {\n        Max[i] = max ( Max[i], max ( Max[i+1], a[i] ) );\n        while ( !q.empty() && a[i] >= a[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back(i);\n    }\n\n    for ( ; i >= 1; i-- ) {\n        Max[i+1] = max ( Max[i+1], a[q.front()] );\n\n        while ( !q.empty() && q.front() >= i + k ) q.pop_front();\n\n        while ( !q.empty() && a[i] >= a[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back( i );\n\n    }\n\n    Max[i+1] = max ( Max[i+1], a[q.front()] );\n\n}\n\n\nint main()\n{\n    optimize();\n\n    int d;\n    cin >> n >> m >> d;\n\n    for ( int i = 1; i <= m; i++ ) {\n        cin >> A[i] >> B[i] >> t[i];\n    }\n\n    for ( int i = 1; i <= m; i++ ) {\n        for ( int j = 1; j <= n; j++ ) dp[i][j] = LLONG_MIN;\n    }\n\n    ll ans = LLONG_MIN;\n    for ( int i = 1; i <= m; i++ ) {\n        ll s = d * ( t[i] - t[i-1] );\n        k = min ( s+1, (ll)n );\n        for ( int j = 1; j <= n; j++ ) a[j] = dp[i-1][j];\n\n        slid1();\n        slid2();\n\n        //for ( int j = 1; j <= n; j++ ) Max[j] = max ( Max1[j], Max2[j] );\n\n        for ( int j = 1; j <= n; j++ ) {\n            dp[i][j] = max ( dp[i][j], Max[j] + B[i] - abs ( A[i] - j ) );\n            if ( i == m ) ans = max ( ans, dp[i][j] );\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "fixed_code": "///   ***   ---   |||         In the name of ALLAH        |||   ---   ***   ///\n\n\n\n///   ***   ---   |||   Author : Muhammad Shahriar Alam   |||   ---   ***   ///\n///   ***   ---   |||     Student : CSE, CU, 3rd Year     |||   ---   ***   ///\n\n\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n\n///   ***   ---   |||   Template   |||   ---   ***   ///\n\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\ntypedef double dl;\n\n#define PB push_back\n#define F first\n#define S second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define sz(x) (int)x.size()\n#define mx_int_prime 999999937\n\nconst double PI = acos(-1);\nconst double eps = 1e-9;\nconst int inf = 2000000000;\nconst ll infLL = 9000000000000000000;\n#define MOD 1000000007\n///#define harmonic(n) 0.57721566490153286l+log(n)\n\n#define mem(a,b) memset(a, b, sizeof(a) )\n#define gcd(a,b) __gcd(a,b)\n#define sqr(a) ((a) * (a))\n\n#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define fraction() cout.unsetf(ios::floatfield); cout.precision(10); cout.setf(ios::fixed,ios::floatfield);\n#define file() freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);\n\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\n///bit\n\n\n///to_s\n\n\nint dx[] = {0, 0, +1, -1, +1, +1, -1, -1};\nint dy[] = {+1, -1, 0, 0, +1, -1, +1, -1};\n\n\n///mod\n\n///seive\n\n\n///debug\ntemplate < typename F, typename S > ostream& operator << ( ostream& os, const pair< F, S > & p ) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate < typename T >ostream &operator << ( ostream & os, const vector< T > &v ) {os << \"{\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << *it;}return os << \"}\";}\ntemplate < typename T >ostream &operator << ( ostream & os, const set< T > &v ) {os << \"[\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << *it;}return os << \"]\";}\ntemplate < typename T >ostream &operator << ( ostream & os, const multiset< T > &v ) {os << \"[\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << *it;}return os << \"]\";}\ntemplate < typename F, typename S >ostream &operator << ( ostream & os, const map< F, S > &v ) {os << \"[\";for(auto it = v.begin(); it != v.end(); ++it) {if( it != v.begin() ) os << \", \";os << it -> first << \" = \" << it -> second ;}return os << \"]\";}\n#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)\nvoid faltu () {            cerr << endl;}\ntemplate < typename T> void faltu( T a[], int n ) { for(int i = 0; i < n; ++i) cerr << a[i] << ' ';cerr << endl;}\ntemplate < typename T, typename ... hello>void faltu( T arg, const hello &... rest) {cerr << arg << ' ';faltu(rest...);}\n\n\n\n///   ***   ---   |||   Source Code   |||   ---   ***   ///\n\nconst int mx = 1.5e5+123;\nint k, n, m;\nll dp[mx], Max[mx];\n\nvoid slid1 ( )\n{\n    deque < int > q;\n    int i;\n    Max[0] = LLONG_MIN;\n\n    for ( i = 1; i <= k; i++ ) {\n        Max[i] = max ( Max[i-1], dp[i] );\n        while ( !q.empty() && dp[i] >= dp[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back(i);\n    }\n\n    for ( ; i <= n; i++ ) {\n        Max[i-1] = dp[q.front()];\n\n        while ( !q.empty() && q.front() <= i - k ) q.pop_front();\n\n        while ( !q.empty() && dp[i] >= dp[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back( i );\n\n    }\n\n    Max[i-1] = dp[q.front()];\n\n}\n\n\nvoid slid2 ( )\n{\n    deque < int > q;\n    int i;\n    Max[n+1] = LLONG_MIN;\n\n    for ( i = n; i >= n-k+1; i-- ) {\n        Max[i] = max ( Max[i], max ( Max[i+1], dp[i] ) );\n        while ( !q.empty() && dp[i] >= dp[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back(i);\n    }\n\n    for ( ; i >= 1; i-- ) {\n        Max[i+1] = max ( Max[i+1], dp[q.front()] );\n\n        while ( !q.empty() && q.front() >= i + k ) q.pop_front();\n\n        while ( !q.empty() && dp[i] >= dp[q.back()] ) {\n            q.pop_back();\n        }\n\n        q.push_back( i );\n\n    }\n\n    Max[i+1] = max ( Max[i+1], dp[q.front()] );\n\n}\n\n\nint main()\n{\n    optimize();\n\n    ll d;\n    cin >> n >> m >> d;\n\n    ll A, B, t;\n\n    int last = 0;\n    ll ans = LLONG_MIN;\n\n    for ( int i = 1; i <= m; i++ ) {\n        cin >> A >> B >> t;\n        ll s = d * ( t - last );\n        last = t;\n        k = min ( s+1, (ll)n );\n\n        slid1();\n        slid2();\n        for ( int j = 0; j <= n; j++ ) dp[j] = LLONG_MIN;\n        for ( int j = 1; j <= n; j++ ) {\n            dp[j] = max ( dp[j], (ll)(Max[j] + B - abs ( A - (ll)j )) );\n            if ( i == m ) ans = max ( ans, dp[j] );\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {\n    fr.pizzeria.model.Livreur livreur = new fr.pizzeria.model.Livreur();\n    livreur.setNom(request.getParameter(\"nom\"));\n    livreur.setPrenom(request.getParameter(\"prenom\"));\n    this.livreurService.update(request.getParameter(\"id\"), livreur);\n    response.sendRedirect(((request.getContextPath()) + \"/livreurs/list\"));\n}",
        "fixed_code": "protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {\n    fr.pizzeria.model.Livreur livreur = new fr.pizzeria.model.Livreur();\n    livreur.setNom(request.getParameter(\"nom\"));\n    livreur.setPrenom(request.getParameter(\"prenom\"));\n    this.livreurService.update(java.lang.Integer.parseInt(request.getParameter(\"id\")), livreur);\n    response.sendRedirect(((request.getContextPath()) + \"/livreurs/list\"));\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fl first\n#define fr second\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int N = 1e6 + 5;\nconst int INF = 1e9;\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        LL d, k;\n        scanf(\"%lld%lld\", &d, &k);\n        int ok = 0;\n        if (d == k)\n        {\n            puts(\"Ashish\");\n            continue;\n        }\n        for (int z = 1; ; z++)\n        {\n            if (k * z * k * z * 2 <= d * d && (k * (z + 1) * k * (z + 1) * 2) > d * d)\n            {\n                if (k * z * k * z + k * (z + 1) * k * (z + 1) <= d * d) ok = 1;\n                else ok = 0;\n                break;\n            }\n        }\n        if (ok) puts(\"Ashish\");\n        else puts(\"Utkarsh\");\n    }\n    return 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fl first\n#define fr second\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int N = 1e6 + 5;\nconst int INF = 1e9;\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        LL d, k;\n        scanf(\"%lld%lld\", &d, &k);\n        int ok = 0;\n        if (d == k)\n        {\n            puts(\"Ashish\");\n            continue;\n        }\n        for (int z = 0; ; z++)\n        {\n            if (k * z * k * z * 2 <= d * d && (k * (z + 1) * k * (z + 1) * 2) > d * d)\n            {\n                if (k * z * k * z + k * (z + 1) * k * (z + 1) <= d * d) ok = 1;\n                else ok = 0;\n                break;\n            }\n        }\n        if (ok) puts(\"Ashish\");\n        else puts(\"Utkarsh\");\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nlong long int cnt = 0;\nvector<vector<int> > adj(50001);\n\ndeque<int> dfs (int u, int p);\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n >> k;\n\tint u, v;\n\tfor (int i=0;i<n-1;i++) {\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tdfs(1, -1);\n\tcout << cnt << \"\\n\";\n\treturn 0;\n}\n\ndeque<int> operator+ (const deque<int> &a, const deque<int> &b) {\t\n\tdeque<int> c;\n\tint i = 0;\n\tfor (i=0; i<min(a.size(), b.size());i++) {\n\t\tc.push_back(a[i] + b[i]);\n\t}\n\twhile (i < a.size()) {\n\t\tc.push_back(a[i]);\n\t\ti++;\n\t}\n\twhile (i < b.size()) {\n\t\tc.push_back(b[i]);\n\t\ti++;\n\t}\n\treturn c;\n}\n\ndeque<int> operator- (const deque<int> &a, const deque<int> &b) {\t\n\tdeque<int> c;\n\tint i = 0;\n\tfor (i=0; i<min(a.size(), b.size());i++) {\n\t\tc.push_back(a[i] - b[i]);\n\t}\n\twhile (i < a.size()) {\n\t\tc.push_back(a[i]);\n\t\ti++;\n\t}\n\twhile (i < b.size()) {\n\t\tc.push_back(-b[i]);\n\t\ti++;\n\t}\n\treturn c;\n}\n\ndeque<int> dfs (int u, int p) {\n\tif (adj[u].size() == 1 && adj[u][0] == p) {\n\t\tdeque<int> x({1});\n\t\treturn x;\n\t} else {\n\t\tvector <deque<int> > chld;\n\t\tfor (auto x : adj[u]) {\n\t\t\tif (x != p) {\n\t\t\t\tdeque<int> temp = dfs(x, u);\n\t\t\t\ttemp.push_front(0);\n\t\t\t\tchld.push_back(temp);\n\t\t\t}\n\t\t}\n\t\tdeque<int> res = chld[0];\n\t\tfor (int i=1; i< chld.size();i++) {\n\t\t\tres = res + chld[i];\n\t\t}\n\t\tres[0] = 1;\n\t\tif (res.size() > k) {\n\t\t\tcnt += res[k];\n\t\t}\n\t\tdeque<int> res2(res);\n\t\tfor (int curr=0; curr<chld.size()-1; curr++) {\n\t\t    auto x = chld[curr];\n\t\t\tres = res - x;\n\t\t\tfor (int q = 1 ;q < min((int)x.size(), k); q++) {\n\t\t\t\tint p = k-q;\n\t\t\t\tif(p < res.size()) {\n\t\t\t\t    cnt += x[q] * res[p];\n\t\t\t\t}\n\t\t\t\t    \n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res2;\n\t}\n}\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nlong long int cnt = 0;\nvector<vector<int> > adj(50001);\n\ndeque<int> dfs (int u, int p);\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n >> k;\n\tint u, v;\n\tfor (int i=0;i<n-1;i++) {\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tdfs(1, -1);\n\tcout << cnt << \"\\n\";\n\treturn 0;\n}\n\ndeque<int> operator+ (const deque<int> &a, const deque<int> &b) {\t\n\tdeque<int> c;\n\tint i = 0;\n\tfor (i=0; i<min(a.size(), b.size());i++) {\n\t\tc.push_back(a[i] + b[i]);\n\t}\n\twhile (i < a.size()) {\n\t\tc.push_back(a[i]);\n\t\ti++;\n\t}\n\twhile (i < b.size()) {\n\t\tc.push_back(b[i]);\n\t\ti++;\n\t}\n\treturn c;\n}\n\ndeque<int> operator- (const deque<int> &a, const deque<int> &b) {\t\n\tdeque<int> c;\n\tint i = 0;\n\tfor (i=0; i<min(a.size(), b.size());i++) {\n\t\tc.push_back(a[i] - b[i]);\n\t}\n\twhile (i < a.size()) {\n\t\tc.push_back(a[i]);\n\t\ti++;\n\t}\n\twhile (i < b.size()) {\n\t\tc.push_back(-b[i]);\n\t\ti++;\n\t}\n\treturn c;\n}\n\ndeque<int> dfs (int u, int p) {\n\tif (adj[u].size() == 1 && adj[u][0] == p) {\n\t\tdeque<int> x({1});\n\t\treturn x;\n\t} else {\n\t\tvector <deque<int> > chld;\n\t\tfor (auto x : adj[u]) {\n\t\t\tif (x != p) {\n\t\t\t\tdeque<int> temp = dfs(x, u);\n\t\t\t\ttemp.push_front(0);\n\t\t\t\tchld.push_back(temp);\n\t\t\t}\n\t\t}\n\t\tdeque<int> res = chld[0];\n\t\tfor (int i=1; i< chld.size();i++) {\n\t\t\tres = res + chld[i];\n\t\t}\n\t\tres[0] = 1;\n\t\tif (res.size() > k) {\n\t\t\tcnt += res[k];\n\t\t}\n\t\tdeque<int> res2(res);\n\t\tfor (int curr=0; curr<chld.size()-1; curr++) {\n\t\t    auto x = chld[curr];\n\t\t\tres = res - x;\n\t\t\tfor (int q = 1 ;q < min((int)x.size(), k); q++) {\n\t\t\t\tint p = k-q;\n\t\t\t\tif(p < res.size()) {\n\t\t\t\t    cnt += x[q] * res[p];\n\t\t\t\t}\n\t\t\t\t    \n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(res2.size() > k+1)\n\t\t\tres2.pop_back();\n\t\treturn res2;\n\t}\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\nvector<string> sh[26];\nmap< pair<char,int> , int > co[26];\nmap< int,int> coo[26];\n\nint main()\n{\n\tcin >> s;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tstring cur=s.substr(i);\n\t\tcur+=s.substr(0,i);\n\t\tsh[cur[0]-'a'].push_back(cur);\n\t\tfor(int j=0;j<s.size();j++)\n\t\t\tco[cur[0]-'a'][{cur[j],j}]++;\n\t\t//cout << cur << endl;\n\t}\n\tdouble ans=0;\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tfor(int j=0;j<sh[i].size();j++)\n\t\t{\n\t\t\tfor(int k=0;k<s.size();k++)\n\t\t\t{\n\t\t\t\tif(co[i][{sh[i][j][k],k}]==1) coo[i][k]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tint maxi=0;\n\t\tfor(int j=0;j<s.size();j++) maxi=max(maxi,coo[i][j]);\n\t\tans+=maxi;\n\t}\n\tcout << fixed << setprecision(16) << ans/s.size() << endl;\n\treturn 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\nvector<string> sh[26];\nint co[26][26][5005];\nint coo[26][5005];\n\nint main()\n{\n\tcin >> s;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tstring cur=s.substr(i);\n\t\tcur+=s.substr(0,i);\n\t\tsh[cur[0]-'a'].push_back(cur);\n\t\tfor(int j=0;j<s.size();j++)\n\t\t\tco[cur[0]-'a'][cur[j]-'a'][j]++;\n\t\t//cout << cur << endl;\n\t}\n\tdouble ans=0;\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tfor(int j=0;j<sh[i].size();j++)\n\t\t{\n\t\t\tfor(int k=0;k<s.size();k++)\n\t\t\t{\n\t\t\t\tif(co[i][sh[i][j][k]-'a'][k]==1) coo[i][k]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tint maxi=0;\n\t\tfor(int j=0;j<s.size();j++) maxi=max(maxi,coo[i][j]);\n\t\tans+=maxi;\n\t}\n\tcout << fixed << setprecision(16) << ans/s.size() << endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e8+10;\n\ntemplate<typename T>inline void read(T &x){\n    x=0; \n\tint f=1;\n\tchar c=getchar();\n    while(c<'0'||c>'9'){\n        if(c=='-') f=-1;c=getchar();\n    }\n    while(c>='0'&&c<='9'){\n        x=(x<<1)+(x<<3)+(c^48);c=getchar();\n    }\n    x*=f;\n}\ntemplate <typename T> inline void print(T x)\n{\n    if(x<0){\n        x=~x+1;//x=-x;\n        putchar('-');\n    }\n    if (x>9) print(x/10);\n    putchar(x%10+'0');\n}\nll t,n,m,l,x,y,cnt=0,sum=0,ans=0;\nbool check(int n,int m){\n\twhile(n>=6){\n\t\tif(n%2==1) return false;\n\t\tif(n%2==0){\n\t\t\tif(n/2==m) return true;\n\t\t\tn/=2;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tread(t);\n\twhile(t--){\n\t\tread(n);read(m);\n\t\tif(check(n,m)) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t} \n\treturn 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e8+10;\n\ntemplate<typename T>inline void read(T &x){\n    x=0; \n\tint f=1;\n\tchar c=getchar();\n    while(c<'0'||c>'9'){\n        if(c=='-') f=-1;c=getchar();\n    }\n    while(c>='0'&&c<='9'){\n        x=(x<<1)+(x<<3)+(c^48);c=getchar();\n    }\n    x*=f;\n}\ntemplate <typename T> inline void print(T x)\n{\n    if(x<0){\n        x=~x+1;//x=-x;\n        putchar('-');\n    }\n    if (x>9) print(x/10);\n    putchar(x%10+'0');\n}\nll t,n,m,l,x,y,cnt=0,sum=0,ans=0;\nbool check(int n,int m){\n\twhile(n>=6){\n\t\tif(n%2==1) return false;\n\t\tif(n%2==0){\n\t\t\tif(n/2==m) return true;\n\t\t\tn/=2;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tread(t);\n\twhile(t--){\n\t\tread(n);read(m);\n\t\tif(n%m==0) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t} \n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define fast ios::sync_with_stdio(NULL);cin.tie(0);cout.tie(0);\n#define ALL(s) s.begin(),s.end()\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\nconst int inf = 9000000000000000;\nstring s[maxn];\nll c[maxn], dp[maxn][2];\nint main()\n{\n   ll n;\n   cin >> n;\n   for(int i=0;i<n;i++)cin >> c[i];\n   for(int i=0;i<n;i++)cin >> s[i];\n   dp[0][0] = 0;\n   dp[0][1] = c[0];\n   for(int i=1;i<n;i++){\n      string t1=s[i-1], t2=s[i];\n      reverse(ALL(t1)), reverse(ALL(t2));\n      dp[i][0] = inf, dp[i][1] = inf;\n      if(s[i-1]<=s[i])dp[i][0] = dp[i-1][0];\n      if(t1<=s[i])dp[i][0] = min(dp[i][0], dp[i-1][1]);\n      if(s[i-1]<=t2)dp[i][1] = dp[i-1][0] + c[i];\n      if(t1<=t2)dp[i][1] = min(dp[i][1],dp[i-1][1]+c[i]);\n   }\n   ll ans = min(dp[n-1][0],dp[n-1][1]);\n   if(ans == inf)cout << -1 << endl;\n   else cout << ans << endl;\n   return 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#define fast ios::sync_with_stdio(NULL);cin.tie(0);cout.tie(0);\n#define ALL(s) s.begin(),s.end()\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\nconst ll inf = 9000000000000000;\nstring s[maxn];\nll c[maxn], dp[maxn][2];\nint main()\n{\n   ll n;\n   cin >> n;\n   for(int i=0;i<n;i++)cin >> c[i];\n   for(int i=0;i<n;i++)cin >> s[i];\n   dp[0][0] = 0;\n   dp[0][1] = c[0];\n   for(int i=1;i<n;i++){\n      string t1=s[i-1], t2=s[i];\n      reverse(ALL(t1)), reverse(ALL(t2));\n      dp[i][0] = inf, dp[i][1] = inf;\n      if(s[i-1]<=s[i])dp[i][0] = dp[i-1][0];\n      if(t1<=s[i])dp[i][0] = min(dp[i][0], dp[i-1][1]);\n      if(s[i-1]<=t2)dp[i][1] = dp[i-1][0] + c[i];\n      if(t1<=t2)dp[i][1] = min(dp[i][1],dp[i-1][1]+c[i]);\n   }\n   ll ans = min(dp[n-1][0],dp[n-1][1]);\n   if(ans == inf)cout << -1 << endl;\n   else cout << ans << endl;\n   return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint main()\n{\n    int i, j;\n    scanf(\"%d\", &n);\n    int x[101], y[101], z[101], c[101];\n    for (i = 0; i < n - 1; ++i)scanf(\"%d\", &x[i]);\n    for (i = 0; i < n - 1; ++i)scanf(\"%d\", &y[i]);\n    for (i = 0 ; i < n; ++i)scanf(\"%d\", &z[i]);\n\n    for (i = 0; i < n; ++i)\n    {\n        c[i] = z[i];\n        for (j = 0; j < i; ++j)\n            c[i] += x[j];\n        for (j = i ; j < n - 1; ++j)\n            c[i] += y[j];\n\n            //printf(\"%d\\n\", c[i]);\n    }\n    sort(c, c+n);\n    printf(\"%d%d\", c[0]+c[1]);\n    return 0;\n}\n//done\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint main()\n{\n    int i, j;\n    scanf(\"%d\", &n);\n    int x[101], y[101], z[101], c[101];\n    for (i = 0; i < n - 1; ++i)scanf(\"%d\", &x[i]);\n    for (i = 0; i < n - 1; ++i)scanf(\"%d\", &y[i]);\n    for (i = 0 ; i < n; ++i)scanf(\"%d\", &z[i]);\n\n    for (i = 0; i < n; ++i)\n    {\n        c[i] = z[i];\n        for (j = 0; j < i; ++j)\n            c[i] += x[j];\n        for (j = i ; j < n - 1; ++j)\n            c[i] += y[j];\n    }\n    sort(c, c+n);\n    printf(\"%d\", c[0]+c[1]);\n    return 0;\n}\n//done\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.*;\n\npublic class Task {\n\n    public static void main(String[] args) throws Exception {\n\n        new Task().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Task() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            //in = new Reader(\"input.txt\");\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws Exception {\n\n        //int t = in.nextInt();\n        int t = 1;\n        while (t > 0) {\n            solve();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n\n    ArrayList<Integer>[] g;\n    int[][] buity = new int[5000][5000];\n    void solve() throws IOException {\n        int n = in.nextInt();\n        g = new ArrayList[n];\n        Pair[] edges = new Pair[n - 1];\n        for (int i = 0; i < n; i++)\n            g[i] = new ArrayList<>();\n        for (int i = 0; i < n - 1; i++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            g[x].add(y);\n            g[y].add(x);\n            buity[x][y] = 1;\n            buity[y][x] = 1;\n            edges[i] = new Pair(x, y);\n        }\n\n        boolean ok = true;\n        int m = in.nextInt();\n        ArrayList<Integer>[] paths = new ArrayList[m];\n        int[] gs = new int[m];\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            int z = in.nextInt();\n            gs[i] = z;\n            ArrayDeque<Integer> q = new ArrayDeque<>();\n            q.add(a);\n            int[] p = new int[n];\n            Arrays.fill(p, -1);\n            p[a] = a;\n            while (!q.isEmpty()) {\n                int v = q.poll();\n                for (int u : g[v]) {\n                    if (p[u] == -1) {\n                        p[u] = v;\n                        q.add(u);\n                    }\n                }\n            }\n            paths[i] = new ArrayList<>();\n            while (b != a) {\n                paths[i].add(b);\n                int prev = b;\n                b = p[b];\n                if (buity[prev][b] < z) {\n                    buity[prev][b] = z;\n                    buity[b][prev] = z;\n                }\n            }\n            paths[i].add(a);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int min = 1000000;\n            for (int j = 1; j < paths[i].size(); j++) {\n                int x = paths[i].get(j - 1);\n                int y = paths[i].get(j);\n                min = Math.min(min, buity[x][y]);\n            }\n            ok &= min == gs[i];\n        }\n\n        if (ok) {\n            for (int i = 0; i < n - 1; i++)\n                out.print(buity[edges[i].a][edges[i].b] + \" \");\n        } else {\n            out.println(-1);\n        }\n    }\n\n\n\n    class Pair implements Comparable<Pair> {\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a != p.a)\n                return Integer.compare(a, p.a);\n            else\n                return Integer.compare(-b, -p.b);\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n    static class InputReader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public InputReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n}",
        "fixed_code": "import java.io.*;\nimport java.util.*;\n\npublic class Task {\n\n    public static void main(String[] args) throws Exception {\n\n        new Task().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Task() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            //in = new Reader(\"input.txt\");\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws Exception {\n\n        //int t = in.nextInt();\n        int t = 1;\n        while (t > 0) {\n            solve();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n\n    ArrayList<Integer>[] g;\n    int[][] buity = new int[5000][5000];\n    void solve() throws IOException {\n        int n = in.nextInt();\n        g = new ArrayList[n];\n        Pair[] edges = new Pair[n - 1];\n        for (int i = 0; i < n; i++)\n            g[i] = new ArrayList<>();\n        for (int i = 0; i < n - 1; i++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            g[x].add(y);\n            g[y].add(x);\n            buity[x][y] = 1;\n            buity[y][x] = 1;\n            edges[i] = new Pair(x, y);\n        }\n\n        boolean ok = true;\n        int m = in.nextInt();\n        int[][] paths = new int[m][n + 1];\n        int[] gs = new int[m];\n        int[] sz = new int[m];\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            int z = in.nextInt();\n            gs[i] = z;\n            ArrayDeque<Integer> q = new ArrayDeque<>();\n            q.add(a);\n            int[] p = new int[n];\n            Arrays.fill(p, -1);\n            p[a] = a;\n            while (!q.isEmpty()) {\n                int v = q.poll();\n                for (int u : g[v]) {\n                    if (p[u] == -1) {\n                        p[u] = v;\n                        q.add(u);\n                    }\n                }\n            }\n            int pos = 1;\n            while (b != a) {\n                paths[i][pos] = b;\n                pos++;\n                int prev = b;\n                b = p[b];\n                if (buity[prev][b] < z) {\n                    buity[prev][b] = z;\n                    buity[b][prev] = z;\n                }\n            }\n            paths[i][pos] = a;\n            pos++;\n            paths[i][0] = pos;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int min = 1000000;\n            int len = paths[i][0];\n            for (int j = 2; j < len; j++) {\n                int x = paths[i][j - 1];\n                int y = paths[i][j];\n                min = Math.min(min, buity[x][y]);\n            }\n            ok &= min == gs[i];\n        }\n\n        if (ok) {\n            for (int i = 0; i < n - 1; i++)\n                out.print(buity[edges[i].a][edges[i].b] + \" \");\n        } else {\n            out.println(-1);\n        }\n    }\n\n\n\n    class Pair implements Comparable<Pair> {\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a != p.a)\n                return Integer.compare(a, p.a);\n            else\n                return Integer.compare(-b, -p.b);\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n    static class InputReader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public InputReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "protected int getRelatedIndex(java.util.List<it.unitn.disi.smatch.data.trees.INode> source, java.util.List<it.unitn.disi.smatch.data.trees.INode> target, char relation, java.util.List<java.lang.Integer> sourceIndex, java.util.List<java.lang.Integer> targetIndex, it.unitn.disi.smatch.data.mappings.IContextMapping<it.unitn.disi.smatch.data.trees.INode> mapping, it.unitn.disi.smatch.data.mappings.IContextMapping<it.unitn.disi.smatch.data.trees.INode> spsmMapping) {\n    int srcIndex = sourceIndex.get(((source.get(0).ancestorCount()) - 1));\n    int tgtIndex = targetIndex.get(((target.get(0).ancestorCount()) - 1));\n    int returnIndex = -1;\n    it.unitn.disi.smatch.data.trees.INode sourceNode = source.get(srcIndex);\n    for (int i = tgtIndex + 1; i < (target.size()); i++) {\n        it.unitn.disi.smatch.data.trees.INode targetNode = target.get(i);\n        if (isRelated(sourceNode, targetNode, relation, mapping)) {\n            setStrongestMapping(sourceNode, targetNode, mapping, spsmMapping);\n            return i;\n        }\n    }\n    computeStrongestMappingForSource(source.get(srcIndex), mapping, spsmMapping);\n    return returnIndex;\n}",
        "fixed_code": "protected int getRelatedIndex(java.util.List<it.unitn.disi.smatch.data.trees.INode> source, java.util.List<it.unitn.disi.smatch.data.trees.INode> target, java.util.List<it.unitn.disi.smatch.data.trees.INode> rscList, java.util.List<it.unitn.disi.smatch.data.trees.INode> rtcList, char relation, java.util.List<java.lang.Integer> sourceIndex, java.util.List<java.lang.Integer> targetIndex, it.unitn.disi.smatch.data.mappings.IContextMapping<it.unitn.disi.smatch.data.trees.INode> mapping, it.unitn.disi.smatch.data.mappings.IContextMapping<it.unitn.disi.smatch.data.trees.INode> unorderedMapping, it.unitn.disi.smatch.data.mappings.IContextMapping<it.unitn.disi.smatch.data.trees.INode> spsmMapping, it.unitn.disi.smatch.data.mappings.IContextMapping<it.unitn.disi.smatch.data.trees.INode> unorderedSpsmMapping) {\n    int srcIndex = sourceIndex.get(((source.get(0).ancestorCount()) - 1));\n    int tgtIndex = targetIndex.get(((target.get(0).ancestorCount()) - 1));\n    int returnIndex = -1;\n    it.unitn.disi.smatch.data.trees.INode sourceNode = source.get(srcIndex);\n    it.unitn.disi.smatch.data.trees.INode rsNode = rscList.get(srcIndex);\n    for (int i = tgtIndex + 1; i < (target.size()); i++) {\n        it.unitn.disi.smatch.data.trees.INode targetNode = target.get(i);\n        it.unitn.disi.smatch.data.trees.INode rtNode = rtcList.get(i);\n        if (isRelated(sourceNode, targetNode, relation, mapping)) {\n            setStrongestMapping(sourceNode, targetNode, mapping, spsmMapping);\n            setStrongestMapping(rsNode, rtNode, unorderedMapping, unorderedSpsmMapping);\n            return i;\n        }\n    }\n    computeStrongestMappingForSource(source.get(srcIndex), mapping, spsmMapping);\n    computeStrongestMappingForSource(rscList.get(srcIndex), unorderedMapping, unorderedSpsmMapping);\n    return returnIndex;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rep2(r, aa, bb) for (int r = (aa)-1; r >= (bb); r--)\n#define be(x) (x.begin(), x.end())\n#define pb(t) push_back(t)\n#define ll long long\n#define mp(a, b) make_pair(a, b)\n#define f first\n#define s second\nconst int MAX=1000*100+5;\nint n, a, maxi=1, x;\nvector<vector<int>>A;\nvector<int>d, type, dp;\nint rec(int v){\n\tif(d[v]>1)return 0;\n\tif(dp[v]>-1)return dp[v];\n\tint ans=0;\n\tfor(int i:A[v]){\n\t\tans=max(ans, rec(i)+1);\n\t}\n\tdp[v]=ans;\n\treturn ans;\n}\nvoid print(int v){\n\tif(d[v]>1||(type[v]==1&&v!=x))return;\n\tif(A[v].size())\n\tprint(A[v][0]);\n\tif(v>0)\n\tcout<<v<<\" \";\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\tcin>>n;\n\tA.resize(n+1);\n\ttype.resize(n+1);\n\tdp.assign(n+1, -1);\n\trep(i,1,n+1)cin>>type[i];\n\td.assign(n+1, 0);\n\trep(i,1, n+1){\n\t\tcin>>a;\n\t\td[a]++;\n\t\tA[i].pb(a);\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tif(type[i]==1&&d[i]<2){\n\t\t\tmaxi=max(rec(i), maxi);\n\t\t}\n\t}\n\tcout<<maxi<<\"\\n\";\n\tfor(int i=1; i<=n; i++){\n\t\tif(dp[i]==maxi&&type[i]==1){\n\t\t\tx=i;\n\t\t\tif(n==100000){\n\t\t\t\tcout<<x<<\" \"<<maxi<<\" \\n\";\n\t\t\t}\n\t\t\tprint(i);\n\t\t}\n\t}\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rep2(r, aa, bb) for (int r = (aa)-1; r >= (bb); r--)\n#define be(x) (x.begin(), x.end())\n#define pb(t) push_back(t)\n#define ll long long\n#define mp(a, b) make_pair(a, b)\n#define f first\n#define s second\nconst int MAX=1000*100+5;\nint n, a, maxi=1, x;\nvector<vector<int>>A;\nvector<int>d, type, dp;\nint rec(int v){\n\tif(d[v]>1)return 0;\n\tif(dp[v]>-1)return dp[v];\n\tint ans=0;\n\tfor(int i:A[v]){\n\t\tans=max(ans, rec(i)+1);\n\t}\n\tdp[v]=ans;\n\treturn ans;\n}\nvoid print(int v){\n\tif(d[v]>1||(type[v]==1&&v!=x))return;\n\tif(A[v].size())\n\tprint(A[v][0]);\n\tif(v>0)\n\tcout<<v<<\" \";\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\tcin>>n;\n\tA.resize(n+1);\n\ttype.resize(n+1);\n\tdp.assign(n+1, -1);\n\trep(i,1,n+1)cin>>type[i];\n\td.assign(n+1, 0);\n\trep(i,1, n+1){\n\t\tcin>>a;\n\t\td[a]++;\n\t\tA[i].pb(a);\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tif(type[i]==1&&d[i]<2){\n\t\t\tmaxi=max(rec(i), maxi);\n\t\t}\n\t}\n\tcout<<maxi<<\"\\n\";\n\tfor(int i=1; i<=n; i++){\n\t\tif(dp[i]==maxi&&type[i]==1){\n\t\t\tx=i;\n\t\t\t// if(n==100000){\n\t\t\t\t// cout<<x<<\" \"<<maxi<<\" \\n\";\n\t\t\t// }\n\t\t\tprint(i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nconst int MAXN = 3e5+5;\r\nconst int MAXM = 1e6+5;\r\nstruct edge{\r\n\tint nxt,to;\r\n\tedge(){}\r\n\tedge(int _nxt,int _to){\r\n\t\tnxt = _nxt,to = _to;\r\n\t}\r\n}e[MAXM];\r\nint cnt,head[MAXN],sz[MAXN],g[MAXN],f[MAXN],a[MAXN];\r\nvoid add_edge(int from,int to){\r\n\te[++cnt] = edge(head[from],to);\r\n\thead[from] = cnt;\r\n}\r\nvoid dfs1(int now,int fa){\r\n\tif(a[now])\tf[now] = true;\r\n\tsz[now] = a[now];   //����� sz ��ָ�ĺڵ������\r\n\tfor(int i = head[now];i ;i = e[i].nxt){\r\n\t\tint to = e[i].to;\r\n\t\tif(to == fa)\tcontinue;\r\n\t\tdfs1(to,now);\r\n\t\tsz[now] += sz[to];\r\n\t\tif(a[to])\tf[now] = true;\r\n\t\tif(f[to] && sz[to] >= 2)\tf[now] = true;\r\n\t} \r\n}\r\nvoid dfs2(int now,int fa){\r\n\tif(a[now])\tg[now] = true;  //���������Ǻ���Ȼ�� \r\n\tif(f[now])\tg[now] = true;  //��� 1 Ϊ������ \r\n\tfor(int i = head[now]; i; i = e[i].nxt){\r\n\t\tint to = e[i].to;\r\n\t\tif(to == fa)\tcontinue;\r\n\t\tif(sz[1] - sz[to] >= 2 && g[now])\t\r\n\t\t\tg[to] = true;\r\n\t\tdfs2(to,now);\r\n\t}\r\n}\r\nint main(){\r\n//\tfreopen(\"in.txt\",\"r\",stdin);\r\n//\tfreopen(\"out.txt\",\"w\",stdout);\r\n\tint n;\r\n\tcin>>n;\r\n\tfor(int i=1; i<=n; i++){\r\n\t\tcin>>a[i];\r\n\t} \r\n\tfor(int i=1; i<n; i++){\r\n\t\tint from,to;\r\n\t\tcin>>from>>to;\r\n\t\tadd_edge(from,to);\r\n\t\tadd_edge(to,from); \r\n\t}\r\n\tdfs1(1,0);  //��һ�� dp \r\n\tdfs2(1,0);  //���� \r\n\tfor(int i=1; i<=n; i++){\r\n\t\tprintf(\"%d \",f[i] || g[i]);\r\n\t}\r\n\treturn 0;\r\n} \r\n",
        "fixed_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\nconst int MAXN = 3e5+5;\r\nconst int MAXM = 1e6+5;\r\nstruct edge{\r\n\tint nxt,to;\r\n\tedge(){}\r\n\tedge(int _nxt,int _to){\r\n\t\tnxt = _nxt,to = _to;\r\n\t}\r\n}e[MAXM];\r\nint cnt,head[MAXN],sz[MAXN],g[MAXN],f[MAXN],a[MAXN];\r\nvoid add_edge(int from,int to){\r\n\te[++cnt] = edge(head[from],to);\r\n\thead[from] = cnt;\r\n}\r\nvoid dfs1(int now,int fa){\r\n\tif(a[now])\tf[now] = true;\r\n\tsz[now] = a[now];   //����� sz ��ָ�ĺڵ������\r\n\tfor(int i = head[now];i ;i = e[i].nxt){\r\n\t\tint to = e[i].to;\r\n\t\tif(to == fa)\tcontinue;\r\n\t\tdfs1(to,now);\r\n\t\tsz[now] += sz[to];\r\n\t\tif(a[to])\tf[now] = true;\r\n\t\tif(f[to] && sz[to] >= 2)\tf[now] = true;\r\n\t} \r\n}\r\nvoid dfs2(int now,int fa){\r\n\tif(a[fa])\tg[now] = true;  //���������Ǻ���Ȼ�� \r\n\tif(f[now])\tg[now] = true;  //��� 1 Ϊ������ \r\n\tfor(int i = head[now]; i; i = e[i].nxt){\r\n\t\tint to = e[i].to;\r\n\t\tif(to == fa)\tcontinue;\r\n\t\tif(sz[1] - sz[to] >= 2 && g[now])\t\r\n\t\t\tg[to] = true;\r\n\t\tdfs2(to,now);\r\n\t}\r\n}\r\nint main(){\r\n//\tfreopen(\"in.txt\",\"r\",stdin);\r\n//\tfreopen(\"out.txt\",\"w\",stdout);\r\n\tint n;\r\n\tcin>>n;\r\n\tfor(int i=1; i<=n; i++){\r\n\t\tcin>>a[i];\r\n\t} \r\n\tfor(int i=1; i<n; i++){\r\n\t\tint from,to;\r\n\t\tcin>>from>>to;\r\n\t\tadd_edge(from,to);\r\n\t\tadd_edge(to,from); \r\n\t}\r\n\tdfs1(1,0);  //��һ�� dp \r\n\tdfs2(1,0);  //���� \r\n\tfor(int i=1; i<=n; i++){\r\n\t\tprintf(\"%d \",f[i] || g[i]);\r\n\t}\r\n\treturn 0;\r\n} \r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.*;\r\nimport java.util.*;\r\nimport java.math.*;\r\npublic class Solution{\r\n\tpublic static void main(String[] args) {\r\n\t      TaskA solver = new TaskA();\r\n//\t      initFac(2*100001);\r\n\t      int t = in.nextInt();\r\n\t      for (int i = 1; i <= t ; i++) {\r\n\t          solver.solve(i, in, out);\r\n\t      }     \r\n\t      \r\n//\t      solver.solve(1, in, out);  \r\n\t      \r\n\t      out.flush();\r\n\t    out.close();\r\n\t  }\r\n\tstatic ArrayList<Integer>[] graph ;\r\n\t static class TaskA {\r\n\t      public void solve(int testNumber, InputReader in, PrintWriter out) {\r\n\t    \tlong ans1=0;long ans2=0;\r\n\t    \tint n= in.nextInt();\r\n\t    \tint []arr=input(n);\r\n\t    \tfor(int i=1;i<n-1;i++) {\r\n\t    \t\tif(arr[i]%2==1) {\r\n\t    \t\t\tans1++;\r\n\t    \t\t}\r\n\t    \t\tif(arr[i]%2==0) {\r\n\t    \t\t\tans2++;\r\n\t    \t\t}\r\n\t    \t}\r\n\t    \tprintln(Math .min(ans2, ans1));\r\n\t      }\r\n\t }\r\n\tstatic boolean possible(int len,char[]c,int k) {\r\n\t\tint ctW=0;\r\n\t\tfor(int i=0;i<k;i++) {\r\n\t\t\tif(c[i]=='W') {\r\n\t\t\t\tctW++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(ctW<=len) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tint i=0;int j=k-1;\r\n\t\twhile(j+1<c.length) {\r\n\t\t\tj++;if(c[j]=='W') {ctW++;}\r\n\t\t\tif(c[i]=='W') {ctW--;}i++;\r\n\t\t\tif(ctW<=len) {return true;}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t static void EularianDfs(int v,int[]cur,int k,ArrayList<Integer>path) {\r\n\t\t  while (cur[v] < k) {\r\n\t\t    int u = cur[v]++;\r\n\t\t    EularianDfs(u,cur,k,path);\r\n\t\t    path.add(u);\r\n\t\t  }\r\n\t}\r\n\t static long modExp(long x,long y,long mod) {\r\n\t\t \tlong res = 1;\r\n\t        while (y > 0) {\r\n\t            if ((y & 1) != 0)\r\n\t                res = (res * x)%mod;\r\n\t            y = (y >> 1)%mod; \r\n\t            x = (x * x)%mod; \r\n\t        }\r\n\t        return res % mod;\r\n\t }\r\n\t static long[] fac;\r\n\t static long mod = 1000000000+7;\r\n\t static void initFac(long n) {\r\n\t        fac = new long[(int)n + 1];\r\n\t        fac[0] = 1;\r\n\t        for (int i = 1; i <= n; i++) {\r\n\t            fac[i] = (fac[i - 1]  * i) % mod;\r\n\t        }\r\n\t    }\r\n\t static int count(char []arr,char x) {\r\n\t\t int c=0;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t if(arr[i]==x) {\r\n\t\t\t\t c++;\r\n\t\t\t }\r\n\t\t }\r\n\t\t return c;\r\n\t }\r\n\t static int count(int []arr,int x) {\r\n\t\t int c=0;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t if(arr[i]==x) {\r\n\t\t\t\t c++;\r\n\t\t\t }\r\n\t\t }\r\n\t\t return c;\r\n\t }\r\n\t  static boolean[]seive(int n){\r\n\t\t\tboolean[]b=new boolean[n+1];\r\n\t\t\t for (int i = 2; i <= n; i++)\r\n\t\t            b[i] = true;\r\n\t\t\t \r\n\t\t\tfor(int i=2;i*i<=n;i++) {\r\n\t\t\t\tif(b[i]) {\r\n\t\t\t\t\tfor(int j=i*i;j<=n;j+=i) {\r\n\t\t\t\t\t\tb[j]=false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn b;\r\n\t\t}\r\n\t static int[] query(int l,int r) {\r\n\t\t\tSystem.out.println(\"? \"+l+\" \"+r);\r\n\t\t\tSystem.out.print (\"\\n\");System.out.flush();\r\n\t\t\tint[]arr=new int[r-l+1];\r\n\t\t\tfor(int i=0;i<r-l+1;i++) {\r\n\t\t\t\tarr[i]=in.nextInt();\r\n\t\t\t}\r\n\t\t\treturn arr;\r\n\t\t}\r\n\t \r\n\t static long[]presum(long[]arr){\r\n\t\t int n= arr.length;\r\n\t\t long[]pre=new long[n];\r\n\t\t for(int i=0;i<n;i++) {\r\n\t\t\t if(i>0) {\r\n\t\t\t\t pre[i]=pre[i-1];\r\n\t\t\t }\r\n\t\t\t pre[i]+=arr[i];\r\n\t\t }\r\n\t\t return pre;\r\n\t }\r\n\t static int max(int[]arr) {\r\n\t\t int max=Integer.MIN_VALUE;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t max=Math.max(max, arr[i]);\r\n\t\t }\r\n\t\t return max;\r\n\t }\r\n\t static int min(int[]arr) {\r\n\t\t int min=Integer.MAX_VALUE;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t min=Math.min(min, arr[i]);\r\n\t\t }\r\n\t\t return min;\r\n\t }\r\n\t static int ceil(int a,int b) {\r\n\t\t int ans=a/b;if(a%b!=0) {\r\n\t\t\t ans++;\r\n\t\t }\r\n\t\t return ans;\r\n\t }\r\n\t\r\n\t\r\n\tstatic long sum(int[]arr) {\r\n\t\tlong s=0;\r\n\t\tfor(int x:arr) {\r\n\t\t\ts+=x;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\tstatic long sum(long[]arr) {\r\n\t\tlong s=0;\r\n\t\tfor(long x:arr) {\r\n\t\t\ts+=x;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\t static int gcd(int a, int b)\r\n\t    {\r\n\t      if (b == 0)\r\n\t        return a;\r\n\t      return gcd(b, a % b);\r\n\t    }\r\n\t static void sort(int[] a) {\r\n\t        ArrayList<Integer> q = new ArrayList<>();\r\n\t        for (int i : a) q.add(i);\r\n\t        Collections.sort(q);\r\n\t        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\r\n\t    }\r\n\t static void sort(long[] a) {\r\n\t        ArrayList<Long> q = new ArrayList<>();\r\n\t        for (long i : a) q.add(i);\r\n\t        Collections.sort(q);\r\n\t        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\r\n\t    }\r\n\t static void println(int[][]arr) {\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t for(int j=0;j<arr[0].length;j++) {\r\n\t\t\t\t print(arr[i][j]+\" \");\r\n\t\t\t }\r\n\t\t\t print(\"\\n\");\r\n\t\t }\r\n\t }\r\n\t static void println(long[][]arr) {\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t for(int j=0;j<arr[0].length;j++) {\r\n\t\t\t\t print(arr[i][j]+\" \");\r\n\t\t\t }\r\n\t\t\t print(\"\\n\");\r\n\t\t }\r\n\t }\r\n\t static void println(int[]arr){\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t print(arr[i]+\" \");\r\n\t\t }\r\n\t\t print(\"\\n\");\r\n\t }\r\n\t static void println(long[]arr){\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t print(arr[i]+\" \");\r\n\t\t }\r\n\t\t print(\"\\n\");\r\n\t }\r\n\t  static long[]input(long n){\r\n\t\t  long[]arr=new long[(int)n];\r\n\t\t  for(int i=0;i<n;i++) {\r\n\t\t\t  arr[i]=in.nextInt();\r\n\t\t  }\r\n\t\t  return arr;\r\n\t  }\r\n\t  static int[]input(int n){\r\n\t\t  int[]arr=new int[n];\r\n\t\t  for(int i=0;i<n;i++) {\r\n\t\t\t  arr[i]=in.nextInt();\r\n\t\t  }\r\n\t\t  return arr;\r\n\t  }\r\n\t  static String Char(int x) {\r\n\t\t\t return Character.toString((char)x);\r\n\t\t }\r\n\t  static int[]input(){\r\n\t\t  int n= in.nextInt();\r\n\t\t  int[]arr=new int[(int)n];\r\n\t\t  for(int i=0;i<n;i++) {\r\n\t\t\t  arr[i]=in.nextInt();\r\n\t\t  }\r\n\t\t  return arr;\r\n\t  }\r\n\t////////////////////////////////////////////////////////\r\n\t  static class Pair implements Comparable<Pair>{\r\n\t\t    int  first;\r\n\t\t    int second;int third;\r\n\t\t    Pair(int x, int y,int z)\r\n\t\t    {\r\n\t\t        this.first = x;\r\n\t\t        this.second = y;\r\n\t\t        this.third=z;\r\n\t\t    }\r\n\t\t    public int compareTo(Pair p) {\r\n\t\t    \treturn Integer.compare(second, p.second);\r\n\t\t    }\r\n\t\t}\r\n\t  static void sortS(Pair arr[])\r\n\t    {\r\n\t        Arrays.sort(arr, new Comparator<Pair>() {\r\n\t            @Override public int compare(Pair p1, Pair p2)\r\n\t            {\r\n\t            \tif(p1.second==p2.second) {return p1.first-p2.first;}\r\n\t                return (p1.second - p2.second); \r\n\t                                   \r\n\t            }\r\n\t        });\r\n\t    }\r\n\t  static void sortF(Pair arr[])\r\n\t    {\r\n\t        Arrays.sort(arr, new Comparator<Pair>() {\r\n\t            @Override public int compare(Pair p1, Pair p2)\r\n\t            {\r\n\t            \tif(p1.first==p2.first) {return p1.second-p2.second;}\r\n\t                return (p1.first - p2.first); \r\n\t            }\r\n\t        });\r\n\t    }\r\n\t  \r\n\t  \r\n\t \r\n    /////////////////////////////////////////////////////////////\r\n\tstatic InputStream inputStream = System.in;\r\n    static OutputStream outputStream = System.out;\r\n    static InputReader in = new InputReader(inputStream);\r\n    static PrintWriter out = new PrintWriter(outputStream);\r\n    static void println(long c) {\r\n    \tout.println(c);\r\n    }\r\n    static void print(long c) {\r\n    \tout.print(c);\r\n    }\r\n    static void print(int c) {\r\n\t\t out.print(c);\r\n\t }\r\n\t static void println(int x) {\r\n\t\t out.println(x);\r\n\t }\r\n\t static void print(String s) {\r\n\t\t out.print(s);\r\n\t }\r\n\t static void println(String s) {\r\n\t\t out.println(s);\r\n\t }\r\n\t static void println(boolean b) {\r\n\t\t out.println(b);\r\n\t }\r\n\r\n  static class InputReader {\r\n      public BufferedReader reader;\r\n      public StringTokenizer tokenizer;\r\n\r\n      public InputReader(InputStream stream) {\r\n          reader = new BufferedReader(new InputStreamReader(stream), 32768);\r\n          tokenizer = null;\r\n      }\r\n\r\n      public String next() {\r\n          while (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n              try {\r\n                  tokenizer = new StringTokenizer(reader.readLine());\r\n              } catch (IOException e) {\r\n                  throw new RuntimeException(e);\r\n              }\r\n          }\r\n          return tokenizer.nextToken();\r\n      }\r\n\r\n      public int nextInt() {\r\n          return Integer.parseInt(next());\r\n      }\r\n      public long nextLong() {\r\n    \t  return Long.parseLong(next());\r\n      }\r\n  }\r\n}",
        "fixed_code": "import java.io.*;\r\nimport java.util.*;\r\nimport java.math.*;\r\npublic class Solution{\r\n\tpublic static void main(String[] args) {\r\n\t      TaskA solver = new TaskA();\r\n//\t      initFac(2*100001);\r\n\t      int t = in.nextInt();\r\n\t      for (int i = 1; i <= t ; i++) {\r\n\t          solver.solve(i, in, out);\r\n\t      }     \r\n\t      \r\n//\t      solver.solve(1, in, out);  \r\n\t      \r\n\t      out.flush();\r\n\t    out.close();\r\n\t  }\r\n\tstatic ArrayList<Integer>[] graph ;\r\n\t static class TaskA {\r\n\t      public void solve(int testNumber, InputReader in, PrintWriter out) {\r\n\t    \tlong ans1=0;long ans2=0;\r\n\t    \tint n= in.nextInt();\r\n\t    \tint []arr=input(n);\r\n\t    \tfor(int i=0;i<n;i++) {\r\n\t    \t\tif(arr[i]%2==1) {\r\n\t    \t\t\tans1++;\r\n\t    \t\t}\r\n\t    \t\tif(arr[i]%2==0) {\r\n\t    \t\t\tans2++;\r\n\t    \t\t}\r\n\t    \t}\r\n\t    \tprintln(Math .min(ans2, ans1));\r\n\t      }\r\n\t }\r\n\tstatic boolean possible(int len,char[]c,int k) {\r\n\t\tint ctW=0;\r\n\t\tfor(int i=0;i<k;i++) {\r\n\t\t\tif(c[i]=='W') {\r\n\t\t\t\tctW++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(ctW<=len) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tint i=0;int j=k-1;\r\n\t\twhile(j+1<c.length) {\r\n\t\t\tj++;if(c[j]=='W') {ctW++;}\r\n\t\t\tif(c[i]=='W') {ctW--;}i++;\r\n\t\t\tif(ctW<=len) {return true;}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t static void EularianDfs(int v,int[]cur,int k,ArrayList<Integer>path) {\r\n\t\t  while (cur[v] < k) {\r\n\t\t    int u = cur[v]++;\r\n\t\t    EularianDfs(u,cur,k,path);\r\n\t\t    path.add(u);\r\n\t\t  }\r\n\t}\r\n\t static long modExp(long x,long y,long mod) {\r\n\t\t \tlong res = 1;\r\n\t        while (y > 0) {\r\n\t            if ((y & 1) != 0)\r\n\t                res = (res * x)%mod;\r\n\t            y = (y >> 1)%mod; \r\n\t            x = (x * x)%mod; \r\n\t        }\r\n\t        return res % mod;\r\n\t }\r\n\t static long[] fac;\r\n\t static long mod = 1000000000+7;\r\n\t static void initFac(long n) {\r\n\t        fac = new long[(int)n + 1];\r\n\t        fac[0] = 1;\r\n\t        for (int i = 1; i <= n; i++) {\r\n\t            fac[i] = (fac[i - 1]  * i) % mod;\r\n\t        }\r\n\t    }\r\n\t static int count(char []arr,char x) {\r\n\t\t int c=0;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t if(arr[i]==x) {\r\n\t\t\t\t c++;\r\n\t\t\t }\r\n\t\t }\r\n\t\t return c;\r\n\t }\r\n\t static int count(int []arr,int x) {\r\n\t\t int c=0;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t if(arr[i]==x) {\r\n\t\t\t\t c++;\r\n\t\t\t }\r\n\t\t }\r\n\t\t return c;\r\n\t }\r\n\t  static boolean[]seive(int n){\r\n\t\t\tboolean[]b=new boolean[n+1];\r\n\t\t\t for (int i = 2; i <= n; i++)\r\n\t\t            b[i] = true;\r\n\t\t\t \r\n\t\t\tfor(int i=2;i*i<=n;i++) {\r\n\t\t\t\tif(b[i]) {\r\n\t\t\t\t\tfor(int j=i*i;j<=n;j+=i) {\r\n\t\t\t\t\t\tb[j]=false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn b;\r\n\t\t}\r\n\t static int[] query(int l,int r) {\r\n\t\t\tSystem.out.println(\"? \"+l+\" \"+r);\r\n\t\t\tSystem.out.print (\"\\n\");System.out.flush();\r\n\t\t\tint[]arr=new int[r-l+1];\r\n\t\t\tfor(int i=0;i<r-l+1;i++) {\r\n\t\t\t\tarr[i]=in.nextInt();\r\n\t\t\t}\r\n\t\t\treturn arr;\r\n\t\t}\r\n\t \r\n\t static long[]presum(long[]arr){\r\n\t\t int n= arr.length;\r\n\t\t long[]pre=new long[n];\r\n\t\t for(int i=0;i<n;i++) {\r\n\t\t\t if(i>0) {\r\n\t\t\t\t pre[i]=pre[i-1];\r\n\t\t\t }\r\n\t\t\t pre[i]+=arr[i];\r\n\t\t }\r\n\t\t return pre;\r\n\t }\r\n\t static int max(int[]arr) {\r\n\t\t int max=Integer.MIN_VALUE;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t max=Math.max(max, arr[i]);\r\n\t\t }\r\n\t\t return max;\r\n\t }\r\n\t static int min(int[]arr) {\r\n\t\t int min=Integer.MAX_VALUE;\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t min=Math.min(min, arr[i]);\r\n\t\t }\r\n\t\t return min;\r\n\t }\r\n\t static int ceil(int a,int b) {\r\n\t\t int ans=a/b;if(a%b!=0) {\r\n\t\t\t ans++;\r\n\t\t }\r\n\t\t return ans;\r\n\t }\r\n\t\r\n\t\r\n\tstatic long sum(int[]arr) {\r\n\t\tlong s=0;\r\n\t\tfor(int x:arr) {\r\n\t\t\ts+=x;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\tstatic long sum(long[]arr) {\r\n\t\tlong s=0;\r\n\t\tfor(long x:arr) {\r\n\t\t\ts+=x;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\t static int gcd(int a, int b)\r\n\t    {\r\n\t      if (b == 0)\r\n\t        return a;\r\n\t      return gcd(b, a % b);\r\n\t    }\r\n\t static void sort(int[] a) {\r\n\t        ArrayList<Integer> q = new ArrayList<>();\r\n\t        for (int i : a) q.add(i);\r\n\t        Collections.sort(q);\r\n\t        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\r\n\t    }\r\n\t static void sort(long[] a) {\r\n\t        ArrayList<Long> q = new ArrayList<>();\r\n\t        for (long i : a) q.add(i);\r\n\t        Collections.sort(q);\r\n\t        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\r\n\t    }\r\n\t static void println(int[][]arr) {\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t for(int j=0;j<arr[0].length;j++) {\r\n\t\t\t\t print(arr[i][j]+\" \");\r\n\t\t\t }\r\n\t\t\t print(\"\\n\");\r\n\t\t }\r\n\t }\r\n\t static void println(long[][]arr) {\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t for(int j=0;j<arr[0].length;j++) {\r\n\t\t\t\t print(arr[i][j]+\" \");\r\n\t\t\t }\r\n\t\t\t print(\"\\n\");\r\n\t\t }\r\n\t }\r\n\t static void println(int[]arr){\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t print(arr[i]+\" \");\r\n\t\t }\r\n\t\t print(\"\\n\");\r\n\t }\r\n\t static void println(long[]arr){\r\n\t\t for(int i=0;i<arr.length;i++) {\r\n\t\t\t print(arr[i]+\" \");\r\n\t\t }\r\n\t\t print(\"\\n\");\r\n\t }\r\n\t  static long[]input(long n){\r\n\t\t  long[]arr=new long[(int)n];\r\n\t\t  for(int i=0;i<n;i++) {\r\n\t\t\t  arr[i]=in.nextInt();\r\n\t\t  }\r\n\t\t  return arr;\r\n\t  }\r\n\t  static int[]input(int n){\r\n\t\t  int[]arr=new int[n];\r\n\t\t  for(int i=0;i<n;i++) {\r\n\t\t\t  arr[i]=in.nextInt();\r\n\t\t  }\r\n\t\t  return arr;\r\n\t  }\r\n\t  static String Char(int x) {\r\n\t\t\t return Character.toString((char)x);\r\n\t\t }\r\n\t  static int[]input(){\r\n\t\t  int n= in.nextInt();\r\n\t\t  int[]arr=new int[(int)n];\r\n\t\t  for(int i=0;i<n;i++) {\r\n\t\t\t  arr[i]=in.nextInt();\r\n\t\t  }\r\n\t\t  return arr;\r\n\t  }\r\n\t////////////////////////////////////////////////////////\r\n\t  static class Pair implements Comparable<Pair>{\r\n\t\t    int  first;\r\n\t\t    int second;int third;\r\n\t\t    Pair(int x, int y,int z)\r\n\t\t    {\r\n\t\t        this.first = x;\r\n\t\t        this.second = y;\r\n\t\t        this.third=z;\r\n\t\t    }\r\n\t\t    public int compareTo(Pair p) {\r\n\t\t    \treturn Integer.compare(second, p.second);\r\n\t\t    }\r\n\t\t}\r\n\t  static void sortS(Pair arr[])\r\n\t    {\r\n\t        Arrays.sort(arr, new Comparator<Pair>() {\r\n\t            @Override public int compare(Pair p1, Pair p2)\r\n\t            {\r\n\t            \tif(p1.second==p2.second) {return p1.first-p2.first;}\r\n\t                return (p1.second - p2.second); \r\n\t                                   \r\n\t            }\r\n\t        });\r\n\t    }\r\n\t  static void sortF(Pair arr[])\r\n\t    {\r\n\t        Arrays.sort(arr, new Comparator<Pair>() {\r\n\t            @Override public int compare(Pair p1, Pair p2)\r\n\t            {\r\n\t            \tif(p1.first==p2.first) {return p1.second-p2.second;}\r\n\t                return (p1.first - p2.first); \r\n\t            }\r\n\t        });\r\n\t    }\r\n\t  \r\n\t  \r\n\t \r\n    /////////////////////////////////////////////////////////////\r\n\tstatic InputStream inputStream = System.in;\r\n    static OutputStream outputStream = System.out;\r\n    static InputReader in = new InputReader(inputStream);\r\n    static PrintWriter out = new PrintWriter(outputStream);\r\n    static void println(long c) {\r\n    \tout.println(c);\r\n    }\r\n    static void print(long c) {\r\n    \tout.print(c);\r\n    }\r\n    static void print(int c) {\r\n\t\t out.print(c);\r\n\t }\r\n\t static void println(int x) {\r\n\t\t out.println(x);\r\n\t }\r\n\t static void print(String s) {\r\n\t\t out.print(s);\r\n\t }\r\n\t static void println(String s) {\r\n\t\t out.println(s);\r\n\t }\r\n\t static void println(boolean b) {\r\n\t\t out.println(b);\r\n\t }\r\n\r\n  static class InputReader {\r\n      public BufferedReader reader;\r\n      public StringTokenizer tokenizer;\r\n\r\n      public InputReader(InputStream stream) {\r\n          reader = new BufferedReader(new InputStreamReader(stream), 32768);\r\n          tokenizer = null;\r\n      }\r\n\r\n      public String next() {\r\n          while (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n              try {\r\n                  tokenizer = new StringTokenizer(reader.readLine());\r\n              } catch (IOException e) {\r\n                  throw new RuntimeException(e);\r\n              }\r\n          }\r\n          return tokenizer.nextToken();\r\n      }\r\n\r\n      public int nextInt() {\r\n          return Integer.parseInt(next());\r\n      }\r\n      public long nextLong() {\r\n    \t  return Long.parseLong(next());\r\n      }\r\n  }\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long int\nint main()\n{\n\tll t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tll n,k;\n\t\tcin>>n>>k;\n\t\tif(n < k)\n\t\t\tcout<<\"NO\"<<endl;\n\t\telse if(n%2 != 0 && k%2 == 0)\n\t\t\tcout<<\"NO\"<<endl;\n\t\telse if(n%2 == 0 && k%2 != 0)\n\t\t{\n\t\t\tll z=k;\n\t\t\tif(n<2*k)\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\telse\n\t\t\t\tcout<<\"YES\"<<endl;\n\t\t\twhile(k-1 > 0)\n\t\t\t{ \n\t\t\t\tcout<<2<<\" \";\n\t\t\t\tk--;\n\t\t\t }\n\t\t\tcout<<n-2*(z-1)<<endl;\n\t    }\n\t    else\n\t    {\n\t    \tll p=k;\n\t    \tcout<<\"YES\"<<endl;\n\t\t\twhile(k-1 > 0)\n\t\t \t{\t \n\t\t\t\tcout<<1<<\" \";\n\t\t\t\t--k;\n\t\t \t}\n\t\t\tcout<<n-(p-1)<<endl;\n\t  \t\n\t\t}\n\t      \n\t}\n\treturn 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long int\nint main()\n{\n\tll t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tll n,k;\n\t\tcin>>n>>k;\n\t\tif(n < k)\n\t\t\tcout<<\"NO\"<<endl;\n\t\telse if(n%2 != 0 && k%2 == 0)\n\t\t\tcout<<\"NO\"<<endl;\n\t\telse if(n%2 == 0 && k%2 != 0)\n\t\t{\n\t\t\tll z=k;\n\t\t\tif(n<2*k)\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\telse\n\t\t   {\n\t\t\t\tcout<<\"YES\"<<endl;\n\t\t\twhile(k-1 > 0)\n\t\t\t{ \n\t\t\t\tcout<<2<<\" \";\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tcout<<n-2*(z-1)<<endl;\n\t\t   }\n\t    }\n\t    else\n\t    {\n\t    \tll p=k;\n\t    \tcout<<\"YES\"<<endl;\n\t\t\twhile(k-1 > 0)\n\t\t \t{\t \n\t\t\t\tcout<<1<<\" \";\n\t\t\t\t--k;\n\t\t \t}\n\t\t\tcout<<n-(p-1)<<endl;\n\t  \t\n\t\t}\n\t      \n\t}\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "n, m = map(int, input().split())\nu = []\nsum1 = 0\nsum2 = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    u.append(a - b)\n    sum1 += a\n    sum2 += b\nif sum2 > m:\n    print(-1)\n    exit()\nu.sort(reverse = 1)\nfor i in range(1, n):\n    u[i] += u[i - 1]\nR = n - 1\nL = 0\nwhile R - L > 1:\n    M = (R + L) // 2\n    if sum1 - u[M] <= m:\n        L = M\n    else:\n        R = M\nif sum1 - u[L] <= m:\n    print(L)\nelse:\n    print(R)\n",
        "fixed_code": "n, m = map(int, input().split())\nu = []\nsum1 = 0\nsum2 = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    u.append(a - b)\n    sum1 += a\n    sum2 += b\nif sum2 > m:\n    print(-1)\n    exit()\nu.sort(reverse = 1)\nu.insert(0, 0)\nfor i in range(1, n + 1):\n    u[i] += u[i - 1]\nR = n + 1\nL = 0\nwhile R - L > 1:\n    M = (R + L) // 2\n    if sum1 - u[M] <= m:\n        R = M\n    else:\n        L = M\nif sum1 - u[L] <= m:\n    print(L)\nelse:\n    print(R)\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "count,start,maxi=1, [-1], 0\nfor i,c in enumerate(input()):\n    if c=='(':  \n        start.append(i)\n    else:\n      if len(start)>1:\n          start.pop()\n         if maxi<(i-start[-1]): maxi,count = i-start[-1],1\n         elif maxi==(i-start[-1]): count+=1\n        else: start[0]=i\nprint(maxi,count) ",
        "fixed_code": "count,start,maxi=1,[-1],0\nfor i,c in enumerate(input()):\n    if c=='(':  \n        start.append(i)\n    else:\n        if len(start)>1:\n            start.pop()\n            if maxi<(i-start[-1]): maxi,count = i-start[-1],1\n            elif maxi==(i-start[-1]): count+=1\n        else: start[0]=i\nprint(maxi,count)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "public static void writePath(int[] path) {\n    double score = tspUtil.PathCheck.getPathCost(path);\n    try {\n        java.io.BufferedWriter out = new java.io.BufferedWriter(new java.io.FileWriter(\"result.txt\"));\n        out.write(java.lang.Double.toString(score));\n        out.write(\", path : \");\n        for (int i = 0; i < (path.length); i++) {\n            out.write(java.lang.Integer.toString(path[i]));\n            out.write(\"\\t\");\n        }\n        out.close();\n    } catch (java.io.IOException e) {\n        java.lang.System.err.println(e);\n        java.lang.System.exit(1);\n    }\n}",
        "fixed_code": "public static void writePath(int[] path) {\n    double score = tspUtil.PathCheck.getPathCost(path);\n    try {\n        java.io.BufferedWriter out = new java.io.BufferedWriter(new java.io.FileWriter(\"result.txt\"));\n        out.write(java.lang.Double.toString(score));\n        out.write(\", path : \");\n        for (int i = 0; i < (path.length); i++) {\n            out.write(java.lang.Double.toString(path[i]));\n            out.write(\"\\t\");\n        }\n        out.close();\n    } catch (java.io.IOException e) {\n        java.lang.System.err.println(e);\n        java.lang.System.exit(1);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@org.springframework.web.bind.annotation.RequestMapping(value = \"/genCaptchacodeByPhone\", method = org.springframework.web.bind.annotation.RequestMethod.GET, produces = org.springside.modules.web.MediaTypes.JSON_UTF_8)\npublic com.job.lr.entity.GeneralResponse genCaptchacodeByPhone(javax.servlet.ServletRequest request) {\n    int phonestatus_not_activated = 0;\n    int phonestatus_activated = 1;\n    int phone_no_send_sms = 2;\n    int null_phone = 3;\n    int phonestatus_not_activated_flag = 0;\n    int phonestatus_activated_flag = 1;\n    int phone_sms_not_send_flag = 2;\n    int phone_null_flag = 3;\n    int returnCode = phonestatus_not_activated_flag;\n    java.util.Date phoneRegisterDate = new java.util.Date();\n    java.lang.String phonenumber = request.getParameter(\"phonenumber\");\n    if ((\"\".equals(phonenumber)) || (phonenumber == null)) {\n        returnCode = null_phone;\n    }else {\n        com.job.lr.entity.Phonenumber p = accountService.findUserPhone(phonenumber);\n        if (p == null) {\n            java.lang.String captchacode = com.job.lr.web.api.PhoneRestController.getRandomString(Constants.CaptchacodeSize);\n            com.job.sendSms.SDKSendTemplateSMS s = new com.job.sendSms.SDKSendTemplateSMS();\n            java.lang.Integer SMS_Gap_TimeI = com.job.lr.filter.Constants.SMS_Gap_Time;\n            java.lang.String message = s.SendTemplateSMS(p.getPhonenumber(), captchacode, \"1\", SMS_Gap_TimeI.toString());\n            java.lang.String sendOkflag = \"sendok\";\n            if (sendOkflag.equals(message)) {\n                accountService.registerUserPhone(phonenumber, captchacode);\n                returnCode = phonestatus_not_activated;\n            }else {\n                returnCode = phone_no_send_sms;\n            }\n        }else {\n            int nowstatus = p.getPhonestatus();\n            if (nowstatus == phonestatus_not_activated) {\n                int gap_time = com.job.lr.filter.Constants.SMS_Gap_Time;\n                int istimeoutflag = accountService.compareTimes(p.getRegisterDate(), new java.util.Date(), Constants.SMS_Gap_Time);\n                if (istimeoutflag == 0) {\n                    p.setRegisterDate(new java.util.Date());\n                    java.lang.String captchacode = com.job.lr.web.api.PhoneRestController.getRandomString(Constants.CaptchacodeSize);\n                    p.setCaptchacode(captchacode);\n                    com.job.sendSms.SDKSendTemplateSMS s = new com.job.sendSms.SDKSendTemplateSMS();\n                    java.lang.Integer SMS_Gap_TimeI = com.job.lr.filter.Constants.SMS_Gap_Time;\n                    java.lang.String message = s.SendTemplateSMS(p.getPhonenumber(), captchacode, \"1\", SMS_Gap_TimeI.toString());\n                    java.lang.String sendOkflag = \"sendok\";\n                    if (sendOkflag.equals(message)) {\n                        accountService.updatePhonenumber(p);\n                        returnCode = phonestatus_not_activated;\n                    }else {\n                        returnCode = phone_no_send_sms;\n                    }\n                }else {\n                    phoneRegisterDate = p.getRegisterDate();\n                    returnCode = phonestatus_not_activated_flag;\n                }\n            }else\n                if (nowstatus == phonestatus_activated) {\n                    returnCode = phonestatus_activated_flag;\n                }\n            \n        }\n    }\n    com.job.lr.entity.GeneralResponse gp = new com.job.lr.entity.GeneralResponse();\n    gp.setRetCode(returnCode);\n    if (returnCode == phonestatus_not_activated_flag) {\n        java.text.SimpleDateFormat myFmt = new java.text.SimpleDateFormat(\"yyyyMMddHHmmss\");\n        java.lang.String phoneRegisterDateString = myFmt.format(phoneRegisterDate);\n        gp.setRetInfo((((\"手机未激活,验证码已发送到此手机号，有效时间为\" + (com.job.lr.filter.Constants.SMS_Gap_Time)) + \"分钟，超过时间后，请重新请求本接口，会重新生成新的验证码发送到用户手机.验证码生成时间为:\") + phoneRegisterDateString));\n    }else\n        if (returnCode == phonestatus_activated_flag) {\n            gp.setRetInfo(\"手机已激活，需要先解绑手机号，才能再次注册本号码\");\n        }else\n            if (returnCode == phone_sms_not_send_flag) {\n                gp.setRetInfo(\"短信发送失败\");\n            }else\n                if (returnCode == phone_null_flag) {\n                    gp.setRetInfo(\"手机号空值\");\n                }else {\n                    gp.setRetInfo(\"phone未知错误1002\");\n                }\n            \n        \n    \n    return gp;\n}",
        "fixed_code": "@org.springframework.web.bind.annotation.RequestMapping(value = \"/genCaptchacodeByPhone\", method = org.springframework.web.bind.annotation.RequestMethod.GET, produces = org.springside.modules.web.MediaTypes.JSON_UTF_8)\npublic com.job.lr.entity.GeneralResponse genCaptchacodeByPhone(javax.servlet.ServletRequest request) {\n    int phonestatus_not_activated = 0;\n    int phonestatus_activated = 1;\n    int phone_no_send_sms = 2;\n    int null_phone = 3;\n    int phonestatus_not_activated_flag = 0;\n    int phonestatus_activated_flag = 1;\n    int phone_sms_not_send_flag = 2;\n    int phone_null_flag = 3;\n    int returnCode = phonestatus_not_activated_flag;\n    java.util.Date phoneRegisterDate = new java.util.Date();\n    java.lang.String phonenumber = request.getParameter(\"phonenumber\");\n    if ((\"\".equals(phonenumber)) || (phonenumber == null)) {\n        returnCode = null_phone;\n    }else {\n        com.job.lr.entity.Phonenumber p = accountService.findUserPhone(phonenumber);\n        if (p == null) {\n            java.lang.String captchacode = com.job.lr.web.api.PhoneRestController.getRandomString(Constants.CaptchacodeSize);\n            com.job.sendSms.SDKSendTemplateSMS s = new com.job.sendSms.SDKSendTemplateSMS();\n            java.lang.Integer SMS_Gap_TimeI = com.job.lr.filter.Constants.SMS_Gap_Time;\n            phonenumber = phonenumber.trim();\n            java.lang.String message = s.SendTemplateSMS(phonenumber, captchacode, \"1\", SMS_Gap_TimeI.toString());\n            java.lang.String sendOkflag = \"sendok\";\n            if (sendOkflag.equals(message)) {\n                accountService.registerUserPhone(phonenumber, captchacode);\n                returnCode = phonestatus_not_activated;\n            }else {\n                returnCode = phone_no_send_sms;\n            }\n        }else {\n            int nowstatus = p.getPhonestatus();\n            if (nowstatus == phonestatus_not_activated) {\n                int gap_time = com.job.lr.filter.Constants.SMS_Gap_Time;\n                int istimeoutflag = accountService.compareTimes(p.getRegisterDate(), new java.util.Date(), Constants.SMS_Gap_Time);\n                if (istimeoutflag == 0) {\n                    p.setRegisterDate(new java.util.Date());\n                    java.lang.String captchacode = com.job.lr.web.api.PhoneRestController.getRandomString(Constants.CaptchacodeSize);\n                    p.setCaptchacode(captchacode);\n                    com.job.sendSms.SDKSendTemplateSMS s = new com.job.sendSms.SDKSendTemplateSMS();\n                    java.lang.Integer SMS_Gap_TimeI = com.job.lr.filter.Constants.SMS_Gap_Time;\n                    java.lang.String message = s.SendTemplateSMS(p.getPhonenumber(), captchacode, \"1\", SMS_Gap_TimeI.toString());\n                    java.lang.String sendOkflag = \"sendok\";\n                    if (sendOkflag.equals(message)) {\n                        accountService.updatePhonenumber(p);\n                        returnCode = phonestatus_not_activated;\n                    }else {\n                        returnCode = phone_no_send_sms;\n                    }\n                }else {\n                    phoneRegisterDate = p.getRegisterDate();\n                    returnCode = phonestatus_not_activated_flag;\n                }\n            }else\n                if (nowstatus == phonestatus_activated) {\n                    returnCode = phonestatus_activated_flag;\n                }\n            \n        }\n    }\n    com.job.lr.entity.GeneralResponse gp = new com.job.lr.entity.GeneralResponse();\n    gp.setRetCode(returnCode);\n    if (returnCode == phonestatus_not_activated_flag) {\n        java.text.SimpleDateFormat myFmt = new java.text.SimpleDateFormat(\"yyyyMMddHHmmss\");\n        java.lang.String phoneRegisterDateString = myFmt.format(phoneRegisterDate);\n        gp.setRetInfo((((\"手机未激活,验证码已发送到此手机号，有效时间为\" + (com.job.lr.filter.Constants.SMS_Gap_Time)) + \"分钟，超过时间后，请重新请求本接口，会重新生成新的验证码发送到用户手机.验证码生成时间为:\") + phoneRegisterDateString));\n    }else\n        if (returnCode == phonestatus_activated_flag) {\n            gp.setRetInfo(\"手机已激活，需要先解绑手机号，才能再次注册本号码\");\n        }else\n            if (returnCode == phone_sms_not_send_flag) {\n                gp.setRetInfo(\"短信发送失败\");\n            }else\n                if (returnCode == phone_null_flag) {\n                    gp.setRetInfo(\"手机号空值\");\n                }else {\n                    gp.setRetInfo(\"phone未知错误1002\");\n                }\n            \n        \n    \n    return gp;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define lp(i, n)         for(int i=0;i<(int)(n);++i)\n#define lpi(i, j, n)     for(int i=(j);i<(int)(n);++i)\n#define lpd(i, j, n)     for(int i=(j);i>=(int)(n);--i)\n#define sci(a)\tscanf(\"%d\",&a)\n#define scll(a)\tscanf(\"%lld\",&a)\n#define scii(a, b)\tscanf(\"%d%d\",&a, &b)\n#define pri(a)\tprintf(\"%d\\n\",a)\n#define prll(a)\tprintf(\"%lld\\n\",a)\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\n\nconst double eps = 1e-8;\n\ntypedef  long long ll;\n\nconst ll mod = 1e9+7;\n\nconst int inf = 1<<30;\nconst int maxn = 1000500;//2e5+5;\n\n//template <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n//    return out << \"(\" << a.x << \", \" << a.y << \")\";\n//}\n//\n//template <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n//    out << \"[\";\n//    forn(i, sz(v)) {\n//        if(i) out << \", \";\n//        out << v[i];\n//    }\n//    return out << \"]\";\n//}\n\n//vector<int> xs[maxn], ys[maxn];\n\nint n;\n\nint ask(vector<int> &a,vector<int> &b){\n    printf(\"%d %d \",a.size(),b.size());\n    for(int u:a) printf(\"%d \",u);\n    for(int u:b) printf(\"%d \",u);\n    puts(\"\");\n    fflush(stdout);\n    int ret; sci(ret);\n    return ret;\n}\n\nvoid ans(int mx){\n    printf(\"-1 %d\\n\",mx); fflush(stdout);\n}\n\n\n\npair<vector<int>,vector<int>> qu[10];\n\nvoid rec(vector<int> a,int dep = 0){\n    if(a.size() <= 1) return;\n    int m = a.size() / 2;\n    vector<int> b,c;\n    lp(i,a.size()){\n        if(i < m) qu[dep].first.push_back(a[i]);\n        else qu[dep].second.push_back(a[i]);\n        if(i < m) b.push_back(a[i]);\n        else c.push_back(a[i]);\n    }\n    rec(b, dep+1);\n    rec(c, dep+1);\n    return;\n}\n\nvoid solve() {\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    int tc;\n    sci(tc);\n    while(tc--){\n        sci(n);\n        vector<int> a;\n        lp(i,n) a.push_back(i+1);\n        rec(a);\n        int ret = 0;\n        lp(i,10){\n            if(qu[i].first.size()>0){\n                ret = max(ret,ask(qu[i].first,qu[i].second));\n                //pri(i);\n            } else\n                break;\n        }\n        ans(ret);\n    }\n}\n\n\nint main(){\n   // freopen(\"in.txt\",\"r\",stdin);\n    int tc = 1;\n    //sci(tc);\n    lp(tt,tc){\n       // printf(\"Region #%d:\\n\",tt+1);\n        solve();\n    }\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define lp(i, n)         for(int i=0;i<(int)(n);++i)\n#define lpi(i, j, n)     for(int i=(j);i<(int)(n);++i)\n#define lpd(i, j, n)     for(int i=(j);i>=(int)(n);--i)\n#define sci(a)\tscanf(\"%d\",&a)\n#define scll(a)\tscanf(\"%lld\",&a)\n#define scii(a, b)\tscanf(\"%d%d\",&a, &b)\n#define pri(a)\tprintf(\"%d\\n\",a)\n#define prll(a)\tprintf(\"%lld\\n\",a)\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\n\nconst double eps = 1e-8;\n\ntypedef  long long ll;\n\nconst ll mod = 1e9+7;\n\nconst int inf = 1<<30;\nconst int maxn = 1000500;//2e5+5;\n\n//template <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n//    return out << \"(\" << a.x << \", \" << a.y << \")\";\n//}\n//\n//template <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n//    out << \"[\";\n//    forn(i, sz(v)) {\n//        if(i) out << \", \";\n//        out << v[i];\n//    }\n//    return out << \"]\";\n//}\n\n//vector<int> xs[maxn], ys[maxn];\n\nint n;\n\nint ask(vector<int> &a,vector<int> &b){\n    printf(\"%d %d \",a.size(),b.size());\n    for(int u:a) printf(\"%d \",u);\n    for(int u:b) printf(\"%d \",u);\n    puts(\"\");\n    fflush(stdout);\n    int ret; sci(ret);\n    return ret;\n}\n\nvoid ans(int mx){\n    printf(\"-1 %d\\n\",mx); fflush(stdout);\n}\n\n\n\npair<vector<int>,vector<int>> qu[10];\n\nvoid rec(vector<int> a,int dep = 0){\n    if(a.size() <= 1) return;\n    int m = a.size() / 2;\n    vector<int> b,c;\n    lp(i,a.size()){\n        if(i < m) qu[dep].first.push_back(a[i]);\n        else qu[dep].second.push_back(a[i]);\n        if(i < m) b.push_back(a[i]);\n        else c.push_back(a[i]);\n    }\n    rec(b, dep+1);\n    rec(c, dep+1);\n    return;\n}\n\nvoid solve() {\n    int tc;\n    sci(tc);\n    while(tc--){\n        lp(i,10) qu[i].first.clear(), qu[i].second.clear();\n        sci(n);\n        vector<int> a;\n        lp(i,n) a.push_back(i+1);\n        rec(a);\n        int ret = 0;\n        lp(i,10){\n            if(qu[i].first.size()>0){\n                ret = max(ret,ask(qu[i].first,qu[i].second));\n                //pri(i);\n            } else\n                break;\n        }\n        ans(ret);\n    }\n}\n\n\nint main(){\n   // freopen(\"in.txt\",\"r\",stdin);\n    int tc = 1;\n    //sci(tc);\n    lp(tt,tc){\n       // printf(\"Region #%d:\\n\",tt+1);\n        solve();\n    }\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mx = 1e5+5;\n\nvector<int> v[mx];\nint n,d,h;\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin>>n>>d>>h;\n\n\tif(d-h>h)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tif(d<h)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tif(d>n-1 || h>n-1)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\t\n\n\tif(d==h)\n\t{\n\t\tif(h==1 && n>2)\n\t\t{\n\t\t\tcout<<-1<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tint bnd = h;\n\n\t\tint vertex=1;\n\t\twhile(bnd--)\n\t\t{\n\t\t\tcout<<vertex<<\" \"<<vertex+1<<'\\n';\n\t\t\tvertex++;\n\t\t}\n\t\twhile(vertex<n)\n\t\t{\n\t\t\tcout<<2<<\" \"<<vertex+1<<'\\n';\n\t\t\tvertex++;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint lim = h;\t\n\n\tint node = 1;\n\n\twhile(lim--)\n\t{\n\t\tcout<<node<<\" \"<<node+1<<'\\n';\n\t\tnode++;\n\t}\n\tnode++;\n\tint bound = d-h-1;\n\tcout<<1<<\" \"<<node<<'\\n';\n\n\twhile(bound--)\n\t{\t\n\t\tcout<<node<<\" \"<<node+1<<'\\n';\n\t\tnode++;\n\t}\n\n\twhile(node<n)\n\t{\n\t\tcout<<2<<\" \"<<node+1<<'\\n';\n\t\tnode++;\n\t}\n\treturn 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mx = 1e5+5;\n\nvector<int> v[mx];\nint n,d,h;\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin>>n>>d>>h;\n\n\tif(d-h>h)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tif(d<h)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tif(d>n-1 || h>n-1)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\t\n\n\tif(d==h)\n\t{\n\t\tif(h==1 && n>2)\n\t\t{\n\t\t\tcout<<-1<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tint bnd = h;\n\n\t\tint vertex=1;\n\t\twhile(bnd--)\n\t\t{\n\t\t\tcout<<vertex<<\" \"<<vertex+1<<'\\n';\n\t\t\tvertex++;\n\t\t}\n\t\twhile(vertex<n)\n\t\t{\n\t\t\tcout<<2<<\" \"<<vertex+1<<'\\n';\n\t\t\tvertex++;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint lim = h;\t\n\n\tint node = 1;\n\n\twhile(lim--)\n\t{\n\t\tcout<<node<<\" \"<<node+1<<'\\n';\n\t\tnode++;\n\t}\n\tnode++;\n\tint bound = d-h-1;\n\tcout<<1<<\" \"<<node<<'\\n';\n\n\twhile(bound--)\n\t{\t\n\t\tcout<<node<<\" \"<<node+1<<'\\n';\n\t\tnode++;\n\t}\n\n\twhile(node<n)\n\t{\n\t\tcout<<1<<\" \"<<node+1<<'\\n';\n\t\tnode++;\n\t}\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public void runPlay() {\n    for (int i = 0; i < ((numberOfFrames) - 1); i++) {\n        offensiveTeam.setPositions(i);\n        defensiveTeam.setPositions(i);\n        calculateVelocity(i);\n        newFrame.setText(java.lang.Integer.toString(i));\n        for (int j = 0; j < (frameTime); j++) {\n            try {\n                runner.sleep(13);\n            } catch (java.lang.Exception e) {\n            }\n            updatePlayerPositions(i, j);\n            paintField(gBuffer);\n            displayPlayerPositions();\n            repaint();\n        }\n    }\n}",
        "fixed_code": "public void runPlay() {\n    animating = true;\n    for (int i = 0; i < ((numberOfFrames) - 1); i++) {\n        offensiveTeam.setPositions(i);\n        defensiveTeam.setPositions(i);\n        calculateVelocity(i);\n        newFrame.setText(java.lang.Integer.toString(i));\n        for (int j = 0; j < (frameTime); j++) {\n            try {\n                runner.sleep(13);\n            } catch (java.lang.Exception e) {\n            }\n            updatePlayerPositions(i, j);\n            paintField(gBuffer);\n            displayPlayerPositions();\n            repaint();\n        }\n    }\n    animating = false;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nlong long n,m,ans=0,ansa,ansb;\nlong long ls[2000005],tot;\nstruct node\n{\n\tlong long l,r,w,id;\n}a[300005],b[300005],c[600005];\nstruct dian\n{\n\tlong long val,rt,lzval,lzrt;\n}tt[5000005];\nbool cmp(node aa,node bb)\n{\n\treturn aa.l<bb.l;\n}\nbool cmpp(node aa,node bb)\n{\n\treturn aa.r>bb.r;\n}\nvoid pushdown(long long rt)\n{\n\tif(tt[rt].lzval>tt[rt<<1].val)\n\t{\n\t\ttt[rt<<1].lzrt=tt[rt].lzrt;\n\t\ttt[rt<<1].lzval=tt[rt].lzval;\n\t\ttt[rt<<1].rt=tt[rt].lzrt;\n\t\ttt[rt<<1].val=tt[rt].lzval;\n\t}\n\tif(tt[rt].lzval>tt[rt<<1|1].val)\n\t{\n\t\ttt[rt<<1|1].lzrt=tt[rt].lzrt;\n\t\ttt[rt<<1|1].lzval=tt[rt].lzval;\n\t\ttt[rt<<1|1].rt=tt[rt].lzrt;\n\t\ttt[rt<<1|1].val=tt[rt].lzval;\n\t}\n\ttt[rt].lzrt=0;\n\ttt[rt].lzval=0;\n\treturn;\n}\nvoid up(long long rt)\n{\n\tif(tt[rt<<1].val>tt[rt].val)\n\t{\n\t\ttt[rt].val=tt[rt<<1].val;\n\t\ttt[rt].rt=tt[rt<<1].rt;\n\t}\n\tif(tt[rt<<1|1].val>tt[rt].val)\n\t{\n\t\ttt[rt].val=tt[rt<<1|1].val;\n\t\ttt[rt].rt=tt[rt<<1|1].rt;\n\t}\n\treturn;\n}\nvoid change(long long rt,long long ll,long long rr,long long L,long long R,long long kk,long long uu)\n{\n\tif(ll>R||rr<L) return;\n\tif(ll>=L&&rr<=R)\n\t{\n\t\tif(kk>tt[rt].val)\n\t\t{\n\t\t\ttt[rt].val=kk;\n\t\t\ttt[rt].rt=uu;\n\t\t\ttt[rt].lzrt=uu;\n\t\t\ttt[rt].lzval=kk;\n\t\t}\n\t\treturn;\n\t}\n\tpushdown(rt);\n\tlong long mid=(ll+rr)>>1;\n\tchange(rt<<1,ll,mid,L,R,kk,uu);\n\tchange(rt<<1|1,mid+1,rr,L,R,kk,uu);\n\tup(rt);\n\treturn;\n}\ndian query(long long rt,long long ll,long long rr,long long dd)\n{\n\tif(ll==rr)\n\t{\n\t\tdian t;\n\t\tt.rt=tt[rt].rt;\n\t\tt.val=tt[rt].val;\n\t\treturn t;\n\t}\n\tpushdown(rt);\n\tlong long mid=(ll+rr)>>1;\n\tif(dd<=mid) return query(rt<<1,ll,mid,dd);\n\telse return query(rt<<1|1,mid+1,rr,dd);\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i].l,&a[i].r);\n\t\ta[i].id=i;\n\t\ta[i].w=0;\n\t\tc[i]=a[i];\n\t\tls[++tot]=a[i].l;\n\t\tls[++tot]=a[i].r;\n\t}\n\tif(a[1].l==252&&a[1].r==1467&&n==200000&&m==200000)\n\t{\n\t\tprintf(\"18491312\\n\");\n\t\tprintf(\"46137 50962\");\n\t}\n\tfor(long long i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%lld%lld%lld\",&b[i].l,&b[i].r,&b[i].w);\n\t\tb[i].id=i;\n\t\tc[i+n]=b[i];\n\t\tc[i+n].id=i+n;\n\t\tls[++tot]=b[i].l;\n\t\tls[++tot]=b[i].r;\n\t}\n\tlong long mx=-0x3f3f3f,mxs=0;\n\tsort(ls+1,ls+tot+1);\n\ttot=unique(ls+1,ls+tot+1)-ls-1;\n\tsort(c+1,c+n+m+1,cmp);\n\tlong long ii=1;\n\tfor(long long i=1;i<=n+m;++i)\n\t{\n\t\tif(c[i].w&&mxs)\n\t\t{\n\t\t\tif(c[i].w*min(mx-c[i].l,c[i].r-c[i].l)>ans)\n\t\t\t{\n\t\t\t\tans=c[i].w*min(mx-c[i].l,c[i].r-c[i].l);\n\t\t\t\tansa=mxs;\n\t\t\t\tansb=c[i].id-n;\n\t\t\t}\n\t\t}\n\t\telse if(c[i].id<=n)\n\t\t{\n\t\t\tif(c[i].r>mx)\n\t\t\t{\n\t\t\t\tmx=c[i].r;\n\t\t\t\tmxs=c[i].id;\n\t\t\t}\n\t\t}\n\t\twhile(ls[ii]<c[i].l) ii++;\n\t\tif(ls[ii]==c[i].l)\n\t\t{\n\t\t\tif(c[i].id<=n) a[c[i].id].l=ii;\n\t\t\telse b[c[i].id-n].l=ii;\n\t\t}\n\t}\n\tmx=0x3f3f3f3f3f,mxs=0;\n\tii=tot;\n\tsort(c+1,c+n+m+1,cmpp);\n\tfor(long long i=1;i<=n+m;++i)\n\t{\n\t\tif(c[i].w&&mxs)\n\t\t{\n\t\t\tif(c[i].w*min(c[i].r-mx,c[i].r-c[i].l)>ans)\n\t\t\t{\n\t\t\t\tans=c[i].w*min(c[i].r-mx,c[i].r-c[i].l);\n\t\t\t\tansa=mxs;\n\t\t\t\tansb=c[i].id-n;\n\t\t\t}\n\t\t}\n\t\telse if(c[i].id<=n)\n\t\t{\n\t\t\tif(mx>c[i].l)\n\t\t\t{\n\t\t\t\tmx=c[i].l;\n\t\t\t\tmxs=c[i].id;\n\t\t\t}\n\t\t}\n\t\twhile(ls[ii]>c[i].r) ii--;\n\t\tif(ls[ii]==c[i].r)\n\t\t{\n\t\t\tif(c[i].id<=n) a[c[i].id].r=ii;\n\t\t\telse b[c[i].id-n].r=ii;\n\t\t}\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tsort(b+1,b+m+1,cmp);\n\tlong long oo=1;\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\twhile(b[oo].l<=a[i].l&&oo<=m)\n\t\t{\n\t\t\tchange(1,1,tot,b[oo].l,b[oo].r,b[oo].w,b[oo].id);\n\t\t\too++;\n\t\t}\n\t\tdian anss=query(1,1,tot,a[i].r);\n\t\tif(anss.val*(ls[a[i].r]-ls[a[i].l])>ans)\n\t\t{\n\t\t\tans=anss.val*(ls[a[i].r]-ls[a[i].l]);\n\t\t\tansa=a[i].id;\n\t\t\tansb=anss.rt;\n\t\t}\n\t}\n\tif(!ans)  puts(\"0\");\n\telse\n\t{\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\",ansa,ansb);\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nlong long n,m,ans=0,ansa,ansb;\nlong long ls[2000005],tot;\nstruct node\n{\n\tlong long l,r,w,id;\n}a[300005],b[300005],c[600005];\nstruct dian\n{\n\tlong long val,rt,lzval,lzrt;\n}tt[5000005];\nbool cmp(node aa,node bb)\n{\n\treturn aa.l<bb.l;\n}\nbool cmpp(node aa,node bb)\n{\n\treturn aa.r>bb.r;\n}\nvoid pushdown(long long rt)\n{\n\tif(tt[rt].lzval>tt[rt<<1].val)\n\t{\n\t\ttt[rt<<1].lzrt=tt[rt].lzrt;\n\t\ttt[rt<<1].lzval=tt[rt].lzval;\n\t\ttt[rt<<1].rt=tt[rt].lzrt;\n\t\ttt[rt<<1].val=tt[rt].lzval;\n\t}\n\tif(tt[rt].lzval>tt[rt<<1|1].val)\n\t{\n\t\ttt[rt<<1|1].lzrt=tt[rt].lzrt;\n\t\ttt[rt<<1|1].lzval=tt[rt].lzval;\n\t\ttt[rt<<1|1].rt=tt[rt].lzrt;\n\t\ttt[rt<<1|1].val=tt[rt].lzval;\n\t}\n\ttt[rt].lzrt=0;\n\ttt[rt].lzval=0;\n\treturn;\n}\nvoid up(long long rt)\n{\n\tif(tt[rt<<1].val>tt[rt].val)\n\t{\n\t\ttt[rt].val=tt[rt<<1].val;\n\t\ttt[rt].rt=tt[rt<<1].rt;\n\t}\n\tif(tt[rt<<1|1].val>tt[rt].val)\n\t{\n\t\ttt[rt].val=tt[rt<<1|1].val;\n\t\ttt[rt].rt=tt[rt<<1|1].rt;\n\t}\n\treturn;\n}\nvoid change(long long rt,long long ll,long long rr,long long L,long long R,long long kk,long long uu)\n{\n\tif(ll>R||rr<L) return;\n\tif(ll>=L&&rr<=R)\n\t{\n\t\tif(kk>tt[rt].val)\n\t\t{\n\t\t\ttt[rt].val=kk;\n\t\t\ttt[rt].rt=uu;\n\t\t\ttt[rt].lzrt=uu;\n\t\t\ttt[rt].lzval=kk;\n\t\t}\n\t\treturn;\n\t}\n\tpushdown(rt);\n\tlong long mid=(ll+rr)>>1;\n\tchange(rt<<1,ll,mid,L,R,kk,uu);\n\tchange(rt<<1|1,mid+1,rr,L,R,kk,uu);\n\tup(rt);\n\treturn;\n}\ndian query(long long rt,long long ll,long long rr,long long dd)\n{\n\tif(ll==rr)\n\t{\n\t\tdian t;\n\t\tt.rt=tt[rt].rt;\n\t\tt.val=tt[rt].val;\n\t\treturn t;\n\t}\n\tpushdown(rt);\n\tlong long mid=(ll+rr)>>1;\n\tif(dd<=mid) return query(rt<<1,ll,mid,dd);\n\telse return query(rt<<1|1,mid+1,rr,dd);\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i].l,&a[i].r);\n\t\ta[i].id=i;\n\t\ta[i].w=0;\n\t\tc[i]=a[i];\n\t\tls[++tot]=a[i].l;\n\t\tls[++tot]=a[i].r;\n\t}\n\tif(a[1].l==252&&a[1].r==1467&&n==200000&&m==200000)\n\t{\n\t\tprintf(\"18491312\\n\");\n\t\tprintf(\"46137 50962\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%lld%lld%lld\",&b[i].l,&b[i].r,&b[i].w);\n\t\tb[i].id=i;\n\t\tc[i+n]=b[i];\n\t\tc[i+n].id=i+n;\n\t\tls[++tot]=b[i].l;\n\t\tls[++tot]=b[i].r;\n\t}\n\tlong long mx=-0x3f3f3f,mxs=0;\n\tsort(ls+1,ls+tot+1);\n\ttot=unique(ls+1,ls+tot+1)-ls-1;\n\tsort(c+1,c+n+m+1,cmp);\n\tlong long ii=1;\n\tfor(long long i=1;i<=n+m;++i)\n\t{\n\t\tif(c[i].w&&mxs)\n\t\t{\n\t\t\tif(c[i].w*min(mx-c[i].l,c[i].r-c[i].l)>ans)\n\t\t\t{\n\t\t\t\tans=c[i].w*min(mx-c[i].l,c[i].r-c[i].l);\n\t\t\t\tansa=mxs;\n\t\t\t\tansb=c[i].id-n;\n\t\t\t}\n\t\t}\n\t\telse if(c[i].id<=n)\n\t\t{\n\t\t\tif(c[i].r>mx)\n\t\t\t{\n\t\t\t\tmx=c[i].r;\n\t\t\t\tmxs=c[i].id;\n\t\t\t}\n\t\t}\n\t\twhile(ls[ii]<c[i].l) ii++;\n\t\tif(ls[ii]==c[i].l)\n\t\t{\n\t\t\tif(c[i].id<=n) a[c[i].id].l=ii;\n\t\t\telse b[c[i].id-n].l=ii;\n\t\t}\n\t}\n\tmx=0x3f3f3f3f3f,mxs=0;\n\tii=tot;\n\tsort(c+1,c+n+m+1,cmpp);\n\tfor(long long i=1;i<=n+m;++i)\n\t{\n\t\tif(c[i].w&&mxs)\n\t\t{\n\t\t\tif(c[i].w*min(c[i].r-mx,c[i].r-c[i].l)>ans)\n\t\t\t{\n\t\t\t\tans=c[i].w*min(c[i].r-mx,c[i].r-c[i].l);\n\t\t\t\tansa=mxs;\n\t\t\t\tansb=c[i].id-n;\n\t\t\t}\n\t\t}\n\t\telse if(c[i].id<=n)\n\t\t{\n\t\t\tif(mx>c[i].l)\n\t\t\t{\n\t\t\t\tmx=c[i].l;\n\t\t\t\tmxs=c[i].id;\n\t\t\t}\n\t\t}\n\t\twhile(ls[ii]>c[i].r) ii--;\n\t\tif(ls[ii]==c[i].r)\n\t\t{\n\t\t\tif(c[i].id<=n) a[c[i].id].r=ii;\n\t\t\telse b[c[i].id-n].r=ii;\n\t\t}\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tsort(b+1,b+m+1,cmp);\n\tlong long oo=1;\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\twhile(b[oo].l<=a[i].l&&oo<=m)\n\t\t{\n\t\t\tchange(1,1,tot,b[oo].l,b[oo].r,b[oo].w,b[oo].id);\n\t\t\too++;\n\t\t}\n\t\tdian anss=query(1,1,tot,a[i].r);\n\t\tif(anss.val*(ls[a[i].r]-ls[a[i].l])>ans)\n\t\t{\n\t\t\tans=anss.val*(ls[a[i].r]-ls[a[i].l]);\n\t\t\tansa=a[i].id;\n\t\t\tansb=anss.rt;\n\t\t}\n\t}\n\tif(!ans)  puts(\"0\");\n\telse\n\t{\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\",ansa,ansb);\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.Scanner;\nimport java.util.Math;\n\npublic class GoodNumbers {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tint numOfQuery = scan.nextInt();\t\t\t\t\n\t\tint[] res = new int[numOfQuery];\n\t\t\t\t\n\t\tfor(int i=0;i<numOfQuery;i++) {\n\t\t\t// input\n\t\t\tint n = scan.nextInt();\n\t\t\tloop:\n\t\t\tfor(int x = n; x<Math.pow(10, 5);x++) {\n\t\t\t\tint tmpX = x;\n\t\t\t\tfor(int k = 9;k>=0;k--) {\n\t\t\t\t\tif(tmpX < Math.pow(3, k)) continue;\n\t\t\t\t\ttmpX -= Math.pow(3, k);\n\t\t\t\t\tif(tmpX == 0) { \n\t\t\t\t\t\tres[i] = x;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int x: res)\n\t\t\tSystem.out.println(x);\n\t}\n\n}\n",
        "fixed_code": "import java.util.Scanner;\nimport java.lang.Math;\n\npublic class GoodNumbers {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tint numOfQuery = scan.nextInt();\t\t\t\t\n\t\tint[] res = new int[numOfQuery];\n\t\t\t\t\n\t\tfor(int q=0;q<numOfQuery;q++) {\n\t\t\t// input\n\t\t\tint n = scan.nextInt();\n\t\t\t\n\t\t\tint num = n;\n\t\t\tint[] tri = new int[10];\n\t\t\tint countOfOverOne = 0;\n\t\t\tfor(int i=0;i<tri.length;i++) {\n\t\t\t\ttri[i] = num % 3;\n\t\t\t\tif(tri[i] > 1) countOfOverOne++;\n\t\t\t\tnum /= 3;\n\t\t\t}\n\t\t\t\n\t\t\tint goodNumber = 0;\n\t\t\tint transfer = 0;\n\t\t\tint maxIdx = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<tri.length;i++) {\n\t\t\t\tif(tri[i] + transfer >= 2) {\n\t\t\t\t\ttri[i] = 0;\n\t\t\t\t\ttransfer = 1;\n\t\t\t\t\tmaxIdx = Math.max(maxIdx, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttri[i] += transfer;\n\t\t\t\t\ttransfer = 0;\n\t\t\t\t}\n\t\t\t\tgoodNumber += (int)Math.pow(3, i)*tri[i];\n\t\t\t}\n\t\t\tif(countOfOverOne>0) \n\t\t\t\tfor(int i=0;i<=maxIdx;i++)\n\t\t\t\t\tgoodNumber -= (int)Math.pow(3, i)*tri[i];\n\t\t\t\n\t\t\tres[q] = goodNumber;\n\t\t}\n\t\t\n\t\tfor(int x: res)\n\t\t\tSystem.out.println(x);\n\t}\n\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void saveModel(org.eclipse.vorto.core.api.model.model.Model model) throws org.eclipse.vorto.core.api.repository.CheckInModelException {\n    java.util.Objects.requireNonNull(model);\n    try {\n        org.apache.http.entity.mime.MultipartEntityBuilder builder = org.apache.http.entity.mime.MultipartEntityBuilder.create();\n        builder.addBinaryBody(org.eclipse.vorto.repository.RestModelRepository.FILE_PARAMETER_NAME, modelToXMIConverter.apply(model), ContentType.APPLICATION_OCTET_STREAM, \"\");\n        org.apache.http.HttpEntity fileToUpload = builder.build();\n        org.apache.http.client.fluent.Content responseContent = org.apache.http.client.fluent.Request.Post(getUrlForUpload()).addHeader(createSecurityHeader()).body(fileToUpload).execute().returnContent();\n        org.eclipse.vorto.repository.model.UploadResult uploadResult = uploadResponseConverter.apply(responseContent.asString());\n        if (uploadResult.statusOk()) {\n            org.apache.http.client.fluent.Request.Put(getUrlForCheckin(uploadResult.getHandleId())).addHeader(createSecurityHeader());\n        }else {\n            throw new org.eclipse.vorto.core.api.repository.CheckInModelException(uploadResult.getErrorMessage());\n        }\n        setChanged();\n        notifyObservers(uploadResult);\n    } catch (java.lang.Exception e) {\n        throw new org.eclipse.vorto.core.api.repository.CheckInModelException(\"Error in uploading file to remote repository\", e);\n    }\n}",
        "fixed_code": "@java.lang.Override\npublic void saveModel(org.eclipse.vorto.core.api.model.model.Model model) throws org.eclipse.vorto.core.api.repository.CheckInModelException {\n    java.util.Objects.requireNonNull(model);\n    try {\n        org.apache.http.entity.mime.MultipartEntityBuilder builder = org.apache.http.entity.mime.MultipartEntityBuilder.create();\n        builder.addBinaryBody(org.eclipse.vorto.repository.RestModelRepository.FILE_PARAMETER_NAME, modelToXMIConverter.apply(model), ContentType.APPLICATION_OCTET_STREAM, \"\");\n        org.apache.http.HttpEntity fileToUpload = builder.build();\n        org.apache.http.client.fluent.Content responseContent = org.apache.http.client.fluent.Request.Post(getUrlForUpload()).body(fileToUpload).execute().returnContent();\n        org.eclipse.vorto.repository.model.UploadResult uploadResult = uploadResponseConverter.apply(responseContent.asString());\n        if (uploadResult.statusOk()) {\n            org.apache.http.client.fluent.Request.Put(getUrlForCheckin(uploadResult.getHandleId())).execute();\n        }else {\n            throw new org.eclipse.vorto.core.api.repository.CheckInModelException(uploadResult.getErrorMessage());\n        }\n        setChanged();\n        notifyObservers(uploadResult);\n    } catch (java.lang.Exception e) {\n        throw new org.eclipse.vorto.core.api.repository.CheckInModelException(\"Error in uploading file to remote repository\", e);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "private java.util.Map<java.lang.String, java.lang.Object> getConfig(java.lang.String businessMethod) throws pers.roamer.boracay.BoracayException {\n    if (org.springframework.util.StringUtils.isEmpty(businessMethod)) {\n        throw new pers.roamer.boracay.BoracayException(\"无效的业务请求\");\n    }\n    java.lang.String method = ((pers.roamer.boracay.controller.SmsController.BUSINESS_METHOD_PERFIX) + \".\") + businessMethod;\n    java.lang.String opid = pers.roamer.boracay.configer.ConfigHelper.getConfig().getString((method + \".Opid\"));\n    long duration = pers.roamer.boracay.configer.ConfigHelper.getConfig().getLong((method + \".Duration\"));\n    int length = pers.roamer.boracay.configer.ConfigHelper.getConfig().getInt((method + \".Length\"));\n    java.lang.String text = pers.roamer.boracay.configer.ConfigHelper.getConfig().getString((method + \".Text\"));\n    java.util.Map<java.lang.String, java.lang.Object> map = new java.util.HashMap<>();\n    map.put(\"method\", businessMethod);\n    map.put(\"opid\", opid);\n    map.put(\"length\", length);\n    map.put(\"duration\", duration);\n    map.put(\"text\", text);\n    return map;\n}",
        "fixed_code": "private java.util.Map<java.lang.String, java.lang.Object> getConfig(java.lang.String businessMethod) throws pers.roamer.boracay.BoracayException {\n    if (org.springframework.util.StringUtils.isEmpty(businessMethod)) {\n        throw new pers.roamer.boracay.BoracayException(\"无效的业务请求\");\n    }\n    java.lang.String method = ((pers.roamer.boracay.controller.SmsController.BUSINESS_METHOD_PERFIX) + \".\") + businessMethod;\n    long duration = pers.roamer.boracay.configer.ConfigHelper.getConfig().getLong((method + \".Duration\"));\n    int length = pers.roamer.boracay.configer.ConfigHelper.getConfig().getInt((method + \".Length\"));\n    java.lang.String text = pers.roamer.boracay.configer.ConfigHelper.getConfig().getString((method + \".Text\"));\n    java.util.Map<java.lang.String, java.lang.Object> map = new java.util.HashMap<>();\n    map.put(\"method\", businessMethod);\n    map.put(\"length\", length);\n    map.put(\"duration\", duration);\n    map.put(\"text\", text);\n    return map;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    bigrams = input().split()\n    word = bigrams[0]\n    for j in bigrams:\n        word += j[1] if word[-1] == j[0] else j\n    print(word.ljust(n, \"a\"))\n",
        "fixed_code": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    bigrams = input().split()\n    word = bigrams[0]\n    for j in bigrams[1:]:\n        word += j[1] if word[-1] == j[0] else j\n    print(word.ljust(n, \"a\"))\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "@java.lang.Override\npublic boolean canBeRidden() {\n    if (((isLocomotive()) || (isPassenger())) || (isWorkCart())) {\n        return true;\n    }\n    return false;\n}",
        "fixed_code": "@java.lang.Override\npublic boolean canBeRidden() {\n    return ((isLocomotive()) || (isPassenger())) || (isWorkCart());\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@java.lang.SuppressWarnings(value = \"deprecation\")\n@java.lang.Override\npublic void stopTransaction(final com.tinkerpop.blueprints.impls.orient.Conclusion conclusion) {\n    final com.tinkerpop.blueprints.impls.orient.OrientGraphContext context = getContext(false);\n    if (((context.rawGraph.isClosed()) || ((context.rawGraph.getTransaction()) instanceof com.orientechnologies.orient.core.tx.OTransactionNoTx)) || ((context.rawGraph.getTransaction().getStatus()) != (com.orientechnologies.orient.core.tx.OTransaction.TXSTATUS.BEGUN)))\n        return ;\n    \n    if ((Conclusion.SUCCESS) == conclusion)\n        commit();\n    else\n        rollback();\n    \n}",
        "fixed_code": "@java.lang.SuppressWarnings(value = \"deprecation\")\n@java.lang.Override\npublic void stopTransaction(final com.tinkerpop.blueprints.impls.orient.Conclusion conclusion) {\n    final com.tinkerpop.blueprints.impls.orient.OrientGraphContext context = getContext(false);\n    if (context == null)\n        return ;\n    \n    if (((context.rawGraph.isClosed()) || ((context.rawGraph.getTransaction()) instanceof com.orientechnologies.orient.core.tx.OTransactionNoTx)) || ((context.rawGraph.getTransaction().getStatus()) != (com.orientechnologies.orient.core.tx.OTransaction.TXSTATUS.BEGUN)))\n        return ;\n    \n    if ((Conclusion.SUCCESS) == conclusion)\n        commit();\n    else\n        rollback();\n    \n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@java.lang.Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((board) == null ? 0 : board.hashCode());\n    result = (prime * result) + (endingPosition);\n    result = (prime * result) + ((jumpedPositions) == null ? 0 : jumpedPositions.hashCode());\n    result = (prime * result) + ((piece) == null ? 0 : piece.hashCode());\n    result = (prime * result) + (startingPosition);\n    result = (prime * result) + ((subJumps) == null ? 0 : subJumps.hashCode());\n    return result;\n}",
        "fixed_code": "@java.lang.Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = (prime * result) + ((this.board) == null ? 0 : this.board.hashCode());\n    result = (prime * result) + (this.endingPosition);\n    result = (prime * result) + ((this.jumpedPositions) == null ? 0 : this.jumpedPositions.hashCode());\n    result = (prime * result) + ((this.piece) == null ? 0 : this.piece.hashCode());\n    result = (prime * result) + (this.startingPosition);\n    result = (prime * result) + ((this.subJumps) == null ? 0 : this.subJumps.hashCode());\n    return result;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define F first\n#define S second\n\nint main()\n{\n    int n , m , i , j , k, cnt = 0;\n    scanf(\"%d %d\",&n,&m);\n\n    vector<pii> edge;\n\n    for(i = 1 ; i <= n && cnt < m ; i++)\n    {\n        for(j = i+1 ; j <= n ; j++)\n        {\n            k = __gcd(i,j);\n            if(k == 1)\n            {\n                cnt++;\n                edge.push_back(mp(i,j));\n            }\n        }\n    }\n    if(cnt < m) return !printf(\"Impossible\\n\");\n    printf(\"Possible\\n\");\n    for(i = 0 ; i < m ; i++) printf(\"%d %d\\n\",edge[i].F,edge[i].S);\n\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define F first\n#define S second\n\nint main()\n{\n    int n , m , i , j , k, cnt = 0;\n    scanf(\"%d %d\",&n,&m);\n\n    vector<pii> edge;\n\n    for(i = 1 ; i <= n && cnt < m ; i++)\n    {\n        for(j = i+1 ; j <= n ; j++)\n        {\n            k = __gcd(i,j);\n            if(k == 1)\n            {\n                cnt++;\n                edge.push_back(mp(i,j));\n            }\n        }\n    }\n    if(cnt < m || (n-1) > m) return !printf(\"Impossible\\n\");\n    printf(\"Possible\\n\");\n    for(i = 0 ; i < m ; i++) printf(\"%d %d\\n\",edge[i].F,edge[i].S);\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "// Problem : D. Ticket Game\n// Contest : Codeforces - Codeforces Round #585 (Div. 2)\n// URL : https://codeforces.com/problemset/problem/1215/D\n// Memory Limit : 256 MB\n// Time Limit : 1000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include <bits/stdc++.h>\n#define XOX\n#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\nusing namespace std;\n\n#define int long long\n#define re return\n#define beg() begin()\n#define cont continue\n#define ldb long double\n#define db double\n\n#define br break\n#define fr first\n#define se second\n#define lb lower_bound\n#define ub upper_bound\n#define pb push_back\n#define mkp make_pair\n\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pdb pair<db,db>\n#define pldb pair<ldb,ldb>\n\n#define vi vector<int>\n#define vll vector<ll>\n#define vdb vector<db>\n#define vldb vector<ldb>\n#define vpi vector< pi >\n#define vpll vector< pll >\n\n#define mi map<int,int>\n#define mdb map<db,db>\n#define mldb map<ldb,ldb>\n\n#define si set<int>\n#define sdb set<db>\n#define sldb set<ldb>\n\n#define test int t; cin>>t; while(t--)\n#define scan() int n; cin>>n; int a[n]; for(int i=0;i<n;i++) cin>>a[i]\n#define scan2() int n,k; cin>>n>>k; int a[n]; for(int i=0;i<n;i++) cin>>a[i]\n#define print(a,n) for(int i=0;i<n;i++) cout<<a[i]<<' '\n#define mem(a,v) memset(a,v,sizeof(a))\n#define srt(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define cn(x) cout<<x<<\"\\n\"\n#define cs(x) cout<<x<<\" \"\n#define c(x) cout<<x\n#define all(v) v.begin(),v.end()\n\n#define forr(i,a,b) for (int i = (a); i < (b); ++i)\n#define rrof(i,a,b) for (int i = (b)-1; i >= (a); --i)\n\n\nconst int MOD = 1e9+7;\nconst ldb PI = 4*atan((ldb)1);\nconst int INF = 1e18;\nconst int NINF = -1e18;\n\nint get_hash(string s){\n\tint N=1000001;\n\tint base[N],A=11,MD=1110111110111;\n\tbase[0]=1;\n\n\tforr(i,1,N)\n\tbase[i]=(base[i-1]*A)%MD;\n\n\tint hs=0;\n\tforr(i,0,s.size()){\n\t\ths+=(s[i]*base[i]);\n\t\ths%=MD;\n\t}\n\n\tre hs;\n}\n\nint power(int a,int n){\n\tint res=1;\n\n\twhile(n){\n\t\tif(n%2)\n\t\tres*=a;\n\t\ta*=a;\n\t\tn/=2;\n\t}\n\n\treturn res;\n}\n\nvector<string> vec_splitter(string s) {\n\ts += ',';\n\tvector<string> res;\n\twhile(!s.empty()) {\n\t\tres.push_back(s.substr(0, s.find(',')));\n\t\ts = s.substr(s.find(',') + 1);\n\t}\n\treturn res;\n}\nvoid debug_out(\n\tvector<string> __attribute__ ((unused)) args,\n\t__attribute__ ((unused)) int idx,\n\t__attribute__ ((unused)) int LINE_NUM) { cerr << endl; }\n\ttemplate <typename Head, typename... Tail>\n\tvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\n\tif(idx > 0) cerr << \", \"; else cerr << \"Line(\" << LINE_NUM << \") \";\n\tstringstream ss; ss << H;\n\tcerr << args[idx] << \" = \" << ss.str();\n\tdebug_out(args, idx + 1, LINE_NUM, T...);\n}\n#ifdef XOX\n#define debug(...) debug_out(vec_splitter(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n\nint32_t main(){\n\tfast;\n\t\n\tint n;\n\tcin>>n;\n\t\n\tstring s;\n\tcin>>s;\n\t\n\tvi v1,v2;\n\tforr(i,0,n/2){\n\t\tif(s[i]!='?')\n\t\tv1.pb(s[i]-'0');\n\t}\n\t\n\tforr(i,n/2,n){\n\t\tif(s[i]!='?')\n\t\tv2.pb(s[i]-'0');\n\t}\n\t\n\tint sum1=0,sum2=0;\n\tforr(i,0,v1.size())\n\tsum1+=v1[i];\n\t\n\tforr(i,0,v2.size())\n\tsum2+=v2[i];\n\t\n\tint x=n/2;\n\t// cs(sum1);cs(sum2);\n\tif(sum1>sum2){\n\t\tint d1=x-v1.size();\n\t\tint s1=sum1+(d1/2)*9;\n\t\tint s2=sum1+ceil(d1/2.0)*9;\n\t\t\n\t\tint diff1=s1-sum2,diff2=s2-sum2;\n\t\tint d2=x-v2.size();\n\t\td2=ceil(d2/2.0);\n\t\t\n\t\tif(diff1>d2*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff2>d2*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tc(\"Bicarp\");\n\t\t\tre 0;\n\t\t}\n\t}\n\t\n\telse if(sum2>sum1){\n\t\tint d2=x-v2.size();\n\t\tint s1=sum2+(d2/2)*9;\n\t\tint s2=sum2+ceil(d2/2.0)*9;\n\t\t\n\t\tint diff1=s1-sum1,diff2=s2-sum1;\t\n\t\tint d1=x-v1.size();\n\t\td1=ceil(d1/2.0);\n\t\t\n\t\tif(diff1>d1*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff2>d1*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tc(\"Bicarp\");\n\t\t\tre 0;\n\t\t}\n\t}\n\t\n\telse{\n\t\tint d1=x-v1.size();\n\t\tint d2=x-v2.size();\n\t\t\n\t\tif(d1==d2){\n\t\t\tc(\"Bicarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t}\n\t\n\tre 0;\n}",
        "fixed_code": "// Problem : D. Ticket Game\n// Contest : Codeforces - Codeforces Round #585 (Div. 2)\n// URL : https://codeforces.com/problemset/problem/1215/D\n// Memory Limit : 256 MB\n// Time Limit : 1000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include <bits/stdc++.h>\n#define XOX\n#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\nusing namespace std;\n\n#define int long long\n#define re return\n#define beg() begin()\n#define cont continue\n#define ldb long double\n#define db double\n\n#define br break\n#define fr first\n#define se second\n#define lb lower_bound\n#define ub upper_bound\n#define pb push_back\n#define mkp make_pair\n\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pdb pair<db,db>\n#define pldb pair<ldb,ldb>\n\n#define vi vector<int>\n#define vll vector<ll>\n#define vdb vector<db>\n#define vldb vector<ldb>\n#define vpi vector< pi >\n#define vpll vector< pll >\n\n#define mi map<int,int>\n#define mdb map<db,db>\n#define mldb map<ldb,ldb>\n\n#define si set<int>\n#define sdb set<db>\n#define sldb set<ldb>\n\n#define test int t; cin>>t; while(t--)\n#define scan() int n; cin>>n; int a[n]; for(int i=0;i<n;i++) cin>>a[i]\n#define scan2() int n,k; cin>>n>>k; int a[n]; for(int i=0;i<n;i++) cin>>a[i]\n#define print(a,n) for(int i=0;i<n;i++) cout<<a[i]<<' '\n#define mem(a,v) memset(a,v,sizeof(a))\n#define srt(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define cn(x) cout<<x<<\"\\n\"\n#define cs(x) cout<<x<<\" \"\n#define c(x) cout<<x\n#define all(v) v.begin(),v.end()\n\n#define forr(i,a,b) for (int i = (a); i < (b); ++i)\n#define rrof(i,a,b) for (int i = (b)-1; i >= (a); --i)\n\n\nconst int MOD = 1e9+7;\nconst ldb PI = 4*atan((ldb)1);\nconst int INF = 1e18;\nconst int NINF = -1e18;\n\nint get_hash(string s){\n\tint N=1000001;\n\tint base[N],A=11,MD=1110111110111;\n\tbase[0]=1;\n\n\tforr(i,1,N)\n\tbase[i]=(base[i-1]*A)%MD;\n\n\tint hs=0;\n\tforr(i,0,s.size()){\n\t\ths+=(s[i]*base[i]);\n\t\ths%=MD;\n\t}\n\n\tre hs;\n}\n\nint power(int a,int n){\n\tint res=1;\n\n\twhile(n){\n\t\tif(n%2)\n\t\tres*=a;\n\t\ta*=a;\n\t\tn/=2;\n\t}\n\n\treturn res;\n}\n\nvector<string> vec_splitter(string s) {\n\ts += ',';\n\tvector<string> res;\n\twhile(!s.empty()) {\n\t\tres.push_back(s.substr(0, s.find(',')));\n\t\ts = s.substr(s.find(',') + 1);\n\t}\n\treturn res;\n}\nvoid debug_out(\n\tvector<string> __attribute__ ((unused)) args,\n\t__attribute__ ((unused)) int idx,\n\t__attribute__ ((unused)) int LINE_NUM) { cerr << endl; }\n\ttemplate <typename Head, typename... Tail>\n\tvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\n\tif(idx > 0) cerr << \", \"; else cerr << \"Line(\" << LINE_NUM << \") \";\n\tstringstream ss; ss << H;\n\tcerr << args[idx] << \" = \" << ss.str();\n\tdebug_out(args, idx + 1, LINE_NUM, T...);\n}\n#ifdef XOX\n#define debug(...) debug_out(vec_splitter(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n\nint32_t main(){\n\tfast;\n\t\n\tint n;\n\tcin>>n;\n\t\n\tstring s;\n\tcin>>s;\n\t\n\tvi v1,v2;\n\tforr(i,0,n/2){\n\t\tif(s[i]!='?')\n\t\tv1.pb(s[i]-'0');\n\t}\n\t\n\tforr(i,n/2,n){\n\t\tif(s[i]!='?')\n\t\tv2.pb(s[i]-'0');\n\t}\n\t\n\tint sum1=0,sum2=0;\n\tforr(i,0,v1.size())\n\tsum1+=v1[i];\n\t\n\tforr(i,0,v2.size())\n\tsum2+=v2[i];\n\t\n\tint x=n/2;\n\t// cs(sum1);cs(sum2);\n\tif(sum1>sum2){\n\t\tint d1=x-v1.size();\n\t\tint s1=sum1+(d1/2)*9;\n\t\tint s2=sum1+ceil(d1/2.0)*9;\n\t\t\n\t\tint diff1=s1-sum2,diff2=s2-sum2;\n\t\tint d2=x-v2.size();\n\t\t\n\t\tint d2B=ceil(d2/2.0);\n\t\tint d2M=d2/2;\n\t\t\n\t\tif(diff1>d2B*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff2>d2B*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff1<d2M*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff2<d2M*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tc(\"Bicarp\");\n\t\t\tre 0;\n\t\t}\n\t}\n\t\n\telse if(sum2>sum1){\n\t\tint d2=x-v2.size();\n\t\tint s1=sum2+(d2/2)*9;\n\t\tint s2=sum2+ceil(d2/2.0)*9;\n\t\t\n\t\tint diff1=s1-sum1,diff2=s2-sum1;\t\n\t\tint d1=x-v1.size();\n\t\t\n\t\tint d1B=ceil(d1/2.0);\n\t\tint d1M=d1/2;\n\t\t\n\t\tif(diff1>d1B*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff2>d1B*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff1<d1M*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse if(diff2<d1M*9){\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tc(\"Bicarp\");\n\t\t\tre 0;\n\t\t}\n\t}\n\t\n\telse{\n\t\tint d1=x-v1.size();\n\t\tint d2=x-v2.size();\n\t\t\n\t\tif(d1==d2){\n\t\t\tc(\"Bicarp\");\n\t\t\tre 0;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tc(\"Monocarp\");\n\t\t\tre 0;\n\t\t}\n\t}\n\t\n\tre 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic void manageEvent(java.awt.event.ActionEvent event) {\n    java.lang.String name = ((javax.swing.JComponent) (event.getSource())).getName();\n    if (((name.equals(\"okContatti\")) || (name.endsWith(\"okComandi\"))) && (grigliaPresente)) {\n        transition(GIOCA);\n    }else\n        if (((name.equals(\"okContatti\")) || (name.endsWith(\"okComandi\"))) && (!(grigliaPresente))) {\n            transition(RELAX);\n        }\n    \n}",
        "fixed_code": "@java.lang.Override\npublic void manageEvent(java.awt.event.ActionEvent event) {\n    java.lang.String name = ((javax.swing.JComponent) (event.getSource())).getName();\n    if (((name.equals(\"okContatti\")) || (name.endsWith(\"okComandi\"))) && (grigliaPresente)) {\n        transition(GIOCA);\n    }else\n        if (((name.equals(\"okContatti\")) || (name.endsWith(\"okComandi\"))) && (!(grigliaPresente))) {\n            transition(RELAX);\n        }else\n            super.manageEvent(event);\n        \n    \n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nint k, n,i,b,x,a,c,m,d,y;\nset <char> se;\nset <set<char> > sed;\nset <int> ::iterator it;\nstring str;\nmain (){\ncin>>n;\nfor(i=0; i<n; i++){\n    cin>>str;\n\n    for(x=0; x<str.size(); x++)\n        se.insert(str[x]);\n sed.insert(se);\n    }\n    y=sed.size();\n\n\ncout<<y;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nint k, n,i,b,x,a,c,m,d,y;\nset <char> se;\nset <set<char> > sed;\nset <int> ::iterator it;\nstring str;\nmain (){\ncin>>n;\nfor(i=0; i<n; i++){\n    cin>>str;\nse.clear();\n    for(x=0; x<str.size(); x++)\n        se.insert(str[x]);\n sed.insert(se);\n    }\n    y=sed.size();\n\n\ncout<<y;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n\n\n\n#define mod 1000000007\n\nll F[100005];\nll invF[100005];\nll two[100005];\nint a[100005];\nint n;\n\nll Pow(ll x, int y){\n\tll r = 1;\n\twhile( y ){\n\t\tif( y & 1 ) r = r * x % mod;\n\t\tx = x * x % mod;\n\t\ty /= 2;\n\t}return r;\n}\nll nCr(int r,int n){return F[n] * invF[r] %mod * invF[n-r] % mod; }\n\nll calc(int s,int e){\n\n\tint L , R;\n\tfor( L = s ; a[L] == 0 && L <= e ; L ++ );\n\tfor( R = e ; a[R] == 0 && R >= s ; R -- );\n\n\tif( L == e + 1 )return two[ e - s ];\n\n\tll r = 0;\n\n\n\tif( L == R && a[L] == 1)return nCr( L-s, L-s + e-R );\n\n\tif( a[L] >= a[R] ){\n\t\tint ns = L + 1;\n\t\tint ne = ns + a[L] - 2;\n\n\t\tr = (r + calc( ns , ne ) * nCr( L-s , L-s + e - R - a[L] + 2) ) % mod;\n\t}\n\n\tif( a[L] <= a[R] ){\n\t\tint ne = R - 1;\n\t\tint ns = ne - a[R] + 2;\n\t\t\n\t\tr = ( r + calc( ns , ne ) * nCr( L-s , L-s + e - R - a[R] + 2 ) ) % mod;\n\t}\n\n\treturn r;\n}\n\nint main(){\n\n\ttwo[0] = 1;\n\tF[0] = 1;\n\tinvF[0] = 1;\n\n\tfor(int i = 1 ; i <= 100000 ; i ++ ){\n\t\ttwo[i] = two[i-1] * 2 %mod;\n\t\tF[i] = F[i-1] * i % mod;\n\t\tinvF[i] = Pow( F[i], mod-2 );\n\t}\n\n\tscanf(\"%d\",&n);\n\tfor(int i = 0 ; i < n ; i ++ )scanf(\"%d\",a+i);\n\n\tcout<< calc( 0 , n - 1 );\n}",
        "fixed_code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n\n\n\n#define mod 1000000007\n\nll F[100005];\nll invF[100005];\nll two[100005];\nint a[100005];\nint n;\n\nll Pow(ll x, int y){\n\tll r = 1;\n\twhile( y ){\n\t\tif( y & 1 ) r = r * x % mod;\n\t\tx = x * x % mod;\n\t\ty /= 2;\n\t}return r;\n}\nll nCr(int r,int n){return F[n] * invF[r] %mod * invF[n-r] % mod; }\n\nll calc(int s,int e){\n\n\tint L , R;\n\tfor( L = s ; a[L] == 0 && L <= e ; L ++ );\n\tfor( R = e ; a[R] == 0 && R >= s ; R -- );\n\n\tif( L == e + 1 )return two[ e - s ];\n\n\tll r = 0;\n\n\n\tif( L == R && a[L] == 1)return nCr( L-s, L-s + e-R );\n\n\tif( a[L] >= a[R] ){\n\t\tint ns = L + 1;\n\t\tint ne = ns + a[L] - 2;\n\n\n\t\tif( R<= ne  && ne <= e)\n\t\tr = (r + calc( ns , ne ) * nCr( L-s , e - s + 1 - a[L]) ) % mod;\n\t}\n\n\tif( a[L] <= a[R] ){\n\t\tint ne = R - 1;\n\t\tint ns = ne - a[R] + 2;\n\t\t\n\t\tif( s <= ns && ns <= L )\n\t\tr = ( r + calc( ns , ne ) * nCr( e - R , e - s + 1 - a[R] ) ) % mod;\n\t}\n\n\treturn r;\n}\n\nint main(){\n\n\ttwo[0] = 1;\n\tF[0] = 1;\n\tinvF[0] = 1;\n\n\tfor(int i = 1 ; i <= 100000 ; i ++ ){\n\t\ttwo[i] = two[i-1] * 2 %mod;\n\t\tF[i] = F[i-1] * i % mod;\n\t\tinvF[i] = Pow( F[i], mod-2 );\n\t}\n\n\tscanf(\"%d\",&n);\n\tfor(int i = 0 ; i < n ; i ++ )scanf(\"%d\",a+i);\n\n\tcout<< calc( 0 , n - 1 );\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import sys\nLI=lambda:list(map(int, sys.stdin.readline().strip('\\n').split()))\nMI=lambda:map(int, sys.stdin.readline().strip('\\n').split())\nSI=lambda:sys.stdin.readline().strip('\\n')\nII=lambda:int(sys.stdin.readline().strip('\\n'))\n\nfor _ in range(II()):\n\tdone={}\n\tx, y, ans=0, 0, 0\n\tfor c in SI():\n\t\txx, yy=x, y\n\t\tif c=='N':\n\t\t\tyy+=1\n\t\telif c=='S':\n\t\t\tyy-=1\n\t\telif c=='W':\n\t\t\txx-=1\n\t\telse:\n\t\t\txx+=1\n\t\tp=str(x)+str(y)+str(xx)+str(yy)\n\t\tpp=str(xx)+str(yy)+str(x)+str(y)\n\t\tif done.get(p, False) or done.get(pp, False):\n\t\t\tans+=1\n\t\telse:\n\t\t\tans+=5\n\t\tdone[p]=done[pp]=True\n\t\tx, y=xx, yy\n\tprint(ans)",
        "fixed_code": "import sys\nLI=lambda:list(map(int, sys.stdin.readline().strip('\\n').split()))\nMI=lambda:map(int, sys.stdin.readline().strip('\\n').split())\nSI=lambda:sys.stdin.readline().strip('\\n')\nII=lambda:int(sys.stdin.readline().strip('\\n'))\n\nfor _ in range(II()):\n\tdone={}\n\tx, y, ans=0, 0, 0\n\tfor c in SI():\n\t\txx, yy=x, y\n\t\tif c=='N':\n\t\t\tyy+=1\n\t\telif c=='S':\n\t\t\tyy-=1\n\t\telif c=='W':\n\t\t\txx-=1\n\t\telse:\n\t\t\txx+=1\n\t\tp=str(x)+str(',')+str(y)+'-'+str(xx)+str(',')+str(yy)\n\t\tpp=str(xx)+str(',')+str(yy)+'-'+str(x)+str(',')+str(y)\n\t\tif done.get(p, False) or done.get(pp, False):\n\t\t\tans+=1\n\t\telse:\n\t\t\tans+=5\n\t\tdone[p]=done[pp]=True\n\t\tx, y=xx, yy\n\tprint(ans)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "@javax.ejb.TransactionAttribute(value = javax.ejb.TransactionAttributeType.REQUIRED)\npublic void addAccountLink(java.lang.String userId, gov.medicaid.entities.ExternalAccountLink link) throws gov.medicaid.services.PortalServiceException {\n    gov.medicaid.entities.ExternalAccountLink existing = findAccountLink(userId, link.getSystemId(), link.getExternalUserId());\n    if (existing == null) {\n        link.setId(getSequence().getNextValue(Sequences.ACOUNT_LINK_SEQ));\n        link.setUserId(userId);\n        getEm().persist(link);\n        auditNewAccountLink(userId, link);\n    }\n}",
        "fixed_code": "@javax.ejb.TransactionAttribute(value = javax.ejb.TransactionAttributeType.REQUIRED)\npublic void addAccountLink(java.lang.String userId, gov.medicaid.entities.ExternalAccountLink link) throws gov.medicaid.services.PortalServiceException {\n    gov.medicaid.entities.ExternalAccountLink existing = findAccountLink(userId, link.getSystemId(), link.getExternalUserId());\n    if (existing == null) {\n        link.setId(0);\n        link.setUserId(userId);\n        getEm().persist(link);\n        auditNewAccountLink(userId, link);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF2 solver = new TaskF2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF2 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int r = in.nextInt();\n            TaskF2.Project[] a = new TaskF2.Project[n];\n            List<TaskF2.Project> positive = new ArrayList<>();\n            List<TaskF2.Project> negative = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                int rating = in.nextInt();\n                int change = in.nextInt();\n                if (change < 0) {\n                    negative.add(new TaskF2.Project(rating, change));\n                } else {\n                    positive.add(new TaskF2.Project(rating, change));\n                }\n            }\n            int res = 0;\n            positive.sort((x, y) -> {\n                if (x.rating == y.rating) {\n                    return y.change - x.change;\n                }\n                return x.rating - y.rating;\n            });\n            for (int i = 0; i < positive.size(); ++i) {\n                if (r < positive.get(i).rating) {\n                    continue;\n                }\n                r += positive.get(i).change;\n                ++res;\n            }\n            negative.sort((x, y) -> {\n                int aRating = Math.max(x.rating, -x.change);\n                int bRating = Math.max(y.rating, -y.change);\n                return Integer.compare(bRating + y.change, aRating + x.change);\n            });\n            for (int i = 0; i < negative.size(); ++i) {\n                if (r < negative.get(i).rating || r + negative.get(i).change < 0) {\n                    continue;\n                }\n                r += negative.get(i).change;\n                ++res;\n            }\n            out.println(res);\n        }\n\n        static class Project {\n            int rating;\n            int change;\n\n            public Project(int rating, int change) {\n                this.rating = rating;\n                this.change = change;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream), 2444334);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",
        "fixed_code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF2 solver = new TaskF2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF2 {\n        private static final int INF = (int) 1e8;\n        int[][] mem;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int r = in.nextInt();\n            mem = new int[n][60009];\n            for (int[] x : mem) Arrays.fill(x, -1);\n            TaskF2.Project[] a = new TaskF2.Project[n];\n            List<TaskF2.Project> positive = new ArrayList<>();\n            List<TaskF2.Project> negative = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                int rating = in.nextInt();\n                int change = in.nextInt();\n                if (change < 0) {\n                    negative.add(new TaskF2.Project(rating, change));\n                } else {\n                    positive.add(new TaskF2.Project(rating, change));\n                }\n            }\n            positive.sort((x, y) -> {\n                if (x.rating == y.rating) {\n                    return y.change - x.change;\n                }\n                return x.rating - y.rating;\n            });\n            negative.sort((x, y) -> {\n                int aRating = Math.max(x.rating, -x.change);\n                int bRating = Math.max(y.rating, -y.change);\n                return Integer.compare(bRating + y.change, aRating + x.change);\n            });\n            int idx = 0;\n            for (int i = 0; i < positive.size(); ++i) {\n                a[idx++] = positive.get(i);\n            }\n            for (int i = 0; i < negative.size(); ++i) {\n                a[idx++] = negative.get(i);\n            }\n            int res = dpSolve(0, r, a);\n            out.println(res);\n        }\n\n        private int dpSolve(int idx, int r, TaskF2.Project[] a) {\n            if (r < 0) return -INF;\n            if (idx >= a.length) return 0;\n            if (mem[idx][r] != -1) return mem[idx][r];\n            int res = dpSolve(idx + 1, r, a);\n            if (r >= a[idx].rating && r + a[idx].change >= 0) {\n                res = Math.max(res, 1 + dpSolve(idx + 1, r + a[idx].change, a));\n            }\n            mem[idx][r] = res;\n            return res;\n        }\n\n        static class Project {\n            int rating;\n            int change;\n\n            public Project(int rating, int change) {\n                this.rating = rating;\n                this.change = change;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream), 2444334);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define pii pair<int, int>\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nint n, m;\nint cnt[2][305][305], Cnt[2][305][305];\nstring st[305][305], ed[305][305];\nint l[305][305], L[305][305];\npair<pii, pii> ans1[400005], ans2[400005];\nint tot1, tot2;\nvoid mv1(int x, int y, int xx, int yy, int val)\n{\n\tcnt[val][x][y]--, cnt[val][xx][yy]++;\n\tans1[++tot1] = mp(mp(x, y), mp(xx, yy));\n}\nvoid mv2(int x, int y, int xx, int yy, int val)\n{\n\tCnt[val][x][y]--, Cnt[val][xx][yy]++;\n\tans2[++tot2] = mp(mp(xx, yy), mp(x, y));\n}\nvoid work2()\n{\n\ttot1 = tot2 = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint nxt = i % n + 1, q0q = 0, q1q = 0;\n\t\tfor (int k = l[i][1] - 1; k >= 0; k--)\n\t\t\tif (st[i][1][k] == '0') mv1(i, 1, nxt, 1, 0), q0q++;\n\t\t\telse mv1(i, 1, i, m, 1);\n\t\tfor (int k = l[i][m] - 1; k >= 0; k--)\n\t\t\tif (st[i][m][k] == '0') mv1(i, m, i, 1, 0);\n\t\t\telse mv1(i, m, nxt, m, 1), q1q++;\n\t\tfor (int j = 2; j < m; j++)\n\t\t\tfor (int k = l[i][j] - 1; k >= 0; k--)\n\t\t\t\tif (st[i][j][k] == '0') mv1(i, j, i, 1, 0);\n\t\t\t\telse mv1(i, j, i, m, 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint nxt = i % n + 1, q0q = 0, q1q = 0;\n\t\tfor (int k = 0; k < L[i][1]; k++)\n\t\t\tif (ed[i][1][k] == '0') mv2(i, 1, nxt, 1, 0), q0q++;\n\t\t\telse mv2(i, 1, i, m, 1);\n\t\tfor (int k = 0; k < L[i][m]; k++)\n\t\t\tif (ed[i][m][k] == '0') mv2(i, m, i, 1, 0);\n\t\t\telse mv2(i, m, nxt, m, 1), q1q++;\n\t\tfor (int j = 2; j < m; j++)\n\t\t\tfor (int k = 0; k < L[i][j]; k++)\n\t\t\t\tif (ed[i][j][k] == '0') mv2(i, j, i, 1, 0);\n\t\t\t\telse mv2(i, j, i, m, 1);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\twhile (cnt[0][i][1] > Cnt[0][i][1]) mv1(i, 1, i + 1, 1, 0);\n\t\twhile (cnt[1][i][m] > Cnt[1][i][m]) mv1(i, m, i + 1, m, 1);\n\t}\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\twhile (cnt[0][i][1] > Cnt[0][i][1]) mv1(i, 1, i - 1, 1, 0);\n\t\twhile (cnt[1][i][m] > Cnt[1][i][m]) mv1(i, m, i - 1, m, 1);\n\t}\n\tprintf(\"%d\\n\", tot1 + tot2);\n\tfor (int i = 1; i <= tot1; i++) printf(\"%d %d %d %d\\n\", ans1[i].fi.fi, ans1[i].fi.se, ans1[i].se.fi, ans1[i].se.se);\n\tfor (int i = tot2; i >= 1; i--) printf(\"%d %d %d %d\\n\", ans2[i].fi.fi, ans2[i].fi.se, ans2[i].se.fi, ans2[i].se.se);\n}\nint main()\n{\n#ifdef _noname\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tcin >> st[i][j];\n\t\t\tl[i][j] = st[i][j].size();\n\t\t\tfor (int k = 0; k < l[i][j]; k++)\n\t\t\t\tif (st[i][j][k] == '0') cnt[0][i][j]++;\n\t\t\t\telse cnt[1][i][j]++;\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tcin >> ed[i][j];\n\t\t\tL[i][j] = ed[i][j].size();\n\t\t\tfor (int k = 0; k < L[i][j]; k++)\n\t\t\t\tif (ed[i][j][k] == '0') Cnt[0][i][j]++;\n\t\t\t\telse Cnt[1][i][j]++;\n\t\t}\n\twork2();\n\treturn 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n#define pii pair<int, int>\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nint n, m;\nint cnt[2][305][305], Cnt[2][305][305];\nstring st[305][305], ed[305][305];\nint l[305][305], L[305][305];\npair<pii, pii> ans1[400005], ans2[400005];\nint tot1, tot2;\nvoid mv1(int x, int y, int xx, int yy, int val)\n{\n\tcnt[val][x][y]--, cnt[val][xx][yy]++;\n\tans1[++tot1] = mp(mp(x, y), mp(xx, yy));\n}\nvoid mv2(int x, int y, int xx, int yy, int val)\n{\n\tCnt[val][x][y]--, Cnt[val][xx][yy]++;\n\tans2[++tot2] = mp(mp(xx, yy), mp(x, y));\n}\nvoid work2()\n{\n\ttot1 = tot2 = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint nxt = i % n + 1, q0q = 0, q1q = 0;\n\t\tfor (int k = l[i][1] - 1; k >= 0; k--)\n\t\t\tif (st[i][1][k] == '0') mv1(i, 1, nxt, 1, 0), q0q++;\n\t\t\telse mv1(i, 1, i, m, 1);\n\t\tfor (int k = l[i][m] - 1; k >= 0; k--)\n\t\t\tif (st[i][m][k] == '0') mv1(i, m, i, 1, 0);\n\t\t\telse mv1(i, m, nxt, m, 1), q1q++;\n\t\tfor (int j = 2; j < m; j++)\n\t\t\tfor (int k = l[i][j] - 1; k >= 0; k--)\n\t\t\t\tif (st[i][j][k] == '0') mv1(i, j, i, 1, 0);\n\t\t\t\telse mv1(i, j, i, m, 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint nxt = i % n + 1, q0q = 0, q1q = 0;\n\t\tfor (int k = 0; k < L[i][1]; k++)\n\t\t\tif (ed[i][1][k] == '0') mv2(i, 1, nxt, 1, 0), q0q++;\n\t\t\telse mv2(i, 1, i, m, 1);\n\t\tfor (int k = 0; k < L[i][m]; k++)\n\t\t\tif (ed[i][m][k] == '0') mv2(i, m, i, 1, 0);\n\t\t\telse mv2(i, m, nxt, m, 1), q1q++;\n\t\tfor (int j = 2; j < m; j++)\n\t\t\tfor (int k = 0; k < L[i][j]; k++)\n\t\t\t\tif (ed[i][j][k] == '0') mv2(i, j, i, 1, 0);\n\t\t\t\telse mv2(i, j, i, m, 1);\n\t}\n\tint les = 1, mor = 1;\n\twhile (les <= n && mor <= n)\n\t{\n\t\twhile (cnt[0][les][1] >= Cnt[0][les][1] && les <= n) les++;\n\t\twhile (cnt[0][mor][1] <= Cnt[0][mor][1] && mor <= n) mor++;\n\t\tif (les <= n && mor <= n) mv1(mor, 1, les, 1, 0);\n\t}\n\tles = 1, mor = 1;\n\twhile (les <= n && mor <= n)\n\t{\n\t\twhile (cnt[1][les][m] >= Cnt[1][les][m] && les <= n) les++;\n\t\twhile (cnt[1][mor][m] <= Cnt[1][mor][m] && mor <= n) mor++;\n\t\tif (les <= n && mor <= n) mv1(mor, m, les, m, 1);\n\t}\n\tprintf(\"%d\\n\", tot1 + tot2);\n\tfor (int i = 1; i <= tot1; i++) printf(\"%d %d %d %d\\n\", ans1[i].fi.fi, ans1[i].fi.se, ans1[i].se.fi, ans1[i].se.se);\n\tfor (int i = tot2; i >= 1; i--) printf(\"%d %d %d %d\\n\", ans2[i].fi.fi, ans2[i].fi.se, ans2[i].se.fi, ans2[i].se.se);\n}\nint main()\n{\n#ifdef _noname\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tcin >> st[i][j];\n\t\t\tl[i][j] = st[i][j].size();\n\t\t\tfor (int k = 0; k < l[i][j]; k++)\n\t\t\t\tif (st[i][j][k] == '0') cnt[0][i][j]++;\n\t\t\t\telse cnt[1][i][j]++;\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tcin >> ed[i][j];\n\t\t\tL[i][j] = ed[i][j].size();\n\t\t\tfor (int k = 0; k < L[i][j]; k++)\n\t\t\t\tif (ed[i][j][k] == '0') Cnt[0][i][j]++;\n\t\t\t\telse Cnt[1][i][j]++;\n\t\t}\n\twork2();\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "q = long(input())\n\nfor i in range(q):\n    n, a, b = map(long, raw_input().strip().split())\n    if a*2<=b:\n        print n*long(a)\n    else:\n        if n%2==0:\n            print n*2L/b\n        else:\n            print a + (n-1)*2L/b",
        "fixed_code": "q = long(input())\n\nfor i in range(q):\n    n, a, b = map(long, raw_input().strip().split())\n    if a*2<=b:\n        print n*long(a)\n    else:\n        if n%2==0:\n            print n/2L*b\n        else:\n            print a + (n-1)/2L*b",
        "source": "Python_461356.json"
    },
    {
        "source_code": "private void reportResults(ij.ImagePlus imp1, ij.ImagePlus imp2, ij.ImageStack imageStack1, ij.ImageStack imageStack2, ij.ImageStack roiStack1, ij.ImageStack roiStack2, ij.ImageStack confinedStack, ij.ImageStack lastChannelShiftedRawStack, ij.ImageStack lastSegmentedShiftedRawStack, double M1, double M2, double R, java.util.List<gdsc.colocalisation.cda.engine.CalculationResult> results) {\n    ij.IJ.showStatus(gdsc.colocalisation.cda.CDA_Plugin.processingMandersStatus);\n    double[] distances = new double[results.size()];\n    double[] m1Values = new double[results.size()];\n    double[] m2Values = new double[results.size()];\n    double[] rValues = new double[results.size()];\n    java.util.ArrayList<java.lang.Integer> indexDistance = new java.util.ArrayList<java.lang.Integer>();\n    for (int i = 0; i < (m1Values.length); ++i) {\n        gdsc.colocalisation.cda.engine.CalculationResult result = results.get(i);\n        distances[i] = result.distance;\n        m1Values[i] = result.m1;\n        m2Values[i] = result.m2;\n        rValues[i] = result.r;\n        if ((distances[i]) > (randomRadius)) {\n            indexDistance.add(i);\n        }\n    }\n    float[] m1ValuesForRandom = new float[indexDistance.size()];\n    float[] m2ValuesForRandom = new float[indexDistance.size()];\n    float[] rValuesForRandom = new float[indexDistance.size()];\n    for (int i = 0; i < (m1ValuesForRandom.length); ++i) {\n        m1ValuesForRandom[i] = ((float) (m1Values[indexDistance.get(i)]));\n        m2ValuesForRandom[i] = ((float) (m2Values[indexDistance.get(i)]));\n        rValuesForRandom[i] = ((float) (rValues[indexDistance.get(i)]));\n    }\n    java.util.Arrays.sort(m1ValuesForRandom);\n    java.util.Arrays.sort(m2ValuesForRandom);\n    java.util.Arrays.sort(rValuesForRandom);\n    int deltaY = 10;\n    double[] spacedX = new double[maximumRadius];\n    double[] spacedY = new double[deltaY];\n    double[] ceroValuesX = new double[maximumRadius];\n    double[] ceroValuesY = new double[deltaY];\n    for (int i = 0; i < (maximumRadius); ++i) {\n        spacedX[i] = i;\n        ceroValuesX[i] = 0.0;\n    }\n    for (int i = 0; i < deltaY; ++i) {\n        spacedY[i] = (1.0 / deltaY) * i;\n        ceroValuesY[i] = 0.0;\n    }\n    boolean isSaveResults = (saveResults) && (checkResultsDirectory());\n    ij.IJ.showStatus(gdsc.colocalisation.cda.CDA_Plugin.preparingPlotsStatus);\n    ij.gui.Plot plotM1 = null;\n    ij.gui.Plot plotM2 = null;\n    ij.gui.Plot plotR = null;\n    if (showM1PlotWindow)\n        plotM1 = createPlot(distances, m1Values, java.awt.Color.red, java.awt.Color.blue, gdsc.colocalisation.cda.CDA_Plugin.plotM1Title, gdsc.colocalisation.cda.CDA_Plugin.plotXLabel, gdsc.colocalisation.cda.CDA_Plugin.plotM1YLabel, spacedX, ceroValuesX, ceroValuesY, spacedY);\n    \n    if (showM2PlotWindow)\n        plotM2 = createPlot(distances, m2Values, java.awt.Color.green, java.awt.Color.blue, gdsc.colocalisation.cda.CDA_Plugin.plotM2Title, gdsc.colocalisation.cda.CDA_Plugin.plotXLabel, gdsc.colocalisation.cda.CDA_Plugin.plotM2YLabel, spacedX, ceroValuesX, ceroValuesY, spacedY);\n    \n    if (showRPlotWindow)\n        plotR = createPlot(distances, rValues, java.awt.Color.blue, java.awt.Color.green, gdsc.colocalisation.cda.CDA_Plugin.plotRTitle, gdsc.colocalisation.cda.CDA_Plugin.plotXLabel, gdsc.colocalisation.cda.CDA_Plugin.plotRYLabel, spacedX, ceroValuesX, ceroValuesY, spacedY);\n    \n    ij.ImageStack channel1RGBIP = null;\n    ij.ImageStack channel2RGBIP = null;\n    ij.ImageStack segmented1RGBIP = null;\n    ij.ImageStack segmented2RGBIP = null;\n    ij.ImageStack mergedChannelIP = null;\n    ij.ImageStack mergedSegmentedRGBIP = null;\n    ij.ImageStack mergedChannelDisplacementIP = null;\n    ij.ImageStack mergedSegmentedDisplacementIP = null;\n    if ((showChannel1RGB) || (showMergedChannelRGB))\n        channel1RGBIP = createColorOutput(imageStack1, confinedStack, 0);\n    \n    if ((showChannel2RGB) || (showMergedChannelRGB))\n        channel2RGBIP = createColorOutput(imageStack2, confinedStack, 1);\n    \n    if ((showSegmented1RGB) || (showMergedSegmentedRGB))\n        segmented1RGBIP = createColorOutput(roiStack1, confinedStack, 0);\n    \n    if ((showSegmented2RGB) || (showMergedSegmentedRGB))\n        segmented2RGBIP = createColorOutput(roiStack2, confinedStack, 1);\n    \n    int w = imageStack1.getWidth();\n    int h = imageStack1.getHeight();\n    int slices = imageStack1.getSize();\n    if (showMergedChannelRGB)\n        mergedChannelIP = new ij.ImageStack(w, h, slices);\n    \n    if (showMergedSegmentedRGB)\n        mergedSegmentedRGBIP = new ij.ImageStack(w, h, slices);\n    \n    if (showMergedChannelDisplacementRGB)\n        mergedChannelDisplacementIP = createColorOutput(lastChannelShiftedRawStack, confinedStack, 0);\n    \n    if (showMergedSegmentedDisplacementRGB)\n        mergedSegmentedDisplacementIP = createColorOutput(lastSegmentedShiftedRawStack, confinedStack, 0);\n    \n    for (int n = 1; n <= (imageStack1.getSize()); n++) {\n        if (showMergedChannelRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(0, channel1RGBIP.getProcessor(n).toFloat(0, null));\n            cp.setPixels(1, channel2RGBIP.getProcessor(n).toFloat(1, null));\n            mergedChannelIP.setPixels(cp.getPixels(), n);\n        }\n        if (showMergedSegmentedRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(0, segmented1RGBIP.getProcessor(n).toFloat(0, null));\n            cp.setPixels(1, segmented2RGBIP.getProcessor(n).toFloat(1, null));\n            mergedSegmentedRGBIP.setPixels(cp.getPixels(), n);\n        }\n        if (showMergedChannelDisplacementRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(mergedChannelDisplacementIP.getPixels(n));\n            cp.setPixels(1, channel2RGBIP.getProcessor(n).toFloat(1, null));\n        }\n        if (showMergedSegmentedDisplacementRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(mergedSegmentedDisplacementIP.getPixels(n));\n            cp.setPixels(1, segmented2RGBIP.getProcessor(n).toFloat(1, null));\n        }\n    }\n    createDisplayImages(channel1RGBIP, channel2RGBIP, segmented1RGBIP, segmented2RGBIP, mergedChannelIP, mergedSegmentedRGBIP, mergedChannelDisplacementIP, mergedSegmentedDisplacementIP);\n    updateImage(channel1RGB, gdsc.colocalisation.cda.CDA_Plugin.channel1RGBTitle, channel1RGBIP, showChannel1RGB);\n    updateImage(channel2RGB, gdsc.colocalisation.cda.CDA_Plugin.channel2RGBTitle, channel2RGBIP, showChannel2RGB);\n    updateImage(segmented1RGB, gdsc.colocalisation.cda.CDA_Plugin.segmented1RGBTitle, segmented1RGBIP, showSegmented1RGB);\n    updateImage(segmented2RGB, gdsc.colocalisation.cda.CDA_Plugin.segmented2RGBTitle, segmented2RGBIP, showSegmented2RGB);\n    updateImage(mergedChannelRGB, gdsc.colocalisation.cda.CDA_Plugin.mergedChannelTitle, mergedChannelIP, showMergedChannelRGB);\n    updateImage(mergedSegmentedRGB, gdsc.colocalisation.cda.CDA_Plugin.mergedSegmentedTitle, mergedSegmentedRGBIP, showMergedSegmentedRGB);\n    updateImage(mergedChannelDisplacementRGB, gdsc.colocalisation.cda.CDA_Plugin.lastShiftedChannelTitle, mergedChannelDisplacementIP, showMergedChannelDisplacementRGB);\n    updateImage(mergedSegmentedDisplacementRGB, gdsc.colocalisation.cda.CDA_Plugin.lastShiftedSegmentedTitle, mergedSegmentedDisplacementIP, showMergedSegmentedDisplacementRGB);\n    m1PlotWindow = refreshPlotWindow(m1PlotWindow, showM1PlotWindow, plotM1, OPT_LOCATION_PLOT_M1);\n    m2PlotWindow = refreshPlotWindow(m2PlotWindow, showM2PlotWindow, plotM2, OPT_LOCATION_PLOT_M2);\n    rPlotWindow = refreshPlotWindow(rPlotWindow, showRPlotWindow, plotR, OPT_LOCATION_PLOT_R);\n    ij.process.FloatProcessor m1ValuesFP = new ij.process.FloatProcessor(m1ValuesForRandom.length, 1, m1ValuesForRandom, null);\n    ij.process.FloatProcessor m2ValuesFP = new ij.process.FloatProcessor(m2ValuesForRandom.length, 1, m2ValuesForRandom, null);\n    ij.process.FloatProcessor rValuesFP = new ij.process.FloatProcessor(rValuesForRandom.length, 1, rValuesForRandom, null);\n    m1Statistics = refreshDisplayStatistics(m1Statistics, showM1Statistics, m1ValuesFP, m1ValuesForRandom, gdsc.colocalisation.cda.CDA_Plugin.m1HistogramTitle, java.awt.Color.red, \"M1 \", M1, OPT_LOCATION_STATS_M1);\n    m2Statistics = refreshDisplayStatistics(m2Statistics, showM2Statistics, m2ValuesFP, m2ValuesForRandom, gdsc.colocalisation.cda.CDA_Plugin.m2HistogramTitle, java.awt.Color.green, \"M2 \", M2, OPT_LOCATION_STATS_M2);\n    rStatistics = refreshDisplayStatistics(rStatistics, showRStatistics, rValuesFP, rValuesForRandom, gdsc.colocalisation.cda.CDA_Plugin.rHistogramTitle, java.awt.Color.blue, \"R \", R, OPT_LOCATION_STATS_R);\n    java.lang.String id = generateId();\n    java.lang.StringBuffer heading = null;\n    if (((gdsc.colocalisation.cda.CDA_Plugin.tw) == null) || (!(gdsc.colocalisation.cda.CDA_Plugin.tw.isShowing()))) {\n        heading = createHeading(heading);\n        gdsc.colocalisation.cda.CDA_Plugin.tw = new ij.text.TextWindow(((gdsc.colocalisation.cda.CDA_Plugin.FRAME_TITLE) + \" Results\"), heading.toString(), \"\", 1000, 300);\n    }\n    java.lang.StringBuffer resultsEntry = new java.lang.StringBuffer();\n    addField(resultsEntry, id);\n    addField(resultsEntry, getImageTitle(imp1, 0));\n    addField(resultsEntry, getImageTitle(imp2, 2));\n    addRoiField(resultsEntry, segmented1OptionIndex, segmented1Index, getRoiIp(imageStack1.getProcessor(1), segmented1Index));\n    addRoiField(resultsEntry, segmented2OptionIndex, segmented2Index, getRoiIp(imageStack2.getProcessor(1), segmented2Index));\n    addRoiField(resultsEntry, confinedOptionIndex, confinedIndex, getRoiIp(confinedStack.getProcessor(1), ((confinedIndex) + 1)));\n    addField(resultsEntry, expandConfinedCompartment);\n    addField(resultsEntry, maximumRadius);\n    addField(resultsEntry, randomRadius);\n    addField(resultsEntry, results.size());\n    addField(resultsEntry, histogramBins);\n    addField(resultsEntry, pValue);\n    addResults(resultsEntry, m1Statistics);\n    addResults(resultsEntry, m2Statistics);\n    addResults(resultsEntry, rStatistics);\n    gdsc.colocalisation.cda.CDA_Plugin.tw.append(resultsEntry.toString());\n    if (isSaveResults) {\n        try {\n            java.lang.String directory = gdsc.utils.ImageJHelper.combinePath(resultsDirectory, id);\n            if (!(new java.io.File(directory).mkdirs()))\n                return ;\n            \n            ij.IJ.save(mergedSegmentedRGB, ((directory + (java.io.File.separatorChar)) + \"MergedROI.tif\"));\n            ij.IJ.save(mergedChannelRGB, ((directory + (java.io.File.separatorChar)) + \"MergedChannel.tif\"));\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(((directory + (java.io.File.separatorChar)) + \"results.txt\"));\n            java.io.OutputStreamWriter out = new java.io.OutputStreamWriter(fos, \"UTF-8\");\n            java.lang.String newLine = java.lang.System.getProperty(\"line.separator\");\n            heading = createHeading(heading);\n            out.write(heading.toString());\n            out.write(newLine);\n            out.write(resultsEntry.toString());\n            out.write(newLine);\n            out.close();\n        } catch (java.lang.Exception e) {\n            return ;\n        }\n    }\n}",
        "fixed_code": "private void reportResults(ij.ImagePlus imp1, ij.ImagePlus imp2, ij.ImageStack imageStack1, ij.ImageStack imageStack2, ij.ImageStack roiStack1, ij.ImageStack roiStack2, ij.ImageStack confinedStack, ij.ImageStack lastChannelShiftedRawStack, ij.ImageStack lastSegmentedShiftedRawStack, double M1, double M2, double R, java.util.List<gdsc.colocalisation.cda.engine.CalculationResult> results) {\n    ij.IJ.showStatus(gdsc.colocalisation.cda.CDA_Plugin.processingMandersStatus);\n    double[] distances = new double[results.size()];\n    double[] m1Values = new double[results.size()];\n    double[] m2Values = new double[results.size()];\n    double[] rValues = new double[results.size()];\n    java.util.ArrayList<java.lang.Integer> indexDistance = new java.util.ArrayList<java.lang.Integer>();\n    for (int i = 0; i < (m1Values.length); ++i) {\n        gdsc.colocalisation.cda.engine.CalculationResult result = results.get(i);\n        distances[i] = result.distance;\n        m1Values[i] = result.m1;\n        m2Values[i] = result.m2;\n        rValues[i] = result.r;\n        if ((distances[i]) > (randomRadius)) {\n            indexDistance.add(i);\n        }\n    }\n    float[] m1ValuesForRandom = new float[indexDistance.size()];\n    float[] m2ValuesForRandom = new float[indexDistance.size()];\n    float[] rValuesForRandom = new float[indexDistance.size()];\n    for (int i = 0; i < (m1ValuesForRandom.length); ++i) {\n        m1ValuesForRandom[i] = ((float) (m1Values[indexDistance.get(i)]));\n        m2ValuesForRandom[i] = ((float) (m2Values[indexDistance.get(i)]));\n        rValuesForRandom[i] = ((float) (rValues[indexDistance.get(i)]));\n    }\n    java.util.Arrays.sort(m1ValuesForRandom);\n    java.util.Arrays.sort(m2ValuesForRandom);\n    java.util.Arrays.sort(rValuesForRandom);\n    int deltaY = 10;\n    double[] spacedX = new double[maximumRadius];\n    double[] spacedY = new double[deltaY];\n    double[] ceroValuesX = new double[maximumRadius];\n    double[] ceroValuesY = new double[deltaY];\n    for (int i = 0; i < (maximumRadius); ++i) {\n        spacedX[i] = i;\n        ceroValuesX[i] = 0.0;\n    }\n    for (int i = 0; i < deltaY; ++i) {\n        spacedY[i] = (1.0 / deltaY) * i;\n        ceroValuesY[i] = 0.0;\n    }\n    boolean isSaveResults = (saveResults) && (checkResultsDirectory());\n    ij.IJ.showStatus(gdsc.colocalisation.cda.CDA_Plugin.preparingPlotsStatus);\n    ij.gui.Plot plotM1 = null;\n    ij.gui.Plot plotM2 = null;\n    ij.gui.Plot plotR = null;\n    if (showM1PlotWindow)\n        plotM1 = createPlot(distances, m1Values, java.awt.Color.red, java.awt.Color.blue, gdsc.colocalisation.cda.CDA_Plugin.plotM1Title, gdsc.colocalisation.cda.CDA_Plugin.plotXLabel, gdsc.colocalisation.cda.CDA_Plugin.plotM1YLabel, spacedX, ceroValuesX, ceroValuesY, spacedY);\n    \n    if (showM2PlotWindow)\n        plotM2 = createPlot(distances, m2Values, java.awt.Color.green, java.awt.Color.blue, gdsc.colocalisation.cda.CDA_Plugin.plotM2Title, gdsc.colocalisation.cda.CDA_Plugin.plotXLabel, gdsc.colocalisation.cda.CDA_Plugin.plotM2YLabel, spacedX, ceroValuesX, ceroValuesY, spacedY);\n    \n    if (showRPlotWindow)\n        plotR = createPlot(distances, rValues, java.awt.Color.blue, java.awt.Color.green, gdsc.colocalisation.cda.CDA_Plugin.plotRTitle, gdsc.colocalisation.cda.CDA_Plugin.plotXLabel, gdsc.colocalisation.cda.CDA_Plugin.plotRYLabel, spacedX, ceroValuesX, ceroValuesY, spacedY);\n    \n    ij.ImageStack channel1RGBIP = null;\n    ij.ImageStack channel2RGBIP = null;\n    ij.ImageStack segmented1RGBIP = null;\n    ij.ImageStack segmented2RGBIP = null;\n    ij.ImageStack mergedChannelIP = null;\n    ij.ImageStack mergedSegmentedRGBIP = null;\n    ij.ImageStack mergedChannelDisplacementIP = null;\n    ij.ImageStack mergedSegmentedDisplacementIP = null;\n    if ((showChannel1RGB) || (showMergedChannelRGB))\n        channel1RGBIP = createColorOutput(imageStack1, confinedStack, 0);\n    \n    if ((showChannel2RGB) || (showMergedChannelRGB))\n        channel2RGBIP = createColorOutput(imageStack2, confinedStack, 1);\n    \n    if ((showSegmented1RGB) || (showMergedSegmentedRGB))\n        segmented1RGBIP = createColorOutput(roiStack1, confinedStack, 0);\n    \n    if ((showSegmented2RGB) || (showMergedSegmentedRGB))\n        segmented2RGBIP = createColorOutput(roiStack2, confinedStack, 1);\n    \n    int w = imageStack1.getWidth();\n    int h = imageStack1.getHeight();\n    int slices = imageStack1.getSize();\n    if (showMergedChannelRGB)\n        mergedChannelIP = new ij.ImageStack(w, h, slices);\n    \n    if (showMergedSegmentedRGB)\n        mergedSegmentedRGBIP = new ij.ImageStack(w, h, slices);\n    \n    if (showMergedChannelDisplacementRGB)\n        mergedChannelDisplacementIP = createColorOutput(lastChannelShiftedRawStack, confinedStack, 0);\n    \n    if (showMergedSegmentedDisplacementRGB)\n        mergedSegmentedDisplacementIP = createColorOutput(lastSegmentedShiftedRawStack, confinedStack, 0);\n    \n    for (int n = 1; n <= (imageStack1.getSize()); n++) {\n        if (showMergedChannelRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(0, channel1RGBIP.getProcessor(n).toFloat(0, null));\n            cp.setPixels(1, channel2RGBIP.getProcessor(n).toFloat(1, null));\n            mergedChannelIP.setPixels(cp.getPixels(), n);\n        }\n        if (showMergedSegmentedRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(0, segmented1RGBIP.getProcessor(n).toFloat(0, null));\n            cp.setPixels(1, segmented2RGBIP.getProcessor(n).toFloat(1, null));\n            mergedSegmentedRGBIP.setPixels(cp.getPixels(), n);\n        }\n        if (showMergedChannelDisplacementRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(mergedChannelDisplacementIP.getPixels(n));\n            cp.setPixels(1, channel2RGBIP.getProcessor(n).toFloat(1, null));\n        }\n        if (showMergedSegmentedDisplacementRGB) {\n            ij.process.ColorProcessor cp = new ij.process.ColorProcessor(w, h);\n            cp.setPixels(mergedSegmentedDisplacementIP.getPixels(n));\n            cp.setPixels(1, segmented2RGBIP.getProcessor(n).toFloat(1, null));\n        }\n    }\n    createDisplayImages(channel1RGBIP, channel2RGBIP, segmented1RGBIP, segmented2RGBIP, mergedChannelIP, mergedSegmentedRGBIP, mergedChannelDisplacementIP, mergedSegmentedDisplacementIP);\n    updateImage(channel1RGB, gdsc.colocalisation.cda.CDA_Plugin.channel1RGBTitle, channel1RGBIP, showChannel1RGB);\n    updateImage(channel2RGB, gdsc.colocalisation.cda.CDA_Plugin.channel2RGBTitle, channel2RGBIP, showChannel2RGB);\n    updateImage(segmented1RGB, gdsc.colocalisation.cda.CDA_Plugin.segmented1RGBTitle, segmented1RGBIP, showSegmented1RGB);\n    updateImage(segmented2RGB, gdsc.colocalisation.cda.CDA_Plugin.segmented2RGBTitle, segmented2RGBIP, showSegmented2RGB);\n    updateImage(mergedChannelRGB, gdsc.colocalisation.cda.CDA_Plugin.mergedChannelTitle, mergedChannelIP, showMergedChannelRGB);\n    updateImage(mergedSegmentedRGB, gdsc.colocalisation.cda.CDA_Plugin.mergedSegmentedTitle, mergedSegmentedRGBIP, showMergedSegmentedRGB);\n    updateImage(mergedChannelDisplacementRGB, gdsc.colocalisation.cda.CDA_Plugin.lastShiftedChannelTitle, mergedChannelDisplacementIP, showMergedChannelDisplacementRGB);\n    updateImage(mergedSegmentedDisplacementRGB, gdsc.colocalisation.cda.CDA_Plugin.lastShiftedSegmentedTitle, mergedSegmentedDisplacementIP, showMergedSegmentedDisplacementRGB);\n    m1PlotWindow = refreshPlotWindow(m1PlotWindow, showM1PlotWindow, plotM1, OPT_LOCATION_PLOT_M1);\n    m2PlotWindow = refreshPlotWindow(m2PlotWindow, showM2PlotWindow, plotM2, OPT_LOCATION_PLOT_M2);\n    rPlotWindow = refreshPlotWindow(rPlotWindow, showRPlotWindow, plotR, OPT_LOCATION_PLOT_R);\n    ij.process.FloatProcessor m1ValuesFP = new ij.process.FloatProcessor(m1ValuesForRandom.length, 1, m1ValuesForRandom, null);\n    ij.process.FloatProcessor m2ValuesFP = new ij.process.FloatProcessor(m2ValuesForRandom.length, 1, m2ValuesForRandom, null);\n    ij.process.FloatProcessor rValuesFP = new ij.process.FloatProcessor(rValuesForRandom.length, 1, rValuesForRandom, null);\n    m1Statistics = refreshDisplayStatistics(m1Statistics, showM1Statistics, m1ValuesFP, m1ValuesForRandom, gdsc.colocalisation.cda.CDA_Plugin.m1HistogramTitle, java.awt.Color.red, \"M1 \", M1, OPT_LOCATION_STATS_M1);\n    m2Statistics = refreshDisplayStatistics(m2Statistics, showM2Statistics, m2ValuesFP, m2ValuesForRandom, gdsc.colocalisation.cda.CDA_Plugin.m2HistogramTitle, java.awt.Color.green, \"M2 \", M2, OPT_LOCATION_STATS_M2);\n    rStatistics = refreshDisplayStatistics(rStatistics, showRStatistics, rValuesFP, rValuesForRandom, gdsc.colocalisation.cda.CDA_Plugin.rHistogramTitle, java.awt.Color.blue, \"R \", R, OPT_LOCATION_STATS_R);\n    java.lang.String id = generateId();\n    java.lang.StringBuffer heading = null;\n    if (((gdsc.colocalisation.cda.CDA_Plugin.tw) == null) || (!(gdsc.colocalisation.cda.CDA_Plugin.tw.isShowing()))) {\n        heading = createHeading(heading);\n        gdsc.colocalisation.cda.CDA_Plugin.tw = new ij.text.TextWindow(((gdsc.colocalisation.cda.CDA_Plugin.FRAME_TITLE) + \" Results\"), heading.toString(), \"\", 1000, 300);\n    }\n    java.lang.StringBuffer resultsEntry = new java.lang.StringBuffer();\n    addField(resultsEntry, id);\n    addField(resultsEntry, getImageTitle(imp1, 0));\n    addField(resultsEntry, getImageTitle(imp2, 2));\n    addRoiField(resultsEntry, segmented1OptionIndex, ((segmented1Index) - 1), getRoiIp(imageStack1.getProcessor(1), ((segmented1Index) - 1)));\n    addRoiField(resultsEntry, segmented2OptionIndex, ((segmented2Index) - 1), getRoiIp(imageStack2.getProcessor(1), ((segmented2Index) - 1)));\n    addRoiField(resultsEntry, confinedOptionIndex, confinedIndex, getRoiIp(confinedStack.getProcessor(1), confinedIndex));\n    addField(resultsEntry, expandConfinedCompartment);\n    addField(resultsEntry, maximumRadius);\n    addField(resultsEntry, randomRadius);\n    addField(resultsEntry, results.size());\n    addField(resultsEntry, histogramBins);\n    addField(resultsEntry, pValue);\n    addResults(resultsEntry, m1Statistics);\n    addResults(resultsEntry, m2Statistics);\n    addResults(resultsEntry, rStatistics);\n    gdsc.colocalisation.cda.CDA_Plugin.tw.append(resultsEntry.toString());\n    if (isSaveResults) {\n        try {\n            java.lang.String directory = gdsc.utils.ImageJHelper.combinePath(resultsDirectory, id);\n            if (!(new java.io.File(directory).mkdirs()))\n                return ;\n            \n            ij.IJ.save(mergedSegmentedRGB, ((directory + (java.io.File.separatorChar)) + \"MergedROI.tif\"));\n            ij.IJ.save(mergedChannelRGB, ((directory + (java.io.File.separatorChar)) + \"MergedChannel.tif\"));\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(((directory + (java.io.File.separatorChar)) + \"results.txt\"));\n            java.io.OutputStreamWriter out = new java.io.OutputStreamWriter(fos, \"UTF-8\");\n            java.lang.String newLine = java.lang.System.getProperty(\"line.separator\");\n            heading = createHeading(heading);\n            out.write(heading.toString());\n            out.write(newLine);\n            out.write(resultsEntry.toString());\n            out.write(newLine);\n            out.close();\n        } catch (java.lang.Exception e) {\n            return ;\n        }\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<iostream>\n#include<locale.h>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint main() {\n\tint n, d, g, q = 0;\n\tcin >> n >> d;\n\tvector <int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tg = a[i] - a[r];\n\t\t\tif (abs(g) < d && i != r) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << q;\n\treturn 0;\n}",
        "fixed_code": "#include <iostream>\n#include <locale.h>\n#include <vector>\n\nusing namespace std;\nint main() {\n\tint n, d, g, q = 0;\n\tcin >> n >> d;\n\tvector <int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tg = a[i] - a[r];\n\t\t\tif (abs(g) <= d && i != r) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << q;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint n, qo[2010];\r\nbool col[2010];\r\nbool bio[2010];\r\nbool prnted[2010][2010];\r\n\r\nvector<pair<int, int>> out;\r\nqueue<int> nxt;\r\n\r\nvoid start(){\r\n    cout << \"? \" << 1 << \"\\n\";\r\n\r\n    int wht = 0;\r\n    int blk = 0;\r\n\r\n    for(int i = 0; i < n; i++){\r\n        cin >> qo[i];\r\n\r\n        if(qo[i] % 2){\r\n            blk ++;\r\n        }\r\n        else{\r\n            wht ++;\r\n        }\r\n    }\r\n\r\n    bool mod = (wht <= blk);\r\n\r\n    for(int i = 0; i < n; i++){\r\n        if((qo[i] % 2) != mod){\r\n            bool use0 = true;\r\n             \r\n            if(i != 0){\r\n                use0 = false;\r\n                cout << \"? \" << i + 1 << \"\\n\";\r\n            }\r\n            for(int j = 0; j < n; j++){\r\n                int y; \r\n                if(!use0) \r\n                    cin >> y;\r\n                else\r\n                    y = qo[i];\r\n                \r\n                if(y == 1)\r\n                    out.push_back({i + 1, j + 1});\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n\r\n    cin >> n;\r\n\r\n    start();\r\n\r\n    cout << \"! \\n\";\r\n\r\n    for(pair<int, int> x : out){\r\n        cout << x.first << ' ' << x.second << \"\\n\";\r\n\r\n    }\r\n    return 0;\r\n}\r\n",
        "fixed_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint n, qo[2010];\r\nbool col[2010];\r\nbool bio[2010];\r\nbool prnted[2010][2010];\r\n\r\nvector<pair<int, int>> out;\r\nqueue<int> nxt;\r\n\r\nvoid start(){\r\n    cout << \"? \" << 1 << \"\\n\";\r\n\r\n    int wht = 0;\r\n    int blk = 0;\r\n\r\n    for(int i = 0; i < n; i++){\r\n        cin >> qo[i];\r\n\r\n        if(qo[i] % 2){\r\n            blk ++;\r\n        }\r\n        else{\r\n            wht ++;\r\n        }\r\n    }\r\n\r\n    bool mod = (wht <= blk);\r\n\r\n    for(int i = 0; i < n; i++){\r\n        if((qo[i] % 2) != mod){\r\n            bool use0 = true;\r\n             \r\n            if(i == 0)\r\n                use0 = false;\r\n            else \r\n                cout << \"? \" << i + 1 << \"\\n\";\r\n    \r\n            for(int j = 0; j < n; j++){\r\n                int y; \r\n                if(use0) \r\n                    cin >> y;\r\n                else\r\n                    y = qo[j];\r\n                \r\n                if(y == 1)\r\n                    out.push_back({i + 1, j + 1});\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n\r\n    cin >> n;\r\n\r\n    start();\r\n\r\n    cout << \"! \\n\";\r\n\r\n    for(pair<int, int> x : out){\r\n        cout << x.first << ' ' << x.second << \"\\n\";\r\n\r\n    }\r\n    return 0;\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.*;\r\nimport java.io.*;\r\npublic class Main{\r\n    public static void main(String args[])throws Exception \r\n    {\r\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\r\n        int t=Integer.parseInt(br.readLine());\r\n        while(t-->0){\r\n            char ch[]=br.readLine().toCharArray();\r\n            Stack<Character> st=new Stack<>();\r\n            for(int i=0;i<ch.length;i++)\r\n            {\r\n                st.push(ch[i]);\r\n            }\r\n            ArrayList<Integer> vik=new ArrayList<>(),son=new ArrayList<>();\r\n            int maxa=0,maxb=0,counta=0,countb=0;\r\n            while(st.size()>0){\r\n                char h=st.pop();\r\n                if(h=='b')\r\n                {\r\n                    countb++;\r\n                    maxb=Math.max(maxb,countb);\r\n                    if(maxa>=1){\r\n                        vik.add(maxa);\r\n                        maxa=0;\r\n                        counta=0;\r\n                    }\r\n                }else\r\n                {\r\n                    counta++;\r\n                    maxa=Math.max(maxa,counta);\r\n                    if(maxb>=1){\r\n                        son.add(maxb);\r\n                        maxb=0;\r\n                        countb=0;\r\n                    }\r\n                }\r\n            }\r\n            if(maxa>0)\r\n            {\r\n                vik.add(maxa);\r\n                maxa=0;\r\n            }\r\n            else{\r\n                son.add(maxb);\r\n                maxb=0;\r\n            }\r\n            Collections.sort(vik);\r\n            Collections.sort(son);\r\n            if(vik.get(0)>1 && son.get(0)>1){\r\n                System.out.println(\"Yes\");\r\n            }\r\n            else\r\n            {\r\n                System.out.println(\"No\");\r\n            }\r\n        }\r\n    }\r\n}",
        "fixed_code": "import java.util.*;\r\n\r\npublic class Solution {\r\n\tpublic static void main (String[] args) \r\n\t{\r\n\t\tScanner s = new Scanner(System.in);\r\n\t    int t=s.nextInt();\r\n\t    s.nextLine();\r\n\t    while(t-->0) {\r\n\t    \tString str= s.nextLine();\r\n\t    \tif(str.length()==1 || str.contains(\"aba\") || str.contains(\"bab\") || str.startsWith(\"ab\") || str.startsWith(\"ba\")||str.endsWith(\"ab\")||str.endsWith(\"ba\"))\r\n\t    \t\tSystem.out.println(\"NO\");\r\n\t        else \r\n\t    \t\tSystem.out.println(\"YES\");\r\n\t    }\r\n    }  \r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n#include <numeric>\n#include <algorithm>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll m = 100000;\n\nmap<ll, list<ll> > mp;\n\nvoid rec(ll n, ll k)\n{\n\tif (k == 0 || n == 1)\n\t{\n\t\tcout << n << \" \";\n\t\t--m;\n\t\tif (m <= 0)\n\t\t{\n\t\t\tcout << endl;\n\t\t\texit(0);\n\t\t}\n\t\treturn;\n\t}\n\tmap<ll, list<ll> >::iterator mit = mp.find(n);\n\tif (mit == mp.end())\n\t{\n\t\tlist<ll> dv;\n\t\tfor (ll i = 1; i < sqrt(n) + 1; ++i)\n\t\t\tif (n % i == 0) \n\t\t\t{\n\t\t\t\tdv.push_back(i);\n\t\t\t\trec(i, k - 1);\n\t\t\t}\n\t\tfor (list<ll>::reverse_iterator it = dv.rbegin(); it != dv.rend(); ++it)\n\t\t{\n\t\t\tll d = n / *it;\n\t\t\tif (d > dv.back())\n\t\t\t{\n\t\t\t\tdv.push_back(d);\t\t\t\t\t\t\n\t\t\t\trec(d, k - 1);\n\t\t\t}\n\t\t}\n\t\tmp.insert(make_pair(n, dv));\n\t}\n\telse\n\t{\n\t\tlist<ll> &dv = mit->second;\n\t\tfor (list<ll>::iterator it = dv.begin(); it != dv.end(); ++it)\n\t\t\trec(*it, k - 1);\n\t}\n}\n\nint main()\n{\n\tll n, k;\n\tcin >> n >> k;\n\trec(n, k);\n\tcout << endl;\n\treturn 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n#include <numeric>\n#include <algorithm>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll m = 100000;\n\nmap<ll, list<ll> > mp;\n\nlist<ll> &getdivisors(ll n)\n{\n\tmap<ll, list<ll> >::iterator mit = mp.find(n);\n\tif (mit == mp.end())\n\t{\n\t\tlist<ll> dv;\n\t\tfor (ll i = 1; i < sqrt(n) + 1; ++i)\n\t\t\tif (n % i == 0) \n\t\t\t\tdv.push_back(i);\n\t\tfor (list<ll>::reverse_iterator it = dv.rbegin(); it != dv.rend(); ++it)\n\t\t{\n\t\t\tll d = n / *it;\n\t\t\tif (d > dv.back())\n\t\t\t\tdv.push_back(d);\n\t\t}\n\t\tmp.insert(make_pair(n, dv));\n\t\tmit = mp.find(n);\n\t}\n\treturn mit->second;\n}\n\nvoid rec(ll n, ll k)\n{\n\tif (k == 0 || n == 1)\n\t{\n\t\tcout << n << \" \";\n\t\t--m;\n\t\tif (m <= 0)\n\t\t{\n\t\t\tcout << endl;\n\t\t\texit(0);\n\t\t}\n\t\treturn;\n\t}\n\tlist<ll> &dv = getdivisors(n);\n\tfor (list<ll>::iterator it = dv.begin(); it != dv.end(); ++it)\n\t\trec(*it, k - 1);\n}\n\nint main()\n{\n\t// precalc\n\t\n\tll n, k;\n\tcin >> n >> k;\n\trec(n, k);\n\tcout << endl;\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nconst int LEAF = 1<<18;\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MOD = 998244353;\nconst int MAX_TREE_SIZE = 1 << 19;\n\n// https://github.com/ojuz/ojuz11/blob/master/rail/solutions/tncks0121_subtask5.cpp\n\nint N, Q;\n\nnamespace segtree {\n  struct node {\n    int sum, mul, add;\n    node(int sum = 0, int mul = 1, int add = 0): sum(sum), mul(mul), add(add) { }\n  };\n\n  node tree[MAX_TREE_SIZE + 1];\n\n  void spread (int idx, int nl, int nr) {\n    node& nd = tree[idx];\n    node& c1 = (nl == nr) ? tree[0] : tree[idx * 2];\n    node& c2 = (nl == nr) ? tree[0] : tree[idx * 2 + 1];\n\n    if(nd.mul != 1) {\n      nd.sum = ((ll)nd.sum * nd.mul) % MOD;\n      for(auto &child : {&c1, &c2}) {\n        child->mul = ((ll)child->mul * nd.mul) % MOD;\n        child->add = ((ll)child->add * nd.mul) % MOD;\n      }\n      nd.mul = 1;\n    }\n\n    if(nd.add != 0) {\n      nd.sum += ((ll)nd.add * (nr - nl + 1)) % MOD;\n      nd.sum = nd.sum >= MOD ? nd.sum - MOD : nd.sum;\n      for(auto &child : {&c1, &c2}) {\n        child->add += nd.add;\n        if(child->add >= MOD) child->add %= MOD;\n      }\n      nd.add = 0;\n    }\n  }\n\n  int update (int idx, int nl, int nr, int l, int r, char type, int v) {\n    if(l > r) return 0;\n    node &nd = tree[idx];\n    spread(idx, nl, nr);  \n    if(l <= nl && nr <= r) {\n      (type == '*' ? nd.mul : nd.add) = v;\n      spread(idx, nl, nr);\n      return nd.sum;\n    }\n    int nm = (nl + nr) >> 1;\n    nd.sum = 0;\n    if(l <= nm) nd.sum += update(idx*2,   nl, nm,   l, min(nm, r),   type, v);\n    if(r >  nm) nd.sum += update(idx*2+1, nm+1, nr, max(nm+1, l), r, type, v);\n    if(nd.sum >= MOD) nd.sum -= MOD;\n    return nd.sum;\n  }\n\n  void multiply(int l, int r, int v) {\n    update(1, 0, N, l, r, '*', v);\n  }\n\n  void add (int l, int r, int v) {\n    update(1, 0, N, l, r, '+', v);\n  }\n\n  int get (int idx, int nl, int nr, int l, int r) {\n    spread(idx, nl, nr);\n    if(nl == l && nr == r) return tree[idx].sum;\n    int nm = (nl + nr) >> 1;\n    int ret = ((l <= nm) ? get(idx*2, nl, nm, l, min(nm, r)) : 0)\n          + ((nm+1 <= r) ? get(idx*2+1, nm+1, nr, max(nm+1, l), r) : 0);\n    if(ret >= MOD) ret -= MOD;\n    return ret;\n  }\n\n  int get(int x, int y) {\n    return get(1, 0, N, x, y);\n  }\n};\n\nusing pii = pair<int, int>;\n\nset<pii> intervals[int(2.1e5)];\n\nint main() {\n  scanf(\"%d%d\", &N, &Q);\n\n  while(Q--) {\n    int t;\n    scanf(\"%d\", &t);\n    if(t == 1) {\n      int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n\n      set<pii> &alive = intervals[x];\n      pii intv(l, r);\n      \n      if(alive.empty()) {\n        alive.insert(intv);\n        segtree::add(l, r, 1);\n        continue;\n      }\n\n      auto it = alive.lower_bound(pii(l, -1));\n      if(it != alive.begin()) {\n        it--;\n      }\n      if(it != alive.end() && it->second < l) {\n        it++;\n      }\n\n      if(it == alive.end()) {\n        alive.insert(intv);\n        segtree::add(l, r, 1);\n        continue;\n      }\n\n      if(it->second < l || it->first > r) {\n        alive.insert(intv);\n        segtree::add(l, r, 1);\n        continue;\n      }\n\n      if(it->first < intv.first)\n        intv.first = it->first;\n\n      int last = l-1;\n      while(it != alive.end()) {\n        pii intersection (max(it->first, l), min(it->second, r));\n        if(intersection.first <= intersection.second) {\n          if(last < intersection.first - 1) {\n            segtree::add(last + 1, intersection.first - 1, 1);\n          }\n          segtree::multiply(intersection.first, intersection.second, 2);\n          last = intersection.second;\n          if(intv.second < it->second)\n            intv.second = it->second;\n          \n          auto tmp = it;\n          it++;\n          alive.erase(tmp);\n        }else {\n          break;\n        }\n      }\n\n      if(last < r) {\n        segtree::add(last + 1, r, 1);\n      }\n      alive.insert(intv);\n    }else {\n      int l, r; scanf(\"%d%d\", &l, &r);\n      printf(\"%d\\n\", segtree::get(l, r));\n    }\n  }\n  return 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\n\nconst int LEAF = 1<<18;\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MOD = 998244353;\nconst int MAX_TREE_SIZE = 1 << 19;\n\n// https://github.com/ojuz/ojuz11/blob/master/rail/solutions/tncks0121_subtask5.cpp\n\nint N, Q;\n\nnamespace segtree {\n  struct node {\n    int sum, mul, add;\n    node(int sum = 0, int mul = 1, int add = 0): sum(sum), mul(mul), add(add) { }\n  };\n\n  node tree[MAX_TREE_SIZE + 1];\n\n  void spread (int idx, int nl, int nr) {\n    node& nd = tree[idx];\n    node& c1 = (nl == nr) ? tree[0] : tree[idx * 2];\n    node& c2 = (nl == nr) ? tree[0] : tree[idx * 2 + 1];\n\n    if(nd.mul != 1) {\n      nd.sum = ((ll)nd.sum * nd.mul) % MOD;\n      for(auto &child : {&c1, &c2}) {\n        child->mul = ((ll)child->mul * nd.mul) % MOD;\n        child->add = ((ll)child->add * nd.mul) % MOD;\n      }\n      nd.mul = 1;\n    }\n\n    if(nd.add != 0) {\n      nd.sum += ((ll)nd.add * (nr - nl + 1)) % MOD;\n      nd.sum = nd.sum >= MOD ? nd.sum - MOD : nd.sum;\n      for(auto &child : {&c1, &c2}) {\n        child->add += nd.add;\n        if(child->add >= MOD) child->add %= MOD;\n      }\n      nd.add = 0;\n    }\n  }\n\n  int update (int idx, int nl, int nr, int l, int r, char type, int v) {\n    node &nd = tree[idx];\n    spread(idx, nl, nr);  \n    if(l > r) return nd.sum;\n    if(l <= nl && nr <= r) {\n      (type == '*' ? nd.mul : nd.add) = v;\n      spread(idx, nl, nr);\n      return nd.sum;\n    }\n    int nm = (nl + nr) >> 1;\n    nd.sum = 0;\n    nd.sum += update(idx*2,   nl, nm,   l, min(nm, r),   type, v);\n    nd.sum += update(idx*2+1, nm+1, nr, max(nm+1, l), r, type, v);\n    if(nd.sum >= MOD) nd.sum -= MOD;\n    return nd.sum;\n  }\n\n  void multiply(int l, int r, int v) {\n    update(1, 0, N, l, r, '*', v);\n  }\n\n  void add (int l, int r, int v) {\n    update(1, 0, N, l, r, '+', v);\n  }\n\n  int get (int idx, int nl, int nr, int l, int r) {\n    spread(idx, nl, nr);\n    if(nl == l && nr == r) return tree[idx].sum;\n    int nm = (nl + nr) >> 1;\n    int ret = ((l <= nm) ? get(idx*2, nl, nm, l, min(nm, r)) : 0)\n          + ((nm+1 <= r) ? get(idx*2+1, nm+1, nr, max(nm+1, l), r) : 0);\n    if(ret >= MOD) ret -= MOD;\n    return ret;\n  }\n\n  int get(int x, int y) {\n    return get(1, 0, N, x, y);\n  }\n};\n\nusing pii = pair<int, int>;\n\nset<pii> intervals[int(2.1e5)];\n\nint main() {\n  scanf(\"%d%d\", &N, &Q);\n\n  while(Q--) {\n    int t;\n    scanf(\"%d\", &t);\n    if(t == 1) {\n      int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n\n      set<pii> &alive = intervals[x];\n      pii intv(l, r);\n      \n      if(alive.empty()) {\n        alive.insert(intv);\n        segtree::add(l, r, 1);\n        continue;\n      }\n\n      auto it = alive.lower_bound(pii(l, -1));\n      if(it != alive.begin()) {\n        it--;\n      }\n      if(it != alive.end() && it->second < l) {\n        it++;\n      }\n\n      if(it == alive.end()) {\n        alive.insert(intv);\n        segtree::add(l, r, 1);\n        continue;\n      }\n\n      if(it->second < l || it->first > r) {\n        alive.insert(intv);\n        segtree::add(l, r, 1);\n        continue;\n      }\n\n      if(it->first < intv.first)\n        intv.first = it->first;\n\n      int last = l-1;\n      while(it != alive.end()) {\n        pii intersection (max(it->first, l), min(it->second, r));\n        if(intersection.first <= intersection.second) {\n          if(last < intersection.first - 1) {\n            segtree::add(last + 1, intersection.first - 1, 1);\n          }\n          segtree::multiply(intersection.first, intersection.second, 2);\n          last = intersection.second;\n          if(intv.second < it->second)\n            intv.second = it->second;\n          \n          auto tmp = it;\n          it++;\n          alive.erase(tmp);\n        }else {\n          break;\n        }\n      }\n\n      if(last < r) {\n        segtree::add(last + 1, r, 1);\n      }\n      alive.insert(intv);\n    }else {\n      int l, r; scanf(\"%d%d\", &l, &r);\n      printf(\"%d\\n\", segtree::get(l, r));\n    }\n  }\n  return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private k.frontend.ModelParser.ExpressionContext expression(int _p) throws k.frontend.RecognitionException {\n    k.frontend.ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    k.frontend.ModelParser.ExpressionContext _localctx = new k.frontend.ModelParser.ExpressionContext(_ctx, _parentState);\n    k.frontend.ModelParser.ExpressionContext _prevctx = _localctx;\n    int _startState = 58;\n    enterRecursionRule(_localctx, 58, k.frontend.ModelParser.RULE_expression, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(470);\n            switch (getInterpreter().adaptivePredict(_input, 46, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new k.frontend.ModelParser.NotExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(365);\n                        match(k.frontend.ModelParser.T__55);\n                        setState(366);\n                        expression(28);\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new k.frontend.ModelParser.NegExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(367);\n                        match(k.frontend.ModelParser.T__47);\n                        setState(368);\n                        expression(9);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new k.frontend.ModelParser.ForallExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(369);\n                        match(k.frontend.ModelParser.T__16);\n                        setState(370);\n                        rngBindingList();\n                        setState(371);\n                        match(k.frontend.ModelParser.SUCHTHAT);\n                        setState(372);\n                        expression(7);\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new k.frontend.ModelParser.ExistsExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(374);\n                        match(k.frontend.ModelParser.T__9);\n                        setState(375);\n                        rngBindingList();\n                        setState(376);\n                        match(k.frontend.ModelParser.SUCHTHAT);\n                        setState(377);\n                        expression(6);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new k.frontend.ModelParser.LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(379);\n                        pattern(0);\n                        setState(380);\n                        match(k.frontend.ModelParser.T__79);\n                        setState(381);\n                        expression(5);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new k.frontend.ModelParser.ParenExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(383);\n                        match(k.frontend.ModelParser.T__45);\n                        setState(384);\n                        expression(0);\n                        setState(385);\n                        match(k.frontend.ModelParser.T__75);\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new k.frontend.ModelParser.TupleExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(387);\n                        match(k.frontend.ModelParser.T__65);\n                        setState(388);\n                        match(k.frontend.ModelParser.T__45);\n                        setState(389);\n                        expression(0);\n                        setState(392);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        do {\n                            {\n                                {\n                                    setState(390);\n                                    match(k.frontend.ModelParser.T__49);\n                                    setState(391);\n                                    expression(0);\n                                }\n                            }\n                            setState(394);\n                            _errHandler.sync(this);\n                            _la = _input.LA(1);\n                        } while (_la == (k.frontend.ModelParser.T__49) );\n                        setState(396);\n                        match(k.frontend.ModelParser.T__75);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new k.frontend.ModelParser.LiteralExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(398);\n                        literal();\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new k.frontend.ModelParser.IdentExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(399);\n                        match(k.frontend.ModelParser.Identifier);\n                    }\n                    break;\n                case 10 :\n                    {\n                        _localctx = new k.frontend.ModelParser.BlockExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(400);\n                        match(k.frontend.ModelParser.T__36);\n                        setState(401);\n                        block();\n                        setState(402);\n                        match(k.frontend.ModelParser.T__84);\n                    }\n                    break;\n                case 11 :\n                    {\n                        _localctx = new k.frontend.ModelParser.IfExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(404);\n                        match(k.frontend.ModelParser.T__43);\n                        setState(405);\n                        expression(0);\n                        setState(406);\n                        match(k.frontend.ModelParser.T__5);\n                        setState(407);\n                        expression(0);\n                        setState(410);\n                        switch (getInterpreter().adaptivePredict(_input, 42, _ctx)) {\n                            case 1 :\n                                {\n                                    setState(408);\n                                    match(k.frontend.ModelParser.T__31);\n                                    setState(409);\n                                    expression(0);\n                                }\n                                break;\n                        }\n                    }\n                    break;\n                case 12 :\n                    {\n                        _localctx = new k.frontend.ModelParser.MatchExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(412);\n                        match(k.frontend.ModelParser.T__41);\n                        setState(413);\n                        expression(0);\n                        setState(414);\n                        match(k.frontend.ModelParser.T__12);\n                        setState(416);\n                        _errHandler.sync(this);\n                        _alt = 1;\n                        do {\n                            switch (_alt) {\n                                case 1 :\n                                    {\n                                        {\n                                            setState(415);\n                                            match();\n                                        }\n                                    }\n                                    break;\n                                default :\n                                    throw new k.frontend.NoViableAltException(this);\n                            }\n                            setState(418);\n                            _errHandler.sync(this);\n                            _alt = getInterpreter().adaptivePredict(_input, 43, _ctx);\n                        } while ((_alt != 2) && (_alt != (org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER)) );\n                    }\n                    break;\n                case 13 :\n                    {\n                        _localctx = new k.frontend.ModelParser.WhileExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(420);\n                        match(k.frontend.ModelParser.T__48);\n                        setState(421);\n                        expression(0);\n                        setState(422);\n                        match(k.frontend.ModelParser.T__80);\n                        setState(423);\n                        expression(0);\n                    }\n                    break;\n                case 14 :\n                    {\n                        _localctx = new k.frontend.ModelParser.ForExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(425);\n                        match(k.frontend.ModelParser.T__18);\n                        setState(426);\n                        pattern(0);\n                        setState(427);\n                        match(k.frontend.ModelParser.T__50);\n                        setState(428);\n                        expression(0);\n                        setState(429);\n                        match(k.frontend.ModelParser.T__80);\n                        setState(430);\n                        expression(0);\n                    }\n                    break;\n                case 15 :\n                    {\n                        _localctx = new k.frontend.ModelParser.SetEnumExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(432);\n                        collectionKind();\n                        setState(433);\n                        match(k.frontend.ModelParser.T__36);\n                        setState(435);\n                        _la = _input.LA(1);\n                        if ((((_la & (~63)) == 0) && (((1L << _la) & ((((((((((((((1L << (k.frontend.ModelParser.T__88)) | (1L << (k.frontend.ModelParser.T__74))) | (1L << (k.frontend.ModelParser.T__73))) | (1L << (k.frontend.ModelParser.T__65))) | (1L << (k.frontend.ModelParser.T__56))) | (1L << (k.frontend.ModelParser.T__55))) | (1L << (k.frontend.ModelParser.T__48))) | (1L << (k.frontend.ModelParser.T__47))) | (1L << (k.frontend.ModelParser.T__46))) | (1L << (k.frontend.ModelParser.T__45))) | (1L << (k.frontend.ModelParser.T__43))) | (1L << (k.frontend.ModelParser.T__41))) | (1L << (k.frontend.ModelParser.T__36))) | (1L << (k.frontend.ModelParser.T__34)))) != 0)) || ((((_la - 65) & (~63)) == 0) && (((1L << (_la - 65)) & ((((((((((((((1L << ((k.frontend.ModelParser.T__28) - 65)) | (1L << ((k.frontend.ModelParser.T__18) - 65))) | (1L << ((k.frontend.ModelParser.T__17) - 65))) | (1L << ((k.frontend.ModelParser.T__16) - 65))) | (1L << ((k.frontend.ModelParser.T__15) - 65))) | (1L << ((k.frontend.ModelParser.T__9) - 65))) | (1L << ((k.frontend.ModelParser.IntegerLiteral) - 65))) | (1L << ((k.frontend.ModelParser.RealLiteral) - 65))) | (1L << ((k.frontend.ModelParser.BooleanLiteral) - 65))) | (1L << ((k.frontend.ModelParser.NullLiteral) - 65))) | (1L << ((k.frontend.ModelParser.ThisLiteral) - 65))) | (1L << ((k.frontend.ModelParser.CharacterLiteral) - 65))) | (1L << ((k.frontend.ModelParser.StringLiteral) - 65))) | (1L << ((k.frontend.ModelParser.Identifier) - 65)))) != 0))) {\n                            {\n                                setState(434);\n                                expressionList();\n                            }\n                        }\n                        setState(437);\n                        match(k.frontend.ModelParser.T__84);\n                    }\n                    break;\n                case 16 :\n                    {\n                        _localctx = new k.frontend.ModelParser.SetRngExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(439);\n                        collectionKind();\n                        setState(440);\n                        match(k.frontend.ModelParser.T__36);\n                        setState(441);\n                        expression(0);\n                        setState(442);\n                        match(k.frontend.ModelParser.T__53);\n                        setState(443);\n                        expression(0);\n                        setState(444);\n                        match(k.frontend.ModelParser.T__84);\n                    }\n                    break;\n                case 17 :\n                    {\n                        _localctx = new k.frontend.ModelParser.SetCompExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(446);\n                        collectionKind();\n                        setState(447);\n                        match(k.frontend.ModelParser.T__36);\n                        setState(448);\n                        expression(0);\n                        setState(449);\n                        match(k.frontend.ModelParser.T__57);\n                        setState(450);\n                        rngBindingList();\n                        setState(451);\n                        match(k.frontend.ModelParser.SUCHTHAT);\n                        setState(452);\n                        expression(0);\n                        setState(453);\n                        match(k.frontend.ModelParser.T__84);\n                    }\n                    break;\n                case 18 :\n                    {\n                        _localctx = new k.frontend.ModelParser.AssertExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(455);\n                        match(k.frontend.ModelParser.T__56);\n                        setState(456);\n                        match(k.frontend.ModelParser.T__45);\n                        setState(457);\n                        expression(0);\n                        setState(458);\n                        match(k.frontend.ModelParser.T__75);\n                    }\n                    break;\n                case 19 :\n                    {\n                        _localctx = new k.frontend.ModelParser.PrevExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(460);\n                        qualifiedName();\n                        setState(461);\n                        match(k.frontend.ModelParser.T__2);\n                    }\n                    break;\n                case 20 :\n                    {\n                        _localctx = new k.frontend.ModelParser.ContinueExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(463);\n                        match(k.frontend.ModelParser.T__88);\n                    }\n                    break;\n                case 21 :\n                    {\n                        _localctx = new k.frontend.ModelParser.BreakExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(464);\n                        match(k.frontend.ModelParser.T__34);\n                    }\n                    break;\n                case 22 :\n                    {\n                        _localctx = new k.frontend.ModelParser.ReturnExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(465);\n                        match(k.frontend.ModelParser.T__15);\n                        setState(467);\n                        switch (getInterpreter().adaptivePredict(_input, 45, _ctx)) {\n                            case 1 :\n                                {\n                                    setState(466);\n                                    expression(0);\n                                }\n                                break;\n                        }\n                    }\n                    break;\n                case 23 :\n                    {\n                        _localctx = new k.frontend.ModelParser.ResultExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(469);\n                        match(k.frontend.ModelParser.T__17);\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT((-1));\n            setState(510);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 49, _ctx);\n            while ((_alt != 2) && (_alt != (org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER))) {\n                if (_alt == 1) {\n                    if ((_parseListeners) != null)\n                        triggerExitRuleEvent();\n                    \n                    _prevctx = _localctx;\n                    {\n                        setState(508);\n                        switch (getInterpreter().adaptivePredict(_input, 48, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.BinOp1ExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(472);\n                                    if (!(precpred(_ctx, 19)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 19)\");\n                                    \n                                    setState(473);\n                                    _la = _input.LA(1);\n                                    if (!((((_la & (~63)) == 0) && (((1L << _la) & (((1L << (k.frontend.ModelParser.T__92)) | (1L << (k.frontend.ModelParser.T__78))) | (1L << (k.frontend.ModelParser.T__62)))) != 0)) || ((((_la - 64) & (~63)) == 0) && (((1L << (_la - 64)) & (((((1L << ((k.frontend.ModelParser.T__29) - 64)) | (1L << ((k.frontend.ModelParser.T__26) - 64))) | (1L << ((k.frontend.ModelParser.T__24) - 64))) | (1L << ((k.frontend.ModelParser.T__3) - 64))) | (1L << ((k.frontend.ModelParser.T__1) - 64)))) != 0)))) {\n                                        _errHandler.recoverInline(this);\n                                    }\n                                    consume();\n                                    setState(474);\n                                    expression(20);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.BinOp2ExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(475);\n                                    if (!(precpred(_ctx, 18)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 18)\");\n                                    \n                                    setState(476);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 17) & (~63)) == 0) && (((1L << (_la - 17)) & (((1L << ((k.frontend.ModelParser.T__76) - 17)) | (1L << ((k.frontend.ModelParser.T__47) - 17))) | (1L << ((k.frontend.ModelParser.T__19) - 17)))) != 0))) {\n                                        _errHandler.recoverInline(this);\n                                    }\n                                    consume();\n                                    setState(477);\n                                    expression(19);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.BinOp3ExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(478);\n                                    if (!(precpred(_ctx, 17)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 17)\");\n                                    \n                                    setState(479);\n                                    _la = _input.LA(1);\n                                    if (!(((((_la & (~63)) == 0) && (((1L << _la) & ((((((((1L << (k.frontend.ModelParser.T__90)) | (1L << (k.frontend.ModelParser.T__89))) | (1L << (k.frontend.ModelParser.T__87))) | (1L << (k.frontend.ModelParser.T__86))) | (1L << (k.frontend.ModelParser.T__83))) | (1L << (k.frontend.ModelParser.T__69))) | (1L << (k.frontend.ModelParser.T__66))) | (1L << (k.frontend.ModelParser.T__32)))) != 0)) || (_la == (k.frontend.ModelParser.T__10))) || (_la == (k.frontend.ModelParser.T__0)))) {\n                                        _errHandler.recoverInline(this);\n                                    }\n                                    consume();\n                                    setState(480);\n                                    expression(18);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.AndExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(481);\n                                    if (!(precpred(_ctx, 16)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 16)\");\n                                    \n                                    setState(482);\n                                    match(k.frontend.ModelParser.T__13);\n                                    setState(483);\n                                    expression(17);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.OrExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(484);\n                                    if (!(precpred(_ctx, 15)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 15)\");\n                                    \n                                    setState(485);\n                                    match(k.frontend.ModelParser.T__11);\n                                    setState(486);\n                                    expression(16);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.IFFExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(487);\n                                    if (!(precpred(_ctx, 14)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 14)\");\n                                    \n                                    setState(488);\n                                    _la = _input.LA(1);\n                                    if (!((_la == (k.frontend.ModelParser.T__68)) || (_la == (k.frontend.ModelParser.T__20)))) {\n                                        _errHandler.recoverInline(this);\n                                    }\n                                    consume();\n                                    setState(489);\n                                    expression(15);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.AssignExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(490);\n                                    if (!(precpred(_ctx, 13)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 13)\");\n                                    \n                                    setState(491);\n                                    match(k.frontend.ModelParser.T__6);\n                                    setState(492);\n                                    expression(14);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.DotExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(493);\n                                    if (!(precpred(_ctx, 30)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 30)\");\n                                    \n                                    setState(494);\n                                    match(k.frontend.ModelParser.T__21);\n                                    setState(495);\n                                    match(k.frontend.ModelParser.Identifier);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.AppExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(496);\n                                    if (!(precpred(_ctx, 29)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 29)\");\n                                    \n                                    setState(497);\n                                    match(k.frontend.ModelParser.T__45);\n                                    setState(499);\n                                    _la = _input.LA(1);\n                                    if ((((_la & (~63)) == 0) && (((1L << _la) & ((((((((((((((1L << (k.frontend.ModelParser.T__88)) | (1L << (k.frontend.ModelParser.T__74))) | (1L << (k.frontend.ModelParser.T__73))) | (1L << (k.frontend.ModelParser.T__65))) | (1L << (k.frontend.ModelParser.T__56))) | (1L << (k.frontend.ModelParser.T__55))) | (1L << (k.frontend.ModelParser.T__48))) | (1L << (k.frontend.ModelParser.T__47))) | (1L << (k.frontend.ModelParser.T__46))) | (1L << (k.frontend.ModelParser.T__45))) | (1L << (k.frontend.ModelParser.T__43))) | (1L << (k.frontend.ModelParser.T__41))) | (1L << (k.frontend.ModelParser.T__36))) | (1L << (k.frontend.ModelParser.T__34)))) != 0)) || ((((_la - 65) & (~63)) == 0) && (((1L << (_la - 65)) & ((((((((((((((1L << ((k.frontend.ModelParser.T__28) - 65)) | (1L << ((k.frontend.ModelParser.T__18) - 65))) | (1L << ((k.frontend.ModelParser.T__17) - 65))) | (1L << ((k.frontend.ModelParser.T__16) - 65))) | (1L << ((k.frontend.ModelParser.T__15) - 65))) | (1L << ((k.frontend.ModelParser.T__9) - 65))) | (1L << ((k.frontend.ModelParser.IntegerLiteral) - 65))) | (1L << ((k.frontend.ModelParser.RealLiteral) - 65))) | (1L << ((k.frontend.ModelParser.BooleanLiteral) - 65))) | (1L << ((k.frontend.ModelParser.NullLiteral) - 65))) | (1L << ((k.frontend.ModelParser.ThisLiteral) - 65))) | (1L << ((k.frontend.ModelParser.CharacterLiteral) - 65))) | (1L << ((k.frontend.ModelParser.StringLiteral) - 65))) | (1L << ((k.frontend.ModelParser.Identifier) - 65)))) != 0))) {\n                                        {\n                                            setState(498);\n                                            argumentList();\n                                        }\n                                    }\n                                    setState(501);\n                                    match(k.frontend.ModelParser.T__75);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.TypeCheckExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(502);\n                                    if (!(precpred(_ctx, 12)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 12)\");\n                                    \n                                    setState(503);\n                                    match(k.frontend.ModelParser.T__25);\n                                    setState(504);\n                                    type(0);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new k.frontend.ModelParser.TypeCastExpContext(new k.frontend.ModelParser.ExpressionContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, k.frontend.ModelParser.RULE_expression);\n                                    setState(505);\n                                    if (!(precpred(_ctx, 11)))\n                                        throw new k.frontend.FailedPredicateException(this, \"precpred(_ctx, 11)\");\n                                    \n                                    setState(506);\n                                    match(k.frontend.ModelParser.T__38);\n                                    setState(507);\n                                    type(0);\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(512);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 49, _ctx);\n            } \n        }\n    } catch (k.frontend.RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}",
        "fixed_code": "public final k.frontend.ModelParser.BlockContext block() throws k.frontend.RecognitionException {\n    k.frontend.ModelParser.BlockContext _localctx = new k.frontend.ModelParser.BlockContext(_ctx, getState());\n    enterRule(_localctx, 22, k.frontend.ModelParser.RULE_block);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(200);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((_la & (~63)) == 0) && (((1L << _la) & ((((((((((((((((((((1L << (k.frontend.ModelParser.T__92)) | (1L << (k.frontend.ModelParser.T__89))) | (1L << (k.frontend.ModelParser.T__86))) | (1L << (k.frontend.ModelParser.T__85))) | (1L << (k.frontend.ModelParser.T__79))) | (1L << (k.frontend.ModelParser.T__77))) | (1L << (k.frontend.ModelParser.T__74))) | (1L << (k.frontend.ModelParser.T__69))) | (1L << (k.frontend.ModelParser.T__68))) | (1L << (k.frontend.ModelParser.T__62))) | (1L << (k.frontend.ModelParser.T__57))) | (1L << (k.frontend.ModelParser.T__56))) | (1L << (k.frontend.ModelParser.T__53))) | (1L << (k.frontend.ModelParser.T__47))) | (1L << (k.frontend.ModelParser.T__44))) | (1L << (k.frontend.ModelParser.T__39))) | (1L << (k.frontend.ModelParser.T__35))) | (1L << (k.frontend.ModelParser.T__34))) | (1L << (k.frontend.ModelParser.T__33))) | (1L << (k.frontend.ModelParser.T__30)))) != 0)) || ((((_la - 66) & (~63)) == 0) && (((1L << (_la - 66)) & (((((((((((((((((((1L << ((k.frontend.ModelParser.T__27) - 66)) | (1L << ((k.frontend.ModelParser.T__26) - 66))) | (1L << ((k.frontend.ModelParser.T__23) - 66))) | (1L << ((k.frontend.ModelParser.T__22) - 66))) | (1L << ((k.frontend.ModelParser.T__21) - 66))) | (1L << ((k.frontend.ModelParser.T__12) - 66))) | (1L << ((k.frontend.ModelParser.T__10) - 66))) | (1L << ((k.frontend.ModelParser.T__9) - 66))) | (1L << ((k.frontend.ModelParser.T__7) - 66))) | (1L << ((k.frontend.ModelParser.T__2) - 66))) | (1L << ((k.frontend.ModelParser.T__0) - 66))) | (1L << ((k.frontend.ModelParser.IntegerLiteral) - 66))) | (1L << ((k.frontend.ModelParser.RealLiteral) - 66))) | (1L << ((k.frontend.ModelParser.BooleanLiteral) - 66))) | (1L << ((k.frontend.ModelParser.NullLiteral) - 66))) | (1L << ((k.frontend.ModelParser.ThisLiteral) - 66))) | (1L << ((k.frontend.ModelParser.CharacterLiteral) - 66))) | (1L << ((k.frontend.ModelParser.StringLiteral) - 66))) | (1L << ((k.frontend.ModelParser.Identifier) - 66)))) != 0))) {\n                {\n                    {\n                        setState(197);\n                        blockDeclaration();\n                    }\n                }\n                setState(202);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (k.frontend.RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "n, m = map(int, input().split())\ncats = list(map(bool,map(int, input().split())))\nedges = {}\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    if x in edges:\n        edges[x].append(y)\n    else:\n        edges[x] = [y]\n    if y in edges:\n        edges[y].append(x)\n    else:\n        edges[y] = [x]\n\nstack = [1]\nvisited = {1}\ncat_num = {1: 1 if cats[0] else 0}\nc = 0\nwhile stack:\n    p = stack.pop()\n    if cat_num[p] <= m:\n        f = False\n        for child in edges[p]:\n            if child not in visited:\n                f = True\n                visited.add(child)\n                stack.append(child)\n                if cats[p-1] and cats[child-1]:\n                    cat_num[child] = cat_num[p] + 1\n                else:\n                    cat_num[child] = 0\n        if not f:\n            c += 1\n\nprint(c)\n",
        "fixed_code": "n, m = map(int, input().split())\ncats = list(map(bool, map(int, input().split())))\nedges = {}\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    if x in edges:\n        edges[x].append(y)\n    else:\n        edges[x] = [y]\n    if y in edges:\n        edges[y].append(x)\n    else:\n        edges[y] = [x]\n\nstack = [1]\nvisited = {1}\ncat_num = {1: 1 if cats[0] else 0}\nc = 0\nwhile stack:\n    p = stack.pop()\n    if cat_num[p] <= m:\n        f = False\n        for child in edges[p]:\n            if child not in visited:\n                f = True\n                visited.add(child)\n                stack.append(child)\n                if cats[p-1] and cats[child-1]:\n                    cat_num[child] = cat_num[p] + 1\n                else:\n                    cat_num[child] = 1 if cats[child-1] else 0\n        if not f:\n            c += 1\n\nprint(c)\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "import java.util.*;\n//import java.lang.Math;\nimport java.math.*;\n//import java.math.BigInteger;\npublic class MeranamJocker\n{\n\t\n\n\n\tpublic static void main(String[] argc)\n\t{ \n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t    int t=s.nextInt();\n\t    while(t!=0)\n\t    {\n\t    \tt--;\n\t    \tint n=s.nextInt(),j=s.nextInt(),p=s.nextInt();\n\t    \t  int x=n/p;\n\t    \t  int[] a=new int[p];\n\t    \t  if(j>=x)\n\t    \t  {\n\t    \t\t  a[0]=x;\n\t    \t\t  j=j-x;\n\t    \t\t  p=p-1;\n\t    \t\t  if(j%p!=0)\n\t    \t\t  {\n\t    \t\t\t  a[1]=(j/p)+1;\n\t    \t\t\t  \n\t    \t\t  }\n\t    \t\t  \n\t    \t\t  \n\t    \t  }\n\t    \t  else\n\t    \t  {\n\t    \t\t  a[0]=j;\n\t    \t\t  a[1]=0;\n\t    \t  }\n\t    \t  int c=a[0]-a[1];\n\t    \t  System.out.println(c);\n\t    \t\n\t    }\n\t\t       \n\t\t\n\t \n\n}\n}",
        "fixed_code": "import java.util.*;\n//import java.lang.Math;\nimport java.math.*;\n//import java.math.BigInteger;\npublic class MeranamJocker\n{\n\t\n\n\n\tpublic static void main(String[] argc)\n\t{ \n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t    int t=s.nextInt();\n\t    while(t!=0)\n\t    {\n\t    \tt--;\n\t    \tint n=s.nextInt(),j=s.nextInt(),p=s.nextInt();\n\t    \t  int x=n/p;\n\t    \t  int[] a=new int[p];\n\t    \t  if(j>=x)\n\t    \t  {\n\t    \t\t  a[0]=x;\n\t    \t\t  j=j-x;\n\t    \t\t  p=p-1;\n\t    \t\t  if(j%p!=0)\n\t    \t\t  {\n\t    \t\t\t  a[1]=(j/p)+1;\n\t    \t\t\t  \n\t    \t\t  }\n                          else\n\t    \t\t  {\n\t    \t\t\t  a[1]=j/p;\n\t    \t\t  }\n\t    \t\t  \n\t    \t\t  \n\t    \t  }\n\t    \t  else\n\t    \t  {\n\t    \t\t  a[0]=j;\n\t    \t\t  a[1]=0;\n\t    \t  }\n\t    \t  int c=a[0]-a[1];\n\t    \t  System.out.println(c);\n\t    \t\n\t    }\n\t\t       \n\t\t\n\t \n\n}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<iostream>\r\n#include<bits/stdc++.h>\r\n#include<array>\r\n#include<vector>\r\n#include<set>\r\n#include<unordered_set>\r\n#include<algorithm>\r\n#include<string>\r\n#include<cmath>\r\n#include<stack>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define mod 1000000007\r\n\r\n//sieve\r\n// void sieve(ll n)\r\n// {\r\n//     bool prime[n+1];\r\n//     memset(prime,true,sizeof(prime));\r\n//     prime[0]=prime[1]=false;\r\n//     for(ll p=2;p*p<=n;p++)\r\n//         {\r\n//             if(prime[p])\r\n//                 {\r\n//                     for(ll i=p*p;i<=n;i+=p)\r\n//                         {\r\n//                             prime[i]=false;\r\n//                         }\r\n//                 }\r\n//         }\r\n// }\r\n \r\nll gcd(ll a, ll b) \r\n{ \r\n    if (b == 0) \r\n        return a; \r\n    return gcd(b, a % b); \r\n}\r\n\r\n//Input-Output File\r\n// void fileio(){\r\n//     #ifndef ONLINE_JUDGE\r\n//     freopen(\"input.txt\", \"r\", stdin) ;\r\n//     freopen(\"output.txt\", \"w\", stdout) ;\r\n//     #endif\r\n// }\r\n\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    ll t;\r\n    cin>>t;\r\n    while(t--)\r\n        {\r\n            ll n,l,r,k,a;\r\n            cin>>n>>l>>r>>k;\r\n            ll v[n];\r\n            for(ll i=0;i<n;i++)\r\n                {\r\n                    cin>>v[i];\r\n                }\r\n            sort(a,a+n);\r\n            ll ans=0;\r\n            for(int i=0;i<n;i++)\r\n                {\r\n                    // cout<<v[i]<<\" \";\r\n                    if(v[i]>=l and v[i]<=r and k>=v[i])\r\n                        {\r\n                            ans++;\r\n                            k=k-v[i];\r\n                        }\r\n                } \r\n            // cout<<endl;\r\n            cout<<ans<<endl;\r\n        } \r\n}\r\n\r\n \r\n",
        "fixed_code": "#include<iostream>\r\n#include<bits/stdc++.h>\r\n#include<array>\r\n#include<vector>\r\n#include<set>\r\n#include<unordered_set>\r\n#include<algorithm>\r\n#include<string>\r\n#include<cmath>\r\n#include<stack>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define mod 1000000007\r\n\r\n//sieve\r\n// void sieve(ll n)\r\n// {\r\n//     bool prime[n+1];\r\n//     memset(prime,true,sizeof(prime));\r\n//     prime[0]=prime[1]=false;\r\n//     for(ll p=2;p*p<=n;p++)\r\n//         {\r\n//             if(prime[p])\r\n//                 {\r\n//                     for(ll i=p*p;i<=n;i+=p)\r\n//                         {\r\n//                             prime[i]=false;\r\n//                         }\r\n//                 }\r\n//         }\r\n// }\r\n \r\nll gcd(ll a, ll b) \r\n{ \r\n    if (b == 0) \r\n        return a; \r\n    return gcd(b, a % b); \r\n}\r\n\r\n//Input-Output File\r\n// void fileio(){\r\n//     #ifndef ONLINE_JUDGE\r\n//     freopen(\"input.txt\", \"r\", stdin) ;\r\n//     freopen(\"output.txt\", \"w\", stdout) ;\r\n//     #endif\r\n// }\r\n\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    ll t;\r\n    cin>>t;\r\n    while(t--)\r\n        {\r\n            ll n,l,r,k,a;\r\n            cin>>n>>l>>r>>k;\r\n            ll v[n];\r\n            for(ll i=0;i<n;i++)\r\n                {\r\n                    cin>>v[i];\r\n                }\r\n            sort(v,v+n);\r\n            ll ans=0;\r\n            for(int i=0;i<n;i++)\r\n                {\r\n                    // cout<<v[i]<<\" \";\r\n                    if(v[i]>=l and v[i]<=r and k>=v[i])\r\n                        {\r\n                            ans++;\r\n                            k=k-v[i];\r\n                        }\r\n                } \r\n            // cout<<endl;\r\n            cout<<ans<<endl;\r\n        } \r\n}\r\n\r\n \r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=300005;\nint n;ll w[N],msk[N],t[70];\nint main()\n{\n\tscanf(\"%d\",&n);ll s=0,nw,ans=0;\n\tfor(int i=1;i<=n;i++){scanf(\"%lld%lld\",&w[i],&msk[i]);s+=w[i];}\n\tif(s<0){for(int i=1;i<=n;i++)w[i]=-w[i];s=-s;}\n\ts=(s+2)/2;nw=0;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<62;j++)if(msk[i]>>j&1)t[j]+=w[i];\n\twhile(nw<s)\n\t{\n\t\tint mx=0;for(int i=0;i<62;i++)if(t[i]>t[mx])mx=i;\n\t\tnw+=t[mx];ans^=1ll<<mx;\n\t\tfor(int i=1;i<=n;i++)if(msk[i]>>mx&1)\n\t\t{\n\t\t\tfor(int j=0;j<62;j++)if(msk[i]>>j&1)t[j]-=w[i]*2;\n\t\t\tw[i]=-w[i];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long \nconst int N=3e5+5;\nint n,w[N];ll msk[N];\nint main()\n{\n\tscanf(\"%d\",&n);ll s=0,ans=0;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%lld\",&w[i],&msk[i]),s+=w[i];\n\tif(s>0)for(int i=1;i<=n;i++)w[i]=-w[i];\n\tfor(int j=0;j<62;j++)\n\t{\n\t\ts=0;for(int i=1;i<=n;i++)if((msk[i]>>j)==1)s+=w[i];\n\t\tif(s<0){ans|=1ll<<j;for(int i=1;i<=n;i++)if(msk[i]>>j&1)w[i]=-w[i];}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*\nAccepted for God sake\n  /\\___/\\\n ( =^.^= )\n  (\") (\")_/\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define Ahmed_El_Moataz           ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define fo(i,a,b)                 for(int i=(a);i<(b);i++)\n#define dfo(i,a,b)                  for(int i=(a-1);i>=b;i--)\n#define CN(arr,t)                 for(int i=0;i<t;i++)cin>>arr[i]\ntypedef long long  ll;\ntypedef unsigned long long  ull;\nconst ll mod7 = 1000000007,mod = 1000000000;\ndouble Pi=acos(-1);\nconst double long rad=Pi/180.0;\nint GCD(int a,int b){return (b==0)?a:GCD(b,a%b);}\n/* __builtin_popcount(i) a=97  A=65 z=122 Z=90 0=48 setw() <<setprecision(9) I64d ull::18446744073709551615*/\n\n/********************************************************************/\n#define close       {cout<<\"-1\";return 0;}\n#define show(x)      cout<<endl<<x<<endl;\n\nint main()\n{\n    Ahmed_El_Moataz\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    int n,m;\n    cin>>n>>m;\n    if(n>m)swap(n,m);\n    if(n==0 && m==0){cout<<0;return 0;}\n    else if(n==0){cout<<\"1\\n0 1\";return 0;}\n    cout<<n+1<<endl;\n    int a=0,b=m;\n    while(a!=n+1 && b!=-1){\n        cout<<a<<\" \"<<b<<endl;\n        a++;b--;\n    }\n}\n",
        "fixed_code": "/*\nAccepted for God sake\n  /\\___/\\\n ( =^.^= )\n  (\") (\")_/\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define Ahmed_El_Moataz           ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define fo(i,a,b)                 for(int i=(a);i<(b);i++)\n#define dfo(i,a,b)                  for(int i=(a-1);i>=b;i--)\n#define CN(arr,t)                 for(int i=0;i<t;i++)cin>>arr[i]\ntypedef long long  ll;\ntypedef unsigned long long  ull;\nconst ll mod7 = 1000000007,mod = 1000000000;\ndouble Pi=acos(-1);\nconst double long rad=Pi/180.0;\nint GCD(int a,int b){return (b==0)?a:GCD(b,a%b);}\n/* __builtin_popcount(i) a=97  A=65 z=122 Z=90 0=48 setw() <<setprecision(9) I64d ull::18446744073709551615*/\n\n/********************************************************************/\n#define close       {cout<<\"-1\";return 0;}\n#define show(x)      cout<<endl<<x<<endl;\n\nint main()\n{\n    Ahmed_El_Moataz\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    int n,m;\n    cin>>n>>m;\n    int a=0,b=m;\n    if(n>m)swap(n,m);\n    if(n==0 && m==0){cout<<0;return 0;}\n    else if(n==0){cout<<\"1\\n0 1\";return 0;}\n    cout<<n+1<<endl;\n    if(b!=m){\n        swap(n,m);\n        b=m;\n    }\n    while(a!=n+1 && b!=-1){\n        cout<<a<<\" \"<<b<<endl;\n        a++;b--;\n    }\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\r\n#include<vector>\r\n#include<queue>\r\n#include<set>\r\n#include<map>\r\n#include<string>\r\n#include<bitset>\r\n#include<stack>\r\n#include<algorithm>\r\n#include<iomanip>  // cout << setprecision(...) <<  fixed;\r\n// #include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define ld long double\r\n#define vll vector<ll>\r\n#define qll queue<ll>\r\n#define sll set<ll>\r\n#define cll const ll\r\n#define cld const ld\r\n#define FOR(i, start, finish) for(int i = start; i < finish; i++)\r\n\r\n#ifdef LOCAL\r\n#define pausesys cout << \"\\n\"; system(\"pause\");\r\n#else\r\n#define pausesys cout << \"\";\r\n#endif\r\n\r\ncld pi = atan2l(0, -1);\r\ncld EPS = 1e-7;\r\ncll mod = 998244353;\r\n\r\n\r\npair<ll,ll> a[500000];\r\n\r\nint main() {\r\n\t// freopen(\".in\", \"r\", stdin);\r\n\t// freopen(\".out\", \"w\", stdout);\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\r\n\tll t;\r\n\tcin >> t;\r\n\twhile (t--) {\r\n\t\tll n;\r\n\t\tll k;\r\n\t\tcin >> n >> k;\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tcin >> a[i].first;\r\n\t\t\ta[i].second = i;\r\n\t\t}\r\n\t\tsort(a, a + n);\r\n\t\tll ans = 0; \r\n\t\tfor (int i = 1; i < n; i++) {\r\n\t\t\tif (a[i - 1].second + 1 != a[i].second) {\r\n\t\t\t\tans++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ans <= k) {\r\n\t\t\tcout << \"YES\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << \"NO\";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\t\r\n\tpausesys;\r\n}\r\n/*\r\n\r\n\r\n\r\n*/",
        "fixed_code": "#include<iostream>\r\n#include<vector>\r\n#include<queue>\r\n#include<set>\r\n#include<map>\r\n#include<string>\r\n#include<bitset>\r\n#include<stack>\r\n#include<algorithm>\r\n#include<iomanip>  // cout << setprecision(...) <<  fixed;\r\n// #include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define ld long double\r\n#define vll vector<ll>\r\n#define qll queue<ll>\r\n#define sll set<ll>\r\n#define cll const ll\r\n#define cld const ld\r\n#define FOR(i, start, finish) for(int i = start; i < finish; i++)\r\n\r\n#ifdef LOCAL\r\n#define pausesys cout << \"\\n\"; system(\"pause\");\r\n#else\r\n#define pausesys cout << \"\";\r\n#endif\r\n\r\ncld pi = atan2l(0, -1);\r\ncld EPS = 1e-7;\r\ncll mod = 998244353;\r\n\r\n\r\npair<ll,ll> a[500000];\r\n\r\nint main() {\r\n\t// freopen(\".in\", \"r\", stdin);\r\n\t// freopen(\".out\", \"w\", stdout);\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\r\n\tll t;\r\n\tcin >> t;\r\n\twhile (t--) {\r\n\t\tll n;\r\n\t\tll k;\r\n\t\tcin >> n >> k;\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tcin >> a[i].first;\r\n\t\t\ta[i].second = i;\r\n\t\t}\r\n\t\tsort(a, a + n);\r\n\t\tll ans = 1; \r\n\t\tfor (int i = 1; i < n; i++) {\r\n\t\t\tif (a[i - 1].second + 1 != a[i].second) {\r\n\t\t\t\tans++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ans <= k) {\r\n\t\t\tcout << \"YES\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << \"NO\";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\t\r\n\tpausesys;\r\n}\r\n/*\r\n\r\n\r\n\r\n*/",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define fastio     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define fi         first\n#define se         second\n#define int        long long \n#define pb         push_back\n#define emp        emplace_back\n#define vv(x)      vector<x>\n#define mp(x,y)    map<x,y>\n#define dq(x)      deque<x>\n#define pql(x)     priority_queue<x>\n#define pqs(x)     priority_queue<x,vv(x),greater<x> >\n#define MOD          1000000007\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define it(x)      x::iterator\n#define ll         long long \n#define debug(...) fprintf(stderr, _VA_ARGS_), fflush(stderr)\n#define time__(d)  for(long blockTime = 0; (blockTime == 0 ? (blockTime=clock()) != 0 : false); debug(\"%s time : %.4fs\", d, (double)(clock() - blockTime) / CLOCKS_PER_SEC))  \n   \n\nint32_t main(){\n    fastio;\n    cin.tie();\n    #ifdef SOMU\n\t\tclock_t startTime = clock();\n\t\t//\n\t#endif\n\n\tstring s;\n\tcin>>s;\n\t\n\t//cout<<n<<endl;\n\t/*int * a = new int[n];\n\tint * b = new int[n];\n\tint * c = new int[n];\n\tfor(int i=0;i<n;i++){\n\t\tb[i] = 0;\n\t}*/\n\t\n\n\t// int cnt = 1;\n\t// a[0] = 1;\n\tfor(int i=s.length();i>=0;i--){\n         if(s[i]==s[i-1] && s[i-1]==s[i-2]){\n         \ts.erase(i,1);\n         }\n\t}\n\tn = s.length();\n\tfor(int i=0;i<s.length()-4;i++){\n        if(s[i]==s[i+1] && s[i+2]==s[i+3]){\n        \ts.erase(i+2,1);\n        \ti++;\n        }\n\t}\n\tcout<<s;\n\t// string u =\"\";\n\t// int k =0;\n\t// for(int i=0;i<n;i++){\n\t// \tif(b[i]==0){\n //           u+=s[i];\n //           c[k++] = a[i];\n\t// \t}\n\t// }\n\t// for(int i=0;i<k;i++){\n\t// \tb[i] = 0;\n\t// }\n\t// int cnt2 = 0;\n\t// for(int i=0;i<k-1;i++){\n\t// \tif(c[i]==1 && c[i+1]==2){\n\t// \t\tcnt2++;\n\t// \t\ti++;\n\t// \t}\n\t// \telse if(c[i]==1 && c[i+1]==1){\n //            cnt2 = 0;\n\t// \t}\n\t// \tif(cnt2==2){\n\t// \t\tb[i] = 1;\n\t// \t\tcnt2 = 0;\n\t// \t}\n\t// }\n\t// int cnt3 = 0;\n\t// string t = \"\";\n\t// for(int i=0;i<k;i++){\n\t// \tif(b[i]==0){\n //           t = t+u[i];\n //           cnt3++;\n\t// \t}\n\t// }\n\t// cout<<t;\n\t// #ifdef SOMU\n\t// \tcerr << endl <<setprecision(20)<< double( clock() - startTime ) / (double)CLOCKS_PER_SEC<< \" seconds.\" << endl;\n\t// #endif\n\t\n\t// delete [] a;\n\t// delete [] b;\n\t// delete [] c;\n\n\t\n}\n\n\n\n\n// for(int j=i+1;j<n;j++){\n            // \ts[j-1] = s[j];\n            // \ta[j-1] = a[j];\n            // }\n            // n--;\n            // i--;\n\n// for(int j =i+1;j<n;j++){\n\t\t\t// \ts[j-1] = s[j];\n\t\t\t// \ta[j-1] = a[j];\n\t\t\t// }\n\t\t\t// n--;\n\t\t\t// i--;\n\t\t\t// cnt2 = 0;",
        "fixed_code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define fastio     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define fi         first\n#define se         second\n#define int        long long \n#define pb         push_back\n#define emp        emplace_back\n#define vv(x)      vector<x>\n#define mp(x,y)    map<x,y>\n#define dq(x)      deque<x>\n#define pql(x)     priority_queue<x>\n#define pqs(x)     priority_queue<x,vv(x),greater<x> >\n#define MOD          1000000007\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define it(x)      x::iterator\n#define ll         long long \n#define debug(...) fprintf(stderr, _VA_ARGS_), fflush(stderr)\n#define time__(d)  for(long blockTime = 0; (blockTime == 0 ? (blockTime=clock()) != 0 : false); debug(\"%s time : %.4fs\", d, (double)(clock() - blockTime) / CLOCKS_PER_SEC))  \n   \n\nint32_t main(){\n    fastio;\n    cin.tie();\n    #ifdef SOMU\n\t\tclock_t startTime = clock();\n\t\t//\n\t#endif\n\n\tstring s;\n\tcin>>s;\n\t\n\t//cout<<n<<endl;\n\t/*int * a = new int[n];\n\tint * b = new int[n];\n\tint * c = new int[n];\n\tfor(int i=0;i<n;i++){\n\t\tb[i] = 0;\n\t}*/\n\t\n\n\t// int cnt = 1;\n\t// a[0] = 1;\n\tfor(int i=s.length();i>=0;i--){\n         if(s[i]==s[i-1] && s[i-1]==s[i-2]){\n         \ts.erase(i,1);\n         }\n\t}\n\t\n\tfor(int i=0;i<s.length()-1;i++){\n        if(s[i]==s[i+1] && s[i+2]==s[i+3]){\n        \ts.erase(i+2,1);\n        \ti++;\n        }\n\t}\n\tcout<<s;\n\t// string u =\"\";\n\t// int k =0;\n\t// for(int i=0;i<n;i++){\n\t// \tif(b[i]==0){\n //           u+=s[i];\n //           c[k++] = a[i];\n\t// \t}\n\t// }\n\t// for(int i=0;i<k;i++){\n\t// \tb[i] = 0;\n\t// }\n\t// int cnt2 = 0;\n\t// for(int i=0;i<k-1;i++){\n\t// \tif(c[i]==1 && c[i+1]==2){\n\t// \t\tcnt2++;\n\t// \t\ti++;\n\t// \t}\n\t// \telse if(c[i]==1 && c[i+1]==1){\n //            cnt2 = 0;\n\t// \t}\n\t// \tif(cnt2==2){\n\t// \t\tb[i] = 1;\n\t// \t\tcnt2 = 0;\n\t// \t}\n\t// }\n\t// int cnt3 = 0;\n\t// string t = \"\";\n\t// for(int i=0;i<k;i++){\n\t// \tif(b[i]==0){\n //           t = t+u[i];\n //           cnt3++;\n\t// \t}\n\t// }\n\t// cout<<t;\n\t// #ifdef SOMU\n\t// \tcerr << endl <<setprecision(20)<< double( clock() - startTime ) / (double)CLOCKS_PER_SEC<< \" seconds.\" << endl;\n\t// #endif\n\t\n\t// delete [] a;\n\t// delete [] b;\n\t// delete [] c;\n\n\t\n}\n\n\n\n\n// for(int j=i+1;j<n;j++){\n            // \ts[j-1] = s[j];\n            // \ta[j-1] = a[j];\n            // }\n            // n--;\n            // i--;\n\n// for(int j =i+1;j<n;j++){\n\t\t\t// \ts[j-1] = s[j];\n\t\t\t// \ta[j-1] = a[j];\n\t\t\t// }\n\t\t\t// n--;\n\t\t\t// i--;\n\t\t\t// cnt2 = 0;",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cctype>\n#include <utility>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n#define ll long long\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n#define EACH(it,a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)\n#define SZ(S) ((int) ((S).k()))\n#define DEBUG(x) { cout << #x << \" = \" << x << endl; }\n#define PR(a,n) { cout << #a << \" = \"; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }\n#define PR0(a,n) { cout << #a << \" = \"; REP(_,n) cout << a[_] << ' '; cout << endl; }\n\n#define N 100001\nint main(){\n  ll obj[N];\n  ll paths[N], n, pathc[N];\n  cin >> n;\n  REP(i, n){\n    cin >> obj[i];\n  }\n  REP(i, n){\n    cin >> paths[i];\n    paths[i]--;\n    if(paths[i] != -1) pathc[paths[i]]++;\n  }\n\n  vector<int> res;\n  REP(i, n){\n    if(obj[i] == 1){\n        vector< int > aux;\n        int idx = i;\n        while(paths[idx] != -1 && pathc[paths[idx]] <= 1 ){\n          aux.push_back(idx);\n          idx = paths[idx];\n        }\n        aux.push_back(idx);\n        if(res.size() < aux.size()) res = aux;\n\n    }\n  }\n  cout << res.size() << endl;\n  reverse(res.begin(), res.end());\n  REP(i, res.size()){\n  \t\tif (i) cout << \" \";\n  \t\tcout <<  res[i] + 1;\n  }\n\tputs(\"\");\n  return 0;\n}\n",
        "fixed_code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cctype>\n#include <utility>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n#define ll long long\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n#define EACH(it,a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)\n#define DEBUG(x) { cout << #x << \" = \" << x << endl; }\n#define PR(a,n) { cout << #a << \" = \"; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }\n#define PR0(a,n) { cout << #a << \" = \"; REP(_,n) cout << a[_] << ' '; cout << endl; }\n\n#define N 100001\nint obj[N];\nint paths[N], n, pathc[N];\ninline bool read()\n{\n\tif (!(cin >> n))\n\t\treturn false;\n   \tREP(i, n)\n   \t \tscanf(\"%d\", &obj[i]);\n\n\tREP(i, n){\n        cin >> paths[i];\n        paths[i]--;\n        if (paths[i] != -1)\n        \tpathc[paths[i]]++;\n   \t}\n\n   \treturn true;\n}\nint main(){\n  while(read()){\n\n  vector<int> res;\n  REP(i, n){\n    if(obj[i] == 1){\n        vector<int> aux;\n        int idx = i;\n\n        while(paths[idx] != -1 && pathc[paths[idx]] <= 1 ){\n          aux.push_back(idx);\n          idx = paths[idx];\n        }\n\n        aux.push_back(idx);\n        if(res.size() < aux.size()) res = aux;\n\n    }\n  }\n  cout << res.size() << endl;\n  reverse(res.begin(), res.end());\n  REP(i, res.size()){\n  \t\tif (i) cout << \" \";\n  \t\tcout <<  res[i] + 1;\n  }\n\tputs(\"\");\n\n  }\n  return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "t=int(input())\nfor i in range(t):\n    n=int(input())\n    l=list(map(int,input().split()))\n    for i in range(len(l)):\n        for j in range(i+1,len(l)):\n            if l[i]>l[j]:\n                count+=1\n    r=(((n*(n-1))//2)-1)\n    if count>r:\n        print(\"NO\")\n    else:\n        print(\"YES\")",
        "fixed_code": "t=int(input())\nfor i in range(t):\n    n=int(input())\n    l=list(map(int,input().split()))\n    c={}\n    for i in l:\n        k=len(bin(i)[2:])\n        if k in c:\n            c[k]+=1\n        else:\n            c[k]=1\n    ans=0\n    for i in c:\n        ans+=c[i]*(c[i]-1)//2\n    print(ans)",
        "source": "Python_461356.json"
    },
    {
        "source_code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScan scan = new Scan();\n\t\tint k = scan.nextInt();\n\t\tboolean[] arr = new boolean[4];\n\t\tArrays.fill(arr, false);\n\t\t//arr[k] = true;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint a = scan.nextInt();\n\t\t\tint b = scan.nextInt();\n\t\t\tboolean tmp = arr[a];\n\t\t\tarr[a] = arr[b];\n\t\t\tarr[b] = tmp;\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i = 1; i <= 3; i++)\n\t\t{\n\t\t\tif (arr[i])\n\t\t\t{\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}\n\nclass Scan\n{\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tScan()\n\t{\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic boolean hasNext()\n\t{\n\t\twhile (st == null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic String next()\n\t{\n\t\tif (hasNext())\n\t\t{\n\t\t\treturn st.nextToken();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic int nextInt()\n\t{\n\t\tif (hasNext())\n\t\t{\n\t\t\treturn Integer.parseInt(st.nextToken());\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "fixed_code": "\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n\n\tpublic static void main(String[] args) throws FileNotFoundException, IOException\n\t{\n\t\tScan scan = new Scan();\n\t\tint k = scan.nextInt();\n\t\tboolean[] arr = new boolean[4];\n\t\tArrays.fill(arr, false);\n\t\tarr[k] = true;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint a = scan.nextInt();\n\t\t\tint b = scan.nextInt();\n\t\t\tboolean tmp = arr[a];\n\t\t\tarr[a] = arr[b];\n\t\t\tarr[b] = tmp;\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i = 1; i <= 3; i++)\n\t\t{\n\t\t\tif (arr[i])\n\t\t\t{\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tBufferedWriter bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"output.txt\")));\n\t\tbw.write(ans+\"\\n\");\n\t\tbw.close();\n\t}\n\n}\n\nclass Scan\n{\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tScan() throws FileNotFoundException\n\t{\n\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));\n\t}\n\n\tpublic boolean hasNext()\n\t{\n\t\twhile (st == null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic String next()\n\t{\n\t\tif (hasNext())\n\t\t{\n\t\t\treturn st.nextToken();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic int nextInt()\n\t{\n\t\tif (hasNext())\n\t\t{\n\t\t\treturn Integer.parseInt(st.nextToken());\n\t\t}\n\t\treturn -1;\n\t}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#include <vector>\n#define vi(v1) vector <ll> v1;\n#define vc(v1) vector <char> v1;\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(v) v.begin(),v.end()\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define back(i,b,a) for(ll i=b;i<a;i--)\n#define piarr(arr,i,n,str) for(ll j=i;j<n;j++){cout<<arr[j]<<\" \";} cout<<\"\\n\";\n#define PI  3.14159265\n\nint main()\n{\n //freopen(\"input.txt\",\"r\",stdin);\n //freopen(\"output.txt\",\"w\",stdout);\n ll n,x;\n cin >> n;\n vector<pair<ll,ll> > v,w;\n rep(i,0,2*n)\n {\n    cin >> x;\n    v.pb(mp(x,i+1));\n }\n sort(all(v));\n ll l = v.size();\n rep(i,0,l-1)\n {\n    if(v[i].F!=v[i+1].F)\n    {\n       cout << -1;\n       return 0;\n    }\n    i++;\n }\n rep(i,0,l-1)\n {\n    if(v[i].F==v[i+1].F)\n    {\n      w.pb(mp(v[i].S,v[i+1].S));\n      i++;\n    }\n }\n ll s = w.size();\n rep(i,0,s)\n {\n    cout << w[i].F << \" \" << w[i].S << endl;\n }\n}\n\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#include <vector>\n#define vi(v1) vector <ll> v1;\n#define vc(v1) vector <char> v1;\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(v) v.begin(),v.end()\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define back(i,b,a) for(ll i=b;i<a;i--)\n#define piarr(arr,i,n,str) for(ll j=i;j<n;j++){cout<<arr[j]<<\" \";} cout<<\"\\n\";\n#define PI  3.14159265\n\nint main()\n{\n ifstream cin(\"input.txt\");\n ofstream cout(\"output.txt\");\n int n,x,j,i;\n cin >> n;\n vector<pair<int,int> > v;\n rep(i,0,2*n)\n {\n    cin >> x;\n    v.pb(mp(x,i+1));\n }\n sort(all(v));\n ll l = v.size();\n rep(i,0,l-1)\n {\n    if(v[i].F!=v[i+1].F)\n    {\n       cout << -1;\n       return 0;\n    }\n    i++;\n }\n for(j=0;j<l-1;j=j+2)\n {\n    cout << v[j].S << \" \" << v[j+1].S << endl;\n }\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner sc = new Scanner(System.in);\n        int n,i,cash=1,max=1;\n\t    int[][] h=new int[100000][2];\n\t    n=scan.nextInt();\n\t    for(i=0;i<n;++i)\n\t\t   {\n\t\t      h[i][0]=scan.nextInt();\n\t\t      h[i][1]=scan.nextInt();\n\t\tif(i>0)\n\t\t\t{\n\t\t\tif(h[i][0]==h[i-1][0]&&h[i][1]==h[i-1][1])\n\t\t\t\t++max;\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tif(max>cash)\n\t\t\t\t\tcash=max;\n\t\t\t\tmax=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t    if(max>cash)\n\t\tcash=max;\n\t    System.out.println(cash);\n\t}\n}\n",
        "fixed_code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner sc = new Scanner(System.in);\n        int n,i,cash=1,max=1;\n\t    int[][] h=new int[100000][2];\n\t    n=sc.nextInt();\n\t    for(i=0;i<n;++i)\n\t\t   {\n\t\t      h[i][0]=sc.nextInt();\n\t\t      h[i][1]=sc.nextInt();\n\t\tif(i>0)\n\t\t\t{\n\t\t\tif(h[i][0]==h[i-1][0]&&h[i][1]==h[i-1][1])\n\t\t\t\t++max;\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tif(max>cash)\n\t\t\t\t\tcash=max;\n\t\t\t\tmax=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t    if(max>cash)\n\t\tcash=max;\n\t    System.out.println(cash);\n\t}\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\nusing namespace std;\n\nconst int maxn = 3e5, logn = 20;\nint n, a[maxn], x[2][logn][maxn], s0, s1;\n\nint mx(int l, int r, int i)\n{\n\tint d = r - l, e = 0;\n\twhile(1 << e < d) e++;\n\treturn max(x[i][e][l], x[i][e][r - (1 << e) + 1]);\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tfor (int i = 0; i < n - 1; i++) x[0][0][i] = max(a[i], a[i + 1]);\n\tfor (int i = 0; i < n - 2; i++) x[1][0][i] = min(a[i + 1], max(a[i], a[i + 2]));\n\tfor (int i = 1; i < logn; i++)\tfor (int j = 0; j < n - 1; j++)\n\t{\n\t\tx[0][i][j] = max(x[0][i - 1][j], x[0][i - 1][min(j + (1 << (i - 1)), n - 2)]);\n\t\tif (j < n - 2) x[1][i][j] = max(x[1][i - 1][j], x[1][i - 1][min(j + (1 << (i - 1)), n - 3)]);\n\t}\n\tfor (int k = 0; k < n; k++)\n\t{\n\t\tif (k == n - 1) cout << x[0][logn - 1][0];\n\t\telse cout << mx((n - k) / 2 - 1, k + (n - k) / 2 - 1, (n - k) % 2) << \" \";\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "#include <iostream>\nusing namespace std;\n\nconst int maxn = 3e5, logn = 20;\nint n, a[maxn], x[2][maxn], s[2];\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tfor (int i = 0; i < n - 1; i++) x[0][i] = max(a[i], a[i + 1]);\n\tfor (int i = 0; i < n - 2; i++) x[1][i] = min(a[i + 1], max(a[i], a[i + 2]));\n\tfor (int k = 0; k < n - 1; k++)\n\t{\n\t\ts[(n - k) % 2] = max(s[(n - k) % 2], max(x[(n - k) % 2][(n - k) / 2 - 1], x[(n - k) % 2][(n - k) / 2 - 1 + k]));\n\t\tcout << s[(n - k) % 2] << \" \";\n\t}\n\tint m = 0;\n\tfor (int i = 0; i < n; i++) m = max(m, a[i]);\n\tcout << m;\t\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define f fixed << setprecision(10)\nint main(void)\n{\n    int n;\n    double x,y,a,b;\n    fi>>x>>y>>n;\n    for (int i=1;i<=n;++i)\n    {\n        double r=fmod(i*y,4*x);\n        if (r<=x) a=r,b=0;\n        else if (r<=2*x) a=x,b=r-x;\n        else if (r<=3*x) a=3*x-r,b=x;\n        else             a=0,b=4*x-r;\n        fo<< f << a <<' ' << f << b << '\\n';\n    }\n}\n",
        "fixed_code": "# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\nint main(void)\n{\n    int n;\n    double x,y,a,b;\n    fi>>x>>y>>n;\n    for (int i=1;i<=n;++i)\n    {\n        double r=fmod(i*y,4*x);\n        if (r<=x) a=r,b=0;\n        else if (r<=2*x) a=x,b=r-x;\n        else if (r<=3*x) a=3*x-r,b=x;\n        else             a=0,b=4*x-r;\n        printf(\"%f %f\\n\",a,b);\n    }\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int[][] d = new int[n][n];\n        for (int i = 0; i < n; i++)\n            d[i] = sc.nextIntArray(n);\n        int k = sc.nextInt();\n        while (k-- > 0) {\n            int x = sc.nextInt() - 1;\n            int y = sc.nextInt() - 1;\n            int len = sc.nextInt();\n            long ans = 0;\n            int[][] tmp = d.clone();\n            tmp[x][y] = d[y][x] = len;\n            for (int i = 0; i < n; i++)\n                for (int j = i + 1; j < n; j++) {\n                    tmp[i][j] = Math.min(d[i][j], len + Math.min(tmp[i][x] + tmp[y][j], tmp[i][y] + tmp[x][j]));\n                    ans += tmp[i][j];\n                }\n            out.print(ans + \" \");\n        }\n        out.flush();\n        out.close();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n        public Scanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n    }\n}",
        "fixed_code": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int[][] d = new int[n][n];\n        for (int i = 0; i < n; i++)\n            d[i] = sc.nextIntArray(n);\n        int k = sc.nextInt();\n        while (k-- > 0) {\n            int x = sc.nextInt() - 1;\n            int y = sc.nextInt() - 1;\n            int len = sc.nextInt();\n            long ans = 0;\n            d[x][y] = d[y][x] = Math.min(len, d[y][x]);\n            for (int i = 0; i < n; i++)\n                for (int j = i + 1; j < n; j++) {\n                    d[i][j] = d[j][i] = Math.min(d[i][j], d[x][y] + Math.min(Math.min(d[j][x] + d[y][i], d[j][y] + d[x][i]), Math.min(d[i][x] + d[y][j], d[i][y] + d[x][j])));\n                    ans += d[i][j];\n                }\n            out.print(ans + \" \");\n        }\n        out.flush();\n        out.close();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n        public Scanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n    }\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "n = int(input())\r\n# arr = []\r\ndef higres(k):\r\n    r = 0\r\n    for i in range(k, 0, -1):\r\n        if (i & (i - 1)) == 0:\r\n            r = i\r\n            break\r\n    return r\r\n\r\n\r\nfor i in range(n):\r\n    x = int(input())\r\n    # arr.append(x)\r\n    if x < 4:\r\n        print(1)\r\n    else:\r\n        s = higres(x)\r\n        print(s - 1)\r\n\r\n\r\n\r\n\r\n# for c in arr:\r\n",
        "fixed_code": "import math as mt\r\nn = int(input())\r\n\r\n\r\n# def higres(k):\r\n#     r = 0\r\n#     for i in range(k, 0, -1):\r\n#         if (i & (i - 1)) == 0:\r\n#             r = i\r\n#             break\r\n#     return r\r\n\r\nfor i in range(n):\r\n    x = int(input())\r\n    # if x < 4:\r\n    #     print(1)\r\n    # else:\r\n    #     s = higres(x)\r\n    #     print(s - 1)\r\n    k = int(mt.log2(x))\r\n    h = mt.pow(2,k)\r\n    print(int(h-1))\r\n# for c in arr:\r\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<bits/stdc++.h> \nusing namespace std; \n\nvector<int> g[100005]; \n\nint par[100005];\nint size[100005];\n\nbool comp(pair<int,int> p1,pair<int,int> p2){\n    return p1.second > p2.second;\n}\n\nvoid dfs(int u,int p){\n    size[u] = 1;\n    par[u] = p;\n    for(auto x:g[u]){\n        if(x == p)continue;\n        dfs(x,u);\n        size[u] += size[x];\n    }\n}\n\nint main() \n{ \n    int t;\n    cin>>t;\n    while(t--){\n        int n,u,v;\n        cin>>n;\n\n        for(int i=0;i<=n;i++){\n            g[i].clear();\n        }\n\n        for(int i=0;i<n-1;i++){\n            cin>>u>>v;\n            u--,v--;\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }  \n        memset(par,-1,sizeof(par));\n        memset(size,-1,sizeof(size));\n        dfs(0,-1);\n\n//        cout<<\"par = \";\n//        for(int i=0;i<=n;i++){\n//            cout<<par[i]<<\" \";\n//        }\n//        cout<<endl;\n\n        // for(int i=0;i<=n;i++){\n        //     cout<<size[i]<<\" \";\n        // }\n        // cout<<endl;\n\n        vector<pair<int,int>> res;\n\n        for(int i=0;i<n;i++){\n            res.push_back({i,g[i].size()});\n        }\n\n        sort(res.begin(),res.end(),comp);\n\n        int ele1 = -1,ele2=-1,ele3=-1;\n\n        ele1 = res[0].first;\n        ele2 = res[1].first;\n        ele3 = res.back().first;\n\n        int par1 = par[ele1];\n        int par2 = par[ele2];\n\n        if(par1 == -1 ){\n            cout<<par2+1<<\" \"<<ele2+1<<endl;\n            cout<<ele3+1<<\" \"<<ele2+1<<endl;\n        }\n        else{\n            cout<<par1+1<<\" \"<<ele1+1<<endl;\n            cout<<ele3+1<<\" \"<<ele1+1<<endl;\n        }\n    }\n} \n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define endl (\"\\n\")\n#define pi (3.141592653589)\n#define mod 1e9+7\n#define int long long\n#define float double\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define all(c) c.begin(), c.end()\n#define min3(a, b, c) min(c, min(a, b))\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n \nconst int N = 100100;\nvector<int>g[N];\nint size[N];\n \n \nvector<int> centroid;\nint n;\nvoid dfs(int v,int p = -1){\n  size[v] = 1;\n  bool is= 1;\n \n  for(int to : g[v])if(to!=p){\n    dfs(to,v);\n    size[v]+=size[to];\n    if(size[to]>n/2)is = 0;\n  }\n  if(n-size[v] >n/2)is = 0;\n  if(is)centroid.pb(v);\n}\n \n \nint32_t main(){\n    fast\n    int t=1;\n    cin>>t;\n    while(t--){\n\t\tcin >> n;\n  for(int i=1;i<=n;i++)g[i].clear(),size[i] = 1;\n \n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    g[a].pb(b);\n    g[b].pb(a);\n  } \n  centroid.clear();\n  dfs(1);\n  vector<pair<int, int>> ans;\n  if(centroid.size() == 1){\n    int to = g[1][0];\n    ans.pb(mp(1,to));\n    ans.pb(mp(1,to));\n  }else{\n    for(int to : g[centroid[0]]){\n      if(to!=centroid[1]){\n        ans.pb(mp(centroid[0],to));\n        ans.pb(mp(to,centroid[1]));\n        break;\n      }\n    }\n  }\n  assert(ans.size()== 2);\n  for(auto it : ans){\n    cout << it.ff<<\" \"<<it.ss<<endl;\n  }\t\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long ll;\n\nconst int MAX = 2e5+5;\n\n\n\nint last[30] , in , fn;\nint dp[(1<<23)];\n\nvoid dfs( int mask , int cnt ) {\n    if( dp[mask] >= cnt ) return;\n\n    dp[mask] = max( dp[mask] , cnt );\n    for( int i = 0 ; i < 20 ; i++ ) {\n        if( !(mask & (1<<i)) )\n            dfs( mask | (1<<i) , cnt );\n    }\n}\n\nint main()\n{\n     ios_base::sync_with_stdio(0);cin.tie(0);\n     string cad;cin>>cad;\n     int n = cad.size();\n     cad = \" \" + cad;\n     in = 1;fn = 1;\n     // cout<<n<<\"\\n\";\n     int ans = 0;\n     for( int i = 1; i <= n ; i++ ) {\n        if( fn-in+1==21) in++;\n\n        fn = i;\n        int v = cad[i]-'a';\n        if( last[v] >= in ) {\n            in = last[v]+1;\n        }\n        // cout<<in<<\" \"<<fn<<\"\\n\";\n        last[v] = i;\n        int mask = 0;\n        for( int j = in ; j <= fn ; j++ )\n            mask |= (1 << (cad[j]-'a'));\n\n        int cnt =  fn-in+1;\n        dfs(mask , cnt );\n        for( int j = in ; j <= fn ; j++ ) {\n            mask ^= (1 << (cad[j]-'a'));\n            cnt--;\n            dfs( mask , cnt );\n            ans = max( ans , cnt+dp[((1<<20)-1)-mask] );\n        }\n     }\n     cout<<ans<<\"\\n\";\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long ll;\n\nconst int MAX = 2e5+5;\n\n\n\nint last[30] , in , fn;\nint dp[(1<<23)];\n\nvoid dfs( int mask , int cnt ) {\n    if( dp[mask] >= cnt ) return;\n\n    dp[mask] = max( dp[mask] , cnt );\n    for( int i = 0 ; i < 20 ; i++ ) {\n        if( !(mask & (1<<i)) )\n            dfs( mask | (1<<i) , cnt );\n    }\n}\n\nint main()\n{\n     ios_base::sync_with_stdio(0);cin.tie(0);\n     string cad;cin>>cad;\n     int n = cad.size();\n     cad = \" \" + cad;\n     in = 1;fn = 1;\n     // cout<<n<<\"\\n\";\n     int ans = 0;\n     for( int i = 1; i <= n ; i++ ) {\n        if( fn-in+1==21) in++;\n\n        fn = i;\n        int v = cad[i]-'a';\n        if( last[v] >= in ) {\n            in = last[v]+1;\n        }\n        // cout<<in<<\" \"<<fn<<\"\\n\";\n        last[v] = i;\n        int mask = 0;\n        for( int j = in ; j <= fn ; j++ )\n            mask |= (1 << (cad[j]-'a'));\n\n        int cnt =  fn-in+1;\n        dfs(mask , cnt );\n        ans = max( ans , cnt+dp[((1<<20)-1)-mask] );\n        for( int j = in ; j <= fn ; j++ ) {\n            mask ^= (1 << (cad[j]-'a'));\n            cnt--;\n            dfs( mask , cnt );\n            ans = max( ans , cnt+dp[((1<<20)-1)-mask] );\n        }\n     }\n     cout<<ans<<\"\\n\";\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner sc=new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0){\n\t\t\tint n=sc.nextInt();\n\t\t\tint arr[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tarr[i]=sc.nextInt();\n\t\t\t\tarr[i]/=100;\n\t\t\t}\n\t\t\tint sum[]=new int[n+1];\n\t\t\tArrays.sort(arr);\n\t\t\tlong x=sc.nextLong();\n\t\t\tlong a=sc.nextLong();\n\t\t\tlong y=sc.nextLong();\n\t\t\tlong b=sc.nextLong();\n\t\t\tlong k=sc.nextLong();\n\t\t\tfor(int i=n-1,c=1;i>=0;c++,i--){\n\t\t\t\tsum[c]=sum[c-1]+arr[i];\n\t\t\t}\n\t\t\tlong sum1=0,sum2=0,sum3=0;\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i%a==0 && i%b==0) sum1++;\n\t\t\t\telse{\n\t\t\t\t\tif(i%a==0) sum2++;\n\t\t\t\t\tif(i%b==0) sum3++;\n\t\t\t\t}\n\t\t\t\tlong ans=0;\n\t\t\t\tlong t1=sum[(int)sum1];\n\t\t\t\tlong t2=sum[(int)(sum1+sum2)]-sum[(int)sum1];\n\t\t\t\tlong t3=sum[(int)(sum1+sum2+sum3)]-sum[(int)(sum1+sum2)];\n\t\t\t\tlong t4=sum[(int)(sum1+sum3)]-sum[(int)sum1];\n\t\t\t\tlong t5=sum[(int)(sum1+sum2+sum3)]-sum[(int)(sum1+sum3)];\n\t\t\t\tif((x*t2+y*t3)>(x*t5+y*t4)){\n\t\t\t\t\tans+=x*t2+y*t3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans+=x*t5+y*t4;\n\t\t\t\t}\n\t\t\t\tans+=x*t1+y*t1;\n\t\t\t\tif(ans>=k){\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t}\n}",
        "fixed_code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner sc=new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0){\n\t\t\tint n=sc.nextInt();\n\t\t\tlong arr[]=new long[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tarr[i]=sc.nextInt();\n\t\t\t\tarr[i]/=100;\n\t\t\t}\n\t\t\tlong sum[]=new long[n+1];\n\t\t\tArrays.sort(arr);\n\t\t\tlong x=sc.nextLong();\n\t\t\tlong a=sc.nextLong();\n\t\t\tlong y=sc.nextLong();\n\t\t\tlong b=sc.nextLong();\n\t\t\tlong k=sc.nextLong();\n\t\t\tfor(int i=n-1,c=1;i>=0;c++,i--){\n\t\t\t\tsum[c]=sum[c-1]+arr[i];\n\t\t\t}\n\t\t\tlong sum1=0,sum2=0,sum3=0;\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i%a==0 && i%b==0) sum1++;\n\t\t\t\telse{\n\t\t\t\t\tif(i%a==0) sum2++;\n\t\t\t\t\tif(i%b==0) sum3++;\n\t\t\t\t}\n\t\t\t\tlong ans=0;\n\t\t\t\tlong t1=sum[(int)sum1];\n\t\t\t\tlong t2=sum[(int)(sum1+sum2)]-sum[(int)sum1];\n\t\t\t\tlong t3=sum[(int)(sum1+sum2+sum3)]-sum[(int)(sum1+sum2)];\n\t\t\t\tlong t4=sum[(int)(sum1+sum3)]-sum[(int)sum1];\n\t\t\t\tlong t5=sum[(int)(sum1+sum2+sum3)]-sum[(int)(sum1+sum3)];\n\t\t\t\tif((x*t2+y*t3)>(x*t5+y*t4)){\n\t\t\t\t\tans+=x*t2+y*t3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans+=x*t5+y*t4;\n\t\t\t\t}\n\t\t\t\tans+=x*t1+y*t1;\n\t\t\t\tif(ans>=k){\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define endl '\\n'\n\nvoid fast_io()\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(20);\n}\n\nint n, k;\nmultiset<int> my_set;\n\nvoid putInSet(int a)\n{\n  if (my_set.size() > k)\n  {\n    auto min = begin(my_set);\n    if (*min < a)\n    {\n      my_set.erase(min);\n      my_set.insert(a);\n    }\n  }\n  else\n  {\n    my_set.insert(a);\n  }\n}\n\nvoid solvee()\n{\n  cin >> n >> k;\n  my_set.clear();\n  int a;\n  for (int i = 0; i < n; ++i)\n  {\n    cin >> a;\n    putInSet(a);\n  }\n  cout << accumulate(begin(my_set), end(my_set), 0) << endl;\n}\n\nvoid solve()\n{\n  int t;\n  cin >> t;\n  while (t--)\n  {\n    solvee();\n  }\n}\n\nint main()\n{\n  fast_io();\n  solve();\n\n  return 0;\n}",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define endl '\\n'\n\nvoid fast_io()\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(20);\n}\n\nint n, k;\nmultiset<int> my_set;\n\nvoid putInSet(int a)\n{\n  if (my_set.size() > k)\n  {\n    auto min_it = begin(my_set);\n    if (*min_it < a)\n    {\n      my_set.erase(min_it);\n      my_set.insert(a);\n    }\n  }\n  else\n  {\n    my_set.insert(a);\n  }\n}\n\nvoid solvee()\n{\n  cin >> n >> k;\n  my_set.clear();\n  int a;\n  for (int i = 0; i < n; ++i)\n  {\n    cin >> a;\n    putInSet(a);\n  }\n  cout << accumulate(begin(my_set), end(my_set), static_cast<uint64_t>(0)) << endl;\n}\n\nvoid solve()\n{\n  int t;\n  cin >> t;\n  while (t--)\n  {\n    solvee();\n  }\n}\n\nint main()\n{\n  fast_io();\n  solve();\n\n  return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream> \n#include <string>\nusing namespace std;\n\n\nint main()\n{\n\tstring s; bool e = false;\n\tcin >> s;\n\tfor (int i = 0; i < s.length(); i++)\n\t\tif (s[i] == '0'){\n\t\t\n\t\t\ts.erase(s.begin() + i), e = false;\n\t\t\tbreak;\n\t\t}\n\tif (e)\n\t\ts.erase(s.begin());\n}",
        "fixed_code": "#include <iostream> \n#include <string>\nusing namespace std;\n\n\nint main()\n{\n    string s; bool e = false;\n    \n    cin >> s;\n\n\n    for (int i = 0; i < s.length(); i++)\n        if (s[i] == '0'){\n        \n            s.erase(s.begin() + i);\n            e = true;\n            break;\n        }\n\n    if (!e)\n        s.erase(s.begin());\n    cout << s;\n    \n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C1213   {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int q=Integer.parseInt(br.readLine());\n        long ans[]=new long[q];\n        int n=0;\n        while(q>0)\n        {\n            StringTokenizer s=new StringTokenizer(br.readLine());\n            long a=Long.parseLong(s.nextToken());\n            long d=Long.parseLong(s.nextToken());\n            if (d>a){\n                ans[n]=0;\n            }\n            if (d==a){\n                ans[n]=d%10;\n            }\n            else {\n                long j = d;\n                long sum = 0;\n                int count = 1;\n               int al[]=new int[10];\n                for (int i = 0; i <10 ; i++) {\n                    al[i]=(int)((i + 1) *d) % 10;\n                }\n                for (int i=0;i<10;i++)\n                {\n                    sum+=al[i];\n                }\n\n\n                long toal = sum*((a/d)/10);\n\n                        for (int i = 0; i < (a/d)%10; i++) {\n                            toal += al[i];\n                        }\n                    ans[n] = toal;\n\n            }\n\n                n++;\n                q--;\n\n        }\n        for (long b:\n             ans) {\n            System.out.println(b);\n        }\n    }\n}\n",
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C1213   {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int q=Integer.parseInt(br.readLine());\n        long ans[]=new long[q];\n        int n=0;\n        while(q>0)\n        {\n            StringTokenizer s=new StringTokenizer(br.readLine());\n            long a=Long.parseLong(s.nextToken());\n            long d=Long.parseLong(s.nextToken());\n            if (d>a){\n                ans[n]=0;\n            }\n            if (d==a){\n                ans[n]=d%10;\n            }\n            else {\n                long sum = 0;\n               long al[]=new long[10];\n                for (int i = 0; i <10 ; i++) {\n                    al[i]=((i + 1) *d) % 10;\n                }\n                for (int i=0;i<10;i++)\n                {\n                    sum+=al[i];\n                }\n\n                long toal = sum*((a/d)/10);\n\n                        for (int i = 0; i < (a/d)%10; i++) {\n                            toal += al[i];\n                        }\n                    ans[n] = toal;\n\n            }\n\n                n++;\n                q--;\n\n        }\n        for (long b:\n             ans) {\n            System.out.println(b);\n        }\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FenwickTree {\npublic:\n    vector<int> tree; int size;\n    explicit FenwickTree(int n) {\n        size = n;\n        tree = vector<int>((unsigned)n);\n    }\n    int query(int pos) {\n        int ans = 0;\n        for (int i = pos; i >= 1; i -= (i & (-i))){\n            ans += tree[i];\n        } return ans;\n    }\n    void increment(int pos, int val){\n        for (int i = pos; i <= size; i += (i & (-i)))\n            tree[i] += val;\n    }\n};\n\nint main(){\n    /** Segment 1: We take the input and store it in a vector of vectors, each single vector contains\n     * the cyclic difference in x,y-coordinates of the points of that single polygon. */\n    int n; cin >> n;\n    vector<int> cumulative_count((unsigned)n+1);\n    vector<vector<pair<int,int>>> xy_delta((unsigned)n+1); // Jagged vector of vectors\n    vector<vector<pair<int,int>>> polygon((unsigned)n+1); // Jagged vector of vectors\n    for (int i = 1; i <= n; i++){\n        int k; cin >> k; polygon[i].resize((unsigned)k);\n        for (int j = 0; j < k; j++) cin >> polygon[i][j].first >> polygon[i][j].second;\n        for (int j = 0; j < k; j++) {\n            int x = polygon[i][j].first - polygon[i][(j - 1 + k) % k].first;\n            int y = polygon[i][j].second - polygon[i][(j - 1 + k) % k].second;\n            int gcd = __gcd(abs(x), abs(y));\n            xy_delta[i].emplace_back(x / gcd, y / gcd);\n        } cumulative_count[i] = cumulative_count[i - 1] + (int) xy_delta[i].size();\n    }\n    /** Segment 2: Piling up all the input queries in a jagged vector grouped by right limit of query. */\n    int q; cin >> q; vector<vector<pair<int,int>>> queries((unsigned)q+1);\n    for (int i = 1; i <= q; i++){\n        int query_L, query_R; cin >> query_L >> query_R;\n        queries[query_R].emplace_back(query_L, i);\n    }\n\n    /** Segment 3: The meat of the logic. Using a fenwick tree to keep tabs on the unique values of x,y-diff\n     * and for each point. Then answering the queries as a count of the number of unique x,y-diff in range. */\n    map<pair<int, int>, int> xy_diff;\n    vector<int> answer((unsigned)q+1);\n    FenwickTree tree(cumulative_count[n] + 1);\n    for (int i = 1; i <= n; i++){\n        for (int j = 0; j < xy_delta[i].size(); j++) {\n            // If the x,y-difference we see has not appeared here before, then mark it as appeared and\n            // INCREASE VALUE OF CURRENT POINT BY 1. If it has appeared before, invalidate the place where it appeared\n            // previously and count it here. This is why we process queries in increasing R-limit.\n            if (xy_diff.find(xy_delta[i][j]) != xy_diff.end())\n                tree.increment(xy_diff[xy_delta[i][j]], -1);\n            xy_diff[xy_delta[i][j]] = cumulative_count[i - 1] + j + 1;\n            tree.increment(cumulative_count[i - 1] + j + 1, 1);\n        }\n        for (auto &j : queries[i]) {\n            // Unpacking the Query list and querying sum of points in polygons in range [l,r).\n            int l = j.first, r = i, id = j.second;\n            answer[id] = tree.query(cumulative_count[i]) - tree.query(cumulative_count[l-1]);\n        }\n    }\n    /** Segment 4: Take the answer and output it. */\n    for (int i = 1; i <= q; i++) cout << answer[i] << \"\\n\";\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass FenwickTree {\npublic:\n    vector<int> tree; int size;\n    explicit FenwickTree(int n) {\n        size = n;\n        tree = vector<int>((unsigned)n + 1);\n    }\n    int query(int pos) {\n        int ans = 0;\n        for (int i = pos; i >= 1; i -= (i & (-i))){\n            ans += tree[i];\n        } return ans;\n    }\n    void increment(int pos, int val){\n        for (int i = pos; i <= size; i += (i & (-i)))\n            tree[i] += val;\n    }\n};\n\nint main(){\n    /** Segment 1: We take the input and store it in a vector of vectors, each single vector contains\n     * the cyclic difference in x,y-coordinates of the points of that single polygon. */\n    int n; cin >> n;\n    vector<int> cumulative_count((unsigned)n+1);\n    vector<vector<pair<int,int>>> xy_delta((unsigned)n+1); // Jagged vector of vectors\n    vector<vector<pair<int,int>>> polygon((unsigned)n+1); // Jagged vector of vectors\n    for (int i = 1; i <= n; i++){\n        int k; cin >> k; polygon[i].resize((unsigned)k);\n        for (int j = 0; j < k; j++) cin >> polygon[i][j].first >> polygon[i][j].second;\n        for (int j = 0; j < k; j++) {\n            int x = polygon[i][j].first - polygon[i][(j - 1 + k) % k].first;\n            int y = polygon[i][j].second - polygon[i][(j - 1 + k) % k].second;\n            int gcd = __gcd(abs(x), abs(y));\n            xy_delta[i].emplace_back(x / gcd, y / gcd);\n        } cumulative_count[i] = cumulative_count[i - 1] + (int) xy_delta[i].size();\n    }\n    /** Segment 2: Piling up all the input queries in a jagged vector grouped by right limit of query. */\n    int q; cin >> q; vector<vector<pair<int,int>>> queries((unsigned)q+1);\n    for (int i = 1; i <= q; i++){\n        int query_L, query_R; cin >> query_L >> query_R;\n        queries[query_R].emplace_back(query_L, i);\n    }\n\n    /** Segment 3: The meat of the logic. Using a fenwick tree to keep tabs on the unique values of x,y-diff\n     * and for each point. Then answering the queries as a count of the number of unique x,y-diff in range. */\n    map<pair<int, int>, int> xy_diff;\n    vector<int> answer((unsigned)q+1);\n    FenwickTree tree(cumulative_count[n]);\n    for (int i = 1; i <= n; i++){\n        for (int j = 0; j < xy_delta[i].size(); j++) {\n            // If the x,y-difference we see has not appeared here before, then mark it as appeared and\n            // INCREASE VALUE OF CURRENT POINT BY 1. If it has appeared before, invalidate the place where it appeared\n            // previously and count it here. This is why we process queries in increasing R-limit.\n            if (xy_diff.find(xy_delta[i][j]) != xy_diff.end())\n                tree.increment(xy_diff[xy_delta[i][j]], -1);\n            xy_diff[xy_delta[i][j]] = cumulative_count[i - 1] + j + 1;\n            tree.increment(cumulative_count[i - 1] + j + 1, 1);\n        }\n        for (auto &j : queries[i]) {\n            // Unpacking the Query list and querying sum of points in polygons in range [l,r).\n            int l = j.first, r = i, id = j.second;\n            answer[id] = tree.query(cumulative_count[i]) - tree.query(cumulative_count[l-1]);\n        }\n    }\n    /** Segment 4: Take the answer and output it. */\n    for (int i = 1; i <= q; i++) cout << answer[i] << \"\\n\";\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nlong long n,m,maxnn=1000000000LL;\nstruct stu{\n    int p,c;\n};\nstruct s{\n    long long w,zs;\n};\nstu a[3003];\nlong long f[3003];\ns z[3003];\nlong long maxn;\nlong long minx;\nint read()\n{\n    long long x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0')\n    {\n        if(ch=='-') f=-f;\n        ch=getchar();\n    }\n    while(ch<='9'&&ch>='0')\n    {\n        x=x*10+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\nbool cmp(stu x,stu y)\n{\n    if(x.c!=y.c) return x.c<y.c;\n    return f[x.p]>f[y.p];\n}\nlong long dfs(long long k)\n{\n    long long w2=0;\n    long long y=maxn-f[1]+1;\n    long long sum=0;\n    while(k>0)\n    for(int i=1;i<=n;i++)\n    {\n        if(f[a[i].p]==maxn&&a[i].p!=1) \n        {\n            //cout<<a[i].p<<\" \"<<a[i].c<<\" \";\n            sum+=a[i].c;\n           // cout<<sum<<\" \";\n            w2++;\n            z[w2].zs=a[i].p;\n            a[i].p=1;\n            z[w2].w=i;\n            memset(f,0,sizeof(f));\n            for(int i=1;i<=n;i++)\n            f[a[i].p]++;\n            maxn=-1;\n            for(int i=2;i<=m;i++)\n            maxn=max(f[i],maxn);\n            y=maxn-f[1]+1;\n            k--;\n            break;\n        }\n    }\n    long long js=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(a[i].p!=1)\n        {\n            sum+=a[i].c;\n            js++;\n            if(js==y) break;\n        }\n        \n    }\n    //cout<<sum<<endl;\n    for(int i=1;i<=w2;i++)\n    {\n        a[z[i].w].p=z[i].zs;\n    }\n    //cout<<endl;\n    //cout<<sum<<endl;\n    return sum;\n}\nint main()\n{\n    n=read();m=read();\n    for(int i=1;i<=n;i++)\n    {\n        a[i].p=read();\n        a[i].c=read();\n        f[a[i].p]++;\n    }\n    if(a[1].c==58)\n    {\n        cout<<6;\n        return 0;\n    }\n   /* if(a[4].c==400)\n    {\n        cout<<500;\n        return 0;\n    }*/\n    maxn=-1;\n    for(int i=2;i<=m;i++)\n    maxn=max(f[i],maxn);\n    if(f[1]>maxn) {\n        cout<<0;\n        return 0;\n    }\n    else\n    {\n        sort(a+1,a+n+1,cmp);\n        long long sum=0,js=0;\n        for(int i=1;i<=n;i++)\n        {\n            if(a[i].p!=1)\n            {\n                sum+=a[i].c;\n                js++;\n                if(js==maxn-f[1]+1) break;\n            }\n           \n        }\n        maxnn=sum;\n        for(int i=1;i<=maxn;i++)\n        {\n            long long AC=dfs(i);\n            maxnn=min(AC,maxnn);\n        }\n          \n       cout<<maxnn;\n    }\n}",
        "fixed_code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nlong long n,m,maxnn=1000000000LL;\nstruct stu{\n    int p,c;\n};\nstruct s{\n    long long w,zs;\n};\nstu a[3003];\nlong long f[3003];\ns z[3003];\nlong long maxn;\nlong long minx;\nint read()\n{\n    long long x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0')\n    {\n        if(ch=='-') f=-f;\n        ch=getchar();\n    }\n    while(ch<='9'&&ch>='0')\n    {\n        x=x*10+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\nbool cmp(stu x,stu y)\n{\n    if(x.c!=y.c) return x.c<y.c;\n    return f[x.p]>f[y.p];\n}\nlong long dfs(long long k)\n{\n    long long w2=0;\n    long long y=maxn-f[1]+1;\n    long long sum=0;\n    while(k>0)\n    for(int i=1;i<=n;i++)\n    {\n        if(f[a[i].p]==maxn&&a[i].p!=1) \n        {\n            //cout<<a[i].p<<\" \"<<a[i].c<<\" \";\n            sum+=a[i].c;\n           // cout<<sum<<\" \";\n            w2++;\n            z[w2].zs=a[i].p;\n            a[i].p=1;\n            z[w2].w=i;\n            memset(f,0,sizeof(f));\n            for(int i=1;i<=n;i++)\n            f[a[i].p]++;\n            maxn=-1;\n            for(int i=2;i<=m;i++)\n            maxn=max(f[i],maxn);\n            y=maxn-f[1]+1;\n            k--;\n            break;\n        }\n    }\n    long long js=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(a[i].p!=1)\n        {\n            sum+=a[i].c;\n            js++;\n            if(js==y) break;\n        }\n        \n    }\n    //cout<<sum<<endl;\n    for(int i=1;i<=w2;i++)\n    {\n        a[z[i].w].p=z[i].zs;\n    }\n    //cout<<endl;\n    //cout<<sum<<endl;\n    return sum;\n}\nint main()\n{\n    n=read();m=read();\n    for(int i=1;i<=n;i++)\n    {\n        a[i].p=read();\n        a[i].c=read();\n        f[a[i].p]++;\n    }\n    if(a[1].c==366201616)\n    {\n        cout<<1530509143;\n        return 0;\n    }\n    if(a[1].c==222470366)\n    {\n        cout<<353427049096;\n        return 0;\n    }\n   /* if(a[4].c==400)\n    {\n        cout<<500;\n        return 0;\n    }*/\n    maxn=-1;\n    for(int i=2;i<=m;i++)\n    maxn=max(f[i],maxn);\n    if(f[1]>maxn) {\n        cout<<0;\n        return 0;\n    }\n    else\n    {\n        sort(a+1,a+n+1,cmp);\n        long long sum=0,js=0;\n        for(int i=1;i<=n;i++)\n        {\n            if(a[i].p!=1)\n            {\n                sum+=a[i].c;\n                js++;\n                if(js==maxn-f[1]+1) break;\n            }\n           \n        }\n        maxnn=sum;\n        for(int i=1;i<=maxn;i++)\n        {\n            long long AC=dfs(i);\n            maxnn=min(AC,maxnn);\n        }\n          \n       cout<<maxnn;\n    }\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main()\n{\n    //follow excellence\n    ll t,n,i,j;\n    cin>>t;\n    while(t--)\n    {\n        ll n,x,m;\n        cin>>n>>x>>m;\n        ll s[m*2],mn=0,ma;\n        for(i=1; i<=m*2; i++)\n        {\n            cin>>s[i];\n            //mn=max(s[i],mn);\n            //ma=min(s[i],ma);\n        }\n        ll ans=0;\n        ma=0;\n        //if(x==n)cout<<n<<endl;\n            for(i=1; i<=m*2; i+=2)\n            {\n                if(s[i+1]>ma)\n                {\n                    if(x>=s[i] and x<=s[i+1])\n                    {\n                        ans=s[i+1];\n                        ma=s[i+1];\n                    }\n                }\n\n            }\n            if(ans==0)cout<<x<<endl;\n            else cout<<ans<<endl;\n    }\n    return 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main()\n{\n    //follow excellence\n    ll t,n,i,j;\n    cin>>t;\n    while(t--)\n    {\n        ll n,x,m;\n        cin>>n>>x>>m;\n        ll s[m*2],mn=0,ma;\n        ll ans=x,ans1=x,a,b;\n        while(m--)\n        {\n            cin>>a>>b;\n            if(ans<a or ans1>b)continue;\n\n            ans=max(b,ans);\n            ans1=min(a,ans1);\n\n        }\n\n        cout<<ans-ans1+1<<endl;\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "﻿#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <fstream>\n#include <string>\n\n\n\n\nusing namespace std;\n\n\n\n\n\nint main()\n{\n\tlong long int n,x;\n\tcin >> n;\n\tcin >> x;\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int g;\n\t\tcin >> g;\n\t\twhile (g > 0 && x > 0) {\n\t\t\tif (g >= x) {\n\t\t\t\tg = g % x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x % g;\n\t\t\t}\n\t\t}\n\t\tx = x + g;\n\t}\n\tint g = 0;\n\tfor (int i = 1; i <= sqrt(x); i++) {\n\t\tif (x % i == 0) {\n\t\t\tg+=2;\n\t\t}\n\t}\n\tif (sqrt(x) * sqrt(x) == x) {\n\t\tg--;\n\t}\n\tcout << g;\n}\n\n\n\n",
        "fixed_code": "﻿#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <fstream>\n#include <string>\n\n\n\n\nusing namespace std;\n\n\n\n\n\nint main()\n{\n\tlong long int n,x;\n\tcin >> n;\n\tcin >> x;\n\tlong long int g;\n\tfor (int i = 1; i < n ; i++) {\n\t\t\n\t\tcin >> g;\n\t\t\n\t\t\twhile (g > 0 && x > 0) {\n\t\t\t\tif (g >= x) {\n\t\t\t\t\tg = g % x;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx = x % g;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = x + g;\n\t\t\n\t}\n\t g = 0;\n\tlong long int i = 1;\n\tfor (i; i * i <= x; i++) {\n\t\tif (x % i == 0) {\n\t\t\tg+=2;\n\t\t}\n\t}\n\ti--;\n\tif (i*i == x) {\n\t\tg--;\n\t}\n\tcout << g;\n\t\n}\n\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5005;\n\nint n, m;\nvector <pair <int, int> > p[N];\n\nint get(int x, int y) {\n    if (x <= y) {\n        return y - x;\n    } else {\n        return n - x + y;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        p[a].push_back({b, a});\n    }\n    for (int i = 1; i <= n; i++) {\n        sort(p[i].begin(), p[i].end(), [](pair <int, int> x, pair <int, int> y) {\n            return get(x.second, x.first) < get(y.second, y.first);\n        });\n    }\n    for (int i = 1; i <= n; i++) {\n        int ans = 0;\n        for (int j = 1; j <= n; j++) {\n            int cur = get(i, j);\n            if (p[j].size()) {\n                cur += get(j, p[j][0].first);\n                cur += ((int) p[j].size() - 1) * n;\n            }\n            ans = max(ans, cur);\n        }\n        cout << ans << ' ';\n    }\n    cout << '\\n';\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5005;\n\nint n, m;\nvector <pair <int, int> > p[N];\n\nint get(int x, int y) {\n    if (x <= y) {\n        return y - x;\n    } else {\n        return n - x + y;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        p[a].push_back({b, a});\n    }\n    for (int i = 1; i <= n; i++) {\n        sort(p[i].begin(), p[i].end(), [](pair <int, int> x, pair <int, int> y) {\n            return get(x.second, x.first) < get(y.second, y.first);\n        });\n    }\n    for (int i = 1; i <= n; i++) {\n        int ans = 0;\n        for (int j = 1; j <= n; j++) {\n            if (p[j].size()) {\n                int cur = get(i, j);\n                cur += get(j, p[j][0].first);\n                int sz = (int) p[j].size();\n                cur += (sz - 1) * n;\n                ans = max(ans, cur);\n            }\n        }\n        cout << ans << ' ';\n    }\n    cout << '\\n';\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#ifdef Fading\n#define gc getchar\n#endif\n#ifndef Fading\ninline char gc(){\n    static char now[1<<16],*S,*T;\n    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n    return *S++;\n}\n#endif\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\n/*\n数位dp。 \n直接状压随便水。 \n*/\nint T;\nll b,dp[12][100][2088],x[111],cnt;\nll dfs(ll zero,ll len,ll lim,ll zt){\n    if (len==0) return (zt==0);\n    if (!lim&&!zero&&(~dp[b][len][zt])) return dp[b][len][zt];\n    ll res=0,mx=(lim?x[len]:b-1);\n    for (ll i=0;i<=mx;i++){\n        res+=dfs(zero|(i!=0),len-1,lim&(i==mx),(zero?zt^(1<<i):(i==0?0:(1<<i))));\n    }\n    if (!lim&&!zero) dp[b][len][zt]=res;\n    return res;\n}\ninline ll calc(ll a){\n    if (a==0) return 1;\n    ll tmp=a,len=0;\n    while (tmp){\n        x[++len]=tmp%b;tmp/=b;\n    }\n    ll ans=dfs(0,len,1,0);\n    return ans;\n}\nsigned main(){\n\tmemset(dp,-1,sizeof dp);\n    T=read();\n    while (T--){\n        b=read();\n        ll l=read(),r=read();\n        printf(\"%I64d\\n\",calc(r)-calc(l-1));\n    }\n    return 0;\n}\n\n",
        "fixed_code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#ifdef Fading\n#define gc getchar\n#endif\n#ifndef Fading\ninline char gc(){\n    static char now[1<<16],*S,*T;\n    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n    return *S++;\n}\n#endif\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3LL)+(x<<1LL)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\n/*\n数位dp。 \n直接状压随便水。 \n*/\nll T;\nll b,dp[12][100][2088],x[111],cnt;\nll dfs(ll zero,ll len,ll lim,ll zt){\n    if (len==0) return (zt==0);\n    if (!lim&&zero&&(~dp[b][len][zt])) return dp[b][len][zt];\n    ll res=0,mx=(lim?x[len]:b-1);\n    for (ll i=0;i<=mx;i++){\n        res+=dfs(zero|(i!=0),len-1,lim&(i==mx),(zero?zt^(1<<i):(i==0?0:(1<<i))));\n    }\n    if (!lim&&zero) dp[b][len][zt]=res;\n    return res;\n}\ninline ll calc(ll a){\n    if (a==0) return 1;\n    ll tmp=a,len=0;\n    while (tmp){\n        x[++len]=tmp%b;tmp/=b;\n    }\n    ll ans=dfs(0,len,1,0);\n    return ans;\n}\nsigned main(){\n\tmemset(dp,-1,sizeof dp);\n    T=read();\n    while (T--){\n        b=read();\n        ll l=read(),r=read();\n        printf(\"%I64d\\n\",calc(r)-calc(l-1));\n    }\n    return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\nprotected void execute() {\n    super.execute();\n    shooterFeederCommand.execute();\n    if (shooterFeederCommand.isFinished()) {\n        if (shooterFeederCommand.aborted) {\n            org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.error(\"ShooterFeederCommand aborted!\");\n        }else {\n            org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"ShooterFeederCommand ended\");\n        }\n        currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.DONE;\n    }\n    switch (currentState) {\n        case WAIT_FOR_VISION :\n            Robot.driveTrain.rawThrottleTurnDrive(0, 0);\n            if (Robot.vision.isBoilerVisionDataValid()) {\n                org.ligerbots.steamworks.subsystems.Vision.VisionData data = Robot.vision.getBoilerVisionData();\n                double tx = data.getTvecX();\n                double tz = data.getTvecZ();\n                double angle = 90 - (java.lang.Math.toDegrees(java.lang.Math.atan2(tz, tx)));\n                currentAngle = angle;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Got data: tx=%f, tz=%f, angle=%f, state=TURN\", tx, tz, angle));\n                double calculatedRpm = 5000;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Shooter rpm: %f\", calculatedRpm));\n                shooterFeederCommand.setRpm(calculatedRpm);\n                turnCommand = new org.ligerbots.steamworks.commands.TurnCommand(angle);\n                turnCommand.initialize();\n                currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.TURN;\n            }\n            break;\n        case TURN :\n            turnCommand.execute();\n            if (turnCommand.isFinished()) {\n                turnCommand.end();\n                if (!(turnCommand.succeeded)) {\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.warn(\"turn command failed, state=ABORTED\");\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.ABORTED;\n                }else {\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"state=WAIT\");\n                    nanosStartOfWait = java.lang.System.nanoTime();\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.WAIT;\n                }\n            }\n            if (!(Robot.vision.isBoilerVisionDataValid())) {\n                Robot.driveTrain.rawThrottleTurnDrive(0, 0);\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"Lost vision, state=WAIT_FOR_VISION\");\n                currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.WAIT_FOR_VISION;\n            }\n            break;\n        case WAIT :\n            if ((((java.lang.System.nanoTime()) - (nanosStartOfWait)) >= (org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.WAIT_NANOS)) && (Robot.vision.isBoilerVisionDataValid())) {\n                org.ligerbots.steamworks.subsystems.Vision.VisionData data = Robot.vision.getBoilerVisionData();\n                double tx = data.getTvecX();\n                double tz = data.getTvecZ();\n                double angle = 90 - (java.lang.Math.toDegrees(java.lang.Math.atan2(tz, tx)));\n                currentAngle = angle;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Got data: tx=%f, tz=%f, angle=%f, state=TURN\", tx, tz, angle));\n                double calculatedRpm = 5000;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Shooter rpm: %f\", calculatedRpm));\n                shooterFeederCommand.setRpm(calculatedRpm);\n                if ((java.lang.Math.abs(angle)) < (org.ligerbots.steamworks.RobotMap.AUTO_TURN_ACCEPTABLE_ERROR)) {\n                    shooterFeederCommand.setWithholdShooting(false);\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.SHOOT;\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"state=SHOOT\");\n                }else {\n                    turnCommand = new org.ligerbots.steamworks.commands.TurnCommand(angle);\n                    turnCommand.initialize();\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.TURN;\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"state=TURN\");\n                }\n            }\n            break;\n        default :\n            Robot.driveTrain.rawThrottleTurnDrive(0, 0);\n            break;\n    }\n}",
        "fixed_code": "@java.lang.Override\nprotected void execute() {\n    super.execute();\n    shooterFeederCommand.execute();\n    if (shooterFeederCommand.isFinished()) {\n        if (shooterFeederCommand.aborted) {\n            org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.error(\"ShooterFeederCommand aborted!\");\n        }else {\n            org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"ShooterFeederCommand ended\");\n        }\n        currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.DONE;\n    }\n    switch (currentState) {\n        case WAIT_FOR_VISION :\n            Robot.driveTrain.rawThrottleTurnDrive(0, 0);\n            if (Robot.vision.isBoilerVisionDataValid()) {\n                org.ligerbots.steamworks.subsystems.Vision.VisionData data = Robot.vision.getBoilerVisionData();\n                double tx = data.getTvecX();\n                double tz = data.getTvecZ();\n                double angle = 90 - (java.lang.Math.toDegrees(java.lang.Math.atan2(tz, tx)));\n                currentAngle = angle;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Got data: tx=%f, tz=%f, angle=%f, state=TURN\", tx, tz, angle));\n                double calculatedRpm = 5000;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Shooter rpm: %f\", calculatedRpm));\n                shooterFeederCommand.setRpm(calculatedRpm);\n                turnCommand = new org.ligerbots.steamworks.commands.TurnCommand(angle);\n                turnCommand.initialize();\n                currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.TURN;\n            }\n            break;\n        case TURN :\n            turnCommand.execute();\n            if (turnCommand.isFinished()) {\n                turnCommand.end();\n                if (!(turnCommand.succeeded)) {\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.warn(\"turn command failed, state=ABORTED\");\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.ABORTED;\n                }else {\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"state=WAIT\");\n                    nanosStartOfWait = java.lang.System.nanoTime();\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.WAIT;\n                }\n            }\n            if (!(Robot.vision.isBoilerVisionDataValid())) {\n                Robot.driveTrain.rawThrottleTurnDrive(0, 0);\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"Lost vision, state=WAIT_FOR_VISION\");\n                currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.WAIT_FOR_VISION;\n            }\n            break;\n        case WAIT :\n            Robot.driveTrain.rawThrottleTurnDrive(0, 0);\n            if ((((java.lang.System.nanoTime()) - (nanosStartOfWait)) >= (org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.WAIT_NANOS)) && (Robot.vision.isBoilerVisionDataValid())) {\n                org.ligerbots.steamworks.subsystems.Vision.VisionData data = Robot.vision.getBoilerVisionData();\n                double tx = data.getTvecX();\n                double tz = data.getTvecZ();\n                double angle = 90 - (java.lang.Math.toDegrees(java.lang.Math.atan2(tz, tx)));\n                currentAngle = angle;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Got data: tx=%f, tz=%f, angle=%f, state=TURN\", tx, tz, angle));\n                double calculatedRpm = 5000;\n                org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(java.lang.String.format(\"Shooter rpm: %f\", calculatedRpm));\n                shooterFeederCommand.setRpm(calculatedRpm);\n                if ((java.lang.Math.abs(angle)) < (org.ligerbots.steamworks.RobotMap.AUTO_TURN_ACCEPTABLE_ERROR)) {\n                    shooterFeederCommand.setWithholdShooting(false);\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.SHOOT;\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"state=SHOOT\");\n                }else {\n                    turnCommand = new org.ligerbots.steamworks.commands.TurnCommand(angle);\n                    turnCommand.initialize();\n                    currentState = org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.State.TURN;\n                    org.ligerbots.steamworks.commands.AlignBoilerAndShootCommand.logger.info(\"state=TURN\");\n                }\n            }\n            break;\n        default :\n            Robot.driveTrain.rawThrottleTurnDrive(0, 0);\n            break;\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "﻿\"\"\"\n<div class=\"problem-statement\"><div class=\"header\"><div class=\"title\">B. The least round way</div><div class=\"time-limit\"><div class=\"property-title\">time limit per test</div>2 seconds</div><div class=\"memory-limit\"><div class=\"property-title\">memory limit per test</div>64 megabytes</div><div class=\"input-file\"><div class=\"property-title\">input</div>standard input</div><div class=\"output-file\"><div class=\"property-title\">output</div>standard output</div></div><div><p>There is a square matrix <span class=\"tex-span\"><i>n</i> × <i>n</i></span>, consisting of non-negative integer numbers. You should find such a way on it that </p><ul> <li> starts in the upper left cell of the matrix; </li><li> each following cell is to the right or down from the current cell; </li><li> the way ends in the bottom right cell. </li></ul><p>Moreover, if we multiply together all the numbers along the way, the result should be the least \"round\". In other words, it should end in the least possible number of zeros.</p></div><div class=\"input-specification\"><div class=\"section-title\">Input</div><p>The first line contains an integer number <span class=\"tex-span\"><i>n</i></span> (<span class=\"tex-span\">2 ≤ <i>n</i> ≤ 1000</span>), <span class=\"tex-span\"><i>n</i></span> is the size of the matrix. Then follow <span class=\"tex-span\"><i>n</i></span> lines containing the matrix elements (non-negative integer numbers not exceeding <span class=\"tex-span\">10<sup class=\"upper-index\">9</sup></span>).</p></div><div class=\"output-specification\"><div class=\"section-title\">Output</div><p>In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.</p></div><div class=\"sample-tests\"><div class=\"section-title\">Examples</div><div class=\"sample-test\"><div class=\"input\"><div class=\"title\">Input</div><pre>3<br>1 2 3<br>4 5 6<br>7 8 9<br></pre></div><div class=\"output\"><div class=\"title\">Output</div><pre>0<br>DDRR<br></pre></div></div></div></div>\n\nB. The least round way\ntime limit per test2 seconds\nmemory limit per test64 megabytes\ninputstandard input\noutputstandard output\nThere is a square matrix n × n, consisting of non-negative integer numbe\nrs. You should find such a way on it that\n\nstarts in the upper left cell of the matrix;\neach following cell is to the right or down from the current cell;\nthe way ends in the bottom right cell.\nMoreover, if we multiply together all the numbers along the way, the res\nult should be the least \"round\". In other words, it should end in the le\nast possible number of zeros.\n\nInput\nThe first line contains an integer number n (2 ≤ n ≤ 1000), n is the siz\ne of the matrix. Then follow n lines containing the matrix elements (non\n-negative integer numbers not exceeding 109).\n\nOutput\nIn the first line print the least number of trailing zeros. In the secon\nd line print the correspondent way itself.\n\nExamples\ninput\n\n3\n1 2 3\n4 5 6\n7 8 9\noutput\n0\nDDRR\n\"\"\"\n\nfrom sys import stdin, stdout\nimport re\n\n\nn = int(stdin.readline())\no = xrange(n)\no1 = xrange(1, n)\nmtin = [map(int,stdin.readline().split()) for i1 in o]\n\n\ndef f(m,k):\n    r = 0\n    while m and m%k == 0:\n        m/=k\n        r+=1\n    return r\n\ndef dp(k):\n    b = [[f(x,k) for x in c] for c in mtin]\n\n    for i1 in o1:\n        b[i1][0] += b[i1-1][0]\n        b[0][i1] += b[0][i1-1]\n\n    for i1 in o1:\n        for i2 in o1:\n            b[i1][i2] += min(b[i1 - 1][i2], b[i1][i2 - 1])\n\n    ans = ''\n    i1 = n - 1\n    i2 = n - 1\n\n    while i1 + i2:\n        if i1 == 0 or ( i1 * i2 and b[i1][i2 - 1] < b[i1 - 1][i2]):\n            i2 -= 1\n            ans += 'R'\n        else:\n            i1 -= 1\n            ans += 'D'\n\n\n    return (b[n-1][n-1], ans[::-1])\n\n\n(a,s) = min(dp(2), dp(5))\n\nfor i1 in o:\n    if a > 1:\n        for i2 in o:\n            if mtin[i1][i2] == 0:\n                a = 1\n                s = 'R' * j + 'D' * (n - 1) + 'R' * (n - 1 - i2)\n\nstdout.write('{:d}\\n{:s}'.format(a,s))\n",
        "fixed_code": "﻿\"\"\"\n<div class=\"problem-statement\"><div class=\"header\"><div class=\"title\">B. The least round way</div><div class=\"time-limit\"><div class=\"property-title\">time limit per test</div>2 seconds</div><div class=\"memory-limit\"><div class=\"property-title\">memory limit per test</div>64 megabytes</div><div class=\"input-file\"><div class=\"property-title\">input</div>standard input</div><div class=\"output-file\"><div class=\"property-title\">output</div>standard output</div></div><div><p>There is a square matrix <span class=\"tex-span\"><i>n</i> × <i>n</i></span>, consisting of non-negative integer numbers. You should find such a way on it that </p><ul> <li> starts in the upper left cell of the matrix; </li><li> each following cell is to the right or down from the current cell; </li><li> the way ends in the bottom right cell. </li></ul><p>Moreover, if we multiply together all the numbers along the way, the result should be the least \"round\". In other words, it should end in the least possible number of zeros.</p></div><div class=\"input-specification\"><div class=\"section-title\">Input</div><p>The first line contains an integer number <span class=\"tex-span\"><i>n</i></span> (<span class=\"tex-span\">2 ≤ <i>n</i> ≤ 1000</span>), <span class=\"tex-span\"><i>n</i></span> is the size of the matrix. Then follow <span class=\"tex-span\"><i>n</i></span> lines containing the matrix elements (non-negative integer numbers not exceeding <span class=\"tex-span\">10<sup class=\"upper-index\">9</sup></span>).</p></div><div class=\"output-specification\"><div class=\"section-title\">Output</div><p>In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.</p></div><div class=\"sample-tests\"><div class=\"section-title\">Examples</div><div class=\"sample-test\"><div class=\"input\"><div class=\"title\">Input</div><pre>3<br>1 2 3<br>4 5 6<br>7 8 9<br></pre></div><div class=\"output\"><div class=\"title\">Output</div><pre>0<br>DDRR<br></pre></div></div></div></div>\n\nB. The least round way\ntime limit per test2 seconds\nmemory limit per test64 megabytes\ninputstandard input\noutputstandard output\nThere is a square matrix n × n, consisting of non-negative integer numbe\nrs. You should find such a way on it that\n\nstarts in the upper left cell of the matrix;\neach following cell is to the right or down from the current cell;\nthe way ends in the bottom right cell.\nMoreover, if we multiply together all the numbers along the way, the res\nult should be the least \"round\". In other words, it should end in the le\nast possible number of zeros.\n\nInput\nThe first line contains an integer number n (2 ≤ n ≤ 1000), n is the siz\ne of the matrix. Then follow n lines containing the matrix elements (non\n-negative integer numbers not exceeding 109).\n\nOutput\nIn the first line print the least number of trailing zeros. In the secon\nd line print the correspondent way itself.\n\nExamples\ninput\n\n3\n1 2 3\n4 5 6\n7 8 9\noutput\n0\nDDRR\n\"\"\"\n\nfrom sys import stdin, stdout\nimport re\n\n\nn = int(stdin.readline())\no = xrange(n)\no1 = xrange(1, n)\nmtin = [map(int,stdin.readline().split()) for i1 in o]\n\n\ndef f(m,k):\n    r = 0\n    while m and m%k == 0:\n        m/=k\n        r+=1\n    return r\n\ndef dp(k):\n    b = [[f(x,k) for x in c] for c in mtin]\n\n    for i1 in o1:\n        b[i1][0] += b[i1-1][0]\n        b[0][i1] += b[0][i1-1]\n\n    for i1 in o1:\n        for i2 in o1:\n            b[i1][i2] += min(b[i1 - 1][i2], b[i1][i2 - 1])\n\n    ans = ''\n    i1 = n - 1\n    i2 = n - 1\n\n    while i1 + i2:\n        if i1 == 0 or ( i1 * i2 and b[i1][i2 - 1] < b[i1 - 1][i2]):\n            i2 -= 1\n            ans += 'R'\n        else:\n            i1 -= 1\n            ans += 'D'\n\n\n    return (b[n-1][n-1], ans[::-1])\n\n\n(a,s) = min(dp(2), dp(5))\n\nfor i1 in o:\n    if a > 1:\n        for i2 in o:\n            if mtin[i1][i2] == 0:\n                a = 1\n                s = 'R' * i2 + 'D' * (n - 1) + 'R' * (n - 1 - i2)\n\nstdout.write('{:d}\\n{:s}'.format(a,s))\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<stdlib.h>\n#include<algorithm>\n#define SIZE_N 100005\n#define x first\n#define y second\nusing namespace std;\npair<int, int> V[SIZE_N];\nint a[SIZE_N],b[SIZE_N];\nint cnt,n;\n/*void solve(int d)\n{\n    int wa=0, wb =0;\n    int news = 0;\n    while (1){\n        int isa = lower_bound(a+1,a+n+1,a[news]+d)-(a) ;//二分查找的时间复杂度是logn\n        int isb = lower_bound(b+1,b+n+1,b[news]+d)-(b) ;//这里注意要使最小值为1，否则会无限循环下去\n        int mintimes = min(isa,isb);\n        bool win = isb == mintimes;//\"=\"的优先级很低 而且是从右到左。“==”的优先级比较高，而且是从左到右\n        if (mintimes > n)\n            return;//printf(\"d=%d  a[n]=%d b[n] = %d isa = %d isb = %d mintimes=%d\\n\",d, a[n],b[n],wa, wb,win);\n//printf(\"d=%d  a[n]=%d b[n] = %d isa = %d isb = %d mintimes=%d\\n\\n\",d, a[n],b[n],isa, isb,win);\n        if (mintimes == n){\n            //if  ( (win == 1 && isb < isa)  ){\n            if (win == 1 && wa<=wb){//这里必须有等号 不然3 1 2 1 就不对了\n                V[cnt].y = d;\n                V[cnt++].x = b[n]/d;\n            }\n            //if (win == 0 && isb > isa){\n            if (win == 0 && wa>= wb){\n                V[cnt].y = d;\n                V[cnt++].x = a[n]/d;\n            }\n            return;\n        }\n        news = mintimes;\n        if (win)//这里ab写反了\n            wb++;\n        else wa++;\n\n    }\n}*/\n\nvoid solve(int d){\n\tint wa=0,wb=0;\n\tint st=0;\n\twhile(1){\n\t\tint f=lower_bound(a+1,a+n+1,a[st]+d)-a;\n\t\tint g=lower_bound(b+1,b+n+1,b[st]+d)-b;\n\t\tint h=min(f,g);\n\t\tint p=g==h;\n\t\tif(h>n) return;\n\t\tif(h==n){\n\n\t\t\tif(p==0&&wa>=wb){\n\t\t\t\tV[cnt].y = d;\n                V[cnt++].x = a[n]/d;\n\t\t\t}\n\t\t\tif(p==1&&wb>=wa){\n\t\t\t\tV[cnt].y = d;\n                V[cnt++].x = b[n]/d;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tst=h;//printf(\"p=%d g = %d h = %d wa = %d wb=%d\\n\",p,g,h,wa,wb);\n\t\tif(p) ++wb;\n\t\telse ++wa;\n\t}\n}\n\nint main()\n{\n    while (~scanf(\"%d\",&n)){\n        cnt = 0;\n        for (int i = 1; i <= n; i++){\n            int temp;\n            scanf(\"%d\",&temp);\n            a[i] = a[i-1];\n            b[i] = b[i-1];\n            if (temp != 2)\n                a[i]++;\n            else b[i]++;\n        }\n        for (int i = 1; i <= n; i++)\n            solve(i);\n        //puts(\"b\");\n        sort(V,V+cnt);\n        printf(\"%d\\n\",cnt);\n        for (int i = 0; i < cnt; i++)\n            printf(\"%d %d\\n\",V[i].x,V[i].y);\n    }\n    return 0;\n}\n",
        "fixed_code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<stdlib.h>\n#include<algorithm>\n#define SIZE_N 100005\n#define x first\n#define y second\nusing namespace std;\npair<int, int> V[SIZE_N];\nint a[SIZE_N],b[SIZE_N];\nint cnt,n;\nvoid solve(int d)\n{\n    int wa=0, wb =0;\n    int news = 0;\n    while (1){\n        int isa = lower_bound(a+1,a+n+1,a[news]+d)-(a) ;//二分查找的时间复杂度是logn\n        int isb = lower_bound(b+1,b+n+1,b[news]+d)-(b) ;//这里注意要使最小值为1，否则会无限循环下去\n        int mintimes = min(isa,isb);\n        bool win = isb == mintimes;//\"=\"的优先级很低 而且是从右到左。“==”的优先级比较高，而且是从左到右\n        if (mintimes > n)\n            return;//printf(\"d=%d  a[n]=%d b[n] = %d isa = %d isb = %d mintimes=%d\\n\",d, a[n],b[n],wa, wb,win);\n//printf(\"d=%d  a[n]=%d b[n] = %d isa = %d isb = %d mintimes=%d\\n\\n\",d, a[n],b[n],isa, isb,win);\n        if (mintimes == n){\n            //if  ( (win == 1 && isb < isa)  ){\n            if (win == 1 && wa<=wb){//这里必须有等号 不然3 1 2 1 就不对了\n                V[cnt].y = d;\n                V[cnt++].x = wb+1;\n            }\n            //if (win == 0 && isb > isa){\n            if (win == 0 && wa>= wb){\n                V[cnt].y = d;\n                V[cnt++].x = wa+1;\n            }\n            return;\n        }\n        news = mintimes;\n        if (win)//这里ab写反了\n            wb++;\n        else wa++;\n\n    }\n}\n\nint main()\n{\n    while (~scanf(\"%d\",&n)){\n        cnt = 0;\n        for (int i = 1; i <= n; i++){\n            int temp;\n            scanf(\"%d\",&temp);\n            a[i] = a[i-1];\n            b[i] = b[i-1];\n            if (temp != 2)\n                a[i]++;\n            else b[i]++;\n        }\n        for (int i = 1; i <= n; i++)\n            solve(i);\n        //puts(\"b\");\n        sort(V,V+cnt);\n        printf(\"%d\\n\",cnt);\n        for (int i = 0; i < cnt; i++)\n            printf(\"%d %d\\n\",V[i].x,V[i].y);\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@java.lang.Override\npublic java.lang.Object getLiteralData() {\n    xdi2.core.impl.json.JSONContextNode jsonContextNode = ((xdi2.core.impl.json.JSONContextNode) (this.getContextNode()));\n    com.google.gson.JsonObject jsonObject = ((xdi2.core.impl.json.JSONGraph) (this.getGraph())).jsonLoad(jsonContextNode.getXDIAddress().toString());\n    return xdi2.core.impl.AbstractLiteralNode.jsonElementToLiteralData(jsonObject.get(XDIConstants.XDI_ARC_LITERAL.toString()));\n}",
        "fixed_code": "@java.lang.Override\npublic java.lang.Object getLiteralData() {\n    xdi2.core.impl.json.JSONContextNode jsonContextNode = ((xdi2.core.impl.json.JSONContextNode) (this.getContextNode()));\n    com.google.gson.JsonObject jsonObject = ((xdi2.core.impl.json.JSONGraph) (this.getGraph())).jsonLoad(jsonContextNode.getXDIAddress().toString());\n    com.google.gson.JsonElement jsonElement = jsonObject.get(XDIConstants.XDI_ARC_LITERAL.toString());\n    if (jsonElement == null) {\n        xdi2.core.impl.json.JSONLiteralNode.log.warn(((\"In literal node \" + (this.getContextNode())) + \" found non-existent value.\"));\n        return null;\n    }\n    return xdi2.core.impl.AbstractLiteralNode.jsonElementToLiteralData(jsonElement);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "public void createCells() {\n    cells = new Cell[num_wide][num_high];\n    for (int row = 0; row < (num_high); row++) {\n        for (int column = 0; column < (num_wide); column++) {\n            cells[row][column] = new Cell();\n        }\n    }\n}",
        "fixed_code": "public void createCells() {\n    cells = new Cell[num_high][num_wide];\n    for (int row = 0; row < (num_high); row++) {\n        for (int column = 0; column < (num_wide); column++) {\n            cells[row][column] = new Cell();\n        }\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "n,m=list(map(int,input().split(' ')))\nc=[]\nfor i in range(n):\n    c.append(list(input()))\nfor i in range(n):\n    for j in range(m):\n        if(i==0):\n            \n            if(c[i][j]=='.'):\n                \n                if(j>0):\n                    if(c[i][j-1]=='B' or c[i][j-1]=='-'):\n                        c[i][j]='W'\n                    if(c[i][j-1]=='W' or c[i][j-1]=='-'):\n                        c[i][j]='B'\n                else:\n                   \n                    c[i][j]='B'\n        else:\n            if(c[i][j]=='.'):\n                if(j>0):\n                    if((c[i][j-1]=='B' or c[i][j-1]=='-') and (c[i-1][j]=='-' or c[i-1][j]=='B')):\n                        c[i][j]='W'\n                    else:\n                        c[i][j]='-'\n                    if((c[i][j-1]=='W' or c[i][j-1]=='-')and (c[i-1][j]=='-' or c[i-1][j]=='W')):\n                        c[i][j]='B'\n                else:\n                    if(c[i-1][j]=='B'):\n                        c[i][j]='W'\n                    else:\n                        c[i][j]='B'\nfor i in c:\n    for j in i:\n        print(j,end=\"\")\n    print()\n       \n                    \n                 ",
        "fixed_code": "n,m=list(map(int,input().split(' ')))\ng=[]\nf=0\nfor i in range(n):\n    c=input()\n    t=''\n    for j in range(m):\n        if(c[j]=='.' and f==1):\n            if(j%2==0 ):\n                t+='W'\n            else:\n                t+='B'\n            \n        \n        elif(c[j]=='.' and f==0):\n            if(j%2==0 ):\n                t+='B'\n            else:\n                t+='W'\n            \n        else:\n            t+='-'\n    g.append(t)\n    if(f==1):\n        f=0\n    else:\n        f=1\nfor i in g:\n    for j in i:\n        print(j,end='')\n    print()\n            ",
        "source": "Python_461356.json"
    },
    {
        "source_code": " #include<bits/stdc++.h>\n using namespace std;\n int n,m;\n vector<int>v[100009];\n bool done[100009];\n bool cyc[100009];\n bool ex;\n void dfs(int node,int p,int s)\n {\n    if (ex)return;\n    if(done[node]&&node==s)\n    {\n        ex=1;\n        return;\n    }\n    if(done[node])return;\n    cyc[node]=1;\n    done[node]=1;\n    for(int i=0;i<v[node].size();i++)\n    {\n        int u = v[node][i];\n        if(u == p)continue;\n        dfs(u,node,s);\n     }\n     if(ex)return;\n     cyc[node]=0;\n }\n void dfs2(int node,int dis)\n {\n     if(ex)return;\n     if(cyc[node])\n     {\n         cout<<dis<<endl;\n         ex=1;\n         return;\n     }\n     for(int i=0;i<v[node].size();i++)\n     {\n         int u=v[node][i];\n         dfs2(u,dis+1);\n     }\n }\n int main()\n {\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0,0);\n    for(int i=0;i<n;i++)\n    {\n        memset(done,0,sizeof(done));\n        if(ex)break;\n        dfs(i,i,i);\n    }\n    for(int i=0;i<n;i++)\n    {\n        memset(done,0,sizeof(done));\n        ex=0;\n        dfs2(i,0);\n    }\n }",
        "fixed_code": " #include<bits/stdc++.h>\n using namespace std;\n int n,m;\n vector<int>v[3009];\n bool done[3009];\n bool cyc[3009];\n bool ex;\n void dfs(int node,int p,int s)\n {\n    if (ex)return;\n    if(done[node]&&node==s)\n    {\n        ex=1;\n        return;\n    }\n    if(done[node])return;\n    cyc[node]=1;\n    done[node]=1;\n    for(int i=0;i<v[node].size();i++)\n    {\n        int u = v[node][i];\n        if(u == p)continue;\n        dfs(u,node,s);\n     }\n     if(ex)return;\n     cyc[node]=0;\n }\n void dfs2(int node,int dis)\n {\n     if(ex)return;\n     if(cyc[node])\n     {\n         cout<<dis<<endl;\n         ex=1;\n         return;\n     }\n     if(done[node])return;\n     done[node] = 1;\n     for(int i=0;i<v[node].size();i++)\n     {\n         int u=v[node][i];\n         dfs2(u,dis+1);\n     }\n }\n int main()\n {\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=0;i<n;i++)\n    {\n        memset(done,0,sizeof(done));\n        memset(cyc,0,sizeof(cyc));\n        dfs(i,i,i);\n        if(ex)break;\n    }\n    for(int i=0;i<n;i++)\n    {\n        memset(done,0,sizeof(done));\n        ex=0;\n        dfs2(i,0);\n    }\n }",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <stack>\n#include <memory.h>\n#include <list>\n#include <numeric>\n#include <functional>\n#include <complex>\n\n#define ll long long\n#define ld long double\n#define ull unsigned ll\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\n\nconst int nax = 5005;\n\nint a[nax];\nint b[nax];\nint c[nax];\nvector<int>g[nax];\nint can[nax][nax];\nint have[nax];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#else\n\t//freopen(\"dictionary.in\", \"r\", stdin);\n\t//freopen(\"dictionary.out\", \"w\", stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcout.precision(20); cout.setf(ios::fixed);\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcan[i][i] = 1;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tcan[u][v] = 1;\n\t}\n\n\tint cur = k;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur < a[i]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcur += b[i];\n\t}\n\n\tcur = k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcur += b[i];\n\t\tint l = 0, r = cur;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) / 2 + 1;\n\t\t\tint tmp = cur - mid;\n\t\t\tint ok = 1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (tmp < a[j]) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttmp += b[j];\n\t\t\t}\n\n\t\t\tif (ok) l = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\n\t\thave[i] = l;\n\t}\n\t\n\tvector<pair<int, int>>tmp(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttmp[i].first = c[i];\n\t\ttmp[i].second = i;\n\t}\n\n\tsort(rall(tmp));\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = tmp[i].second;\n\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\tif (can[j][v] && have[j]) {\n\t\t\t\tans += tmp[i].first;\n\t\t\t\thave[j]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\treturn 0;\n}",
        "fixed_code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <stack>\n#include <memory.h>\n#include <list>\n#include <numeric>\n#include <functional>\n#include <complex>\n\n#define ll long long\n#define ld long double\n#define ull unsigned ll\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\n\nconst int nax = 5005;\n\nint a[nax];\nint b[nax];\nint c[nax];\nvector<int>g[nax];\nint can[nax][nax];\nint have[nax];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#else\n\t//freopen(\"dictionary.in\", \"r\", stdin);\n\t//freopen(\"dictionary.out\", \"w\", stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcout.precision(20); cout.setf(ios::fixed);\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcan[i][i] = 1;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tcan[u][v] = 1;\n\t}\n\n\tint cur = k;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur < a[i]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcur += b[i];\n\t}\n\n\tcur = k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcur += b[i];\n\t\tint l = 0, r = cur;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) / 2 + 1;\n\t\t\tint tmp = cur - mid;\n\t\t\tint ok = 1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (tmp < a[j]) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttmp += b[j];\n\t\t\t}\n\n\t\t\tif (ok) l = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\n\t\thave[i] = l;\n\t}\n\t\n\tvector<pair<int, int>>tmp(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttmp[i].first = c[i];\n\t\ttmp[i].second = i;\n\t}\n\n\tsort(rall(tmp));\n\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = tmp[i].second;\n\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\tif (can[j][v] && have[j] > 0) {\n\t\t\t\tint ok = 1;\n\t\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\t\tif (have[k] == 0) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!ok) continue;\n\t\t\t\tans += tmp[i].first;\n\t\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\t\thave[k]--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,k,n) for(int i = k; i < n; i++)  \n#define repp(i,a,n,k) for(typeof(a) i=a;i!=n;i+=k)\n\n#define int long long\n#define all(a) a.begin(),a.end()       \n\n#define pb push_back\ntypedef long long ll; \ntypedef pair<int, int> ii;\ntypedef pair<int,ii > iii;\n\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<char> vchar;\n\n#define ff first\n#define ss second\n\n#define lb lower_bound\n#define ub upper_bound\n#define me max_element\n\n\n#define INF 1000000000\n//#define mod 998244353\n#define mod 1000000007\n#define endl \"\\n\"\n\n\n  \n\n\nint modPow(int a, int b);\nint modInv(int a);     \n\n\nvoid solve(){\n    int n,m,a,b;\n    cin >> n >> m >> a >> b;\n    if(n*a!=m*b){\n        cout << \"NO\\n\";\n        return;\n    }\n    int aa[n][m];\n    cout << \"YES\\n\";\n    rep(i,0,n){\n        rep(j,0,m){\n            aa[i][j]=0;\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,m){\n            aa[(j+i)%n][(j)%m]=1;\n        }\n    }\n    rep(i,0,n){\n        rep(j,0,m)cout << aa[i][j];\n        cout << endl;\n    }\n    //cout << endl;\n\n}\n\n\n\n\n\n\nsigned main(){\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //cout << fixed;\n    //cout <<setprecision(6);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    int test=1; cin >> test; while(test--)\n    solve();\n}\n\nint modPow(int a, int b){\n    if(b==0)return 1;\n    if(b%2==0){\n        int x = a*a;\n        x%=mod;\n        return modPow(x,b/2);\n    }\n    return (a*modPow(a,b-1))%mod;\n}\n\n\nint modInv(int a){\n    return modPow(a,mod-2);\n}\n\n\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,k,n) for(int i = k; i < n; i++)  \n#define repp(i,a,n,k) for(typeof(a) i=a;i!=n;i+=k)\n\n#define int long long\n#define all(a) a.begin(),a.end()       \n\n#define pb push_back\ntypedef long long ll; \ntypedef pair<int, int> ii;\ntypedef pair<int,ii > iii;\n\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<char> vchar;\n\n#define ff first\n#define ss second\n\n#define lb lower_bound\n#define ub upper_bound\n#define me max_element\n\n\n#define INF 1000000000\n//#define mod 998244353\n#define mod 1000000007\n#define endl \"\\n\"\n\n\n  \n\n\nint modPow(int a, int b);\nint modInv(int a);     \n\n\nvoid solve(){\n    int n,m,a,b;\n    cin >> n >> m >> a >> b;\n    if(n*a!=m*b){\n        cout << \"NO\\n\";\n        return;\n    }\n    int aa[n][m];\n    cout << \"YES\\n\";\n    rep(i,0,n){\n        rep(j,0,m){\n            aa[i][j]=0;\n        }\n    }\n    rep(i,0,n*a){\n        aa[i/a][i%m]=1;\n    }\n    rep(i,0,n){\n        rep(j,0,m)cout << aa[i][j];\n        cout << endl;\n    }\n    //cout << endl;\n\n}\n\n\n\n\n\n\nsigned main(){\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //cout << fixed;\n    //cout <<setprecision(6);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    int test=1; cin >> test; while(test--)\n    solve();\n}\n\nint modPow(int a, int b){\n    if(b==0)return 1;\n    if(b%2==0){\n        int x = a*a;\n        x%=mod;\n        return modPow(x,b/2);\n    }\n    return (a*modPow(a,b-1))%mod;\n}\n\n\nint modInv(int a){\n    return modPow(a,mod-2);\n}\n\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "from collections import Counter\ngoals = []\nT = int(input())\nif T == 1:\n    print(str(input().strip()))\nelse:\n    for i in range(T):\n        goals.append(str(input().strip()))\n    \n    k1, k2 = Counter(goals).keys()\n    x1, x2 = Counter(goals).values()\n    \n    print(k1) if x1>x2 else print(k2)",
        "fixed_code": "from collections import Counter\ngoals = []\nT = int(input())\nif T == 1:\n    print(str(input().strip()))\nelse:\n    for i in range(T):\n        goals.append(str(input().strip()))\n    \n    keys = Counter(goals).keys()\n    values = Counter(goals).values()\n    if(len(keys))<=1:\n        k1, = keys\n        print(k1)\n    else:\n        k1, k2 = keys\n        x1, x2 = values\n        print(k1) if x1>x2 else print(k2)\n        \n            \n    ",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<algorithm>\n#include<iostream>\n#include<string.h>\n#include<vector>\n#include<set>\n#define ALL(X) X.begin(),X.end()\n#define SZ(X) X.size()\nusing namespace std;\nint main ()\n{\n    int r,c;\n    cin>>r>>c;\n    vector<string>v(r);\n    for(int i=0; i<r; i++)\n        cin>>v[i];\n\n    for(int i=0; i<SZ(v); i++)\n    {\n        for(int j=0; j<SZ(v[i])-1; j++)\n            if(v[i][j]!=v[i][j+1] )\n            {\n                cout<<\"NO\\n\";\n                return 0;\n            }\n\n        if( (v[i]!=v.back() && v[i][0]==v[i+1][0] ) || v.back()[0]==v[SZ(v)-2][0] )\n        {\n            cout<<\"NO\\n\";\n            return 0;\n        }\n    }\n    cout<<\"YES\\n\";\n    return 0;\n}",
        "fixed_code": "#include<algorithm>\n#include<iostream>\n#include<string.h>\n#include<vector>\n#include<set>\n#define ALL(X) X.begin(),X.end()\n#define SZ(X) X.size()\nusing namespace std;\nint main ()\n{\n    int r,c;\n    cin>>r>>c;\n    vector<string>v(r);\n    for(int i=0; i<r; i++)\n        cin>>v[i];\n\n    for(int i=0; i<SZ(v); i++)\n    {\n        for(int j=0; j<SZ(v[i])-1; j++)\n            if(v[i][j]!=v[i][j+1] )\n            {\n                cout<<\"NO\\n\";\n                return 0;\n            }\n\n        if( SZ(v)>1 && ( (v[i]!=v.back() && v[i][0]==v[i+1][0] ) || v.back()[0]==v[SZ(v)-2][0] ) )\n        {\n            cout<<\"NO\\n\";\n            return 0;\n        }\n    }\n    cout<<\"YES\\n\";\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*\n*/\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cmath>\n#define M 1003\n#define N 201000\n#define ll long long\nusing namespace std;\n\nint read() {\n\tint nm = 0, f = 1;\n\tchar c = getchar();\n\tfor(; !isdigit(c); c = getchar()) if(c == '-') f = -1;\n\tfor(; isdigit(c); c = getchar()) nm = nm * 10 + c - '0';\n\treturn nm * f;\n}\nll f[M][M], sum[M][M];\nint a[N], b[N];\nint belong[N];\nint id[N], zd[N];\nint n, m, biao;\nint ln[M], rn[M];\nset<int> st;\n\nint sta[M], tp;\nint main() {\n\t//freopen(\".in\", \"r\", stdin), freopen(\".out\", \"w\", stdout);\n\tn = read(), m = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read(), id[a[i]] = i;\n\tfor(int i = 1; i <= n; i++) b[i] = read(), zd[b[i]] = i;\n\tif(n <= -300) {\n\t\tfor(int i = 1; i <= m; i++) {\n\t\t\tint op = read();\n\t\t\tif(op == 1) {\n\t\t\t\tint aa = read(), bb = read(), c = read(), d = read();\n\t\t\t\tst.clear();\n\t\t\t\tfor(int j = aa; j <= bb; j++) st.insert(a[j]);\n\t\t\t\tint ans = 0;\n\t\t\t\tfor(int j = c; j <= d; j++) if(st.find(b[j]) != st.end()) ans++;\n\t\t\t\tcout << ans << \"\\n\";\n\t\t\t} else {\n\t\t\t\tint aa = read(), bb = read();\n\t\t\t\tswap(b[aa], b[bb]);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbiao = sqrt(n);\n\tfor(int i = 1; i < M; i++) ln[i] = 0x3e3e3e3e, rn[i] = 0;\n\tfor(int i = 1; i <= n; i++) belong[i] = (i - 1) / biao + 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tint op = id[b[i]];\n\t\tint zz = belong[op];\n\t\tf[zz][belong[i]]++;\n\t}\n\tfor(int i = 1; i <= belong[n]; i++) {\n\t\tfor(int j = 1; j <= belong[n]; j++) {\n\t\t\tsum[i][j] = sum[i - 1][j] + f[i][j];\n\t\t}\n\t}\n\twhile(m--) {\n\t\tint op = read();\n\t\tint ans = 0;\n\t\tif(op == 1) {\n\t\t\tint aa = read(), bb = read(), c = read(), d = read();\n\t\t\tfor(int i = aa; i <= min(belong[aa] * biao, bb); i++) {\n\t\t\t\tif(zd[a[i]] >= c && zd[a[i]] <= d) ans++;\n\t\t\t}\n\t\t\tif(belong[aa] != belong[bb]) {\n\t\t\t\tfor(int i = (belong[bb] - 1) * biao + 1; i <= bb; i++)\n\t\t\t\t\tif(zd[a[i]] >= c && zd[a[i]] <= d) ans++;\n\t\t\t}\n\t\t\tint ln = belong[aa], rn = belong[bb] - 1;\n\n\t\t\tfor(int i = c; i <= min(belong[c] * biao, d); i++) if(id[b[i]] >= belong[aa] * biao + 1 && id[b[i]] <= (belong[bb] - 1) * biao) ans++;\n\t\t\tif(belong[c] != belong[d]) {\n\t\t\t\tfor(int i = (belong[d] - 1) * biao + 1; i <= d; i++)\n\t\t\t\t\tif(id[b[i]] >= belong[aa] * biao + 1 && id[b[i]] <= belong[bb - 1] * biao) ans++;\n\t\t\t}\n\t\t\tif(ln <= rn) for(int i = belong[c] + 1; i <= belong[d] - 1; i++) ans += sum[rn][i] - sum[ln][i];\n\t\t\tcout << ans << \"\\n\";\n\t\t} else {\n\t\t\tint aa = read(), bb = read();\n\t\t\tint op = id[b[aa]], zz = belong[op];\n\t\t\tf[zz][belong[aa]]--;\n\t\t\top = id[b[bb]], zz = belong[op];\n\t\t\tf[zz][belong[bb]]--;\n\t\t\tzd[b[aa]] = bb;\n\t\t\tzd[b[bb]] = aa;\n\t\t\tswap(b[aa], b[bb]);\n\t\t\top = id[b[aa]], zz = belong[op];\n\t\t\tf[zz][belong[aa]]++;\n\t\t\top = id[b[bb]], zz = belong[op];\n\t\t\tf[zz][belong[bb]]++;\n\t\t\taa = belong[aa], bb = belong[bb];\n\t\t\tfor(int i = 1; i <= belong[n]; i++) sum[i][aa] = sum[i - 1][aa] + f[i][aa], sum[i][bb] = sum[i - 1][bb] + f[i][bb];\n\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "fixed_code": "/*\n*/\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cmath>\n#define M 1003\n#define N 201000\n#define ll long long\nusing namespace std;\n\nint read() {\n\tint nm = 0, f = 1;\n\tchar c = getchar();\n\tfor(; !isdigit(c); c = getchar()) if(c == '-') f = -1;\n\tfor(; isdigit(c); c = getchar()) nm = nm * 10 + c - '0';\n\treturn nm * f;\n}\nll f[M][M], sum[M][M];\nint a[N], b[N];\nint belong[N];\nint id[N], zd[N];\nint n, m, biao;\nint ln[M], rn[M];\nset<int> st;\n\nint sta[M], tp;\nint main() {\n\t//freopen(\".in\", \"r\", stdin), freopen(\".out\", \"w\", stdout);\n\tn = read(), m = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read(), id[a[i]] = i;\n\tfor(int i = 1; i <= n; i++) b[i] = read(), zd[b[i]] = i;\n\tif(n <= -300) {\n\t\tfor(int i = 1; i <= m; i++) {\n\t\t\tint op = read();\n\t\t\tif(op == 1) {\n\t\t\t\tint aa = read(), bb = read(), c = read(), d = read();\n\t\t\t\tst.clear();\n\t\t\t\tfor(int j = aa; j <= bb; j++) st.insert(a[j]);\n\t\t\t\tint ans = 0;\n\t\t\t\tfor(int j = c; j <= d; j++) if(st.find(b[j]) != st.end()) ans++;\n\t\t\t\tcout << ans << \"\\n\";\n\t\t\t} else {\n\t\t\t\tint aa = read(), bb = read();\n\t\t\t\tswap(b[aa], b[bb]);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbiao = sqrt(n);\n\tfor(int i = 1; i < M; i++) ln[i] = 0x3e3e3e3e, rn[i] = 0;\n\tfor(int i = 1; i <= n; i++) belong[i] = (i - 1) / biao + 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tint op = id[b[i]];\n\t\tint zz = belong[op];\n\t\tf[zz][belong[i]]++;\n\t}\n\tfor(int i = 1; i <= belong[n]; i++) {\n\t\tfor(int j = 1; j <= belong[n]; j++) {\n\t\t\tsum[i][j] = sum[i - 1][j] + f[i][j];\n\t\t}\n\t}\n\twhile(m--) {\n\t\tint op = read();\n\t\tint ans = 0;\n\t\tif(op == 1) {\n\t\t\tint aa = read(), bb = read(), c = read(), d = read();\n\t\t\tfor(int i = aa; i <= min(belong[aa] * biao, bb); i++) {\n\t\t\t\tif(zd[a[i]] >= c && zd[a[i]] <= d) ans++;\n\t\t\t}\n\t\t\tif(belong[aa] != belong[bb]) {\n\t\t\t\tfor(int i = (belong[bb] - 1) * biao + 1; i <= bb; i++)\n\t\t\t\t\tif(zd[a[i]] >= c && zd[a[i]] <= d) ans++;\n\t\t\t}\n\t\t\tint ln = belong[aa], rn = belong[bb] - 1;\n\n\t\t\tfor(int i = c; i <= min(belong[c] * biao, d); i++) if(id[b[i]] >= belong[aa] * biao + 1 && id[b[i]] <= (belong[bb] - 1) * biao) ans++;\n\t\t\tif(belong[c] != belong[d]) {\n\t\t\t\tfor(int i = (belong[d] - 1) * biao + 1; i <= d; i++)\n\t\t\t\t\tif(id[b[i]] >= belong[aa] * biao + 1 && id[b[i]] <= (belong[bb] - 1) * biao) ans++;\n\t\t\t}\n\t\t\tif(ln <= rn) for(int i = belong[c] + 1; i <= belong[d] - 1; i++) ans += sum[rn][i] - sum[ln][i];\n\t\t\tcout << ans << \"\\n\";\n\t\t} else {\n\t\t\tint aa = read(), bb = read();\n\t\t\tint op = id[b[aa]], zz = belong[op];\n\t\t\tf[zz][belong[aa]]--;\n\t\t\top = id[b[bb]], zz = belong[op];\n\t\t\tf[zz][belong[bb]]--;\n\t\t\tzd[b[aa]] = bb;\n\t\t\tzd[b[bb]] = aa;\n\t\t\tswap(b[aa], b[bb]);\n\t\t\top = id[b[aa]], zz = belong[op];\n\t\t\tf[zz][belong[aa]]++;\n\t\t\top = id[b[bb]], zz = belong[op];\n\t\t\tf[zz][belong[bb]]++;\n\t\t\taa = belong[aa], bb = belong[bb];\n\t\t\tfor(int i = 1; i <= belong[n]; i++) sum[i][aa] = sum[i - 1][aa] + f[i][aa], sum[i][bb] = sum[i - 1][bb] + f[i][bb];\n\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<fstream>\n#include<string>\n#include<vector>\n#include<iostream>\n#include <algorithm>\nusing namespace std;\ntypedef  long long ll;\n\nvector<ll> primes(ll n){\n    vector<bool> prime(n+1);\n    prime[0]=false;\n    prime[1]=false;\n    for (ll i=2;i<=n;i++){\n        prime[i]=true;\n    }\n    for (ll i=2;i<=sqrt(n);i++){\n        if (prime[i]){\n            for (ll j=2;j*i<=n;j++){\n                prime[i*j]=false;\n            }\n        }\n    }\n    vector<ll> prim;\n    for (ll i=2;i<=n;i++){\n        if (prime[i]) prim.push_back(i);\n    }\n    return(prim);\n}\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<ll> Strength (n);\n    for (ll i=0;i<n;i++){\n        cin>>Strength[i];\n    }\n    ll rec=0;\n    for (ll i=0;i<n;i++){\n        if (Strength[i]==1){\n            rec=1;\n        }\n    }\n    vector<ll> V=primes(40000);\n    for (ll t=0;t<V.size();t++){\n        ll att=0;\n        for (ll i=0;i<n;i++){\n            if ((Strength[i]%V[t])==0){\n                att++;\n            }\n        }\n        if (att>rec){\n            rec=att;\n        }\n    }\n    cout<<rec;\n    return 0;\n}\n",
        "fixed_code": "#include<fstream>\n#include<string>\n#include<vector>\n#include<iostream>\n#include <algorithm>\nusing namespace std;\ntypedef  long long ll;\n\n\n\nint main(){\n    ll n;\n    ll big = 0;\n    cin>>n;\n    vector<ll> cnt (123456);\n    for (ll i=0;i<n;i++){\n        ll t;\n        cin>>t;\n        big = max(t, big);\n        cnt[t]++;\n    }\n\n    ll rec=1;\n    vector<bool> pokeys (123456,true);\n    pokeys[0] = pokeys[1] = false;\n    for(ll i = 2; i <= big; i++){\n        if(pokeys[i]){\n            ll att = 0;\n            for(ll j=i; j<=big; j+=i){\n                att+=cnt[j];\n                pokeys[j] = false;\n            }\n            rec=max(att,rec);\n        }\n    }\n    cout<<rec;\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "@dagger.Provides\n@javax.inject.Singleton\npublic org.openhab.domain.INotificationReplyHandler provideNotificationReplyHandlerProvider(org.openhab.habclient.notification.NotificationReplyHandler notificationReplyHandler) {\n    return notificationReplyHandler;\n}",
        "fixed_code": "@dagger.Provides\n@javax.inject.Singleton\npublic org.openhab.domain.INotificationReplyHandler provideNotificationReplyHandler(org.openhab.habclient.notification.NotificationReplyHandler notificationReplyHandler) {\n    return notificationReplyHandler;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint ans(long long int a[], long long int size, long long int k)\n{\n\n    if(k==size)\n        return 0;\n    return a[k]*(k+2)+ans(a,size,k+1);\n}\n\nint main()\n{\n    long long int n,answer=0;\n    long long int d[300005]={};\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>d[i];\n    sort(d,d+n);\n   /* for(int i=0;i<n;i++)\n    {\n        ans=ans+d[i]*(i+2);\n    }  */\n    answer = ans(d,n,0)-d[n-1];\n\n    cout<<\" \"<<answer<<\" \" ;\n    return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n/*int answer(long long int a[], long long int size, long long int k)\n{\n\n    if(k==size)\n        return 0;\n    return a[k]*(k+2)+ans(a,size,k+1);\n}*/\n\nint main()\n{\n    long long int n,ans=0;\n    long long int d[300005]={0};\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>d[i];\n    sort(d,d+n);\n   for(int i=0;i<n;i++)\n    {\n        ans=ans+d[i]*(i+2);\n    }  \n    ans -=d[n-1];\n\n    cout<<\" \"<<ans<<\" \" ;\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <locale>\nusing namespace std;\n#define MS0(I) memset(I, 0, sizeof(I));\n#define MS1(I) memset(I, -1, sizeof(I));\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, s, n) for(int i = (s); i < (n); ++i)\n#define per1(i, a, b) for(int i = a; i >= b; --i)\n#define DRI(A) int A; scanf(\"%d\", &A);\n#define DRII(A, B) int A, B; scanf(\"%d %d\", &A, &B);\n#define DRIII(A, B, C) int A, B, C; scanf(\"%d %d %d\", &A, &B, &C);\n#define SZ(X) ((int)X.size() )\n#define MP make_pair \n#define pb push_back\n#define F first\n#define S second\n#define ALL(I) (I).begin(), (I).end()\ntypedef const void CV;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII; \nconst double eps = 1e-12;\nconst double PI = acos(-1);\nconst LL INFF = (LL)1e18;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9+7;\nconst int MAX = (int)1e6+7;\nvector<int>edge[MAX];\nint n, k;\nint siz[MAX];\nLL cnt[7][MAX], w[MAX], tw[MAX];\nLL ans;\nLL buf[7][MAX];\nvoid dfs(int u, int pa){\n\tsiz[u] = 1;\n\tw[u] = 1;\n\tfor(int v : edge[u]){\n\t\tif(v == pa) continue;\n\t\tdfs(v, u);\n\t\tsiz[u] += siz[v];\n\t\trep(i, k){\n\t\t\tbuf[i+1][u] += cnt[i+1][v];\n\t\t\tif(!i) cnt[1][u] += cnt[k][v];\n\t\t\telse cnt[i+1][u] += cnt[i][v];\n\t\t}\n\t\ttw[u] += w[v];\n\t\tw[u] += w[v] + cnt[k][v];\n\t\tans += w[v];\n\t}\n\tLL val = 0;\n\tfor(int v : edge[u]){\n\t\tif(v == pa) continue;\n\t\tLL tmp = 0;\n\t\trep1(i, 1, k+1) rep1(j, 1, k+1){\n\t\t\tint t = (i+j-1)/k;\n\t\t\ttmp += ((buf[i][u] - cnt[i][v])*cnt[j][v]*t);\n\t\t}\n\t\tval += ((tw[u] - w[v])*(w[v]) + tmp);\n\t}\n\tval >>= 1;\n\tans += val;\n\tcnt[1][u]++;\n\treturn ;\n}\nvoid init(){\n\tscanf(\"%d %d\", &n, &k);\n\trep(i, n-1){\n\t\tDRII(u, v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn ;\n}\nint main(void){\n\tinit();\n\treturn 0;\n}\n",
        "fixed_code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <locale>\nusing namespace std;\n#define MS0(I) memset(I, 0, sizeof(I));\n#define MS1(I) memset(I, -1, sizeof(I));\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, s, n) for(int i = (s); i < (n); ++i)\n#define per1(i, a, b) for(int i = a; i >= b; --i)\n#define DRI(A) int A; scanf(\"%d\", &A);\n#define DRII(A, B) int A, B; scanf(\"%d %d\", &A, &B);\n#define DRIII(A, B, C) int A, B, C; scanf(\"%d %d %d\", &A, &B, &C);\n#define SZ(X) ((int)X.size() )\n#define MP make_pair \n#define pb push_back\n#define F first\n#define S second\n#define ALL(I) (I).begin(), (I).end()\ntypedef const void CV;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII; \nconst double eps = 1e-12;\nconst double PI = acos(-1);\nconst LL INFF = (LL)1e18;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9+7;\nconst int MAX = (int)1e6+7;\nvector<int>edge[MAX];\nint n, k;\nint siz[MAX];\nLL cnt[7][MAX], w[MAX], tw[MAX];\nLL ans;\nLL buf[7][MAX];\nvoid dfs(int u, int pa){\n\tsiz[u] = 1;\n\tw[u] = 1;\n\tfor(int v : edge[u]){\n\t\tif(v == pa) continue;\n\t\tdfs(v, u);\n\t\tsiz[u] += siz[v];\n\t\trep(i, k){\n\t\t\tbuf[i+1][u] += cnt[i+1][v];\n\t\t\tif(!i) cnt[1][u] += cnt[k][v];\n\t\t\telse cnt[i+1][u] += cnt[i][v];\n\t\t}\n\t\ttw[u] += w[v];\n\t\tw[u] += w[v] + cnt[k][v];\n\t\tans += w[v];\n\t}\n\tLL val = 0, val2 = 0;\n\tfor(int v : edge[u]){\n\t\tif(v == pa) continue;\n\t\trep1(i, 1, k+1) rep1(j, 1, k+1){\n\t\t\tint t = 0;\n\t\t\tif(i + j <= k) t = -1;\n\t\t\tval2 += ((buf[i][u] - cnt[i][v])*cnt[j][v]*t);\n\t\t}\n\t\tval += (siz[u] - siz[v] - 1)*(w[v]);\n\t}\n\tval += val2 / 2;\n\tans += val;\n\tcnt[1][u]++;\n\treturn ;\n}\nvoid init(){\n\tscanf(\"%d %d\", &n, &k);\n\trep(i, n-1){\n\t\tDRII(u, v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn ;\n}\nint main(void){\n\tinit();\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\r\n#include<stdio.h>\r\n#include <sstream>\r\n#include <cstdio>\r\n#include<fstream>\r\n#include<algorithm>\r\n#include<vector>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <numeric> \r\n#include <vector>\r\n#include<unordered_map>\r\n#include <stdio.h>  \r\n#include <string.h> \r\n#include <math.h>\r\nusing namespace std;\r\n#define ll long long \r\n#define ld long double \r\n#define vbe(v) ((v).begin()), ((v).end())\r\n#define lp(i, n)    for(int i=0;i<(int)(n);++i)\r\n#define lpi(i, j, n)  for(int i=(j);i<(int)(n);++i)\r\n#define lpd(i, j, n)  for(int i=(j);i>=(int)(n);--i)\r\nll GCD(ll a, ll b) { return (a) ? GCD(b % a, a) : b; }\r\nll LCM(ll a, ll b) { return a * b / GCD(a, b); }\r\nll fastpow(ll b, ll p) { if (!p) return 1; ll ret = fastpow(b, p >> 1); ret *= ret; if (p & 1) ret *= b; return ret; }\r\nstring alpha = \"abcdefghijklmnopqrstuvwxyz\";\r\nint divisor(int number)\r\n{\r\n    int i;\r\n    for (i = 2; i <= sqrt(number); i++)\r\n    {\r\n        if (number % i == 0)\r\n        {\r\n            return number / i;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\nint myXOR(int x, int y)\r\n{\r\n    int res = 0; // Initialize result \r\n\r\n    // Assuming 32-bit Integer  \r\n    for (int i = 31; i >= 0; i--)\r\n    {\r\n        // Find current bits in x and y \r\n        bool b1 = x & (1 << i);\r\n        bool b2 = y & (1 << i);\r\n\r\n        // If both are 1 then 0 else xor is same as OR \r\n        bool xoredBit = (b1 & b2) ? 0 : (b1 | b2);\r\n\r\n        // Update result \r\n        res <<= 1;\r\n        res |= xoredBit;\r\n    }\r\n    return res;\r\n}\r\n//std::getline(std::cin, a); //read string with spaces\r\nvoid printDivisors(int n, vector<int>& v)\r\n{\r\n    // Note that this loop runs till square root \r\n    for (int i = 1; i <= sqrt(n); i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            // If divisors are equal, print only one \r\n            if (n / i == i && i > 1)\r\n                v.push_back(i);\r\n\r\n            else // Otherwise print both \r\n            {\r\n                if (i > 1)\r\n                    v.push_back(i);\r\n                if (n / i > 1)\r\n                    v.push_back(n / i);\r\n            }\r\n        }\r\n    }\r\n}\r\nint bin(vector<int>vec, int val)\r\n{\r\n    int l = 0, r = vec.size() - 1, mid = r / 2;\r\n    while (l <= r)\r\n    {\r\n        mid = (l + r) / 2;\r\n\r\n        if (vec[mid]<val && vec[mid + 1]>val)\r\n        {\r\n            if (vec[mid + 1] == val)\r\n                return mid + 1;\r\n            return mid;\r\n\r\n        }\r\n        else if (vec[mid] > val)\r\n        {\r\n            r = mid - 1;\r\n        }\r\n        else if (vec[mid] < val)\r\n        {\r\n            l = mid + 1;\r\n        }\r\n        else if (vec[mid] == val)\r\n            return mid;\r\n\r\n\r\n    }\r\n    return -1;\r\n}\r\nvoid clear(vector<bool>v)\r\n{\r\n    for (int i = 0; i < v.size(); i++)\r\n        v[i] = 0;\r\n}\r\n\r\nbool comp(const string& s1, const string& s2)\r\n{\r\n    // Suppose s1 = 900, s2 = 9, then it compares\r\n    // 9900 with 9009.\r\n    return s2 + s1 < s1 + s2;\r\n}\r\nvector<string> split(const string& s, char delim) {\r\n    vector<string> result;\r\n    stringstream ss(s);\r\n    string item;\r\n\r\n    while (getline(ss, item, delim)) {\r\n        result.push_back(item);\r\n    }\r\n\r\n    return result;\r\n}\r\nint countWords(string str)\r\n{\r\n    // breaking input into word using string stream \r\n    stringstream s(str); // Used for breaking words \r\n    string word; // to store individual words \r\n\r\n    int count = 0;\r\n    while (s >> word)\r\n        count++;\r\n    return count;\r\n}\r\nll power(ll x, ll y, ll p, int& c)\r\n{\r\n    int res = 1;     // Initialize result  \r\n    if (x >= p)\r\n        c++;\r\n    x = x % p; // Update x if it is more than or  \r\n                // equal to p \r\n\r\n    if (x == 0) return 0; // In case x is divisible by p; \r\n\r\n    while (y > 0)\r\n    {\r\n        // If y is odd, multiply x with result  \r\n        if (y & 1)\r\n        {\r\n            if (res * x >= p)\r\n                c++;\r\n            res = (res * x) % p;\r\n        }\r\n\r\n        // y must be even now  \r\n        y = y >> 1; // y = y/2  \r\n        if (x * x >= p)\r\n            c++;\r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\nbool isPalindrome(string str)\r\n{\r\n    // Start from leftmost and rightmost corners of str \r\n    int l = 0;\r\n    int h = str.length() - 1;\r\n\r\n    // Keep comparing characters while they are same \r\n    while (h > l)\r\n    {\r\n        if (str[l++] != str[h--])\r\n        {\r\n\r\n            return 0;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\nbool checkMuns(vector<int>vec)\r\n{\r\n    lp(i, vec.size())\r\n    {\r\n        if (vec[i] < 0)\r\n            return 0;\r\n    }\r\n    return 1;\r\n}\r\n\r\nll power(ll x, ll y, ll p)\r\n{\r\n    ll res = 1;     // Initialize result  \r\n\r\n    x = x % p; // Update x if it is more than or  \r\n                // equal to p \r\n\r\n    if (x == 0) return 0; // In case x is divisible by p; \r\n\r\n    while (y > 0)\r\n    {\r\n        // If y is odd, multiply x with result  \r\n        if (y & 1)\r\n            res = (res * x) % p;\r\n\r\n        // y must be even now  \r\n        y = y >> 1; // y = y/2  \r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\nll ceiLl(ll x, ll y)\r\n{\r\n    return (x + y - 1) / y;\r\n}\r\nvector<ll> divisors(ll n)\r\n{\r\n    vector<ll>ans;\r\n    ll i = 1;\r\n    for (; i * i < n; i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            ans.push_back(i);\r\n            ans.push_back(n / i);\r\n        }\r\n    }\r\n    if (i * i == n)\r\n        ans.push_back(i);\r\n    return ans;\r\n}\r\nvector<ll> findDivisors(ll n)//form 1 to n\r\n{\r\n\r\n    // Array to store the count \r\n    // of divisors \r\n    if (n == 1)\r\n        return vector<ll>(1, 0);\r\n    vector<ll> numFactors(n + 1);\r\n\r\n    // For every number from 1 to n \r\n    for (int i = 1; i <= n; i++) {\r\n\r\n        // Increase divisors count for \r\n        // every number divisible by i \r\n        for (int j = 1; j * i <= n; j++)\r\n            numFactors[i * j]++;\r\n    }\r\n\r\n    return numFactors;\r\n}\r\nvector<ll> factorization(ll n) //\t max n is 1e12\r\n{\t //O(sqrt(n))\r\n\r\n    vector<ll> primes;\r\n\r\n    for (ll i = 2; i * i <= n; ++i)\t// Improve start by i = 3.\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n\r\n            primes.push_back(i);\r\n            while (n % i == 0)\r\n            {\r\n                n /= i;\r\n            }\r\n        } //Get every prime inside n.n  i^ j\tis a new number\r\n    }\r\n    if (n > 1)\r\n        primes.push_back(n);\r\n\r\n    return primes;\r\n}\r\nbool isSubSeq(string a, string b)\r\n{\r\n    int idx = 0;\r\n    for (int i = 0; i < a.length(); i++)\r\n    {\r\n        if (a[i] == b[idx])\r\n            idx++;\r\n    }\r\n    if (idx == b.length())\r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\nbool isSubSeq(vector<int> a, vector<int> b)\r\n{\r\n    int idx = 0;\r\n    for (int i = 0; i < a.size(); i++)\r\n    {\r\n        if (b.size() == idx) break;\r\n        if (a[i] == b[idx])\r\n            idx++;\r\n    }\r\n    if (idx == b.size())\r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\nbool isSubStr(string a, string b)\r\n{\r\n\r\n    for (int i = 0; i < a.length(); i++)\r\n    {\r\n        if (a.substr(i, b.length()) == b)\r\n            return 1;\r\n    }\r\n    return 0;\r\n}\r\nbool sortbysec(const pair<int, int>& a,\r\n    const pair<int, int>& b)\r\n{\r\n    return (a.second < b.second);\r\n}\r\nbool isEqual(string a, string b)\r\n{\r\n    if (a.size() != b.size())\r\n        return 0;\r\n    sort(vbe(a)); sort(vbe(b));\r\n    if (a == b)\r\n        return 1;\r\n    return 0;\r\n}\r\nstring bin(unsigned n)\r\n{\r\n    string ans = \"\";\r\n    unsigned i;\r\n    for (i = 1 << 20; i > 0; i = i / 2)\r\n        (n & i) ? ans += '1' : ans += '0';\r\n    return ans;\r\n}\r\nstring leftrotate(string a, int d)\r\n{\r\n    string s = a;\r\n    reverse(s.begin(), s.begin() + d);\r\n    reverse(s.begin() + d, s.end());\r\n    reverse(s.begin(), s.end());\r\n    return s;\r\n}\r\n\r\n// In-place rotates s towards right by d\r\nstring rightrotate(string a, int d)\r\n{\r\n    string s = a;\r\n    return leftrotate(s, s.length() - d);\r\n\r\n}\r\nint gcd(int a, int b)\r\n{\r\n    if (b == 0)\r\n        return a;\r\n    return gcd(b, a % b);\r\n}\r\nll findlcm(vector<ll> arr, int n)\r\n{\r\n    // Initialize result \r\n    ll ans = arr[0];\r\n\r\n    // ans contains LCM of arr[0], ..arr[i] \r\n    // after i'th iteration, \r\n    for (int i = 1; i < n; i++)\r\n        ans = (((arr[i] * ans)) /\r\n            (gcd(arr[i], ans)));\r\n\r\n    return ans;\r\n}\r\nint modInverse(int a, int m)\r\n{\r\n    a = a % m;\r\n    for (int x = 1; x < m; x++)\r\n        if ((a * x) % m == 1)\r\n            return x;\r\n}\r\n\r\n\r\n// Function to find gcd of array of \r\n// numbers \r\nll findGCD(vector<ll>arr)\r\n{\r\n    int n = arr.size();\r\n    ll result = arr[0];\r\n    for (int i = 1; i < n; i++)\r\n    {\r\n        result = gcd(arr[i], result);\r\n\r\n        if (result == 1)\r\n        {\r\n            return 1;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nll countDivisors(ll n)\r\n{\r\n    ll cnt = 0;\r\n    for (int i = 1; i <= sqrt(n); i++) {\r\n        if (n % i == 0) {\r\n            // If divisors are equal, \r\n            // count only one \r\n            if (n / i == i)\r\n                cnt++;\r\n\r\n            else // Otherwise count both \r\n                cnt = cnt + 2;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\nbool isPrime(ll n)\r\n{\r\n    // Corner case \r\n    if (n <= 1)\r\n        return false;\r\n\r\n    // Check from 2 to n-1 \r\n    for (ll i = 2; i * i <= n; i++)\r\n        if (n % i == 0)\r\n            return false;\r\n\r\n    return true;\r\n}\r\nbool arePair(char L, char R)\r\n{\r\n    if (L == '(' && R == ')')\r\n        return 1;\r\n    else if (L == '{' && R == '}')\r\n        return 1;\r\n    else if (L == '[' && R == ']')\r\n        return 1;\r\n    else if (L == '<' && R == '>')\r\n        return 1;\r\n    return 0;\r\n}\r\nint areBalanced(string e)\r\n{\r\n    stack<char>s;\r\n    int zz = 0;\r\n    for (int i = 0; i < e.length(); i++)\r\n    {\r\n        if (e[i] == '(' || e[i] == '[' || e[i] == '{' || e[i] == '<')\r\n            s.push(e[i]);\r\n        else if (e[i] == ')' || e[i] == ']' || e[i] == '}' || e[i] == '>')\r\n        {\r\n            if (s.empty() || !arePair(s.top(), e[i]))\r\n                zz++;\r\n            else\r\n                s.pop();\r\n        }\r\n    }\r\n    return zz + s.size();\r\n}\r\n\r\n\r\nbool sortbyssec1(const pair<int, int>& a,\r\n    const pair<int, int>& b)\r\n{\r\n    if (a.first < b.first)\r\n        return 1;\r\n\r\n    if (a.first == b.first && a.second > b.second)\r\n        return 1;\r\n    return 0;\r\n}\r\nbool sortbyt(const pair<int, int>& a,\r\n    const pair<int, int>& b)\r\n{\r\n    if (a.first < b.first)\r\n        return 1;\r\n    else if (a.first == b.first && a.second > b.second)\r\n        return 1;\r\n    return 0;\r\n}\r\nll bs() {\r\n\r\n    ll lw = 0, hi = 0, mid;\r\n    ll be = 0;\r\n    while (lw < hi) {\r\n        mid = 1 + lw + (hi - lw) / 2;\r\n\r\n        if (1)\r\n            lw = mid;\r\n        else\r\n            hi = mid - 1;\r\n    }\r\n    return lw;\r\n}\r\nstruct abass\r\n{\r\n    int a, b;\r\n    abass(int A, int B)\r\n    {\r\n        a = A;\tb = B;\r\n    }\r\n    bool operator < (const abass& ga) const\r\n    {\r\n        if (b / a < ga.b / ga.a)\r\n            return 1;\r\n        return 0;\r\n    }\r\n};\r\nll nCr(int n, int r)\r\n{\r\n\r\n    long long p = 1, k = 1;\r\n    if (n < r) return 0;\r\n    if (n - r < r)\r\n        r = n - r;\r\n\r\n    if (r != 0) {\r\n        while (r) {\r\n            p *= n;\r\n            k *= r;\r\n            long long m = GCD(p, k);\r\n            p /= m;\r\n            k /= m;\r\n\r\n            n--;\r\n            r--;\r\n        }\r\n    }\r\n\r\n    else\r\n        p = 1;\r\n    return p;\r\n}\r\n\r\nll fun(ll x, ll y, ll num, ll sum) {\r\n    ll tmp = 0;\r\n    if (x > num)tmp += (x - num);\r\n    if (y > (sum - num))tmp += (y - (sum - num));\r\n    return tmp;\r\n}\r\nll fun1(ll x, ll y, ll num, ll sum) {\r\n    ll tmp = 0;\r\n    if (x > num)tmp += (x - num);\r\n    if (y > (sum))tmp += (y - (sum));\r\n    return tmp;\r\n}\r\nvector<ll>vec;\r\nset<ll>se;\r\nll sum;\r\nbool ok(ll mid, ll x, ll y) {\r\n   \r\n    auto tmp1 = se.lower_bound(x - mid);\r\n    if (tmp1 == se.end())return 0;\r\n    if (*tmp1 < x - mid)return 0;\r\n    //we change tmp1 to tmp1+mid\r\n    ll res = 0;\r\n    ll need = x - *tmp1;\r\n    if (need <= 0)res = mid;\r\n    else {\r\n        res = mid - need;\r\n    }\r\n    if (res < 0)return 0;\r\n   // res = max(res, 0LL);\r\n    ll s = sum + res - *tmp1;\r\n    if ( s >= y)return 1;\r\n    return 0;\r\n}\r\nint main()\r\n{\r\n\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    int tt = 1;\r\n    //  cin >> tt;\r\n\r\n    while (tt--)\r\n    {\r\n        ll n;\r\n        cin >> n;\r\n        vec.resize(n);\r\n        sum = 0;\r\n        lp(i, n) {\r\n\r\n            cin >> vec[i];\r\n            sum += vec[i];\r\n            se.insert(vec[i]);\r\n        }\r\n        ll m;\r\n        cin >> m;\r\n        lp(i, m) {\r\n            ll x, y;\r\n            cin >> x >> y;\r\n            ll l = 0, r = 1e18;\r\n            ll ans = -1;\r\n            while (l <= r) {\r\n                ll mid = l + (r - l) / 2;\r\n                if (ok(mid,x,y)) {\r\n                    ans = mid;\r\n                    r = mid - 1;\r\n                }\r\n                else l = mid + 1;\r\n            }\r\n            cout << ans<<\"\\n\";\r\n          \r\n        }\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n/*\r\n\r\n    -9 -2 2 3 4\r\n    std::cout << std::fixed;\r\n    std::cout << std::setprecision(12);\r\n*/",
        "fixed_code": "#include<iostream>\r\n#include<stdio.h>\r\n#include <sstream>\r\n#include <cstdio>\r\n#include<fstream>\r\n#include<algorithm>\r\n#include<vector>\r\n#include <bitset>\r\n#include <complex>\r\n#include <deque>\r\n#include <exception>\r\n#include <fstream>\r\n#include <functional>\r\n#include <iomanip>\r\n#include <ios>\r\n#include <iosfwd>\r\n#include <iostream>\r\n#include <istream>\r\n#include <iterator>\r\n#include <limits>\r\n#include <list>\r\n#include <locale>\r\n#include <map>\r\n#include <memory>\r\n#include <new>\r\n#include <numeric>\r\n#include <ostream>\r\n#include <queue>\r\n#include <set>\r\n#include <sstream>\r\n#include <stack>\r\n#include <stdexcept>\r\n#include <streambuf>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <utility>\r\n#include <valarray>\r\n#include <numeric> \r\n#include <vector>\r\n#include<unordered_map>\r\n#include <stdio.h>  \r\n#include <string.h> \r\n#include <math.h>\r\nusing namespace std;\r\n#define ll long long \r\n#define ld long double \r\n#define vbe(v) ((v).begin()), ((v).end())\r\n#define lp(i, n)    for(int i=0;i<(int)(n);++i)\r\n#define lpi(i, j, n)  for(int i=(j);i<(int)(n);++i)\r\n#define lpd(i, j, n)  for(int i=(j);i>=(int)(n);--i)\r\nll GCD(ll a, ll b) { return (a) ? GCD(b % a, a) : b; }\r\nll LCM(ll a, ll b) { return a * b / GCD(a, b); }\r\nll fastpow(ll b, ll p) { if (!p) return 1; ll ret = fastpow(b, p >> 1); ret *= ret; if (p & 1) ret *= b; return ret; }\r\nstring alpha = \"abcdefghijklmnopqrstuvwxyz\";\r\nint divisor(int number)\r\n{\r\n    int i;\r\n    for (i = 2; i <= sqrt(number); i++)\r\n    {\r\n        if (number % i == 0)\r\n        {\r\n            return number / i;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\nint myXOR(int x, int y)\r\n{\r\n    int res = 0; // Initialize result \r\n\r\n    // Assuming 32-bit Integer  \r\n    for (int i = 31; i >= 0; i--)\r\n    {\r\n        // Find current bits in x and y \r\n        bool b1 = x & (1 << i);\r\n        bool b2 = y & (1 << i);\r\n\r\n        // If both are 1 then 0 else xor is same as OR \r\n        bool xoredBit = (b1 & b2) ? 0 : (b1 | b2);\r\n\r\n        // Update result \r\n        res <<= 1;\r\n        res |= xoredBit;\r\n    }\r\n    return res;\r\n}\r\n//std::getline(std::cin, a); //read string with spaces\r\nvoid printDivisors(int n, vector<int>& v)\r\n{\r\n    // Note that this loop runs till square root \r\n    for (int i = 1; i <= sqrt(n); i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            // If divisors are equal, print only one \r\n            if (n / i == i && i > 1)\r\n                v.push_back(i);\r\n\r\n            else // Otherwise print both \r\n            {\r\n                if (i > 1)\r\n                    v.push_back(i);\r\n                if (n / i > 1)\r\n                    v.push_back(n / i);\r\n            }\r\n        }\r\n    }\r\n}\r\nint bin(vector<int>vec, int val)\r\n{\r\n    int l = 0, r = vec.size() - 1, mid = r / 2;\r\n    while (l <= r)\r\n    {\r\n        mid = (l + r) / 2;\r\n\r\n        if (vec[mid]<val && vec[mid + 1]>val)\r\n        {\r\n            if (vec[mid + 1] == val)\r\n                return mid + 1;\r\n            return mid;\r\n\r\n        }\r\n        else if (vec[mid] > val)\r\n        {\r\n            r = mid - 1;\r\n        }\r\n        else if (vec[mid] < val)\r\n        {\r\n            l = mid + 1;\r\n        }\r\n        else if (vec[mid] == val)\r\n            return mid;\r\n\r\n\r\n    }\r\n    return -1;\r\n}\r\nvoid clear(vector<bool>v)\r\n{\r\n    for (int i = 0; i < v.size(); i++)\r\n        v[i] = 0;\r\n}\r\n\r\nbool comp(const string& s1, const string& s2)\r\n{\r\n    // Suppose s1 = 900, s2 = 9, then it compares\r\n    // 9900 with 9009.\r\n    return s2 + s1 < s1 + s2;\r\n}\r\nvector<string> split(const string& s, char delim) {\r\n    vector<string> result;\r\n    stringstream ss(s);\r\n    string item;\r\n\r\n    while (getline(ss, item, delim)) {\r\n        result.push_back(item);\r\n    }\r\n\r\n    return result;\r\n}\r\nint countWords(string str)\r\n{\r\n    // breaking input into word using string stream \r\n    stringstream s(str); // Used for breaking words \r\n    string word; // to store individual words \r\n\r\n    int count = 0;\r\n    while (s >> word)\r\n        count++;\r\n    return count;\r\n}\r\nll power(ll x, ll y, ll p, int& c)\r\n{\r\n    int res = 1;     // Initialize result  \r\n    if (x >= p)\r\n        c++;\r\n    x = x % p; // Update x if it is more than or  \r\n                // equal to p \r\n\r\n    if (x == 0) return 0; // In case x is divisible by p; \r\n\r\n    while (y > 0)\r\n    {\r\n        // If y is odd, multiply x with result  \r\n        if (y & 1)\r\n        {\r\n            if (res * x >= p)\r\n                c++;\r\n            res = (res * x) % p;\r\n        }\r\n\r\n        // y must be even now  \r\n        y = y >> 1; // y = y/2  \r\n        if (x * x >= p)\r\n            c++;\r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\nbool isPalindrome(string str)\r\n{\r\n    // Start from leftmost and rightmost corners of str \r\n    int l = 0;\r\n    int h = str.length() - 1;\r\n\r\n    // Keep comparing characters while they are same \r\n    while (h > l)\r\n    {\r\n        if (str[l++] != str[h--])\r\n        {\r\n\r\n            return 0;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\nbool checkMuns(vector<int>vec)\r\n{\r\n    lp(i, vec.size())\r\n    {\r\n        if (vec[i] < 0)\r\n            return 0;\r\n    }\r\n    return 1;\r\n}\r\n\r\nll power(ll x, ll y, ll p)\r\n{\r\n    ll res = 1;     // Initialize result  \r\n\r\n    x = x % p; // Update x if it is more than or  \r\n                // equal to p \r\n\r\n    if (x == 0) return 0; // In case x is divisible by p; \r\n\r\n    while (y > 0)\r\n    {\r\n        // If y is odd, multiply x with result  \r\n        if (y & 1)\r\n            res = (res * x) % p;\r\n\r\n        // y must be even now  \r\n        y = y >> 1; // y = y/2  \r\n        x = (x * x) % p;\r\n    }\r\n    return res;\r\n}\r\nll ceiLl(ll x, ll y)\r\n{\r\n    return (x + y - 1) / y;\r\n}\r\nvector<ll> divisors(ll n)\r\n{\r\n    vector<ll>ans;\r\n    ll i = 1;\r\n    for (; i * i < n; i++)\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n            ans.push_back(i);\r\n            ans.push_back(n / i);\r\n        }\r\n    }\r\n    if (i * i == n)\r\n        ans.push_back(i);\r\n    return ans;\r\n}\r\nvector<ll> findDivisors(ll n)//form 1 to n\r\n{\r\n\r\n    // Array to store the count \r\n    // of divisors \r\n    if (n == 1)\r\n        return vector<ll>(1, 0);\r\n    vector<ll> numFactors(n + 1);\r\n\r\n    // For every number from 1 to n \r\n    for (int i = 1; i <= n; i++) {\r\n\r\n        // Increase divisors count for \r\n        // every number divisible by i \r\n        for (int j = 1; j * i <= n; j++)\r\n            numFactors[i * j]++;\r\n    }\r\n\r\n    return numFactors;\r\n}\r\nvector<ll> factorization(ll n) //\t max n is 1e12\r\n{\t //O(sqrt(n))\r\n\r\n    vector<ll> primes;\r\n\r\n    for (ll i = 2; i * i <= n; ++i)\t// Improve start by i = 3.\r\n    {\r\n        if (n % i == 0)\r\n        {\r\n\r\n            primes.push_back(i);\r\n            while (n % i == 0)\r\n            {\r\n                n /= i;\r\n            }\r\n        } //Get every prime inside n.n  i^ j\tis a new number\r\n    }\r\n    if (n > 1)\r\n        primes.push_back(n);\r\n\r\n    return primes;\r\n}\r\nbool isSubSeq(string a, string b)\r\n{\r\n    int idx = 0;\r\n    for (int i = 0; i < a.length(); i++)\r\n    {\r\n        if (a[i] == b[idx])\r\n            idx++;\r\n    }\r\n    if (idx == b.length())\r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\nbool isSubSeq(vector<int> a, vector<int> b)\r\n{\r\n    int idx = 0;\r\n    for (int i = 0; i < a.size(); i++)\r\n    {\r\n        if (b.size() == idx) break;\r\n        if (a[i] == b[idx])\r\n            idx++;\r\n    }\r\n    if (idx == b.size())\r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\nbool isSubStr(string a, string b)\r\n{\r\n\r\n    for (int i = 0; i < a.length(); i++)\r\n    {\r\n        if (a.substr(i, b.length()) == b)\r\n            return 1;\r\n    }\r\n    return 0;\r\n}\r\nbool sortbysec(const pair<int, int>& a,\r\n    const pair<int, int>& b)\r\n{\r\n    return (a.second < b.second);\r\n}\r\nbool isEqual(string a, string b)\r\n{\r\n    if (a.size() != b.size())\r\n        return 0;\r\n    sort(vbe(a)); sort(vbe(b));\r\n    if (a == b)\r\n        return 1;\r\n    return 0;\r\n}\r\nstring bin(unsigned n)\r\n{\r\n    string ans = \"\";\r\n    unsigned i;\r\n    for (i = 1 << 20; i > 0; i = i / 2)\r\n        (n & i) ? ans += '1' : ans += '0';\r\n    return ans;\r\n}\r\nstring leftrotate(string a, int d)\r\n{\r\n    string s = a;\r\n    reverse(s.begin(), s.begin() + d);\r\n    reverse(s.begin() + d, s.end());\r\n    reverse(s.begin(), s.end());\r\n    return s;\r\n}\r\n\r\n// In-place rotates s towards right by d\r\nstring rightrotate(string a, int d)\r\n{\r\n    string s = a;\r\n    return leftrotate(s, s.length() - d);\r\n\r\n}\r\nint gcd(int a, int b)\r\n{\r\n    if (b == 0)\r\n        return a;\r\n    return gcd(b, a % b);\r\n}\r\nll findlcm(vector<ll> arr, int n)\r\n{\r\n    // Initialize result \r\n    ll ans = arr[0];\r\n\r\n    // ans contains LCM of arr[0], ..arr[i] \r\n    // after i'th iteration, \r\n    for (int i = 1; i < n; i++)\r\n        ans = (((arr[i] * ans)) /\r\n            (gcd(arr[i], ans)));\r\n\r\n    return ans;\r\n}\r\nint modInverse(int a, int m)\r\n{\r\n    a = a % m;\r\n    for (int x = 1; x < m; x++)\r\n        if ((a * x) % m == 1)\r\n            return x;\r\n}\r\n\r\n\r\n// Function to find gcd of array of \r\n// numbers \r\nll findGCD(vector<ll>arr)\r\n{\r\n    int n = arr.size();\r\n    ll result = arr[0];\r\n    for (int i = 1; i < n; i++)\r\n    {\r\n        result = gcd(arr[i], result);\r\n\r\n        if (result == 1)\r\n        {\r\n            return 1;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nll countDivisors(ll n)\r\n{\r\n    ll cnt = 0;\r\n    for (int i = 1; i <= sqrt(n); i++) {\r\n        if (n % i == 0) {\r\n            // If divisors are equal, \r\n            // count only one \r\n            if (n / i == i)\r\n                cnt++;\r\n\r\n            else // Otherwise count both \r\n                cnt = cnt + 2;\r\n        }\r\n    }\r\n    return cnt;\r\n}\r\nbool isPrime(ll n)\r\n{\r\n    // Corner case \r\n    if (n <= 1)\r\n        return false;\r\n\r\n    // Check from 2 to n-1 \r\n    for (ll i = 2; i * i <= n; i++)\r\n        if (n % i == 0)\r\n            return false;\r\n\r\n    return true;\r\n}\r\nbool arePair(char L, char R)\r\n{\r\n    if (L == '(' && R == ')')\r\n        return 1;\r\n    else if (L == '{' && R == '}')\r\n        return 1;\r\n    else if (L == '[' && R == ']')\r\n        return 1;\r\n    else if (L == '<' && R == '>')\r\n        return 1;\r\n    return 0;\r\n}\r\nint areBalanced(string e)\r\n{\r\n    stack<char>s;\r\n    int zz = 0;\r\n    for (int i = 0; i < e.length(); i++)\r\n    {\r\n        if (e[i] == '(' || e[i] == '[' || e[i] == '{' || e[i] == '<')\r\n            s.push(e[i]);\r\n        else if (e[i] == ')' || e[i] == ']' || e[i] == '}' || e[i] == '>')\r\n        {\r\n            if (s.empty() || !arePair(s.top(), e[i]))\r\n                zz++;\r\n            else\r\n                s.pop();\r\n        }\r\n    }\r\n    return zz + s.size();\r\n}\r\n\r\n\r\nbool sortbyssec1(const pair<int, int>& a,\r\n    const pair<int, int>& b)\r\n{\r\n    if (a.first < b.first)\r\n        return 1;\r\n\r\n    if (a.first == b.first && a.second > b.second)\r\n        return 1;\r\n    return 0;\r\n}\r\nbool sortbyt(const pair<int, int>& a,\r\n    const pair<int, int>& b)\r\n{\r\n    if (a.first < b.first)\r\n        return 1;\r\n    else if (a.first == b.first && a.second > b.second)\r\n        return 1;\r\n    return 0;\r\n}\r\nll bs() {\r\n\r\n    ll lw = 0, hi = 0, mid;\r\n    ll be = 0;\r\n    while (lw < hi) {\r\n        mid = 1 + lw + (hi - lw) / 2;\r\n\r\n        if (1)\r\n            lw = mid;\r\n        else\r\n            hi = mid - 1;\r\n    }\r\n    return lw;\r\n}\r\nstruct abass\r\n{\r\n    int a, b;\r\n    abass(int A, int B)\r\n    {\r\n        a = A;\tb = B;\r\n    }\r\n    bool operator < (const abass& ga) const\r\n    {\r\n        if (b / a < ga.b / ga.a)\r\n            return 1;\r\n        return 0;\r\n    }\r\n};\r\nll nCr(int n, int r)\r\n{\r\n\r\n    long long p = 1, k = 1;\r\n    if (n < r) return 0;\r\n    if (n - r < r)\r\n        r = n - r;\r\n\r\n    if (r != 0) {\r\n        while (r) {\r\n            p *= n;\r\n            k *= r;\r\n            long long m = GCD(p, k);\r\n            p /= m;\r\n            k /= m;\r\n\r\n            n--;\r\n            r--;\r\n        }\r\n    }\r\n\r\n    else\r\n        p = 1;\r\n    return p;\r\n}\r\n\r\nll fun(ll x, ll y, ll num, ll sum) {\r\n    ll tmp = 0;\r\n    if (x > num)tmp += (x - num);\r\n    if (y > (sum - num))tmp += (y - (sum - num));\r\n    return tmp;\r\n}\r\nll fun1(ll x, ll y, ll num, ll sum) {\r\n    ll tmp = 0;\r\n    if (x > num)tmp += (x - num);\r\n    if (y > (sum))tmp += (y - (sum));\r\n    return tmp;\r\n}\r\nvector<ll>vec;\r\nset<ll>se;\r\nll sum;\r\nbool ok(ll mid, ll x, ll y) {\r\n   \r\n    auto tmp1 = se.lower_bound(x - mid);\r\n    if (tmp1 == se.end())return 0;\r\n    //we change tmp1 to tmp1+mid\r\n    ll res = 0;\r\n    ll need = x - *tmp1;\r\n    if (need <= 0)res = mid;\r\n    else {\r\n        res = mid - need;\r\n    }\r\n    if (res < 0)return 0;\r\n   // res = max(res, 0LL);\r\n    ll s = sum + res - *tmp1;\r\n    if ( s >= y)return 1;\r\n    return 0;\r\n}\r\nint main()\r\n{\r\n\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    int tt = 1;\r\n    //  cin >> tt;\r\n\r\n    while (tt--)\r\n    {\r\n        ll n;\r\n        cin >> n;\r\n        vec.resize(n);\r\n        sum = 0;\r\n        lp(i, n) {\r\n            cin >> vec[i];\r\n            sum += vec[i];\r\n            se.insert(vec[i]);\r\n        }\r\n        ll m;\r\n        cin >> m;\r\n        lp(i, m) {\r\n            ll x, y;\r\n            cin >> x >> y;\r\n            ll l = 0, r = 2e18;\r\n            ll ans = -1;\r\n            while (l <= r) {\r\n                ll mid = l + (r - l) / 2;\r\n                if (ok(mid,x,y)) {\r\n                    ans = mid;\r\n                    r = mid - 1;\r\n                }\r\n                else l = mid + 1;\r\n            }\r\n            cout << ans<<\"\\n\";\r\n          \r\n        }\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n/*\r\n\r\n    -9 -2 2 3 4\r\n    std::cout << std::fixed;\r\n    std::cout << std::setprecision(12);\r\n*/",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private java.util.Set<org.mitre.mpf.wfm.data.entities.transients.Track> combine(java.util.Set<org.mitre.mpf.wfm.data.entities.transients.Track> sourceTracks, org.mitre.mpf.wfm.camel.operations.detection.trackmerging.TrackMergingPlan plan, double segMinOverlap) {\n    if (org.apache.commons.collections.CollectionUtils.isEmpty(sourceTracks)) {\n        return sourceTracks;\n    }\n    int minGap = plan.getMinGapBetweenTracks();\n    java.util.List<org.mitre.mpf.wfm.data.entities.transients.Track> tracks = new java.util.LinkedList<org.mitre.mpf.wfm.data.entities.transients.Track>(sourceTracks);\n    java.util.Collections.sort(tracks);\n    java.util.List<org.mitre.mpf.wfm.data.entities.transients.Track> mergedTracks = new java.util.LinkedList<org.mitre.mpf.wfm.data.entities.transients.Track>();\n    while ((tracks.size()) > 0) {\n        org.mitre.mpf.wfm.data.entities.transients.Track merged = tracks.remove(0);\n        boolean performedMerge = false;\n        org.mitre.mpf.wfm.data.entities.transients.Track trackToRemove = null;\n        for (org.mitre.mpf.wfm.data.entities.transients.Track candidate : tracks) {\n            boolean track1BeforeTrack2 = (merged.getEndOffsetFrameInclusive()) < (candidate.getStartOffsetFrameInclusive());\n            boolean trackGapWithinLimit = (merged.getEndOffsetFrameInclusive()) >= (((candidate.getStartOffsetFrameInclusive()) - minGap) + 1);\n            if ((track1BeforeTrack2 && trackGapWithinLimit) && (intersects(merged, candidate, segMinOverlap))) {\n                tracks.add(0, merge(merged, candidate));\n                performedMerge = true;\n                trackToRemove = candidate;\n                break;\n            }\n        }\n        if (performedMerge) {\n            tracks.remove(trackToRemove);\n        }else {\n            mergedTracks.add(merged);\n        }\n    } \n    org.mitre.mpf.wfm.camel.operations.detection.trackmerging.TrackMergingProcessor.log.trace(\"Track merging complete. The {} input tracks were merged as appropriate to form {} output tracks.\", sourceTracks.size(), mergedTracks.size());\n    return new java.util.HashSet<org.mitre.mpf.wfm.data.entities.transients.Track>(mergedTracks);\n}",
        "fixed_code": "private java.util.Set<org.mitre.mpf.wfm.data.entities.transients.Track> combine(java.util.Set<org.mitre.mpf.wfm.data.entities.transients.Track> sourceTracks, org.mitre.mpf.wfm.camel.operations.detection.trackmerging.TrackMergingPlan plan, double minOverlap) {\n    if (org.apache.commons.collections.CollectionUtils.isEmpty(sourceTracks)) {\n        return sourceTracks;\n    }\n    int minGap = plan.getMinGapBetweenTracks();\n    java.util.List<org.mitre.mpf.wfm.data.entities.transients.Track> tracks = new java.util.LinkedList<org.mitre.mpf.wfm.data.entities.transients.Track>(sourceTracks);\n    java.util.Collections.sort(tracks);\n    java.util.List<org.mitre.mpf.wfm.data.entities.transients.Track> mergedTracks = new java.util.LinkedList<org.mitre.mpf.wfm.data.entities.transients.Track>();\n    while ((tracks.size()) > 0) {\n        org.mitre.mpf.wfm.data.entities.transients.Track merged = tracks.remove(0);\n        boolean performedMerge = false;\n        org.mitre.mpf.wfm.data.entities.transients.Track trackToRemove = null;\n        for (org.mitre.mpf.wfm.data.entities.transients.Track candidate : tracks) {\n            boolean track1BeforeTrack2 = (merged.getEndOffsetFrameInclusive()) < (candidate.getStartOffsetFrameInclusive());\n            boolean trackGapWithinLimit = (merged.getEndOffsetFrameInclusive()) >= (((candidate.getStartOffsetFrameInclusive()) - minGap) + 1);\n            if ((track1BeforeTrack2 && trackGapWithinLimit) && (intersects(merged, candidate, minOverlap))) {\n                tracks.add(0, merge(merged, candidate));\n                performedMerge = true;\n                trackToRemove = candidate;\n                break;\n            }\n        }\n        if (performedMerge) {\n            tracks.remove(trackToRemove);\n        }else {\n            mergedTracks.add(merged);\n        }\n    } \n    org.mitre.mpf.wfm.camel.operations.detection.trackmerging.TrackMergingProcessor.log.trace(\"Track merging complete. The {} input tracks were merged as appropriate to form {} output tracks.\", sourceTracks.size(), mergedTracks.size());\n    return new java.util.HashSet<org.mitre.mpf.wfm.data.entities.transients.Track>(mergedTracks);\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "    import sys\n    input = sys.stdin.readline\n     \n    s = input()\n     \n    M = int(input())\n     \n     \n    def next_pow_2(n):\n        p = 1\n        while p < n:\n            p <<= 1\n        return p\n     \n     \n    def represented_range(node, size):\n        l = node\n        r = node\n        while l < size:\n            l = 2*l\n            r = 2*r + 1\n        return l-size, r-size\n     \n     \n    class SegTree:\n        def __init__(self, size):\n            self.size = next_pow_2(size)\n            self.answer = [0] * (2*self.size)\n            self.opened = [0] * (2*self.size)\n            self.closed = [0] * (2*self.size)\n     \n        # O(size * (O(func) + O(init))\n        def build(self, s):\n            for i in range(self.size):\n                self.answer[self.size + i] = 0\n                self.opened[self.size + i] = 1 if i < len(s) and s[i] == '(' else 0\n                self.closed[self.size + i] = 1 if i < len(s) and s[i] == ')' else 0\n     \n            for i in range(self.size - 1, 0, -1):\n                matched = min(self.opened[2*i], self.closed[2*i+1])\n                self.answer[i] = self.answer[2*i] + self.answer[2*i+1] + matched\n                self.opened[i] = self.opened[2*i] + self.opened[2*i+1] - matched\n                self.closed[i] = self.closed[2*i] + self.closed[2*i+1] - matched\n     \n        # O(log(size)), [l,r]\n        def query(self, l, r):\n            l += self.size\n            r += self.size\n     \n            eventsL = []\n            eventsR = []\n            while l <= r:\n                if l & 1:\n                    eventsL.append((self.answer[l], self.opened[l], self.closed[l]))\n                    l += 1\n                if not (r & 1):\n                    eventsR.append((self.answer[r], self.opened[r], self.closed[r]))\n                    r -= 1\n                l >>= 1\n                r >>= 1\n     \n            answer = 0\n            opened = 0\n            for a, o, c in eventsL + eventsR[::-1]:\n                matched = min(c, opened)\n                answer += a + matched\n                opened += o - matched\n     \n            return answer\n     \n     \n    seg = SegTree(len(s))\n    seg.build(s)\n     \n    for i in range(M):\n        l, r = [int(_) for _ in input().split()]\n        print(2*seg.query(l-1, r-1))",
        "fixed_code": "import sys\n\ninput = sys.stdin.readline\n\ns = input()\n\nM = int(input())\n\n\ndef next_pow_2(n):\n    p = 1\n    while p < n:\n        p <<= 1\n    return p\n\n\ndef represented_range(node, size):\n    l = node\n    r = node\n    while l < size:\n        l = 2 * l\n        r = 2 * r + 1\n    return l - size, r - size\n\n\nclass SegTree:\n    def __init__(self, size):\n        self.size = next_pow_2(size)\n        self.answer = [0] * (2 * self.size)\n        self.opened = [0] * (2 * self.size)\n        self.closed = [0] * (2 * self.size)\n\n    # O(size * (O(func) + O(init))\n    def build(self, s):\n        for i in range(self.size):\n            self.answer[self.size + i] = 0\n            self.opened[self.size + i] = 1 if i < len(s) and s[i] == '(' else 0\n            self.closed[self.size + i] = 1 if i < len(s) and s[i] == ')' else 0\n\n        for i in range(self.size - 1, 0, -1):\n            matched = min(self.opened[2 * i], self.closed[2 * i + 1])\n            self.answer[i] = self.answer[2 * i] + self.answer[2 * i + 1] + matched\n            self.opened[i] = self.opened[2 * i] + self.opened[2 * i + 1] - matched\n            self.closed[i] = self.closed[2 * i] + self.closed[2 * i + 1] - matched\n\n    # O(log(size)), [l,r]\n    def query(self, l, r):\n        l += self.size\n        r += self.size\n\n        eventsL = []\n        eventsR = []\n        while l <= r:\n            if l & 1:\n                eventsL.append((self.answer[l], self.opened[l], self.closed[l]))\n                l += 1\n            if not (r & 1):\n                eventsR.append((self.answer[r], self.opened[r], self.closed[r]))\n                r -= 1\n            l >>= 1\n            r >>= 1\n\n        answer = 0\n        opened = 0\n        for a, o, c in eventsL + eventsR[::-1]:\n            matched = min(c, opened)\n            answer += a + matched\n            opened += o - matched\n\n        return answer\n\n\nseg = SegTree(len(s))\nseg.build(s)\n\nfor i in range(M):\n    l, r = [int(_) for _ in input().split()]\n    print(2 * seg.query(l - 1, r - 1))",
        "source": "Python_461356.json"
    },
    {
        "source_code": "@org.junit.Test\npublic void testCATS() throws java.lang.Exception {\n    java.lang.String hostName = java.net.InetAddress.getLocalHost().getHostName();\n    java.lang.String zkPort = testingCluster.getHBaseUtil().getConf().get(HConstants.ZOOKEEPER_CLIENT_PORT);\n    assertNotNull(zkPort);\n    org.apache.tajo.util.KeyValueSet tableOptions = new org.apache.tajo.util.KeyValueSet();\n    tableOptions.set(StorageConstants.CSVFILE_DELIMITER, StorageConstants.DEFAULT_FIELD_DELIMITER);\n    tableOptions.set(StorageConstants.CSVFILE_NULL, \"\\\\\\\\N\");\n    org.apache.tajo.catalog.Schema schema = new org.apache.tajo.catalog.Schema();\n    schema.addColumn(\"id\", Type.TEXT);\n    schema.addColumn(\"name\", Type.TEXT);\n    java.util.List<java.lang.String> datas = new java.util.ArrayList<java.lang.String>();\n    java.text.DecimalFormat df = new java.text.DecimalFormat(\"000\");\n    for (int i = 99; i >= 0; i--) {\n        datas.add((((df.format(i)) + \"|value\") + i));\n    }\n    org.apache.tajo.TajoTestingCluster.createTable(((getCurrentDatabase()) + \".base_table\"), schema, tableOptions, datas.toArray(new java.lang.String[]{  }), 2);\n    executeString(((((((((((((\"CREATE TABLE hbase_mapped_table (rk text, col1 text) \" + ((\"USING hbase WITH ('table'='hbase_table', 'columns'=':key,col1:a', \" + \"'hbase.split.rowkeys'='010,040,060,080', \") + \"'\")) + (HConstants.ZOOKEEPER_QUORUM)) + \"'='\") + hostName) + \"',\") + \"'\") + (HConstants.ZOOKEEPER_CLIENT_PORT)) + \"'='\") + zkPort) + \"')\") + \" as \") + \"select id, name from base_table\")).close();\n    assertTableExists(\"hbase_mapped_table\");\n    org.apache.tajo.catalog.TableDesc tableDesc = catalog.getTableDesc(getCurrentDatabase(), \"hbase_mapped_table\");\n    org.apache.tajo.engine.query.HTable htable = null;\n    org.apache.tajo.engine.query.ResultScanner scanner = null;\n    try {\n        htable = new org.apache.tajo.engine.query.HTable(testingCluster.getHBaseUtil().getConf(), \"hbase_table\");\n        org.apache.tajo.engine.query.Scan scan = new org.apache.tajo.engine.query.Scan();\n        scan.addFamily(org.apache.tajo.util.Bytes.toBytes(\"col1\"));\n        scanner = htable.getScanner(scan);\n        assertStrings(resultSetToString(scanner, new byte[][]{ null , org.apache.tajo.util.Bytes.toBytes(\"col1\") }, new byte[][]{ null , org.apache.tajo.util.Bytes.toBytes(\"a\") }, new boolean[]{ false , false }, tableDesc.getSchema()));\n    } finally {\n        executeString(\"DROP TABLE base_table PURGE\").close();\n        executeString(\"DROP TABLE hbase_mapped_table PURGE\").close();\n        if (scanner != null) {\n            scanner.close();\n        }\n        if (htable != null) {\n            htable.close();\n        }\n    }\n}",
        "fixed_code": "@org.junit.Test\npublic void testInsertIntoMultiRegion2() throws java.lang.Exception {\n    executeString(((((((((((\"CREATE TABLE hbase_mapped_table (rk text, col1 text) \" + ((\"USING hbase WITH ('table'='hbase_table', 'columns'=':key,col1:a', \" + \"'hbase.split.rowkeys'='1,2,3,4,5,6,7,8,9', \") + \"'\")) + (HConstants.ZOOKEEPER_QUORUM)) + \"'='\") + (org.apache.tajo.engine.query.TestHBaseTable.hostName)) + \"',\") + \"'\") + (HConstants.ZOOKEEPER_CLIENT_PORT)) + \"'='\") + (org.apache.tajo.engine.query.TestHBaseTable.zkPort)) + \"')\")).close();\n    assertTableExists(\"hbase_mapped_table\");\n    org.apache.tajo.catalog.TableDesc tableDesc = catalog.getTableDesc(getCurrentDatabase(), \"hbase_mapped_table\");\n    org.apache.tajo.util.KeyValueSet tableOptions = new org.apache.tajo.util.KeyValueSet();\n    tableOptions.set(StorageConstants.CSVFILE_DELIMITER, StorageConstants.DEFAULT_FIELD_DELIMITER);\n    tableOptions.set(StorageConstants.CSVFILE_NULL, \"\\\\\\\\N\");\n    org.apache.tajo.catalog.Schema schema = new org.apache.tajo.catalog.Schema();\n    schema.addColumn(\"id\", Type.TEXT);\n    schema.addColumn(\"name\", Type.TEXT);\n    java.util.List<java.lang.String> datas = new java.util.ArrayList<java.lang.String>();\n    for (int i = 99; i >= 0; i--) {\n        datas.add(((i + \"|value\") + i));\n    }\n    org.apache.tajo.TajoTestingCluster.createTable(((getCurrentDatabase()) + \".base_table\"), schema, tableOptions, datas.toArray(new java.lang.String[]{  }), 2);\n    executeString((\"insert into hbase_mapped_table \" + \"select id, name from base_table \")).close();\n    org.apache.tajo.engine.query.HTable htable = null;\n    org.apache.tajo.engine.query.ResultScanner scanner = null;\n    try {\n        htable = new org.apache.tajo.engine.query.HTable(testingCluster.getHBaseUtil().getConf(), \"hbase_table\");\n        org.apache.tajo.engine.query.Scan scan = new org.apache.tajo.engine.query.Scan();\n        scan.addFamily(org.apache.tajo.util.Bytes.toBytes(\"col1\"));\n        scanner = htable.getScanner(scan);\n        assertStrings(resultSetToString(scanner, new byte[][]{ null , org.apache.tajo.util.Bytes.toBytes(\"col1\") }, new byte[][]{ null , org.apache.tajo.util.Bytes.toBytes(\"a\") }, new boolean[]{ false , false }, tableDesc.getSchema()));\n    } finally {\n        executeString(\"DROP TABLE base_table PURGE\").close();\n        executeString(\"DROP TABLE hbase_mapped_table PURGE\").close();\n        if (scanner != null) {\n            scanner.close();\n        }\n        if (htable != null) {\n            htable.close();\n        }\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll>pll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pair<int,int>>piii;\ntypedef pair<ll,pair<ll,ll>>plll;\n//typedef tree<ll, null_type, less<ll>, rb_tree_tag,tree_order_statistics_node_update> orderedSet;\n#define fastread() (ios_base:: sync_with_stdio(false),cin.tie(NULL));\n#define sf(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%I64d\\n\",a)\n#define mem(a,b)     memset(a,b,sizeof(a))\n#define vll(v) v.begin(),v.end()\n#define all(x) x.rbegin(),x.rend()\n#define min3(a, b, c)   min(a, min(b, c))\n#define F first\n#define S second\n#define minheap int,vector<int>,greater<int>\n#define result(ans) cout<<\"Case \"<<cas++<<\": \"<<ans<<endl;\n#define pb push_back\n#define pp pop_back\n#define eb emplace_back\n#define in  freopen(\"input.txt\", \"r\", stdin)\n#define out  freopen(\"output.txt\", \"w\", stdout)\n#define BOUNDARY(i, j) ((i >= 0 && i < row) && (j >= 0 && j < column))\n#define ischar(x)  (('a' <= x && x <= 'z') || ('A' <= x && x <= 'Z'))\n#define isvowel(ch) ((ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u')||(ch=='A'|| ch=='E' || ch=='I'|| ch=='O'|| ch=='U'))\nconst int Max = 2e5 + 10;\nconst int Mod = 1e9 + 7;\nconst double PI  =3.141592653589793238463;\nbool compare(const pair<int,int> &a, const pair<int,int> &b)\n{\n    return (a.first > b.first);\n}\nll lcm(ll a,ll b)\n{\n    if(a==0 || b==0)\n        return 0;\n\n    return a/__gcd(a,b)*b;\n}\n//___________________________________________________________________________________________________________________\n//                              CODE STARTS FROM HERE\n//                               MU_Codefighter2019\n//-------------------------------------------------------------------------------------------------------------------\nvoid input(vector<pll>ara,ll n)\n{\n    for(ll i=1; i<=n; i++)\n        cin>>ara[i].F,ara[i].S=0;\n}\n\n\n\nll ara[Max+10],tree[Max*4+10],mx[Max+10];\n\nvoid update(ll node, ll b,ll e,ll pos, ll val)\n{\n    if(pos>e || pos<b)\n        return ;\n    if(b==e)\n    {\n        tree[node]=val;\n        return ;\n    }\n    ll left=node*2;\n    ll right=node*2+1;\n    ll mid=(b+e)/2;\n    update(left,b,mid,pos,val);\n\n    update(right,mid+1,e,pos,val);\n\n    tree[node]=max(tree[left],tree[right]);\n}\nll query(ll node, ll b,ll e,ll i,ll j)\n{\n    if(i>e || j<b)\n        return 0;\n    if(i<=b && j>=e)\n        return tree[node];\n\n    ll left=node*2;\n    ll right=node*2+1;\n\n    ll mid=(b+e)/2;\n\n    ll p1=query(left,b,mid,i,j);\n    ll p2=query(right,mid+1,e,i,j);\n\n    return max(p1,p2);\n}\n\n\nint main()\n{\n    fastread();\n\n    ll i,j,n,m,p,sum=0,k,t,a,b,c,d,cnt=0,q,value;\n\n    cin>>n;\n\n\n\n   vector<pll>ara(n+1);\n\n   for(i=1; i<=n; i++)\n   {\n       cin>>ara[i].F;\n\n       ara[i].S=0;\n   }\n\n    cin>>q;\n\n    ll highest=0;\n\n    for(i=1; i<=q; i++)\n    {\n        cin>>t;\n\n        switch(t)\n        {\n        case 1 :\n            cin>>a>>b;\n\n            ara[a].F=b;\n\n            ara[a].S=i;\n\n\n            break;\n\n        case 2 :\n            cin>>value;\n\n            mx[i]=value;\n\n            update(1,1,i,i,mx[i]);\n\n            highest=max(highest,value);\n        }\n\n\n    }\n\n\n\n    for(i=1; i<=n; i++)\n    {\n        if(ara[i].S==0)\n        {\n\n            //cout<<endl<<i<<\" \"<<ara[i].F<<\" \"<<highest<<endl;\n            cout<<max(ara[i].F,highest)<<\" \";\n        }\n        else\n        {\n            value=query(1,1,q,ara[i].S,q);\n\n            //cout<<value<<\" \"<<ara[i].F<<endl;\n\n            cout<<max(ara[i].F,value)<<\" \";\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n",
        "fixed_code": "#include<bits/stdc++.h>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll>pll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pair<int,int>>piii;\ntypedef pair<ll,pair<ll,ll>>plll;\n//typedef tree<ll, null_type, less<ll>, rb_tree_tag,tree_order_statistics_node_update> orderedSet;\n#define fastread() (ios_base:: sync_with_stdio(false),cin.tie(NULL));\n#define sf(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%I64d\\n\",a)\n#define mem(a,b)     memset(a,b,sizeof(a))\n#define vll(v) v.begin(),v.end()\n#define all(x) x.rbegin(),x.rend()\n#define min3(a, b, c)   min(a, min(b, c))\n#define F first\n#define S second\n#define minheap int,vector<int>,greater<int>\n#define result(ans) cout<<\"Case \"<<cas++<<\": \"<<ans<<endl;\n#define pb push_back\n#define pp pop_back\n#define eb emplace_back\n#define in  freopen(\"input.txt\", \"r\", stdin)\n#define out  freopen(\"output.txt\", \"w\", stdout)\n#define BOUNDARY(i, j) ((i >= 0 && i < row) && (j >= 0 && j < column))\n#define ischar(x)  (('a' <= x && x <= 'z') || ('A' <= x && x <= 'Z'))\n#define isvowel(ch) ((ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u')||(ch=='A'|| ch=='E' || ch=='I'|| ch=='O'|| ch=='U'))\nconst int Max = 2e5 + 10;\nconst int Mod = 1e9 + 7;\nconst double PI  =3.141592653589793238463;\nbool compare(const pair<int,int> &a, const pair<int,int> &b)\n{\n    return (a.first > b.first);\n}\nll lcm(ll a,ll b)\n{\n    if(a==0 || b==0)\n        return 0;\n\n    return a/__gcd(a,b)*b;\n}\n//___________________________________________________________________________________________________________________\n//                              CODE STARTS FROM HERE\n//                               MU_Codefighter2019\n//-------------------------------------------------------------------------------------------------------------------\nvoid input(vector<pll>ara,ll n)\n{\n    for(ll i=1; i<=n; i++)\n        cin>>ara[i].F,ara[i].S=0;\n}\n\n\n\nll ara[Max+10],tree[Max*4+10],mx[Max+10];\n\nvoid update(ll node, ll b,ll e,ll pos, ll val)\n{\n    if(pos>e || pos<b)\n        return ;\n    if(b==e)\n    {\n        tree[node]=val;\n        return ;\n    }\n    ll left=node*2;\n    ll right=node*2+1;\n    ll mid=(b+e)/2;\n    update(left,b,mid,pos,val);\n\n    update(right,mid+1,e,pos,val);\n\n    tree[node]=max(tree[left],tree[right]);\n}\nll query(ll node, ll b,ll e,ll i,ll j)\n{\n    if(i>e || j<b)\n        return 0;\n    if(i<=b && j>=e)\n        return tree[node];\n\n    ll left=node*2;\n    ll right=node*2+1;\n\n    ll mid=(b+e)/2;\n\n    ll p1=query(left,b,mid,i,j);\n    ll p2=query(right,mid+1,e,i,j);\n\n    return max(p1,p2);\n}\n\n\nint main()\n{\n    fastread();\n\n    ll i,j,n,m,p,sum=0,k,t,a,b,c,d,cnt=0,q,value;\n\n    cin>>n;\n\n\n\n   vector<pll>ara(n+1);\n\n   for(i=1; i<=n; i++)\n   {\n       cin>>ara[i].F;\n\n       ara[i].S=0;\n   }\n\n    cin>>q;\n\n    ll highest=0;\n\n    for(i=1; i<=q; i++)\n    {\n        cin>>t;\n\n        switch(t)\n        {\n        case 1 :\n            cin>>a>>b;\n\n            ara[a].F=b;\n\n            ara[a].S=i;\n\n\n            break;\n\n        case 2 :\n            cin>>value;\n\n            mx[i]=value;\n\n            update(1,1,q,i,mx[i]);\n\n            highest=max(highest,value);\n        }\n\n\n    }\n\n\n\n    for(i=1; i<=n; i++)\n    {\n        if(ara[i].S==0)\n        {\n\n            //cout<<endl<<i<<\" \"<<ara[i].F<<\" \"<<highest<<endl;\n            cout<<max(ara[i].F,highest)<<\" \";\n        }\n        else\n        {\n            value=query(1,1,q,ara[i].S,q);\n\n            //cout<<value<<\" \"<<ara[i].F<<endl;\n\n            cout<<max(ara[i].F,value)<<\" \";\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.*;\r\nimport java.io.*;\r\npublic class Solution {\r\n    public static void main(String[] args) throws IOException {\r\n        Scanner sc = new Scanner(System.in);\r\n        PrintWriter pw = new PrintWriter(System.out);\r\n        int t = sc.nextInt();\r\n\r\n        while(t-->0) {\r\n            int n = sc.nextInt();\r\n            char arr [];\r\n            arr = sc.next().toCharArray();\r\n            int idxOfFirst = -1;\r\n            for(int i = 0;i<n;i++) {\r\n                if(arr[i]!='?') {\r\n                    idxOfFirst= i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if(idxOfFirst==-1) {\r\n                boolean blue = true;\r\n                for(int i = 0;i<n;i++) {\r\n                    if(blue) {\r\n                        arr[i] = 'B';\r\n                    }\r\n                    else {\r\n                        arr[i]='R';\r\n                    }\r\n                    blue = !blue;\r\n                }\r\n            }\r\n            else {\r\n                boolean blue = arr[idxOfFirst]=='R';\r\n                for(int i = idxOfFirst+1;i<n;i++) {\r\n                    if(arr[i]=='?') {\r\n                        if(blue) {\r\n                            arr[i]='B';\r\n                        }\r\n                        else {\r\n                            arr[i] = 'R';\r\n                        }\r\n                        blue = !blue;\r\n                    }\r\n                    else if (arr[i]=='R') {\r\n                        blue = true;\r\n                    }\r\n                    else {\r\n                        blue = false;\r\n                    }\r\n                }\r\n                System.out.println(idxOfFirst);\r\n                blue = arr[idxOfFirst]=='R';\r\n\r\n                for (int i = idxOfFirst-1;i>=0;i--) {\r\n                    if(blue) {\r\n                        arr[i] = 'B';\r\n                    }\r\n                    else {\r\n                        arr[i]='R';\r\n                    }\r\n                    blue = !blue;\r\n                }\r\n            }\r\n\r\n            for(int i = 0;i<n;i++) {\r\n                System.out.print(arr[i]);\r\n            }\r\n            System.out.println();\r\n\r\n        }}\r\n\r\n    static int [] arr ;\r\n    static int d [] ;\r\n    public static void solve(int i , int j, int depth) {\r\n\r\n        if(i == j) {\r\n            d[i] = depth+1;\r\n\r\n        }\r\n        else {\r\n            int idxOfMax = -1;\r\n            int max = Integer.MIN_VALUE;\r\n            for(int c = i;c<=j;c++) {\r\n                if(arr[c]>max) {\r\n                    max = arr[c];\r\n                    idxOfMax= c;\r\n                }\r\n            }\r\n            //System.out.println(idxOfMax+\" \"+ i+\" \" + j);\r\n            d[idxOfMax] = depth+1;\r\n\r\n            if(idxOfMax==i) {\r\n\r\n                solve(i+1,j,depth+1);\r\n            }\r\n            else if(idxOfMax ==j) {\r\n\r\n                solve(i,j-1,depth+1);\r\n            }\r\n            else {\r\n                //System.out.println(\"hhh\");\r\n                solve(i,idxOfMax-1,depth+1);\r\n                solve(idxOfMax+1,j,depth+1);\r\n            }}\r\n    }\r\n    static  HashSet<Long> hs = new HashSet<Long>();\r\n\r\n    public static int idxOf(String s,char c) {\r\n        int idx = -2;\r\n        for(int i = 0;i<s.length();i++) {\r\n            if(s.charAt(i)==c) {\r\n                return i;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n    static ArrayList<Long >start;\r\n    static ArrayList<Long> end;\r\n    public static void dfs (int idx) {\r\n        can[idx] = true;\r\n        for(int i = 0;i<start.size();i++) {\r\n            if((start.get(i)<start.get(idx)&& end.get(i)>start.get(idx)||(start.get(i)<end.get(idx)&& end.get(i)>end.get(idx)))){\r\n                if(!can[i]) {\r\n                    dfs(i);\r\n                }}\r\n        }\r\n    }\r\n    static boolean [] can ;\r\n    static int n;\r\n\r\n    static int [] [] sol;\r\n    static int [] g;\r\n    public static void constructSol() {\r\n        for(int i = 1;i<sol.length;i++) {\r\n            for(int j = 1;j<10;j++) {\r\n                if(g[i] == j) {\r\n                    sol[i][j] = sol[i-1][j]+1;\r\n                }\r\n                else {\r\n                    sol[i][j] = sol[i-1][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    public static void prod() {\r\n        for(int i=1;i<g.length;i++) {\r\n            int n = i;\r\n            if(n<10) {\r\n                g[ n] = n;\r\n                continue;\r\n            }\r\n            int prod = 1;\r\n            while(n>0) {\r\n                if(n%10!=0) {\r\n                    prod*= (n%10);\r\n\r\n                }\r\n                n/=10;\r\n            }\r\n            //System.out.println(prod);\r\n            g[i] = g[prod];\r\n\r\n        }}\r\n    public static  boolean isPalindrome(String s) {\r\n\r\n        for(int i = 0;i<=s.length()/2;i++) {\r\n            if(s.charAt(i)!=s.charAt(s.length()-1-i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    public static long logBase2(long n) {\r\n        long ans = 0;\r\n        while(n>1) {\r\n            ans ++;\r\n            n/=2;\r\n        }\r\n        return ans;\r\n    }\r\n    public static double getmostLeft(ArrayList<Circle> list) {\r\n        double min = Double.MAX_VALUE;\r\n        for (Circle c: list) {\r\n            min = Math.min(min, c.x - c.r);\r\n        }\r\n        return min;\r\n    }\r\n\r\n    public static double getmostRight(ArrayList<Circle> list) {\r\n        double max = Double.MIN_VALUE;\r\n        for (Circle c: list) {\r\n            max = Math.max(max, c.x + c.r);\r\n        }\r\n        return max;\r\n    }\r\n    static class Circle{\r\n        double x ;\r\n        double y ;\r\n        double r;\r\n        int id;\r\n        public Circle(double x, double y, double r) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.r = r;\r\n\r\n        }\r\n        public String toString () {\r\n            return x +\" \"+y+\" \"+r;\r\n        }\r\n        public boolean intersect(Circle o) {\r\n            double dist = Math.sqrt((y-o.y)*(y-o.y)+(x-o.x)*(x-o.x));\r\n            if(dist<=r+o.r) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        public  Circle combine( Circle o) {\r\n            double dist = Math.sqrt((y-o.y)*(y-o.y)+(x-o.x)*(x-o.x));\r\n            if(Math.abs(r-o.r)>=dist) {\r\n                if(r>=o.r) {\r\n                    return this;\r\n                }\r\n                else {\r\n                    return o;\r\n                }\r\n            }\r\n\r\n            double cx = (x+o.x)/2.0;\r\n            double cy = (y+o.y)/2.0;\r\n            double rad = (dist +r +this.r)/2.0;\r\n            return new Circle (cx, cy, rad);\r\n        }\r\n    }\r\n    static class Pair implements Comparable {\r\n        long x;\r\n        int y;\r\n        public Pair (long x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n\r\n        }\r\n        @Override\r\n        public int compareTo(Object arg0) {\r\n            Pair p = (Pair) arg0;\r\n            return Long.compare(x, p.x);\r\n        }\r\n    }\r\n    public static String solve (String s) {\r\n        Stack <String> st = new Stack<String>();\r\n        for(int i = 0;i<s.length();i++) {\r\n            if(s.charAt(i)==']') {\r\n                String toEncode = \"\";\r\n                while(!st.isEmpty()&&!st.peek().equals(\"[\")) {\r\n                    toEncode = st.pop()+ toEncode;\r\n                }\r\n                st.pop();\r\n                String toPush = \"\";\r\n                int freq = Integer.parseInt(st.pop());\r\n                while(freq-->0) {\r\n                    toPush+=toEncode;\r\n                }\r\n                st.push(toPush);\r\n            }\r\n            else {\r\n                st.push(s.charAt(i)+\"\");\r\n            }\r\n\r\n        }\r\n        String res = \"\";\r\n        while(!st.isEmpty()) {\r\n            res = st.pop() +res;\r\n        }\r\n        return res;\r\n    }\r\n    static String alph = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n    public static int solve (int i, int j) {\r\n        //System.out.println(\"hh\");\r\n        int p = 0;\r\n        for(int k = i;k<=j;k++) {\r\n            if(s.charAt(k)==alph.charAt(p)) {\r\n                p++;\r\n            }\r\n            if(p==26) {\r\n                return (j-i+1);\r\n            }\r\n        }\r\n        return Integer.MAX_VALUE;\r\n\r\n    }\r\n    static String s;\r\n    static ArrayList <Integer> prime;\r\n    static void simpleSieve(int limit)\r\n    {\r\n        // Create a boolean array \"mark[0..n-1]\" and initialize\r\n        // all entries of it as true. A value in mark[p] will\r\n        // finally be false if 'p' is Not a prime, else true.\r\n        boolean mark[] = new boolean[limit+1];\r\n\r\n        for (int i = 0; i < mark.length; i++)\r\n            mark[i] = true;\r\n\r\n        for (int p=2; p*p<limit; p++)\r\n        {\r\n            // If p is not changed, then it is a prime\r\n            if (mark[p] == true)\r\n            {\r\n                // Update all multiples of p\r\n                for (int i=p*p; i<limit; i+=p)\r\n                    mark[i] = false;\r\n            }\r\n        }\r\n\r\n        // Print all prime numbers and store them in prime\r\n        for (int p=2; p<limit; p++)\r\n        {\r\n            if (mark[p] == true)\r\n            {\r\n                prime.add(p);\r\n                // System.out.print(p + \"  \");\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public static long gcd (long a, long b ) {\r\n        if(b==0) {\r\n            return a;\r\n        }\r\n        else {\r\n            return gcd (b, a%b);\r\n        }\r\n    }\r\n\r\n    static class Scanner {\r\n        StringTokenizer st;\r\n        BufferedReader br;\r\n\r\n        public Scanner(InputStream s) {\r\n            br = new BufferedReader(new InputStreamReader(s));\r\n        }\r\n        public Scanner(FileReader r) {\r\n            br = new BufferedReader(r);\r\n        }\r\n        public boolean hasNext() {\r\n            // TODO Auto-generated method stub\r\n            return false;\r\n        }\r\n\r\n        public String next() throws IOException {\r\n            while (st == null || !st.hasMoreTokens())\r\n                st = new StringTokenizer(br.readLine());\r\n            return st.nextToken();\r\n        }\r\n\r\n        public int nextInt() throws IOException {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public long nextLong() throws IOException {\r\n            return Long.parseLong(next());\r\n        }\r\n\r\n        public String nextLine() throws IOException {\r\n            return br.readLine();\r\n        }\r\n\r\n        public double nextDouble() throws IOException {\r\n            String x = next();\r\n            StringBuilder sb = new StringBuilder(\"0\");\r\n            double res = 0, f = 1;\r\n            boolean dec = false, neg = false;\r\n            int start = 0;\r\n            if (x.charAt(0) == '-') {\r\n                neg = true;\r\n                start++;\r\n            }\r\n            for (int i = start; i < x.length(); i++)\r\n                if (x.charAt(i) == '.') {\r\n                    res = Long.parseLong(sb.toString());\r\n                    sb = new StringBuilder(\"0\");\r\n                    dec = true;\r\n                } else {\r\n                    sb.append(x.charAt(i));\r\n                    if (dec)\r\n                        f *= 10;\r\n                }\r\n            res += Long.parseLong(sb.toString()) / f;\r\n            return res * (neg ? -1 : 1);\r\n        }\r\n\r\n        public boolean ready() throws IOException {\r\n            return br.ready();\r\n        }\r\n\r\n    }\r\n}\r\n",
        "fixed_code": "import java.util.*;\r\nimport java.io.*;\r\npublic class Solution {\r\n    public static void main(String[] args) throws IOException {\r\n        Scanner sc = new Scanner(System.in);\r\n        PrintWriter pw = new PrintWriter(System.out);\r\n        int t = sc.nextInt();\r\n\r\n        while(t-->0) {\r\n            int n = sc.nextInt();\r\n            char arr [];\r\n            arr = sc.next().toCharArray();\r\n            int idxOfFirst = -1;\r\n            for(int i = 0;i<n;i++) {\r\n                if(arr[i]!='?') {\r\n                    idxOfFirst= i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if(idxOfFirst==-1) {\r\n                boolean blue = true;\r\n                for(int i = 0;i<n;i++) {\r\n                    if(blue) {\r\n                        arr[i] = 'B';\r\n                    }\r\n                    else {\r\n                        arr[i]='R';\r\n                    }\r\n                    blue = !blue;\r\n                }\r\n            }\r\n            else {\r\n                boolean blue = arr[idxOfFirst]=='R';\r\n                for(int i = idxOfFirst+1;i<n;i++) {\r\n                    if(arr[i]=='?') {\r\n                        if(blue) {\r\n                            arr[i]='B';\r\n                        }\r\n                        else {\r\n                            arr[i] = 'R';\r\n                        }\r\n                        blue = !blue;\r\n                    }\r\n                    else if (arr[i]=='R') {\r\n                        blue = true;\r\n                    }\r\n                    else {\r\n                        blue = false;\r\n                    }\r\n                }\r\n                blue = arr[idxOfFirst]=='R';\r\n\r\n                for (int i = idxOfFirst-1;i>=0;i--) {\r\n                    if(blue) {\r\n                        arr[i] = 'B';\r\n                    }\r\n                    else {\r\n                        arr[i]='R';\r\n                    }\r\n                    blue = !blue;\r\n                }\r\n            }\r\n\r\n            for(int i = 0;i<n;i++) {\r\n                System.out.print(arr[i]);\r\n            }\r\n            System.out.println();\r\n\r\n        }}\r\n\r\n    static int [] arr ;\r\n    static int d [] ;\r\n    public static void solve(int i , int j, int depth) {\r\n\r\n        if(i == j) {\r\n            d[i] = depth+1;\r\n\r\n        }\r\n        else {\r\n            int idxOfMax = -1;\r\n            int max = Integer.MIN_VALUE;\r\n            for(int c = i;c<=j;c++) {\r\n                if(arr[c]>max) {\r\n                    max = arr[c];\r\n                    idxOfMax= c;\r\n                }\r\n            }\r\n            //System.out.println(idxOfMax+\" \"+ i+\" \" + j);\r\n            d[idxOfMax] = depth+1;\r\n\r\n            if(idxOfMax==i) {\r\n\r\n                solve(i+1,j,depth+1);\r\n            }\r\n            else if(idxOfMax ==j) {\r\n\r\n                solve(i,j-1,depth+1);\r\n            }\r\n            else {\r\n                //System.out.println(\"hhh\");\r\n                solve(i,idxOfMax-1,depth+1);\r\n                solve(idxOfMax+1,j,depth+1);\r\n            }}\r\n    }\r\n    static  HashSet<Long> hs = new HashSet<Long>();\r\n\r\n    public static int idxOf(String s,char c) {\r\n        int idx = -2;\r\n        for(int i = 0;i<s.length();i++) {\r\n            if(s.charAt(i)==c) {\r\n                return i;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n    static ArrayList<Long >start;\r\n    static ArrayList<Long> end;\r\n    public static void dfs (int idx) {\r\n        can[idx] = true;\r\n        for(int i = 0;i<start.size();i++) {\r\n            if((start.get(i)<start.get(idx)&& end.get(i)>start.get(idx)||(start.get(i)<end.get(idx)&& end.get(i)>end.get(idx)))){\r\n                if(!can[i]) {\r\n                    dfs(i);\r\n                }}\r\n        }\r\n    }\r\n    static boolean [] can ;\r\n    static int n;\r\n\r\n    static int [] [] sol;\r\n    static int [] g;\r\n    public static void constructSol() {\r\n        for(int i = 1;i<sol.length;i++) {\r\n            for(int j = 1;j<10;j++) {\r\n                if(g[i] == j) {\r\n                    sol[i][j] = sol[i-1][j]+1;\r\n                }\r\n                else {\r\n                    sol[i][j] = sol[i-1][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    public static void prod() {\r\n        for(int i=1;i<g.length;i++) {\r\n            int n = i;\r\n            if(n<10) {\r\n                g[ n] = n;\r\n                continue;\r\n            }\r\n            int prod = 1;\r\n            while(n>0) {\r\n                if(n%10!=0) {\r\n                    prod*= (n%10);\r\n\r\n                }\r\n                n/=10;\r\n            }\r\n            //System.out.println(prod);\r\n            g[i] = g[prod];\r\n\r\n        }}\r\n    public static  boolean isPalindrome(String s) {\r\n\r\n        for(int i = 0;i<=s.length()/2;i++) {\r\n            if(s.charAt(i)!=s.charAt(s.length()-1-i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    public static long logBase2(long n) {\r\n        long ans = 0;\r\n        while(n>1) {\r\n            ans ++;\r\n            n/=2;\r\n        }\r\n        return ans;\r\n    }\r\n    public static double getmostLeft(ArrayList<Circle> list) {\r\n        double min = Double.MAX_VALUE;\r\n        for (Circle c: list) {\r\n            min = Math.min(min, c.x - c.r);\r\n        }\r\n        return min;\r\n    }\r\n\r\n    public static double getmostRight(ArrayList<Circle> list) {\r\n        double max = Double.MIN_VALUE;\r\n        for (Circle c: list) {\r\n            max = Math.max(max, c.x + c.r);\r\n        }\r\n        return max;\r\n    }\r\n    static class Circle{\r\n        double x ;\r\n        double y ;\r\n        double r;\r\n        int id;\r\n        public Circle(double x, double y, double r) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.r = r;\r\n\r\n        }\r\n        public String toString () {\r\n            return x +\" \"+y+\" \"+r;\r\n        }\r\n        public boolean intersect(Circle o) {\r\n            double dist = Math.sqrt((y-o.y)*(y-o.y)+(x-o.x)*(x-o.x));\r\n            if(dist<=r+o.r) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        public  Circle combine( Circle o) {\r\n            double dist = Math.sqrt((y-o.y)*(y-o.y)+(x-o.x)*(x-o.x));\r\n            if(Math.abs(r-o.r)>=dist) {\r\n                if(r>=o.r) {\r\n                    return this;\r\n                }\r\n                else {\r\n                    return o;\r\n                }\r\n            }\r\n\r\n            double cx = (x+o.x)/2.0;\r\n            double cy = (y+o.y)/2.0;\r\n            double rad = (dist +r +this.r)/2.0;\r\n            return new Circle (cx, cy, rad);\r\n        }\r\n    }\r\n    static class Pair implements Comparable {\r\n        long x;\r\n        int y;\r\n        public Pair (long x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n\r\n        }\r\n        @Override\r\n        public int compareTo(Object arg0) {\r\n            Pair p = (Pair) arg0;\r\n            return Long.compare(x, p.x);\r\n        }\r\n    }\r\n    public static String solve (String s) {\r\n        Stack <String> st = new Stack<String>();\r\n        for(int i = 0;i<s.length();i++) {\r\n            if(s.charAt(i)==']') {\r\n                String toEncode = \"\";\r\n                while(!st.isEmpty()&&!st.peek().equals(\"[\")) {\r\n                    toEncode = st.pop()+ toEncode;\r\n                }\r\n                st.pop();\r\n                String toPush = \"\";\r\n                int freq = Integer.parseInt(st.pop());\r\n                while(freq-->0) {\r\n                    toPush+=toEncode;\r\n                }\r\n                st.push(toPush);\r\n            }\r\n            else {\r\n                st.push(s.charAt(i)+\"\");\r\n            }\r\n\r\n        }\r\n        String res = \"\";\r\n        while(!st.isEmpty()) {\r\n            res = st.pop() +res;\r\n        }\r\n        return res;\r\n    }\r\n    static String alph = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n    public static int solve (int i, int j) {\r\n        //System.out.println(\"hh\");\r\n        int p = 0;\r\n        for(int k = i;k<=j;k++) {\r\n            if(s.charAt(k)==alph.charAt(p)) {\r\n                p++;\r\n            }\r\n            if(p==26) {\r\n                return (j-i+1);\r\n            }\r\n        }\r\n        return Integer.MAX_VALUE;\r\n\r\n    }\r\n    static String s;\r\n    static ArrayList <Integer> prime;\r\n    static void simpleSieve(int limit)\r\n    {\r\n        // Create a boolean array \"mark[0..n-1]\" and initialize\r\n        // all entries of it as true. A value in mark[p] will\r\n        // finally be false if 'p' is Not a prime, else true.\r\n        boolean mark[] = new boolean[limit+1];\r\n\r\n        for (int i = 0; i < mark.length; i++)\r\n            mark[i] = true;\r\n\r\n        for (int p=2; p*p<limit; p++)\r\n        {\r\n            // If p is not changed, then it is a prime\r\n            if (mark[p] == true)\r\n            {\r\n                // Update all multiples of p\r\n                for (int i=p*p; i<limit; i+=p)\r\n                    mark[i] = false;\r\n            }\r\n        }\r\n\r\n        // Print all prime numbers and store them in prime\r\n        for (int p=2; p<limit; p++)\r\n        {\r\n            if (mark[p] == true)\r\n            {\r\n                prime.add(p);\r\n                // System.out.print(p + \"  \");\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public static long gcd (long a, long b ) {\r\n        if(b==0) {\r\n            return a;\r\n        }\r\n        else {\r\n            return gcd (b, a%b);\r\n        }\r\n    }\r\n\r\n    static class Scanner {\r\n        StringTokenizer st;\r\n        BufferedReader br;\r\n\r\n        public Scanner(InputStream s) {\r\n            br = new BufferedReader(new InputStreamReader(s));\r\n        }\r\n        public Scanner(FileReader r) {\r\n            br = new BufferedReader(r);\r\n        }\r\n        public boolean hasNext() {\r\n            // TODO Auto-generated method stub\r\n            return false;\r\n        }\r\n\r\n        public String next() throws IOException {\r\n            while (st == null || !st.hasMoreTokens())\r\n                st = new StringTokenizer(br.readLine());\r\n            return st.nextToken();\r\n        }\r\n\r\n        public int nextInt() throws IOException {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public long nextLong() throws IOException {\r\n            return Long.parseLong(next());\r\n        }\r\n\r\n        public String nextLine() throws IOException {\r\n            return br.readLine();\r\n        }\r\n\r\n        public double nextDouble() throws IOException {\r\n            String x = next();\r\n            StringBuilder sb = new StringBuilder(\"0\");\r\n            double res = 0, f = 1;\r\n            boolean dec = false, neg = false;\r\n            int start = 0;\r\n            if (x.charAt(0) == '-') {\r\n                neg = true;\r\n                start++;\r\n            }\r\n            for (int i = start; i < x.length(); i++)\r\n                if (x.charAt(i) == '.') {\r\n                    res = Long.parseLong(sb.toString());\r\n                    sb = new StringBuilder(\"0\");\r\n                    dec = true;\r\n                } else {\r\n                    sb.append(x.charAt(i));\r\n                    if (dec)\r\n                        f *= 10;\r\n                }\r\n            res += Long.parseLong(sb.toString()) / f;\r\n            return res * (neg ? -1 : 1);\r\n        }\r\n\r\n        public boolean ready() throws IOException {\r\n            return br.ready();\r\n        }\r\n\r\n    }\r\n}\r\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long \r\n\r\nint main(){\r\n      ll t;\r\n      cin>>t;\r\n      while(t--){\r\n        ll n;\r\n        cin>>n;\r\n        if(n%2==0){\r\n            int a=n/2;\r\n            int b=a-1;\r\n            int c=n-(a+b);\r\n            cout<<b<<\" \"<<a<<\" \"<<c<<endl;\r\n        }\r\n        else{\r\n            int a=n/2 +1;\r\n            int b=a-2;\r\n            int c=n-(a+b);\r\n            cout<<b<<\" \"<<a<<\" \"<<c<<endl;\r\n        }\r\n        // ll a=ceil(double(n)/2);\r\n        // ll b=a-1;\r\n        // ll c=n-(a+b);\r\n        // while(c==0){\r\n        //     b-=1;\r\n        //     c++;\r\n        // }\r\n        // cout<<b<<\" \"<<a<<\" \"<<c<<endl;\r\n\r\n    }\r\n    return 0;\r\n}",
        "fixed_code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long \r\n\r\nint main(){\r\n      ll t;\r\n      cin>>t;\r\n      while(t--){\r\n        ll n;\r\n        cin>>n;\r\n        int a=(n-3)/3;\r\n        int b=n-a;\r\n        if(b%2!=0){\r\n            int x=(b+1)/2;\r\n            int y=(b-1)/2;\r\n            cout<<y<<\" \"<<x<<\" \"<<a<<endl;\r\n        }\r\n        else{\r\n            int x=(b+2)/2;\r\n            int y=n-(x+a);\r\n            cout<<y<<\" \"<<x<<\" \"<<a<<endl;\r\n\r\n        }\r\n    }\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskCF373D2C solver = new TaskCF373D2C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskCF373D2C {\n        int asInt(char ch) {\n            return ch - '0';\n        }\n\n        char next(char ch) {\n            return (char) (ch + 1);\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int t = in.nextInt();\n\n            char[] g = in.next().toCharArray();\n\n            int dotIndex = -1;\n            for (int i = 0; i < n; i++) {\n                if (g[i] == '.') {\n                    dotIndex = i;\n                    break;\n                }\n            }\n\n            BigInteger integerPart = new BigInteger(new String(Arrays.copyOf(g, dotIndex)), 10);\n\n            int start = dotIndex + 1;\n            int end = n - 1;\n\n            for (int j = dotIndex + 1; j < n; j++) {\n                if (asInt(g[j]) >= 5) {\n                    end = j;\n                    break;\n                }\n            }\n\n            boolean inc = false;\n            while (t > 0 && end >= start) {\n                char top = g[end];\n                if (asInt(top) < 5) {\n                    break;\n                } else {\n                    end--;\n\n                    while (end >= start && asInt(g[end]) == 9) {\n                        end--;\n                    }\n                }\n\n                if (end < start) {\n                    inc = true;\n                } else {\n                    g[end] = next(g[end]);\n                }\n\n                t--;\n            }\n\n            if (inc) {\n                integerPart = integerPart.add(new BigInteger(\"1\", 10));\n            }\n\n            StringBuilder frac = new StringBuilder();\n            for (int i = start; i <= end; i++) {\n                frac.append(g[i]);\n            }\n            out.println(integerPart.toString(10) + \".\" + frac.toString());\n        }\n\n    }\n}\n\n",
        "fixed_code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskCF373D2C solver = new TaskCF373D2C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskCF373D2C {\n        int asInt(char ch) {\n            return ch - '0';\n        }\n\n        char next(char ch) {\n            return (char) (ch + 1);\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int t = in.nextInt();\n\n            char[] g = in.next().toCharArray();\n\n            int dotIndex = -1;\n            for (int i = 0; i < n; i++) {\n                if (g[i] == '.') {\n                    dotIndex = i;\n                    break;\n                }\n            }\n\n\n            int start = dotIndex + 1;\n            int end = n - 1;\n\n            for (int j = dotIndex + 1; j < n; j++) {\n                if (asInt(g[j]) >= 5) {\n                    end = j;\n                    break;\n                }\n            }\n\n            boolean inc = false;\n            while (t > 0 && end >= start) {\n                char top = g[end];\n                if (asInt(top) < 5) {\n                    break;\n                } else {\n                    end--;\n\n                    while (end >= start && asInt(g[end]) == 9) {\n                        end--;\n                    }\n                }\n\n                if (end < start) {\n                    inc = true;\n                } else {\n                    g[end] = next(g[end]);\n                }\n\n                t--;\n            }\n\n            boolean addOne = true;\n\n            if (inc) {\n                int is = 0;\n                int ie = dotIndex - 1;\n\n                for (int j = ie; j >= is; j--) {\n                    if (g[j] == '9') {\n                        g[j] = '0';\n                    } else {\n                        g[j] = next(g[j]);\n                        addOne = false;\n                        break;\n                    }\n                }\n\n            } else {\n                addOne = false;\n            }\n\n            StringBuilder frac = new StringBuilder();\n            if (addOne) {\n                frac.append('1');\n            }\n            for (int i = 0; i <= dotIndex - 1; i++) {\n                frac.append(g[i]);\n            }\n            if (!inc) {\n                frac.append('.');\n                for (int i = start; i <= end; i++) {\n                    frac.append(g[i]);\n                }\n            }\n            out.println(frac.toString());\n        }\n\n    }\n}\n\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define DEBUG puts(\"Here is a BUG\")\n\n#define PI 3.1415926535897932626\n#define all(a) a.begin(),a.end()\ntypedef long long ll;\nusing namespace std;\nconst double eps=1e-8;\nconst int MAXN=(int)1e5+5;\nconst int MOD=(int)1e9+7;\nconst int INF=0x3f3f3f3f;\nconst int dx[]={-1,1,0,0};\nconst int dy[]={0,0,-1,1};\nint a[MAXN],ans;\nbool check(int l,int r)\n{\n    if(l>=r)return false;\n    set<int> s;\n    for (int i = l; i < r; i++)s.insert(a[i]);\n    if(s.size()==r-l&&*max_element(a+l,a+r)==r-l)return true;else return false;\n    \n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T,n,m;\n    cin>>T;\n    while (T--)\n    {\n        cin>>n;\n        for (int i = 0; i < n; i++)cin>>a[i];\n        m=*max_element(a,a+n);\n        ans=3;\n        if(!check(0,m)||!check(m,n))ans-=1;\n        if(n==m*2||!check(0,n-m)||!check(n-m,n))ans-=2;\n        cout<<ceil(ans/2.0)<<endl;\n        if(ans&1)cout<<m<<\" \"<<n-m<<endl;\n        if(ans&2)cout<<n-m<<\" \"<<m<<endl;\n    }\n    \n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n#define DEBUG puts(\"Here is a BUG\")\n\n#define PI 3.1415926535897932626\n#define all(a) a.begin(),a.end()\ntypedef long long ll;\nusing namespace std;\nconst double eps=1e-8;\nconst int MAXN=(int)2e5+5;\nconst int MOD=(int)1e9+7;\nconst int INF=0x3f3f3f3f;\nconst int dx[]={-1,1,0,0};\nconst int dy[]={0,0,-1,1};\nint a[MAXN],ans;\nbool check(int l,int r)\n{\n    if(l>=r)return false;\n    set<int> s;\n    for (int i = l; i < r; i++)s.insert(a[i]);\n    if(s.size()==r-l&&*max_element(a+l,a+r)==r-l)return true;else return false;\n    \n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T,n,m;\n    cin>>T;\n    while (T--)\n    {\n        cin>>n;\n        for (int i = 0; i < n; i++)cin>>a[i];\n        m=*max_element(a,a+n);\n        ans=3;\n        if(!check(0,m)||!check(m,n))ans-=1;\n        if(n==m*2||!check(0,n-m)||!check(n-m,n))ans-=2;\n        cout<<ceil(ans/2.0)<<endl;\n        if(ans&1)cout<<m<<\" \"<<n-m<<endl;\n        if(ans&2)cout<<n-m<<\" \"<<m<<endl;\n    }\n    \n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*ckpeteryu*/\n#include<iostream>\n#include<iomanip>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<bitset>\n#include<string>\n#include<ctime>\n#include<functional>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define FOR(i,s,e) for(int i=(s);i<(int)(e);i++)\n#define FOE(i,s,e) for(int i=(s);i<=(int)(e);i++)\n#define FOD(i,s,e) for(int i=(s);i>=(int)(e);i--)\n#define FORVEC(i,a) for(int i=0;i<(int)((a).size());i++)\n#define pb push_back\n#define mp make_pair\n#define CLR(s,x) memset(s,x,sizeof(s))\n#define LL long long int\n#define L long int\n\nint n;\nvector<int> v;\nvector<int> vlen;\nint ans=0;\n\nint main(int argc, char **argv){\n\t//ios_base::sync_with_stdio(false);\t\n\tscanf(\"%d\",&n);\n\tint a[n+10];\n\tint lev[n+10];\n\tFOE(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tif(n==1)printf(\"1\");\n\telse if(n==2){\n\t\tif(a[1]==1e9 && a[2]==1)printf(\"1\");else printf(\"2\");\n\t}else{\t\t\n\t\tfill(lev,lev+n+10,1);\t\t\n\t\tint val=1;\n\t\tFOE(i,2,n){\n\t\t\tif(a[i]>a[i-1]){\n\t\t\t\tval=lev[i]=lev[i-1]+1;\n\t\t\t}else{\n\t\t\t\tvlen.pb(val);\n\t\t\t\tv.pb(i);\n\t\t\t\tval=1;\n\t\t\t}\n\t\t}\n\t\tvlen.pb(val);\n\t\t\t\t\n\t\ta[0]=-1;\n\t\t\n\t\tint sz=v.size();\n\t\tint ans=0;\n\t\t\n\t\tint len=vlen.size();\n\t\tFOR(i,0,len){\n\t\t\tans=max(vlen[i],ans);\n\t\t}\t\t\t\n\t\t\n\t\tif(!sz){\n\t\t\tprintf(\"%d\",vlen[0]);\n\t\t}else{\n\t\t    if(len>=2 && lev[1]==1 && lev[2]==1){\t\t\t\t\t\t\t\n\t\t\t\tans=max(ans,vlen[1]+1);\n\t\t\t}\n\t\t\tif(v[sz-1]==n){\t\t\t\t\n\t\t\t\tans=max(vlen[sz-1]+1,ans);\n\t\t\t\tsz--;\n\t\t\t}\t\t\t\t\n\t\t\tFOR(i,0,sz){\t\t\t\n\t\t\t\tif(a[v[i]+1]-a[v[i]-1]>=2 || (a[v[i]+1]-a[v[i]-2]>=3 && a[v[i]]-a[v[i]-2]>=2)){\n\t\t\t\t\tans=max(vlen[i]+vlen[i+1],ans);\n\t\t\t\t}else if(a[v[i]-1]<1e9){\n\t\t\t\t\tans=max(vlen[i]+1,ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\",ans);\n\t\t}\t\t\t\t\n\t\t\t\t\n\t\t/*puts(\"\");\n\t\tFOE(i,1,n)cout<<lev[i]<<\" \";puts(\"\");\n\t\tFOR(i,0,v.size())cout<<v[i]<<\" \";puts(\"\");\n\t\tFOR(i,0,vlen.size())cout<<vlen[i]<<\" \";puts(\"\");*/\n\t}\n\treturn 0;\n}",
        "fixed_code": "/*ckpeteryu*/\n#include<iostream>\n#include<iomanip>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<bitset>\n#include<string>\n#include<ctime>\n#include<functional>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define FOR(i,s,e) for(int i=(s);i<(int)(e);i++)\n#define FOE(i,s,e) for(int i=(s);i<=(int)(e);i++)\n#define FOD(i,s,e) for(int i=(s);i>=(int)(e);i--)\n#define FORVEC(i,a) for(int i=0;i<(int)((a).size());i++)\n#define pb push_back\n#define mp make_pair\n#define CLR(s,x) memset(s,x,sizeof(s))\n#define LL long long int\n#define L long int\n\nint n;\nvector<int> v;\nvector<int> vlen;\nint ans=0;\n\nint main(int argc, char **argv){\n\t//ios_base::sync_with_stdio(false);\t\n\tscanf(\"%d\",&n);\n\tint a[n+10];\n\tint lev[n+10];\n\tFOE(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tif(n==1)printf(\"1\");\n\telse if(n==2){\n\t\tif(a[1]==1e9 && a[2]==1)printf(\"1\");else printf(\"2\");\n\t}else{\t\t\n\t\tfill(lev,lev+n+10,1);\t\t\n\t\tint val=1;\n\t\tFOE(i,2,n){\n\t\t\tif(a[i]>a[i-1]){\n\t\t\t\tval=lev[i]=lev[i-1]+1;\n\t\t\t}else{\n\t\t\t\tvlen.pb(val);\n\t\t\t\tv.pb(i);\n\t\t\t\tval=1;\n\t\t\t}\n\t\t}\n\t\tvlen.pb(val);\n\t\t\t\t\n\t\ta[0]=-1;\n\t\t\n\t\tint sz=v.size();\n\t\tint ans=0;\n\t\t\n\t\tint len=vlen.size();\n\t\tFOR(i,0,len){\n\t\t\tans=max(vlen[i],ans);\n\t\t}\t\t\t\n\t\t\n\t\tif(!sz){\n\t\t\tprintf(\"%d\",vlen[0]);\n\t\t}else{\n\t\t    if(len>=2 && lev[1]==1 && lev[2]==1){\t\t\t\t\t\t\t\n\t\t\t\tans=max(ans,vlen[1]+1);\n\t\t\t}\n\t\t\tif(v[sz-1]==n){\t\t\t\t\n\t\t\t\tans=max(vlen[sz-1]+1,ans);\n\t\t\t\tsz--;\n\t\t\t}\t\t\t\t\n\t\t\tFOR(i,0,sz){\t\t\t\n\t\t\t\tif(a[v[i]+1]-a[v[i]-1]>=2 || (a[v[i]+1]-a[v[i]-2]>=3 && a[v[i]]-a[v[i]-2]>=2)){\n\t\t\t\t\tans=max(vlen[i]+vlen[i+1],ans);\t\t\t\t\n\t\t\t\t}\n\t\t\t\tans=max(vlen[i]+1,ans);\n\t\t\t\tans=max(vlen[i+1]+1,ans);\n\t\t\t}\n\t\t\tprintf(\"%d\",ans);\n\t\t}\t\t\t\t\n\t\t\t\t\n\t\t/*puts(\"\");\n\t\tFOE(i,1,n)cout<<lev[i]<<\" \";puts(\"\");\n\t\tFOR(i,0,v.size())cout<<v[i]<<\" \";puts(\"\");\n\t\tFOR(i,0,vlen.size())cout<<vlen[i]<<\" \";puts(\"\");*/\n\t}\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nusing ll = long long;\n\nint const nmax = 100;\nchar v[1 + nmax][1 + nmax];\nint n, m;\n\nbool check(int i, int j, int k, char ch){\n  if(i + k - 1 <= n && j + k - 1 <= m) {\n    for(int x = 0; x < k; x++)\n      if(v[i][j + x] != 0 || v[i + x][j] != 0)\n        return 0;\n    for(int x = 0; x < k; x++)\n      if(v[i - 1][j + x] == ch || v[i + x][j - 1] == ch)\n        return 0;\n    if(v[i][j + k] == ch)\n      return 0;\n    return 1;\n  } else\n    return 0;\n}\n\nvoid place(int i, int j, int k, int ch){\n  for(int x = i; x < i + k; x++)\n    for(int y = j; y < j + k; y++)\n      v[x][y] = ch;\n}\n\nint main()\n{\n  cin >> n >> m;\n  for(int i = 1;i <= n; i++)\n    for(int j = 1;j <= m; j++)\n      if(v[i][j] == 0){\n        if(check(i, j, 1, 'a') == 1){\n          int sz = 1;\n          while(check(i, j, sz + 1, 'a') == 1)\n            sz++;\n          place(i, j, sz, 'a');\n        } else if(check(i, j, 1, 'b') == 1){\n          int sz = 1;\n          while(check(i, j, sz + 1, 'b') == 1 && check(i, j + sz, 1, 'a') == 0)\n            sz++;\n          place(i, j, sz, 'b');\n        } else\n          place(i, j, 1, 'c');\n      }\n\n  for(int i = 1;i <= n; i++) {\n    for(int j = 1;j <= m; j++)\n      cout << (char)(v[i][j] - 'a' + 'A');\n    cout << '\\n';\n  }\n  return 0;\n}\n",
        "fixed_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nusing ll = long long;\n\nint const nmax = 100;\nchar v[1 + nmax][1 + nmax];\nint n, m;\n\nbool check(int i, int j, int k, char ch){\n  if(i + k - 1 <= n && j + k - 1 <= m) {\n    for(int x = 0; x < k; x++)\n      if(v[i][j + x] != 0 || v[i + x][j] != 0)\n        return 0;\n    for(int x = 0; x < k; x++)\n      if(v[i - 1][j + x] == ch || v[i + x][j - 1] == ch)\n        return 0;\n    if(v[i][j + k] == ch)\n      return 0;\n    return 1;\n  } else\n    return 0;\n}\n\nvoid place(int i, int j, int k, int ch){\n  for(int x = i; x < i + k; x++)\n    for(int y = j; y < j + k; y++)\n      v[x][y] = ch;\n}\n\nint main()\n{\n  cin >> n >> m;\n  for(int i = 1;i <= n; i++)\n    for(int j = 1;j <= m; j++)\n      if(v[i][j] == 0){\n        if(check(i, j, 1, 'a') == 1){\n          int sz = 1;\n          while(check(i, j, sz + 1, 'a') == 1)\n            sz++;\n          place(i, j, sz, 'a');\n        } else if(check(i, j, 1, 'b') == 1){\n          int sz = 1;\n          while(check(i, j, sz + 1, 'b') == 1 && check(i, j + sz, 1, 'a') == 0)\n            sz++;\n          place(i, j, sz, 'b');\n        } else if(check(i, j, 1, 'c') == 1) {\n          int sz = 1;\n          place(i, j, 1, 'c');\n          while(check(i, j, sz + 1, 'c') == 1 && check(i, j + sz, 1, 'a') == 0 && check(i, j + sz, 1, 'b') == 0)\n            sz++;\n          place(i, j, sz, 'c');\n        } else\n          place(i, j, 1, 'd');\n      }\n\n  for(int i = 1;i <= n; i++) {\n    for(int j = 1;j <= m; j++)\n      cout << (char)(v[i][j] - 'a' + 'A');\n    cout << '\\n';\n  }\n  return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 1e5 + 10;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 9;\nint min(int a, int b) {return a < b ? a : b;}\nint max(int a, int b) {return a > b ? a : b;}\n\n/*main..............................................................................*/\nint par[MAXN], power[MAXN];\n\nint find(int x)\n{\n    if(x == par[x]) return x;\n    else return par[x] = find(par[x]);\n}\n\nint main()\n{\n    //freopen(\"data.in\", \"r\", stdin);\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    for(int i = 1; i <= n; i++) par[i] = i;\n    \n    power[0] = 1;\n    for(int i = 1; i <= n; i++) power[i] = power[i - 1] * 2 % MOD;\n\n    int tot = 0;\n    for(int i = 0; i < m; i++)\n    {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n\n        u = find(u), v = find(v);\n        if(u != v)\n        {\n            par[u] = v;\n        }\n        else\n        {\n            tot++;\n        }\n\n        printf(\"%d\\n\", (power[tot] + MOD - 1) % MOD);\n    }\n    return 0;\n}",
        "fixed_code": "#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 1e5 + 10;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 9;\nint min(int a, int b) {return a < b ? a : b;}\nint max(int a, int b) {return a > b ? a : b;}\n\n/*main..............................................................................*/\nint par[MAXN], power[MAXN];\n\nint find(int x)\n{\n    if(x == par[x]) return x;\n    else return par[x] = find(par[x]);\n}\n\nint main()\n{\n    //freopen(\"data.in\", \"r\", stdin);\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    for(int i = 1; i <= n; i++) par[i] = i;\n    \n    power[0] = 1;\n    for(int i = 1; i <= m; i++) power[i] = power[i - 1] * 2 % MOD;\n\n    int tot = 0;\n    for(int i = 0; i < m; i++)\n    {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n\n        u = find(u), v = find(v);\n        if(u != v)\n        {\n            par[u] = v;\n        }\n        else\n        {\n            tot++;\n        }\n\n        printf(\"%d\\n\", (power[tot] + MOD - 1) % MOD);\n    }\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<cmath>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<iostream>\n#include<set>\nusing namespace std;\nlong long n,a[111111];\nlong long pw[33];\nmap<long long,long long>m;\nset<long long> st;\nint main()\n{\n\tcin>>n;\n\tif(n==100){cout<<27<<endl;return 0;}\n\tlong long mx=0;\n\tlong long mx2=0;\n\tlong long c2=0;\n\tlong long u;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(u=1;u<=30;u++){long long uu=pow(2,u);pw[u]=pow(2,u);}\n\tlong long ans1=0,ans2=0;\n\tfor(long long i=1;i<=30;i++)\n\t{\t\n\t\tm.clear();\n\t\tst.clear();\n\t\t//memset(m,0,999999999);\n\t\tvector<long long>yx;\n\t\tfor(long long j=1;j<=n;j++)\n\t\t{\n\t\t\tif(pw[i]>a[j]){m[a[j]]++;if(!st.count(a[j]))yx.push_back(a[j]),st.insert(a[j]);}\n\t\t}\n\t\tfor(long long j=0;j<yx.size();j++)\n\t\t{\n\t\t\tif(yx[j]!=pw[i]/2)\n\t\t\tans1+=m[yx[j]]*m[pw[i]-yx[j]];\n\t\t\telse ans2+=m[yx[j]]*(m[yx[j]]-1)/2; \n\t\t\t//if()cout<<yx[j]<<\" \"<<pw[i]-yx[j]<<\" \"<<m[yx[j]]<<\" \"<<m[pw[i]-yx[j]]<<endl;\n\t\t}\n\t}\n\tcout<<ans1/2+ans2<<endl;\n\treturn 0;\n}",
        "fixed_code": "#include<cmath>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<iostream>\n#include<set>\nusing namespace std;\nlong long n,a[111111];\nlong long pw[33];\nmap<long long,long long>m;\nset<long long> st;\nint main()\n{\n\tcin>>n;\n\t//if(n==100){cout<<27<<endl;return 0;}\n\tlong long mx=0;\n\tlong long mx2=0;\n\tlong long c2=0;\n\tlong long u;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(u=1;u<=30;u++){long long uu=pow(2,u);pw[u]=pow(2,u);}\n\tlong long ans1=0,ans2=0;\n\tfor(long long i=1;i<=30;i++)\n\t{\t\n\t\tm.clear();\n\t\tst.clear();\n\t\t//memset(m,0,999999999);\n\t\tvector<long long>yx;\n\t\tfor(long long j=1;j<=n;j++)\n\t\t{\n\t\t\tif(pw[i]>a[j]){m[a[j]]++;if(!st.count(a[j]))yx.push_back(a[j]),st.insert(a[j]);}\n\t\t}\n\t\tfor(long long j=0;j<yx.size();j++)\n\t\t{\n\t\t\tif(yx[j]!=pw[i]/2)\n\t\t\tans1+=m[yx[j]]*m[pw[i]-yx[j]];\n\t\t\telse ans2+=m[yx[j]]*(m[yx[j]]-1)/2; \n\t\t\t//if()cout<<yx[j]<<\" \"<<pw[i]-yx[j]<<\" \"<<m[yx[j]]<<\" \"<<m[pw[i]-yx[j]]<<endl;\n\t\t}\n\t}\n\tcout<<ans1/2+ans2<<endl;\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define ll long long\n#define pb push_back\n//////////////////////////\nconst int oo = 1e9 + 9;\nconst ll inf = 1e18 + 18;\nconst int max6 = 1e6 + 6;\nconst int modx = 1e9 + 123;\nconst int mody = 997;\nconst int base = 137;\ntypedef pair <int,int> ii;\n//////////////////////////\nint a[5];\n\n//////////////////////////\nmain()\n{\n#define file \"\"\n#ifndef ONLINE_JUDGE\n    freopen(file\"inp\",\"r\",stdin);\n    freopen(file\"out\",\"w\",stdout);\n#endif // ONLINE_JUDGE\n\n    int t;\n    cin >> t;\n\n    while (t -- )\n    {\n        for (int i = 0; i <= 2; ++i)\n            cin >> a[i];\n\n        int pre = -oo;\n        string res = \"\";\n        for (int i = 1; i <= a[0]+1; ++i)\n            res += \"0\",pre = 0;\n\n        if (pre == -oo)\n        {\n            if (a[1]%2)\n            {\n                res += \"0\";\n                for (int i = 1; i <= a[1]; ++i)\n                    res += '0'+i%2,pre = i%2;\n            }\n            else if (a[1])\n            {\n                res += \"1\";\n                for (int i = 1; i <= a[1]; ++i)\n                    res += '1'-i%2,pre = 1-i%2;\n            }\n        }\n        else\n        {\n            if (a[1] && a[1]%2 == 0)\n            {\n                res = \"1\"+res;\n                a[1]--;\n            }\n\n            for (int i = 1; i <= a[1]; ++i)\n                res += '0'+i%2,pre = i%2;\n        }\n\n        if (pre == -oo)\n            for (int i = 1; i <= a[2]+1; ++i)\n                res += \"1\";\n        else\n            for (int i = 1; i <= a[2]; ++i)\n            res += \"1\";\n        cout<<res<<\"\\n\";\n    }\n}\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define ll long long\n#define pb push_back\n//////////////////////////\nconst int oo = 1e9 + 9;\nconst ll inf = 1e18 + 18;\nconst int max6 = 1e6 + 6;\nconst int modx = 1e9 + 123;\nconst int mody = 997;\nconst int base = 137;\ntypedef pair <int,int> ii;\n//////////////////////////\nint a[5];\n\n//////////////////////////\nmain()\n{\n#define file \"\"\n#ifndef ONLINE_JUDGE\n    freopen(file\"inp\",\"r\",stdin);\n    freopen(file\"out\",\"w\",stdout);\n#endif // ONLINE_JUDGE\n\n    int t;\n    cin >> t;\n\n    while (t -- )\n    {\n        for (int i = 0; i <= 2; ++i)\n            cin >> a[i];\n\n        int pre = -oo;\n        string res = \"\";\n        if (a[0])\n            for (int i = 1; i <= a[0]+1; ++i)\n                res += \"0\",pre = 0;\n\n        if (pre == -oo)\n        {\n            if (a[1]%2)\n            {\n                for (int i = 0; i <= a[1]; ++i)\n                    res += '0'+i%2,pre = i%2;\n            }\n            else if (a[1])\n            {\n                for (int i = 1; i <= a[1]+1; ++i)\n                    res += '0'+i%2,pre = i%2;\n            }\n        }\n        else\n        {\n            if (a[1] >= 2 && a[1]%2 == 0)\n                a[1]--,res = \"1\"+res;\n            for (int i = 1; i <= a[1]; ++i)\n                res += '0'+i%2,pre = i%2;\n        }\n\n        if (pre == -oo)\n            for (int i = 1; i <= a[2]+1; ++i)\n                res += \"1\";\n        else for (int i = 1; i <= a[2]; ++i)\n                res += \"1\";\n        cout<<res<<\"\\n\";\n    }\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.Scanner;\r\n\r\npublic class A1613 {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner s = new Scanner(System.in);\r\n        int noOfComparison = s.nextInt();\r\n        for (int i = 0; i < noOfComparison; i++) {\r\n            int x1 = s.nextInt();\r\n            int p1 = s.nextInt();\r\n            int x2 = s.nextInt();\r\n            int p2 = s.nextInt();\r\n            compare(x1, p1, x2, p2);\r\n        }\r\n    }\r\n\r\n    private static void compare(int x1, int p1, int x2, int p2) {\r\n        while (x1 % 10 == 0) {\r\n            x1 /= 10;\r\n            p1++;\r\n        }\r\n        while (x2 % 10 == 0) {\r\n            x2 /= 10;\r\n            p2++;\r\n        }\r\n        if (p1 > p2) {\r\n            System.out.println(\">\");\r\n        } else if (p2 > p1) {\r\n            System.out.println(\"<\");\r\n        } else {\r\n            if (x1 > x2) {\r\n                System.out.println(\">\");\r\n            } else if (x2 > x1) {\r\n                System.out.println(\"<\");\r\n            } else {\r\n                System.out.println(\"=\");\r\n            }\r\n        }\r\n    }\r\n}",
        "fixed_code": "import java.util.Scanner;\r\n\r\npublic class A1613 {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner s = new Scanner(System.in);\r\n        int noOfComparison = s.nextInt();\r\n        for (int i = 0; i < noOfComparison; i++) {\r\n            int x1 = s.nextInt();\r\n            int p1 = s.nextInt();\r\n            int x2 = s.nextInt();\r\n            int p2 = s.nextInt();\r\n            compare(x1, p1, x2, p2);\r\n        }\r\n    }\r\n\r\n    private static void compare(int x1, int p1, int x2, int p2) {\r\n        while (x1 % 10 == 0) {\r\n            x1 /= 10;\r\n            p1++;\r\n        }\r\n        while (x2 % 10 == 0) {\r\n            x2 /= 10;\r\n            p2++;\r\n        }\r\n        if (p1 > p2) {\r\n            x1 *= Math.pow(10, (p1 - p2));\r\n        } else if (p2 > p1) {\r\n            x2 *= Math.pow(10, p2-p1);\r\n        }\r\n        directCompare(x1, x2);\r\n    }\r\n\r\n    private static void directCompare(int x1, int x2) {\r\n\r\n        if (x1 > x2) {\r\n            System.out.println(\">\");\r\n        } else if (x2 > x1) {\r\n            System.out.println(\"<\");\r\n        } else {\r\n            System.out.println(\"=\");\r\n        }\r\n    }\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.StringTokenizer;\r\nimport java.util.*;\r\n\r\npublic class B_Eastern_Exhibition {\r\n\r\n    public static void main(String[] args) {\r\n        FastScanner fs = new FastScanner();\r\n        int T = fs.nextInt();\r\n        outer: while (T-- > 0) {\r\n            int n = fs.nextInt();\r\n            int[] x = new int[n];\r\n            int[] y = new int[n];\r\n            for (int i = 0; i < n; i++) {\r\n                x[i] = fs.nextInt();\r\n                y[i] = fs.nextInt();\r\n            }\r\n            if (n % 2 != 0) {\r\n                System.out.println(1);\r\n                continue outer;\r\n            }\r\n            Arrays.sort(x);\r\n            Arrays.sort(y);\r\n            n--;\r\n            int inX = x[n / 2 + 1] - x[n / 2] + 1;\r\n            int inY = y[n / 2 + 1] - y[n / 2] + 1;\r\n            System.out.println(inX * inY);\r\n        }\r\n\r\n    }\r\n\r\n    static final int mod = 1_000_000_007;\r\n\r\n    static long mul(long a, long b) {\r\n        return a * b % mod;\r\n    }\r\n\r\n    static long fact(int x) {\r\n        long ans = 1;\r\n        for (int i = 2; i <= x; i++)\r\n            ans = mul(ans, i);\r\n        return ans;\r\n    }\r\n\r\n    static long fastPow(long base, long exp) {\r\n        if (exp == 0)\r\n            return 1;\r\n        long half = fastPow(base, exp / 2);\r\n        if (exp % 2 == 0)\r\n            return mul(half, half);\r\n        return mul(half, mul(half, base));\r\n    }\r\n\r\n    static long modInv(long x) {\r\n        return fastPow(x, mod - 2);\r\n    }\r\n\r\n    static long nCk(int n, int k) {\r\n        return mul(fact(n), mul(modInv(fact(k)), modInv(fact(n - k))));\r\n    }\r\n\r\n    static class FastScanner {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        StringTokenizer st = new StringTokenizer(\"\");\r\n\r\n        String next() {\r\n            while (!st.hasMoreTokens())\r\n                try {\r\n                    st = new StringTokenizer(br.readLine());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            return st.nextToken();\r\n        }\r\n\r\n        int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        int[] readArray(int n) {\r\n            int[] a = new int[n];\r\n            for (int i = 0; i < n; i++)\r\n                a[i] = nextInt();\r\n            return a;\r\n        }\r\n\r\n        long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n}\r\n",
        "fixed_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.StringTokenizer;\r\nimport java.util.*;\r\n\r\npublic class B_Eastern_Exhibition {\r\n\r\n    public static void main(String[] args) {\r\n        FastScanner fs = new FastScanner();\r\n        int T = fs.nextInt();\r\n        outer: while (T-- > 0) {\r\n            int n = fs.nextInt();\r\n            int[] x = new int[n];\r\n            int[] y = new int[n];\r\n            for (int i = 0; i < n; i++) {\r\n                x[i] = fs.nextInt();\r\n                y[i] = fs.nextInt();\r\n            }\r\n            if (n % 2 != 0) {\r\n                System.out.println(1);\r\n                continue outer;\r\n            }\r\n            Arrays.sort(x);\r\n            Arrays.sort(y);\r\n            n--;\r\n            long inX = x[n / 2 + 1] - x[n / 2] + 1;\r\n            long inY = y[n / 2 + 1] - y[n / 2] + 1;\r\n            System.out.println(inX * inY);\r\n        }\r\n\r\n    }\r\n\r\n    static final int mod = 1_000_000_007;\r\n\r\n    static long mul(long a, long b) {\r\n        return a * b % mod;\r\n    }\r\n\r\n    static long fact(int x) {\r\n        long ans = 1;\r\n        for (int i = 2; i <= x; i++)\r\n            ans = mul(ans, i);\r\n        return ans;\r\n    }\r\n\r\n    static long fastPow(long base, long exp) {\r\n        if (exp == 0)\r\n            return 1;\r\n        long half = fastPow(base, exp / 2);\r\n        if (exp % 2 == 0)\r\n            return mul(half, half);\r\n        return mul(half, mul(half, base));\r\n    }\r\n\r\n    static long modInv(long x) {\r\n        return fastPow(x, mod - 2);\r\n    }\r\n\r\n    static long nCk(int n, int k) {\r\n        return mul(fact(n), mul(modInv(fact(k)), modInv(fact(n - k))));\r\n    }\r\n\r\n    static class FastScanner {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        StringTokenizer st = new StringTokenizer(\"\");\r\n\r\n        String next() {\r\n            while (!st.hasMoreTokens())\r\n                try {\r\n                    st = new StringTokenizer(br.readLine());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            return st.nextToken();\r\n        }\r\n\r\n        int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        int[] readArray(int n) {\r\n            int[] a = new int[n];\r\n            for (int i = 0; i < n; i++)\r\n                a[i] = nextInt();\r\n            return a;\r\n        }\r\n\r\n        long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n    }\r\n\r\n}\r\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <map>\r\n#include <cmath>\r\n#include <set>\r\n\r\nusing namespace std;\r\nvector<int> arr;\r\nvector<int> ones;\r\nconst long long INF = 1e13;\r\nint main() {\r\n    int n;\r\n    cin >> n;\r\n    arr.resize(n);\r\n    long long dp[n + 1][n + 1];\r\n    for(int i = 0; i < n; i++){\r\n        cin >> arr[i];\r\n        if(arr[i] == 1){\r\n            ones.push_back(i);\r\n        }\r\n    }\r\n    for(int i = 0; i <= n; i++){\r\n        for(int j = 0; j <= n; j++){\r\n            dp[i][j] = INF;\r\n        }\r\n    }\r\n    for(int i = 0; i < n; i++){\r\n        for(int j = 0; j <= ones.size(); j++){\r\n            if(i < j){\r\n                dp[i][j] = INF;\r\n                continue;\r\n            }\r\n            if(j == 0){\r\n                dp[i][j] = 0;\r\n                continue;\r\n            }\r\n            if(arr[i] == 0){\r\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + abs(ones[j - 1] - i));\r\n            }else{\r\n                dp[i][j] = dp[i - 1][j];\r\n            }\r\n        }\r\n    }\r\n    cout << dp[n - 1][ones.size()] << endl;\r\n}",
        "fixed_code": "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <map>\r\n#include <cmath>\r\n#include <set>\r\n\r\nusing namespace std;\r\nvector<int> arr;\r\nvector<int> ones;\r\nconst long long INF = 1e13;\r\nint main() {\r\n    int n;\r\n    cin >> n;\r\n    arr.resize(n);\r\n    long long dp[n + 1][n + 1];\r\n    for(int i = 0; i < n; i++){\r\n        cin >> arr[i];\r\n        if(arr[i] == 1){\r\n            ones.push_back(i);\r\n        }\r\n    }\r\n    for(int i = 0; i <= n; i++){\r\n        for(int j = 0; j <= n; j++){\r\n            dp[i][j] = INF;\r\n        }\r\n        dp[i][0] = 0;\r\n    }\r\n    for(int i = 1; i <= n; i++){\r\n        for(int j = 1; j <= ones.size(); j++){\r\n            if(arr[i - 1] == 0){\r\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + abs(ones[j - 1] - i + 1));\r\n            }else{\r\n                dp[i][j] = dp[i - 1][j];\r\n            }\r\n        }\r\n    }\r\n    cout << dp[n][ones.size()] << endl;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "private boolean navigateToMyLocation() {\n    android.location.Location location = getMyLocation();\n    if (location != null) {\n        googleMap.animateCamera(com.google.android.gms.maps.CameraUpdateFactory.newLatLngZoom(new com.google.android.gms.maps.model.LatLng(location.getLatitude(), location.getLongitude()), 17));\n        com.google.android.gms.maps.model.CameraPosition cameraPosition = new com.google.android.gms.maps.model.CameraPosition.Builder().target(new com.google.android.gms.maps.model.LatLng(location.getLatitude(), location.getLongitude())).zoom(17).bearing(0).tilt(10).build();\n        googleMap.animateCamera(com.google.android.gms.maps.CameraUpdateFactory.newCameraPosition(cameraPosition));\n        return true;\n    }else\n        return false;\n    \n}",
        "fixed_code": "private boolean checkIfLocationEnabled() {\n    try {\n        gps_enabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);\n    } catch (java.lang.Exception ex) {\n    }\n    try {\n        network_enabled = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);\n    } catch (java.lang.Exception ex) {\n    }\n    if ((!(gps_enabled)) && (!(network_enabled)))\n        return false;\n    else\n        return true;\n    \n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "/*\n���� ���ݷ�Χ ���� ʵ��\n*/\n/*\n�ع���̬\n������̬\n*/\n\n/*\nÿ���õ�����һ���߶���һ������\n\n��������  ������һ��x ����y1��y2\n���Ǻ��ŵ� ���ŵĵ�ǰ����x���м��� ���仰˵ ��֮ǰ��\nĳһ�㿪ʼ ���һ�û�н��� ����y����y1��y2֮����м���\n\n�ٿ������ŵ� �Ӻ���ǰ����\n�ֱ���ÿһ��\n�õ�һ��\nyu=min(y2,y2)\nyd=max(y1,y1)\n\n���ǵ�ǰ���ŵĴ������֮��ĸ��� ���߶���ά��\n2*1/2+3*2/2+\n�����Ŵ�ǰ��������߶�����һ�µ����\n\n����һ��xһ��y\n\n��֪һ������ ��������λ��y1��y2֮��ĺ���\nÿ�ο���һ������\n2.5*10^6*log2500=5*10^7\n\n�Ѳ��ɶ�ÿ����ά��һ���߶���\n������n*nlog=n^2*log\n\n�������е����� һ��ʼ�Ͱ�����ǰ������Ҵ����ҵ����к��߼���\n�����ڱ�����ʱ�� ������һ������ �ʹ���ȥ����Щ�������޵�\n\n\n��������ÿһ������(x1,y1,x2,y1) ע�⴦������Ǵ��ĸ��ط���ʧx2 ������Щ�ط����ֹ�x1...\n\n1.��ɢ����������\n2.���еĺ��߼�����ʵ�λ�ã�������ʧ\n3.��ʼģ��\n\nÿ��x��Ӧ����2���¼�����ʧ�ʹ� �ȼ�����ʧ�����Ӵ�\n*/\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=5e3+5;\nconst int MAXM=25+5;\nconst int MOD=1e9+7;\nconst double pi=3.1415926535;\nint n,sum[MAXN][MAXN<<1],rec[MAXN][4],xx[MAXN<<1],yy[MAXN<<1],cnt1,cnt2;\nll ans;\nvector<int>eds[MAXN<<1];\nvector<int>vv[MAXN<<1];\nvoid init()\n{\n    cnt1=cnt2=ans=0;\n    for(ll i=0;i<=25;i++)\n    {\n        eds[i].clear();\n        vv[i].clear();\n    }\n    memset(sum,0,sizeof(sum));\n}\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid update(int op,int x,int y)\n{\n    for(int i=x;i<=n;i+=lowbit(i))\n    {\n        sum[op][i]+=y;\n    }\n}\nint query(int op,int x)\n{\n    int ans=0;\n    for(int i=x;i>0;i-=lowbit(i))\n    {\n       ans+=sum[op][i];\n    }\n    return ans;\n}\nint qq(int op,int x,int y)\n{\n    return query(op,y)-query(op,x-1);\n}\nvoid add(int op,int p)\n{\n    update(op,p,1);\n}\nvoid sub(int op,int p)\n{\n    update(op,p,-1);\n}\nbool ishengxian(int i)\n{\n    return rec[i][1]==rec[i][3];\n}\nbool isshuxian(int i)\n{\n    return rec[i][0]==rec[i][2];\n}\nint Hash1(int x)\n{\n    return lower_bound(xx+1,xx+1+cnt1,x)-xx;\n}\nint Hash2(int x)\n{\n    return lower_bound(yy+1,yy+1+cnt2,x)-yy;\n}\n\nvoid processvv()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(isshuxian(i))\n        {\n            int p=Hash1(rec[i][0]);\n            vv[p].push_back(i);\n        }\n    }\n}\nvoid processjoin()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(ishengxian(i))\n        {\n           // vector<pair<int,int> >tem;\n            int st=Hash1(rec[i][0]);\n            int ed=Hash1(rec[i][2]);\n            int hh=Hash2(rec[i][1]);\n            if(st>ed)\n            {\n                swap(st,ed);\n            }\n            for(int j=st;j<=ed;j++)\n            {\n                for(int k=0;k<vv[j].size();k++)\n                {\n                    add(vv[j][k],hh);\n                    //tem.push_back(make_pair(vv[j][k],hh));\n                }\n            }\n            eds[ed+1].push_back(i);\n           // byebye[ed].push_back(tem);\n        }\n    }\n}\n\nvoid solve()\n{\n    sort(xx+1,xx+1+cnt1);\n    cnt1=unique(xx+1,xx+1+cnt1)-xx-1;\n    sort(yy+1,yy+1+cnt2);\n    cnt2=unique(yy+1,yy+1+cnt2)-yy-1;\n    processvv();\n    processjoin();\n\n    for(int i=1;i<=cnt1;i++)\n    {\n        for(int j=0;j<eds[i].size();j++)\n        {\n            int theone=eds[i][j];\n            int st=Hash1(rec[theone][0]);\n            int ed=Hash1(rec[theone][2]);\n            if(st>ed)\n            {\n                swap(st,ed);\n            }\n            int hh=Hash2(rec[theone][1]);\n            for(int jj=st;jj<=ed;jj++)\n            {\n                for(int k=0;k<vv[jj].size();k++)\n                {\n                   // add(vv[j][k],hh);\n                    sub(vv[jj][k],hh);\n                }\n            }\n        }\n        for(int j=0;j<vv[i].size();j++)\n        {\n            int YUNow=rec[vv[i][j]][1];\n            int YDNow=rec[vv[i][j]][3];\n            if(YUNow<YDNow)\n            {\n                swap(YUNow,YDNow);\n            }\n            for(int k=1;k<i;k++)\n            {\n                for(int kk=0;kk<vv[k].size();kk++)\n                {\n                    int YUPre=rec[vv[k][kk]][1];\n                    int YDPre=rec[vv[k][kk]][3];\n                    if(YUPre<YDPre)\n                    {\n                        swap(YUPre,YDPre);\n                    }\n                    int YUT=min(YUNow,YUPre);\n                    int YDT=max(YDNow,YDPre);\n                    if(YUT>YDT)\n                    {\n                        int num=qq(vv[k][kk],Hash2(YDT),Hash2(YUT));\n                        ans+=(ll)num*((ll)num-1)/2;\n                    }\n                }\n            }\n        }\n\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main()\n{\n\n//    freopen(\"c://duipai//data.txt\",\"r\",stdin);\n//    freopen(\"c://duipai//wa.txt\",\"w\",stdout);\n    while(~scanf(\"%d\",&n))\n    {\n        init();\n//        string str;\n//        cin>>str;\n//        cout<<str<<endl;\n        for(int i=1;i<=n;i++)\n        {\n            int x1,y1,x2,y2;\n            scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n            rec[i][0]=x1;\n            rec[i][1]=y1;\n            rec[i][2]=x2;\n            rec[i][3]=y2;\n            xx[++cnt1]=x1;\n            xx[++cnt1]=x2;\n            yy[++cnt2]=y1;\n            yy[++cnt2]=y2;\n        }\n        solve();\n\n    }\n}\n/*\n5\n1 1 1 3\n2 1 2 3\n1 3 2 3\n1 2 2 2\n1 1 2 1\n*/\n",
        "fixed_code": "/*\n���� ���ݷ�Χ ���� ʵ��\n*/\n/*\n�ع���̬\n������̬\n*/\n\n/*\nÿ���õ�����һ���߶���һ������\n\n��������  ������һ��x ����y1��y2\n���Ǻ��ŵ� ���ŵĵ�ǰ����x���м��� ���仰˵ ��֮ǰ��\nĳһ�㿪ʼ ���һ�û�н��� ����y����y1��y2֮����м���\n\n�ٿ������ŵ� �Ӻ���ǰ����\n�ֱ���ÿһ��\n�õ�һ��\nyu=min(y2,y2)\nyd=max(y1,y1)\n\n���ǵ�ǰ���ŵĴ������֮��ĸ��� ���߶���ά��\n2*1/2+3*2/2+\n�����Ŵ�ǰ��������߶�����һ�µ����\n\n����һ��xһ��y\n\n��֪һ������ ��������λ��y1��y2֮��ĺ���\nÿ�ο���һ������\n2.5*10^6*log2500=5*10^7\n\n�Ѳ��ɶ�ÿ����ά��һ���߶���\n������n*nlog=n^2*log\n\n�������е����� һ��ʼ�Ͱ�����ǰ������Ҵ����ҵ����к��߼���\n�����ڱ�����ʱ�� ������һ������ �ʹ���ȥ����Щ�������޵�\n\n\n��������ÿһ������(x1,y1,x2,y1) ע�⴦������Ǵ��ĸ��ط���ʧx2 ������Щ�ط����ֹ�x1...\n\n1.��ɢ����������\n2.���еĺ��߼�����ʵ�λ�ã�������ʧ\n3.��ʼģ��\n\nÿ��x��Ӧ����2���¼�����ʧ�ʹ� �ȼ�����ʧ�����Ӵ�\n*/\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=5e3+5;\nconst int MAXM=25+5;\nconst int MOD=1e9+7;\nconst double pi=3.1415926535;\nint n,sum[MAXN][MAXN<<1],rec[MAXN][4],xx[MAXN<<1],yy[MAXN<<1],cnt1,cnt2;\nll ans;\nvector<int>eds[MAXN<<1];\nvector<int>vv[MAXN<<1];\nvoid init()\n{\n    cnt1=cnt2=ans=0;\n    for(ll i=0;i<=25;i++)\n    {\n        eds[i].clear();\n        vv[i].clear();\n    }\n    memset(sum,0,sizeof(sum));\n}\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid update(int op,int x,int y)\n{\n    for(int i=x;i<=cnt2;i+=lowbit(i))\n    {\n        sum[op][i]+=y;\n    }\n}\nint query(int op,int x)\n{\n    int ans=0;\n    for(int i=x;i>0;i-=lowbit(i))\n    {\n       ans+=sum[op][i];\n    }\n    return ans;\n}\nint qq(int op,int x,int y)\n{\n    return query(op,y)-query(op,x-1);\n}\nvoid add(int op,int p)\n{\n    update(op,p,1);\n}\nvoid sub(int op,int p)\n{\n    update(op,p,-1);\n}\nbool ishengxian(int i)\n{\n    return rec[i][1]==rec[i][3];\n}\nbool isshuxian(int i)\n{\n    return rec[i][0]==rec[i][2];\n}\nint Hash1(int x)\n{\n    return lower_bound(xx+1,xx+1+cnt1,x)-xx;\n}\nint Hash2(int x)\n{\n    return lower_bound(yy+1,yy+1+cnt2,x)-yy;\n}\n\nvoid processvv()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(isshuxian(i))\n        {\n            int p=Hash1(rec[i][0]);\n            vv[p].push_back(i);\n        }\n    }\n}\nvoid processjoin()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(ishengxian(i))\n        {\n           // vector<pair<int,int> >tem;\n            int st=Hash1(rec[i][0]);\n            int ed=Hash1(rec[i][2]);\n            int hh=Hash2(rec[i][1]);\n            if(st>ed)\n            {\n                swap(st,ed);\n            }\n            for(int j=st;j<=ed;j++)\n            {\n                for(int k=0;k<vv[j].size();k++)\n                {\n                    add(vv[j][k],hh);\n                    //tem.push_back(make_pair(vv[j][k],hh));\n                }\n            }\n            eds[ed+1].push_back(i);\n           // byebye[ed].push_back(tem);\n        }\n    }\n}\n\nvoid solve()\n{\n    sort(xx+1,xx+1+cnt1);\n    cnt1=unique(xx+1,xx+1+cnt1)-xx-1;\n    sort(yy+1,yy+1+cnt2);\n    cnt2=unique(yy+1,yy+1+cnt2)-yy-1;\n    processvv();\n    processjoin();\n\n    for(int i=1;i<=cnt1;i++)\n    {\n        for(int j=0;j<eds[i].size();j++)\n        {\n            int theone=eds[i][j];\n            int st=Hash1(rec[theone][0]);\n            int ed=Hash1(rec[theone][2]);\n            if(st>ed)\n            {\n                swap(st,ed);\n            }\n            int hh=Hash2(rec[theone][1]);\n            for(int jj=st;jj<=ed;jj++)\n            {\n                for(int k=0;k<vv[jj].size();k++)\n                {\n                   // add(vv[j][k],hh);\n                    sub(vv[jj][k],hh);\n                }\n            }\n        }\n        for(int j=0;j<vv[i].size();j++)\n        {\n            int YUNow=rec[vv[i][j]][1];\n            int YDNow=rec[vv[i][j]][3];\n            if(YUNow<YDNow)\n            {\n                swap(YUNow,YDNow);\n            }\n            for(int k=1;k<i;k++)\n            {\n                for(int kk=0;kk<vv[k].size();kk++)\n                {\n                    int YUPre=rec[vv[k][kk]][1];\n                    int YDPre=rec[vv[k][kk]][3];\n                    if(YUPre<YDPre)\n                    {\n                        swap(YUPre,YDPre);\n                    }\n                    int YUT=min(YUNow,YUPre);\n                    int YDT=max(YDNow,YDPre);\n                    if(YUT>YDT)\n                    {\n                        int num=qq(vv[k][kk],Hash2(YDT),Hash2(YUT));\n                        ans+=(ll)num*((ll)num-1)/2;\n                    }\n                }\n            }\n        }\n\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main()\n{\n\n//    freopen(\"c://duipai//data.txt\",\"r\",stdin);\n//    freopen(\"c://duipai//wa.txt\",\"w\",stdout);\n    while(~scanf(\"%d\",&n))\n    {\n        init();\n//        string str;\n//        cin>>str;\n//        cout<<str<<endl;\n        for(int i=1;i<=n;i++)\n        {\n            int x1,y1,x2,y2;\n            scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n            rec[i][0]=x1;\n            rec[i][1]=y1;\n            rec[i][2]=x2;\n            rec[i][3]=y2;\n            xx[++cnt1]=x1;\n            xx[++cnt1]=x2;\n            yy[++cnt2]=y1;\n            yy[++cnt2]=y2;\n        }\n        solve();\n\n    }\n}\n/*\n5\n1 1 1 3\n2 1 2 3\n1 3 2 3\n1 2 2 2\n1 1 2 1\n*/\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "function(ele) {\n\t\tif (ele) {\n\t\t\tvar permalink = ele.parentNode.parentNode.firstChild.firstChild;\n\t\t\tif (permalink) {\n\t\t\t\t// check if we've already viewed the source.. if so just reveal it instead of loading...\n\t\t\t\tvar prevSib = ele.parentNode.parentNode.previousSibling;\n\t\t\t\tif (typeof(prevSib.querySelector) == 'undefined') prevSib = prevSib.previousSibling;\n\t\t\t\tvar sourceDiv = prevSib.querySelector('.viewSource');\n\t\t\t\tif (sourceDiv) {\n\t\t\t\t\tsourceDiv.style.display = 'block';\n\t\t\t\t} else {\n\t\t\t\t\tvar jsonURL = permalink.getAttribute('href');\n\t\t\t\t\tvar sourceLink = 'comment';\n\t\t\t\t\tif (hasClass(permalink, 'comments')) {\n\t\t\t\t\t\tsourceLink = 'selftext';\n\t\t\t\t\t}\n\t\t\t\t\tif (jsonURL.indexOf('?context') != -1) {\n\t\t\t\t\t\tjsonURL = jsonURL.replace('?context=3','.json?');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjsonURL += '/.json';\n\t\t\t\t\t}\n\t\t\t\t\tthis.viewSourceEle = ele;\n\t\t\t\t\tthis.viewSourceLink = sourceLink;\n\t\t\t\t\tjsonURL = RESUtils.insertParam(jsonURL,'app','res');\n\t\t\t\t\tGM_xmlhttpRequest({\n\t\t\t\t\t\tmethod:\t\"GET\",\n\t\t\t\t\t\turl:\tjsonURL,\n\t\t\t\t\t\tonload:\tfunction(response) {\n\t\t\t\t\t\t\tvar thisResponse = JSON.parse(response.responseText);\n\t\t\t\t\t\t\tvar userTextForm = document.createElement('div');\n\t\t\t\t\t\t\taddClass(userTextForm,'usertext-edit');\n\t\t\t\t\t\t\taddClass(userTextForm,'viewSource');\n\t\t\t\t\t\t\tif (modules['commentPreview'].viewSourceLink == 'comment') {\n\t\t\t\t\t\t\t\tvar sourceText = thisResponse[1].data.children[0].data.body;\n\t\t\t\t\t\t\t\tuserTextForm.innerHTML = '<div><textarea rows=\"1\" cols=\"1\" name=\"text\">' + sourceText + '</textarea></div><div class=\"bottom-area\"><div class=\"usertext-buttons\"><button type=\"button\" class=\"cancel\">hide</button></div></div>';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar sourceText = thisResponse[0].data.children[0].data.selftext;\n\t\t\t\t\t\t\t\tuserTextForm.innerHTML = '<div><textarea rows=\"1\" cols=\"1\" name=\"text\">' + sourceText + '</textarea></div><div class=\"bottom-area\"><div class=\"usertext-buttons\"><button type=\"button\" class=\"cancel\">hide</button></div></div>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar cancelButton = userTextForm.querySelector('.cancel');\n\t\t\t\t\t\t\tcancelButton.addEventListener('click', modules['commentPreview'].hideSource, false);\n\t\t\t\t\t\t\tvar prevSib = modules['commentPreview'].viewSourceEle.parentNode.parentNode.previousSibling;\n\t\t\t\t\t\t\tif (typeof(prevSib.querySelector) == 'undefined') prevSib = prevSib.previousSibling;\n\t\t\t\t\t\t\tprevSib.appendChild(userTextForm);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}",
        "fixed_code": "function(e) {\n\t\te.preventDefault();\n\t\tvar ele = e.target;\n\t\tif (ele) {\n\t\t\tvar permalink = ele.parentNode.parentNode.firstChild.firstChild;\n\t\t\tif (permalink) {\n\t\t\t\t// check if we've already viewed the source.. if so just reveal it instead of loading...\n\t\t\t\tvar prevSib = ele.parentNode.parentNode.previousSibling;\n\t\t\t\tif (typeof(prevSib.querySelector) == 'undefined') prevSib = prevSib.previousSibling;\n\t\t\t\tvar sourceDiv = prevSib.querySelector('.viewSource');\n\t\t\t\tif (sourceDiv) {\n\t\t\t\t\tsourceDiv.style.display = 'block';\n\t\t\t\t} else {\n\t\t\t\t\tvar jsonURL = permalink.getAttribute('href');\n\t\t\t\t\tvar sourceLink = 'comment';\n\t\t\t\t\tif (hasClass(permalink, 'comments')) {\n\t\t\t\t\t\tsourceLink = 'selftext';\n\t\t\t\t\t}\n\t\t\t\t\tif (jsonURL.indexOf('?context') != -1) {\n\t\t\t\t\t\tjsonURL = jsonURL.replace('?context=3','.json?');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjsonURL += '/.json';\n\t\t\t\t\t}\n\t\t\t\t\tmodules['commentPreview'].viewSourceEle = ele;\n\t\t\t\t\tmodules['commentPreview'].viewSourceLink = sourceLink;\n\t\t\t\t\tjsonURL = RESUtils.insertParam(jsonURL,'app','res');\n\t\t\t\t\tGM_xmlhttpRequest({\n\t\t\t\t\t\tmethod:\t\"GET\",\n\t\t\t\t\t\turl:\tjsonURL,\n\t\t\t\t\t\tonload:\tfunction(response) {\n\t\t\t\t\t\t\tvar thisResponse = JSON.parse(response.responseText);\n\t\t\t\t\t\t\tvar userTextForm = document.createElement('div');\n\t\t\t\t\t\t\taddClass(userTextForm,'usertext-edit');\n\t\t\t\t\t\t\taddClass(userTextForm,'viewSource');\n\t\t\t\t\t\t\tif (modules['commentPreview'].viewSourceLink == 'comment') {\n\t\t\t\t\t\t\t\tvar sourceText = thisResponse[1].data.children[0].data.body;\n\t\t\t\t\t\t\t\tuserTextForm.innerHTML = '<div><textarea rows=\"1\" cols=\"1\" name=\"text\">' + sourceText + '</textarea></div><div class=\"bottom-area\"><div class=\"usertext-buttons\"><button type=\"button\" class=\"cancel\">hide</button></div></div>';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar sourceText = thisResponse[0].data.children[0].data.selftext;\n\t\t\t\t\t\t\t\tuserTextForm.innerHTML = '<div><textarea rows=\"1\" cols=\"1\" name=\"text\">' + sourceText + '</textarea></div><div class=\"bottom-area\"><div class=\"usertext-buttons\"><button type=\"button\" class=\"cancel\">hide</button></div></div>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar cancelButton = userTextForm.querySelector('.cancel');\n\t\t\t\t\t\t\tcancelButton.addEventListener('click', modules['commentPreview'].hideSource, false);\n\t\t\t\t\t\t\tvar prevSib = modules['commentPreview'].viewSourceEle.parentNode.parentNode.previousSibling;\n\t\t\t\t\t\t\tif (typeof(prevSib.querySelector) == 'undefined') prevSib = prevSib.previousSibling;\n\t\t\t\t\t\t\tprevSib.appendChild(userTextForm);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}",
        "source": "FixJs_55551.json"
    },
    {
        "source_code": "a",
        "fixed_code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint main(){\n    int n,a=0,f=0,I=0;\n    cin>>n;\n    string s;\n    cin>>s;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='A')\n        a++;\n        if(s[i]=='F')\n        f++;\n         if(s[i]=='I')\n        I++;\n    }\n    int sum=0;\n/*\n    for(int i=0;i<s.size();i++){\n    if(s[i]=='A'){\n        a--;\n        if(I==0)\n        if(a>0||f>0)\n            sum++;\n\n            a++;\n    }\n    if(s[i]=='I'){\n        I--;\n        if(I==0&&a>0||f>0)\n            sum++;\n    }\n\n\n    }*/\n    if(I==0)\n        cout<<a;\n    else if(I>1)\n        cout<<0;\n    else if(I==1)\n        cout<<1;\n\n\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import math\r\nfor _ in range(int(input())):\r\n    p,a,b,c = map(int,input().split())\r\n    ar,br,cr = map(int,[math.ceil(p/a),math.ceil(p/b),math.ceil(p/c)])\r\n    print(min(a*ar-p,b*br-p,c*cr-p))\r\n",
        "fixed_code": "import math\r\nfor _ in range(int(input())):\r\n    p,a,b,c = map(int,input().split())\r\n    ar,br,cr = p%a,p%b,p%c\r\n    if ar == 0 or br == 0 or cr == 0 :\r\n        print(0)\r\n    else:\r\n        print(min(a-p%a,b-p%b,c-p%c))\r\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "//package goku;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class goku {\n\n    BufferedReader br;\n    PrintWriter out;\n    \n    long mod = (long) (1e9 + 7), inf = (long) (5e18);\n    \n    void spiritBomb() {\n        int n = ni(), d = ni() + 1;\n        long m = nl();\n        long a[] = new long[n];\n        for(int i = 0; i < n; i++)  a[i] = nl();\n        Arrays.sort(a);\n        \n        int n1 = 0;\n        for(int i = 0; i < n; i++)  if(a[i] <= m)   n1++;\n        int n2 = n - n1;\n        \n        if(n1 == 0) {\n            long ans = 0;       int j = n-1;\n            for(int i = 0; i < n; i += d) {\n                ans += a[j--];\n            }\n            out.println(ans);   return;\n        }\n        \n        long small[] = new long[n1 + 1];\n        long big[] = new long[n2 + 1];\n        int u = 1, v = 1;\n        for(int i = n-1; i >= 0; i--) {\n            if(i >= n1) {\n                big[u] = a[i] + big[u-1];\n                u++;\n            } else {\n                small[v] = a[i] + small[v-1];\n                v++;\n            }\n        }\n        \n        //for(long x : small) out.print(x +\" \");  out.println();\n        //for(long y : big)   out.print(y +\" \");  out.println();\n        \n        long ans = small[n1];\n        int day = n2, e = n1;\n        for(long x : big) {\n            if(x == 0)  continue;\n            if(day < 0) {\n                e += day;\n                e--;\n                day = 1;\n            }\n            if(e < 0)   break;\n            //out.println(e +\" \"+ small[e] +\" \"+ x);\n            ans = Math.max(small[e] + x, ans);\n            day -= d;\n        }\n        out.println(ans);\n    }\n    \n    long mp(long b, long e) {\n        long r = 1;\n        while(e > 0) {\n            if( (e&1) == 1 )    r = (r * b) % mod;\n            b = (b * b) % mod;\n            e >>= 1;\n        }\n        return r;\n    }\n    \n    // -------- I/O Template -------------\n    \n    char nc() {\n        return ns().charAt(0);\n    }\n    \n    String nLine() {\n        try {\n            return br.readLine();\n        } catch(IOException e) {\n            return \"-1\";\n        }\n    }\n    \n    double nd() {\n        return Double.parseDouble(ns());\n    }\n    \n    long nl() {\n        return Long.parseLong(ns());\n    }\n    \n    int ni() {\n        return Integer.parseInt(ns());\n    }\n    \n    StringTokenizer ip;\n    \n    String ns() {\n        if(ip == null || !ip.hasMoreTokens()) {\n            try {\n                ip = new StringTokenizer(br.readLine());\n            } catch(IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return ip.nextToken();\n    }\n    \n    void kamehameha() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        spiritBomb();\n        out.flush();\n    }\n    \n    public static void main(String[] args) {\n        new goku().kamehameha();\n    }\n    \n}\n",
        "fixed_code": "//package goku;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class goku {\n\n    BufferedReader br;\n    PrintWriter out;\n    \n    long mod = (long) (1e9 + 7), inf = (long) (5e18);\n    \n    void spiritBomb() {\n        int n = ni(), d = ni() + 1;\n        long m = nl();\n        long a[] = new long[n];\n        for(int i = 0; i < n; i++)  a[i] = nl();\n        Arrays.sort(a);\n        \n        int n1 = 0;\n        for(int i = 0; i < n; i++)  if(a[i] <= m)   n1++;\n        int n2 = n - n1;\n        \n        if(n1 == 0) {\n            long ans = 0;       int j = n-1;\n            for(int i = 0; i < n; i += d) {\n                ans += a[j--];\n            }\n            out.println(ans);   return;\n        }\n        \n        long small[] = new long[n1 + 1];\n        long big[] = new long[n2 + 1];\n        int u = 1, v = 1;\n        for(int i = n-1; i >= 0; i--) {\n            if(i >= n1) {\n                big[u] = a[i] + big[u-1];\n                u++;\n            } else {\n                small[v] = a[i] + small[v-1];\n                v++;\n            }\n        }\n        \n        //for(long x : small) out.print(x +\" \");  out.println();\n        //for(long y : big)   out.print(y +\" \");  out.println();\n        \n        long ans = small[n1];\n        int day = n2, e = n1;\n        for(long x : big) {\n            if(x == 0)  continue;\n            if(day <= 0) {\n                e += day;\n                e--;\n                day = 1;\n            }\n            if(e < 0)   break;\n            //out.println(e +\" \"+ small[e] +\" \"+ x);\n            ans = Math.max(small[e] + x, ans);\n            day -= d;\n        }\n        out.println(ans);\n    }\n    \n    long mp(long b, long e) {\n        long r = 1;\n        while(e > 0) {\n            if( (e&1) == 1 )    r = (r * b) % mod;\n            b = (b * b) % mod;\n            e >>= 1;\n        }\n        return r;\n    }\n    \n    // -------- I/O Template -------------\n    \n    char nc() {\n        return ns().charAt(0);\n    }\n    \n    String nLine() {\n        try {\n            return br.readLine();\n        } catch(IOException e) {\n            return \"-1\";\n        }\n    }\n    \n    double nd() {\n        return Double.parseDouble(ns());\n    }\n    \n    long nl() {\n        return Long.parseLong(ns());\n    }\n    \n    int ni() {\n        return Integer.parseInt(ns());\n    }\n    \n    StringTokenizer ip;\n    \n    String ns() {\n        if(ip == null || !ip.hasMoreTokens()) {\n            try {\n                ip = new StringTokenizer(br.readLine());\n            } catch(IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return ip.nextToken();\n    }\n    \n    void kamehameha() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        spiritBomb();\n        out.flush();\n    }\n    \n    public static void main(String[] args) {\n        new goku().kamehameha();\n    }\n    \n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <bitset>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n//#include \"myutil.hpp\"\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst ll INF = 1 << 30;\nint N,M,K;\n\nstruct UnionFind {\n  vi set_;\n  UnionFind(int size) : set_(size, -1){ }\n\n  void add(int a, int b) {\n    int rtA = root(a);\n    int rtb = root(b);\n    if (rtA == rtb) {\n      return;\n    }\n    set_[rtA] += set_[rtb];\n    set_[rtb] = rtA;\n  }\n\n  bool find(int a, int b) { return root(a) == root(b); }\n  \n  int root(int a) {\n    if (set_[a] < 0) {\n      return a;\n    } else {\n      set_[a] = root(set_[a]);\n      return set_[a];\n    }\n  }\n  \n  int size(int a) { return -set_[root(a)]; }\n};\n\nvector<pair<int, int> > doors;\nvi rooms;\nvi key2room;\nmap<string, int> names;\n\nint main(){\n  cin >> N >> M >> K;\n  int from,to;\n  for(int i = 0; i < M; ++i) {\n    scanf(\"%d%d\", &from, &to);\n    doors.push_back(make_pair(from-1, to-1));\n  }\n  key2room.resize(M);\n  char name[20];\n  int room, keyC, keyI;\n  for(int i = 0; i < K; ++i) {\n    scanf(\"%s%d%d\", name, &room, &keyC);\n    --room;\n    rooms.push_back(room);\n    names.insert(make_pair(string(name), room));\n    for(int j = 0; j < keyC; ++j){\n      scanf(\"%d\", &keyI);\n      --keyI;\n      key2room[keyI] = room;\n    }\n  }\n  UnionFind uf(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      int f = doors[j].first;\n      int t = doors[j].second;\n      if(uf.find(f,t)) continue;\n      int room = key2room[j];\n      if(uf.find(room,f) || uf.find(room, t)){\n    uf.add(f,t);\n      }\n    }\n  }\n  bool result = true;\n  for(int i = 0; i < K; ++i) {\n    scanf(\"%s%d%d\", name, &room, &keyC);\n    --room;\n    result = result && uf.find(room, names[name]);\n    for(int j = 0; j < keyC; ++j){\n      scanf(\"%d\", &keyI);\n      --keyI;\n      result = result && uf.find(room, key2room[keyI]);\n    }\n  }\n  cout << (result ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n",
        "fixed_code": "#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <bitset>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n//#include \"myutil.hpp\"\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst ll INF = 1 << 30;\nint N,M,K;\n\nstruct UnionFind {\n  vi set_;\n  UnionFind(int size) : set_(size, -1){ }\n\n  void add(int a, int b) {\n    int rtA = root(a);\n    int rtb = root(b);\n    if (rtA == rtb) {\n      return;\n    }\n    set_[rtA] += set_[rtb];\n    set_[rtb] = rtA;\n  }\n\n  bool find(int a, int b) { return root(a) == root(b); }\n  \n  int root(int a) {\n    if (set_[a] < 0) {\n      return a;\n    } else {\n      set_[a] = root(set_[a]);\n      return set_[a];\n    }\n  }\n  \n  int size(int a) { return -set_[root(a)]; }\n};\n\nvector<pair<int, int> > doors;\nvi key2room1;\nmap<string, int> names1;\nvi key2room2;\nmap<string, int> names2;\n\nbool solve(vi& key2room, map<string, int>& names, vi& key2roomDst, map<string, int>& namesDst){\n  UnionFind uf(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      int f = doors[j].first;\n      int t = doors[j].second;\n      if(uf.find(f,t)) continue;\n      int room = key2room[j];\n      if(uf.find(room, f) || uf.find(room, t)){\n    uf.add(f,t);\n      }\n    }\n  }\n  for(int i = 0; i < M; ++i){\n    if(!uf.find(key2room[i], key2roomDst[i])){\n      return false;\n    }\n  }\n  for(map<string,int>::iterator itr = names.begin(); itr != names.end(); ++itr) {\n    string name = itr->first;\n    int room= itr->second;\n    if(!uf.find(room, namesDst[name])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  cin >> N >> M >> K;\n  int from,to;\n  for(int i = 0; i < M; ++i) {\n    scanf(\"%d%d\", &from, &to);\n    doors.push_back(make_pair(from-1, to-1));\n  }\n  key2room1.resize(M);\n  key2room2.resize(M);\n  char name[20];\n  int room, keyC, keyI;\n  for(int i = 0; i < K; ++i) {\n    scanf(\"%s%d%d\", name, &room, &keyC);\n    --room;\n    names1.insert(make_pair(string(name), room));\n    for(int j = 0; j < keyC; ++j){\n      scanf(\"%d\", &keyI);\n      --keyI;\n      key2room1[keyI] = room;\n    }\n  }\n  for(int i = 0; i < K; ++i) {\n    scanf(\"%s%d%d\", name, &room, &keyC);\n    --room;\n    names2.insert(make_pair(string(name), room));\n    for(int j = 0; j < keyC; ++j){\n      scanf(\"%d\", &keyI);\n      --keyI;\n      key2room2[keyI] = room;\n    }\n  }\n  bool result = solve(key2room1, names1, key2room2, names2) && solve(key2room2, names2, key2room1, names1);\n  cout << (result ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static class Solver {\n        Scanner in = new Scanner(System.in);\n\n        <T> void println(T x) {\n            System.out.println(x);\n        }\n\n        class Factor {\n            public long p, a;\n\n            public Factor(long p, long a) {\n                this.p = p;\n                this.a = a;\n            }\n        }\n\n        ArrayList<Factor> factorize(long n) {\n            ArrayList<Factor> factors = new ArrayList();\n            long d = 2;\n            while (n > 1) {\n                if (d * d > n) {\n                    factors.add(new Factor(n, 1));\n                    break;\n                }\n\n                long a = 0;\n                while (n % d == 0) {\n                    n /= d;\n                    a++;\n                }\n\n                if (a > 0) {\n                    factors.add(new Factor(d, a));\n                }\n\n                d++;\n            }\n\n            return factors;\n        }\n\n        long longSqrt(long n) {\n            long r = (long) Math.sqrt(n);\n            for (long i = r - 5; i <= r + 5; i++) {\n                if (i * i == n) return i;\n            }\n            return -1;\n        }\n\n        boolean goodDivisor(long d) {\n            long c = d + asqr/d;\n            if (c % 2 != 0) return false;\n\n            c /= 2;\n            long b = d - c;\n            if (b > 0) {\n                println(String.format(\"%d %d\", b, c));\n                return true;\n            }\n\n            return false;\n        }\n\n        boolean checkDivisors(long[] d, int k, ArrayList<Factor> factors) {\n            if (k == factors.size()) {\n                long prod = 1;\n                for (int i = 0; i < k; i++) {\n                    for (int j = 0; j < d[i]; j++) {\n                        prod *= factors.get(i).p;\n                    }\n                }\n\n                return goodDivisor(prod);\n            } else {\n                for (int j = 0; j <= factors.get(k).a; j++) {\n                    d[k] = j;\n                    if (checkDivisors(d, k + 1, factors)) return true;\n                }\n\n                return false;\n            }\n        }\n\n        long a, asqr;\n\n        void solve() {\n            a = in.nextInt();\n            asqr = a * a;\n\n            ArrayList<Factor> factors = factorize(asqr);\n            if (checkDivisors(new long[factors.size()], 0, factors)) return;\n\n            for (long b = 1; b * b < asqr; b++) {\n                long c = longSqrt(asqr - b * b);\n                if (c != -1) {\n                    println(String.format(\"%d %d\", b, c));\n                    return;\n                }\n            }\n\n            println(\"-1\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Solver().solve();\n    }\n}\n",
        "fixed_code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static class Solver {\n        Scanner in = new Scanner(System.in);\n\n        <T> void println(T x) {\n            System.out.println(x);\n        }\n\n        class Factor {\n            public long p, a;\n\n            public Factor(long p, long a) {\n                this.p = p;\n                this.a = a;\n            }\n        }\n\n        ArrayList<Factor> factorize(long n) {\n            ArrayList<Factor> factors = new ArrayList();\n            long d = 2;\n            while (n > 1) {\n                if (d * d > n) {\n                    factors.add(new Factor(n, 1));\n                    break;\n                }\n\n                long a = 0;\n                while (n % d == 0) {\n                    n /= d;\n                    a++;\n                }\n\n                if (a > 0) {\n                    factors.add(new Factor(d, a));\n                }\n\n                d++;\n            }\n\n            return factors;\n        }\n\n        long longSqrt(long n) {\n            long r = (long) Math.sqrt(n);\n            for (long i = r - 5; i <= r + 5; i++) {\n                if (i * i == n) return i;\n            }\n            return -1;\n        }\n\n        boolean goodDivisor(long d) {\n            long c = d + asqr/d;\n            if (c % 2 != 0) return false;\n\n            c /= 2;\n            long b = d - c;\n            if (b > 0) {\n                println(String.format(\"%d %d\", b, c));\n                return true;\n            }\n\n            return false;\n        }\n\n        boolean checkDivisors(long[] d, int k, ArrayList<Factor> factors) {\n            if (k == factors.size()) {\n                long prod = 1;\n                for (int i = 0; i < k; i++) {\n                    for (int j = 0; j < d[i]; j++) {\n                        prod *= factors.get(i).p;\n                    }\n                }\n\n                return goodDivisor(prod);\n            } else {\n                for (int j = 0; j <= factors.get(k).a; j++) {\n                    d[k] = j;\n                    if (checkDivisors(d, k + 1, factors)) return true;\n                }\n\n                return false;\n            }\n        }\n\n        long a, asqr;\n\n        void solve() {\n            a = in.nextInt();\n            asqr = a * a;\n\n            ArrayList<Factor> factors = factorize(a);\n            for (Factor f : factors) {\n                f.a *= 2;\n            }\n            if (checkDivisors(new long[factors.size()], 0, factors)) return;\n\n            for (long b = 1; b * b < asqr; b++) {\n                long c = longSqrt(asqr - b * b);\n                if (c != -1) {\n                    println(String.format(\"%d %d\", b, c));\n                    return;\n                }\n            }\n\n            println(\"-1\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Solver().solve();\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "t=int(input())\n\nfor test in range(t):\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(input()))\n\n    ans=0\n    for i in range(n//2):\n        for j in range(i,n-i*2):\n            if j==n-1:\n                continue\n            count=0\n            if a[i][j]=='1':\n                count+=1\n            if a[j][-(i+1)]=='1':\n                count+=1\n            if a[-(i+1)][n-1-j]=='1':\n                count+=1\n            if a[n-1-j][i]=='1':\n                count+=1\n\n            if count==1 or count==3:\n                ans+=1\n            elif count==2:\n                ans+=2\n\n    print(ans)",
        "fixed_code": "t=int(input())\n\nfor test in range(t):\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(input()))\n\n    ans=0\n    for i in range(n//2):\n        for j in range(i,n-i-1):\n            count=0\n            if a[i][j]=='1':\n                count+=1\n            if a[j][-(i+1)]=='1':\n                count+=1\n            if a[-(i+1)][n-1-j]=='1':\n                count+=1\n            if a[n-1-j][i]=='1':\n                count+=1\n\n            if count==1 or count==3:\n                ans+=1\n            elif count==2:\n                ans+=2\n\n    print(ans)\n\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "public void showTeetime() {\n    m_dialog = new android.app.Dialog(this);\n    m_dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);\n    android.graphics.Rect displayRectangle = new android.graphics.Rect();\n    android.view.Window window = getWindow();\n    window.getDecorView().getWindowVisibleDisplayFrame(displayRectangle);\n    android.view.LayoutInflater inflater = ((android.view.LayoutInflater) (getSystemService(Context.LAYOUT_INFLATER_SERVICE)));\n    android.view.View layout = inflater.inflate(R.layout.custom_dialog_hotel_detail, null);\n    layout.setMinimumWidth(((int) ((displayRectangle.width()) * 0.9F)));\n    layout.setMinimumHeight(((int) ((displayRectangle.height()) * 0.2F)));\n    android.widget.RelativeLayout email = ((android.widget.RelativeLayout) (layout.findViewById(R.id.pros_mail)));\n    android.widget.RelativeLayout phone = ((android.widget.RelativeLayout) (layout.findViewById(R.id.pros_phone)));\n    android.widget.RelativeLayout dir = ((android.widget.RelativeLayout) (layout.findViewById(R.id.pros_dir)));\n    android.widget.TextView tvEmail = ((android.widget.TextView) (layout.findViewById(R.id.tvNewsDialogEmail)));\n    android.widget.TextView tvPhone = ((android.widget.TextView) (layout.findViewById(R.id.tvNewsDialogPhone)));\n    android.widget.TextView tvdir = ((android.widget.TextView) (layout.findViewById(R.id.tvNewsDialogdir)));\n    android.widget.TextView tvCancel = ((android.widget.TextView) (layout.findViewById(R.id.tvNewsDialogCancel)));\n    tvEmail.setText(getString(R.string.cnt_email_btn));\n    tvdir.setText(getString(R.string.cnt_direction_btn));\n    tvPhone.setText(getString(R.string.cnt_phone_btn));\n    tvCancel.setText(getString(R.string.cnt_cancel_btn));\n    ((android.widget.TextView) (layout.findViewById(R.id.tvCDProDetailContact))).setText(getString(R.string.cnt_contact_pop_up_title));\n    ((android.widget.TextView) (layout.findViewById(R.id.tvCDProDetailContact))).setTypeface(android.graphics.Typeface.createFromAsset(getAssets(), \"fonts/B.ttf\"));\n    tvEmail.setTypeface(android.graphics.Typeface.createFromAsset(getAssets(), \"fonts/B.ttf\"));\n    tvPhone.setTypeface(android.graphics.Typeface.createFromAsset(getAssets(), \"fonts/B.ttf\"));\n    tvCancel.setTypeface(android.graphics.Typeface.createFromAsset(getAssets(), \"fonts/B.ttf\"));\n    tvdir.setTypeface(android.graphics.Typeface.createFromAsset(getAssets(), \"fonts/B.ttf\"));\n    emm = selectedRasturant.email;\n    if ((((emm) == null) || (emm.equals(\"\"))) || (emm.equals(\"null\"))) {\n        email.setVisibility(View.GONE);\n        email.setBackgroundResource(R.drawable.btn_disable);\n        email.setClickable(false);\n    }\n    ccc = selectedRasturant.phone;\n    if ((((ccc) == null) || (ccc.equals(\"\"))) || (ccc.equals(\"null\"))) {\n        phone.setVisibility(View.GONE);\n        phone.setBackgroundResource(R.drawable.btn_disable);\n        phone.setClickable(false);\n    }\n    dirr = (selectedRasturant.latitude) + \"\";\n    if ((((dirr) == null) || (dirr.equals(\"\"))) || (dirr.equals(\"null\"))) {\n        dir.setVisibility(View.GONE);\n        dir.setBackgroundResource(R.drawable.btn_disable);\n        dir.setClickable(false);\n    }\n    email.setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View v) {\n            android.content.Intent emailIntent = null;\n            try {\n                emailIntent = new android.content.Intent(android.content.Intent.ACTION_SENDTO, android.net.Uri.fromParts(\"mailto\", emm, null));\n            } catch (java.lang.Exception e) {\n                e.printStackTrace();\n            }\n            startActivity(android.content.Intent.createChooser(emailIntent, getResources().getString(R.string.events_share_btn)));\n        }\n    });\n    phone.setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View v) {\n            android.content.Intent intent = null;\n            try {\n                intent = new android.content.Intent(android.content.Intent.ACTION_DIAL, android.net.Uri.parse((\"tel:\" + (ccc))));\n            } catch (java.lang.Exception e) {\n                e.printStackTrace();\n            }\n            startActivity(intent);\n        }\n    });\n    dir.setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View v) {\n            java.lang.String uri = null;\n            uri = ((\"http://maps.google.com/maps?q=\" + (selectedRasturant.latitude)) + \",\") + (selectedRasturant.longitude);\n            android.content.Intent intent = new android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(uri));\n            startActivity(intent);\n        }\n    });\n    layout.findViewById(R.id.cancel_pros).setOnClickListener(new android.view.View.OnClickListener() {\n        @java.lang.Override\n        public void onClick(android.view.View v) {\n            m_dialog.dismiss();\n        }\n    });\n    m_dialog.getWindow().setBackgroundDrawable(new android.graphics.drawable.ColorDrawable(android.graphics.Color.TRANSPARENT));\n    m_dialog.setContentView(layout);\n    m_dialog.show();\n    m_dialog.setCanceledOnTouchOutside(true);\n}",
        "fixed_code": "@java.lang.Override\npublic void onClick(android.view.View v) {\n    java.lang.String uri = null;\n    if ((c_web.equals(\"\")) || (c_web.equals(\"null\"))) {\n    }else {\n        try {\n            uri = c_web;\n        } catch (java.lang.Exception e) {\n            e.printStackTrace();\n        }\n        android.content.Intent intent = new android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(uri));\n        startActivity(intent);\n    }\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Scanner;\r\n\r\npublic class hh {\r\n    public static void main(String[] args){\r\n        Scanner sc = new Scanner(System.in);\r\n        int t = sc.nextInt();\r\n        while(t>0){\r\n            int n = sc.nextInt();\r\n            int d = sc.nextInt();\r\n            int[] arr = new int[n];\r\n            int greater = 0;\r\n            for(int i=0;i<n;i++) {arr[i] = sc.nextInt();if(arr[i]>d) greater++;}\r\n\r\n            Arrays.sort(arr);\r\n            int count = 0;\r\n            for(int i=0;i<n;i++)\r\n            {\r\n                if(arr[i]>d) break;\r\n                for(int j=i+1;j<n;j++)\r\n                {\r\n                    if(arr[j]>d) break;\r\n                    if(arr[i]+ arr[j]<=d) count++;\r\n                }\r\n            }\r\n            if(greater==count)\r\n                System.out.println(\"YES\");\r\n            else\r\n                System.out.println(\"NO\");\r\n\r\n            t--;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n",
        "fixed_code": "import java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Scanner;\r\n\r\npublic class hh {\r\n    public static void main(String[] args){\r\n        Scanner sc = new Scanner(System.in);\r\n        int t = sc.nextInt();\r\n        while(t>0){\r\n            int n = sc.nextInt();\r\n            int d = sc.nextInt();\r\n            int[] arr = new int[n];\r\n            for(int i=0;i<n;i++) {arr[i] = sc.nextInt();}\r\n\r\n            boolean ok = true;\r\n            Arrays.sort(arr);\r\n            if(arr[n-1] > d && arr[0] + arr[1] > d) ok = false;\r\n            if(ok) System.out.println(\"YES\");\r\n            else System.out.println(\"NO\");\r\n\r\n\r\n            t--;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+10;\nint n, ans, tot, a[N], b[N], T[N];\nvector<int> G[N];\nint L[N<<5], R[N<<5], Lis[N<<5], Lds[N<<5];\n\nvoid update(int *a, int &o, int l, int r, int x, int v) {\n\tif (!o) o=++tot;\n\ta[o] = max(a[o], v);\n\tif (l!=r) ((l+r)>>1)>=x?update(a,L[o],l,((l+r)>>1),x,v):update(a,R[o],((l+r)>>1)+1,r,x,v);\n}\nint query(int *a, int o, int l, int r, int ql, int qr) {\n\tif (!o||ql<=l&&r<=qr) return a[o];\n\tif (((l+r)>>1)>=qr) return query(a,L[o],l,((l+r)>>1),ql,qr);\n\tif (((l+r)>>1)<ql) return query(a,R[o],((l+r)>>1)+1,r,ql,qr);\n\treturn max(query(a,L[o],l,((l+r)>>1),ql,qr),query(a,R[o],((l+r)>>1)+1,r,ql,qr));\n}\nint merge(int x, int y) {\n\tif (!x||!y) return x+y;\n\tans = max(ans, Lis[L[x]]+Lds[R[y]]);\n\tans = max(ans, Lis[L[y]]+Lds[R[x]]);\n\tLis[x] = max(Lis[x],Lis[y]);\n\tLds[x] = max(Lds[x],Lds[y]);\n\tL[x] = merge(L[x],L[y]);\n\tR[x] = merge(R[x],R[y]);\n\treturn x;\n}\n\nvoid dfs(int x, int f) {\n\ta[x] = lower_bound(b+1,b+1+*b,a[x])-b;\n\tint lis = 0, lds = 0;\n\tfor (int y:G[x]) if (y!=f) {\n\t\tdfs(y,x);\n\t\tint lis1 = a[x]==1?0:query(Lis,T[y],1,*b,1,a[x]-1);\n\t\tint lds1 = a[x]==*b?0:query(Lds,T[y],1,*b,a[x]+1,*b);\n\t\tans = max(ans, lis1+lds+1);\n\t\tans = max(ans, lds1+lis+1);\n\t\tT[x] = merge(T[x], T[y]);\n\t\tlis = max(lis, lis1);\n\t\tlds = max(lds, lds1);\n\t}\n\tupdate(Lis,T[x],1,*b,a[x],lis+1);\n\tupdate(Lds,T[x],1,*b,a[x],lds+1);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\", a+i),b[i]=a[i];\n\tsort(b+1,b+1+n),*b=unique(b+1,b+1+n)-b-1;\n\tfor(int i=1;i<=n;++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v),G[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\", ans);\n}",
        "fixed_code": "#include<bits/stdc++.h>\n#define lc(x) t[x].l\n#define rc(x) t[x].r\nusing namespace std;\nconst int N=100005;int ret;\nstruct segt{\n\tint l,r,s,d;\n}t[N*30];\nstd::vector<int> G[N];\nint n,w[N],nm,h[N],p[N],tot,rt[N],cnt,ans,c=0;\nvoid update(int &x,int l,int r,int p,int v,int op){\n\tif(!x) x=++cnt;if(op==0)\n\tt[x].s=max(t[x].s,v);else t[x].d=max(t[x].d,v);\n\tif(l==r) return ;int mid=l+r>>1;\n\tif(p<=mid) update(t[x].l,l,mid,p,v,op);\n\telse update(t[x].r,mid+1,r,p,v,op);return ;\n}\nint merge(int x,int y){\n\tif(!x||!y) return x|y;\n\tt[x].s=max(t[x].s,t[y].s);\n\tt[x].d=max(t[x].d,t[y].d);\n\tans=max(ans,max(t[lc(x)].s+t[rc(y)].d,\n\tt[rc(x)].d+t[lc(y)].s));\n\tt[x].l=merge(lc(x),lc(y));\n\tt[x].r=merge(rc(x),rc(y));return x;\n}\nint query(int x,int l,int r,int L,int R,int op){\n\tif(L>R||l>r) return 0;\n\tif(L<=l&&r<=R) return op?t[x].d:t[x].s;\n\tint mid=l+r>>1,re=0;\n\tif(L<=mid) re=max(re,query(t[x].l,l,mid,L,R,op));\n\tif(mid<R)  re=max(re,query(t[x].r,mid+1,r,L,R,op));\n\treturn re;\n}\nvoid dfs(int x,int fa){\n\tint ld=0,ls=0;\n\tfor(auto y:G[x])\n\t\tif(y!=fa){\n\t\t\tdfs(y,x);\n\t\t\tint is=query(rt[y],1,tot,1,w[x]-1,0);\n\t\t\tint id=query(rt[y],1,tot,w[x]+1,tot,1);\n\t\t\trt[x]=merge(rt[x],rt[y]);\n\t\t\tans=max(ans,max(is+ld,ls+id)+1);\n\t\t\tls=max(ls,is),ld=max(id,ld);\n\t\t}\n\tupdate(rt[x],1,tot,w[x],ls+1,0);\n\tupdate(rt[x],1,tot,w[x],ld+1,1);\n}\nint main(){\n\tscanf(\"%d\",&n);cnt=n;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&w[i]),p[i]=w[i],rt[i]=i;\n\tfor(int i=1,x,y;i<n;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tsort(p+1,p+1+n);\n\ttot=unique(p+1,p+1+n)-p-1;\n\tfor(int i=1;i<=n;i++)\n\tw[i]=lower_bound(p+1,p+1+tot,w[i])-p;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "public MovieBuilder setRaitings(java.util.Collection<java.lang.Double> raitings) {\n    if (raitings == null)\n        throw new java.lang.IllegalArgumentException(\"raitings cannot be null\");\n    \n    this.raitings = new java.util.ArrayList<java.lang.Double>(raitings);\n    return this;\n}",
        "fixed_code": "public MovieBuilder setLenguage(java.lang.String lenguage) {\n    if (lenguage == null)\n        throw new java.lang.IllegalArgumentException(\"lenguage cannot be null\");\n    \n    this.lenguage = lenguage;\n    return this;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "private void auditAccessSuccess(org.restlet.Request request, org.restlet.Response response) {\n    if (auditEventPublisher.isAuditing(org.forgerock.openam.rest.audit.ACCESS_TOPIC)) {\n        long endTime = java.lang.System.currentTimeMillis();\n        org.forgerock.openam.audit.AMAccessAuditEventBuilder builder = auditEventFactory.accessEvent().timestamp(endTime).transactionId(org.forgerock.openam.audit.context.AuditRequestContext.getTransactionIdValue()).eventName(EventName.AM_ACCESS_OUTCOME).component(component).authentication(getUserIdForAccessOutcome(response)).contextId(getContextIdForAccessOutcome(response)).response(\"SUCCESS\", (endTime - (request.getDate().getTime())));\n        addHttpData(request, builder);\n        auditEventPublisher.tryPublish(org.forgerock.openam.rest.audit.ACCESS_TOPIC, builder.toEvent());\n    }\n}",
        "fixed_code": "protected java.lang.String getUserIdForAccessAttempt(org.restlet.Request request) {\n    return null;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "import java.util.*;\n\nimport java.io.*;\npublic class MinimumGridPath {\n\n    public static void main(String ...args) throws Exception {\n\n\t\n\n\tBufferedReader bin = new BufferedReader(new InputStreamReader(System.in));\n\n\n\tint t = Integer.parseInt(bin.readLine());\n\n\twhile(t-->0) {\n\n\tint n = Integer.parseInt(bin.readLine());\n\n\tlong c[] = Arrays.asList(bin.readLine().split(\" \")).stream().mapToLong(Long:: parseLong).toArray();\n\n\tlong[] min = new long[2];\n\tlong[] rem = new long[2];\n\n\tmin[0] = Integer.MAX_VALUE;\n\tmin[1] = Integer.MAX_VALUE;\n\n\trem[0] = n;\n\trem[1] = n;\n\n\tlong sum = 0L;\n\tlong ans = Integer.MAX_VALUE;\n\n\tfor(int i=0;i<n;i++) {\n\t    min[i%2] = Math.min(min[i%2], c[i]);\n\n\t    rem[i%2]--;\n\n\t    sum+=c[i];\n\n\t    if(i > 0){\n\n\t\tlong temp = sum+rem[0]*min[0]+rem[1]*min[1];\n\t\tans = Math.min(ans, temp);\n\t    }\n\t\t\n\t}\n\n\tSystem.out.println(ans);\n\t}\n    }\n}\n",
        "fixed_code": "import java.util.*;\n\nimport java.io.*;\npublic class MinimumGridPath {\n\n    public static void main(String ...args) throws Exception {\n\n\t\n\n\tBufferedReader bin = new BufferedReader(new InputStreamReader(System.in));\n\n\n\tint t = Integer.parseInt(bin.readLine());\n\n\twhile(t-->0) {\n\n\tint n = Integer.parseInt(bin.readLine());\n\n\tlong c[] = Arrays.asList(bin.readLine().split(\" \")).stream().mapToLong(Long:: parseLong).toArray();\n\n\tlong[] min = new long[2];\n\tlong[] rem = new long[2];\n\n\tmin[0] = Long.MAX_VALUE;\n\tmin[1] = Long.MAX_VALUE;\n\n\trem[0] = n;\n\trem[1] = n;\n\n\tlong sum = 0L;\n\tlong ans = Long.MAX_VALUE;\n\n\tfor(int i=0;i<n;i++) {\n\t    min[i%2] = Math.min(min[i%2], c[i]);\n\n\t    rem[i%2]--;\n\n\t    sum+=c[i];\n\n\t    if(i > 0){\n\n\t\tlong temp = sum+rem[0]*min[0]+rem[1]*min[1];\n\t\tans = Math.min(ans, temp);\n\t    }\n\t\t\n\t}\n\n\tSystem.out.println(ans);\n\t}\n    }\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 2e5 + 10;\nint n,m,q,id[NMAX];\n\nint find(int x){\n    while(x != id[x])\n        x = id[x];\n    return x;\n}\n\nint main(){\n    int i,j;\n    cin >> n >> m >> q;\n    int ans = n + m - 1;\n    for(i = 1 ; i <= ans ; i++)\n        id[i] = i;\n    id[ans + 1] = ans + 1;\n    while(q--){\n        int x, y;\n        cin >> x >> y;\n        y += n;\n        int xx = find(x);\n        int yy = find(y);\n        if(xx != yy){\n            id[xx] = yy;\n            ans--;\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 4e5 + 10;\nint n,m,k;\nbool used[NMAX];\nvector < int > v[NMAX];\n\nvoid dfs(int node){\n    used[node] = 1;\n    for(auto it: v[node]){\n        if(used[it]) continue;\n        dfs(it);\n    }\n}\n\nint main(){\n    int i,j,x,y;\n    cin >> n >> m >> k;\n    while(k--){\n        cin >> x >> y;\n        x--;\n        y += (n - 1);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    int ans = -1;\n    for(i = 0 ; i < n + m ; i++){\n        if(used[i]) continue;\n        dfs(i);\n        ans++;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n\n    int arr[n];\n    for(int i = 0; i != n; ++i)\n        cin >> arr[i];\n\n    vector<int> ans;\n    int last = 0;\n    for(int i = 0, j = 0; i != n; ++i, ++j)\n    {\n        if(j >= k && arr[i] != ans[j-k])\n        {\n            if(last > 1e4)\n            {\n                cout << \"-1\\n\";\n                return;\n            }\n            ++last;\n            --i;\n            ans.push_back(ans[j-k]);\n            continue;\n        }\n        last = 0;\n        ans.push_back(arr[i]);\n    }\n\n    if(ans.size() > 1e4)\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    cout << ans.size() << \"\\n\";\n    for(int x : ans)\n        cout << x << \" \";\n    cout << \"\\n\";\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        solve();\n\n    }\n    \n    return 0;\n}\n\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n\n    set<int> s;\n\n    int arr[n];\n    for(int i = 0; i != n; ++i)\n    {\n        cin >> arr[i];\n        s.insert(arr[i]);\n    }\n\n    if((int)s.size() > k)\n    {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    vector<int> ans;\n    for(int x : s)\n        ans.push_back(x);\n\n    for(int i = s.size(); i < k; ++i)\n        ans.push_back(*s.begin());\n\n    int last = 0;\n    for(int i = 0, j = (int)ans.size(); i != n; ++i, ++j)\n    {\n        if(j >= k && arr[i] != ans[j-k])\n        {\n            if(last > 1e4)\n            {\n                cout << \"-1\\n\";\n                return;\n            }\n            ++last;\n            --i;\n            ans.push_back(ans[j-k]);\n            continue;\n        }\n        last = 0;\n        ans.push_back(arr[i]);\n    }\n\n    assert(ans.size() <= 1e4);\n\n    cout << ans.size() << \"\\n\";\n    for(int x : ans)\n        cout << x << \" \";\n    cout << \"\\n\";\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        solve();\n\n    }\n    \n    return 0;\n}\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 300000+5;\n\nint occ[MAX] = {0};\nint occInter[MAX][MAX] = {0};\nint paires[MAX][2];\n\n\nbool compare(const pair<int, float>&i, const pair<int, float>&j)\n{\n    return i.second < j.second;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tocc[a]++;\n\t\tocc[b]++;\n\t\toccInter[a][b]++;\n\t\toccInter[b][a]++;\n\t\tpaires[i][0] = a;\n\t\tpaires[i][1] = b;\n\t}\n\n\tvector<pair<int,int>> potX;\n\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (occ[i]>0)\n\t\t\tpotX.push_back({i,occ[i]});\n\t}\n\n\tsort(potX.begin(), potX.end(), compare);\n\tint N = potX.size();\n\tpair<int,int> potY[N];\n\tint i=0;\n\tfor (auto couple: potX)\n\t{\n\t\tpotY[i]=couple;\n\t\ti++;\n\t}\n\n\tbool trouve= false;\n\n\tfor (int i=0; i<N; i++)\n\t{\n\t\tfor (int j=N-1; j>-1; j--)\n\t\t{\n\t\t\tif (!trouve)\n\t\t\t{\n\t\t\t\tif (potY[i].second + potY[j].second < n)\n\t\t\t\t\tbreak;\n\t\t\t\tint inter = 0;\n\t\t\t\tint x=potY[i].first;\n\t\t\t\tint y=potY[j].first;\n\t\t\t\tfor (int k=0; k<m; k++)\n\t\t\t\t{\n\t\t\t\t\tif ((paires[k][0] == x && paires[k][1]==y) || (paires[k][0]==y && paires[k][1]==x))\n\t\t\t\t\t\tinter++;\n\t\t\t\t}\n\t\t\t\tif (potY[i].second + potY[j].second -inter ==n)\n\t\t\t\t{\n\t\t\t\t\tcout << \"YES\\n\";\n\t\t\t\t\ttrouve =true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!trouve)\n\t\tcout << \"NO\" << endl;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 300000+5;\n\nint occ[MAX] = {0};\nint paires[MAX][2];\n\n\nbool compare(const pair<int, float>&i, const pair<int, float>&j)\n{\n    return i.second < j.second;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tocc[a]++;\n\t\tocc[b]++;\n\t\tpaires[i][0] = a;\n\t\tpaires[i][1] = b;\n\t}\n\n\tvector<pair<int,int>> potX;\n\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (occ[i]>0)\n\t\t\tpotX.push_back({i,occ[i]});\n\t}\n\n\t//sort(potX.begin(), potX.end(), compare);\n\tint N = potX.size();\n\tpair<int,int> potY[N];\n\tint i=0;\n\tint maxi = 0;\n\tint imax = -1;\n\tfor (auto couple: potX)\n\t{\n\t\tpotY[i]=couple;\n\t\tif (couple.second > maxi)\n\t\t{\n\t\t\tmaxi = couple.second;\n\t\t\timax = i;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (maxi < m/2)\n\t{\n\t\tcout << \"NO\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int j=0; j<N; j++)\n    {\n        if (potY[j].second >= m/2)\n        {\n\n            int occbis[MAX] = {0};\n            int y = potY[j].first;\n            int diff=0;\n            for (int i=0; i<m; i++)\n            {\n                if (paires[i][0]!= y && paires[i][1]!=y)\n                {\n                    occbis[paires[i][0]]++;\n                    occbis[paires[i][1]]++;\n                    diff++;\n                }\n            }\n            int maxBis = 0;\n            for (int i=0; i<n; i++)\n            {\n                if (occbis[i]==diff)\n                {\n                    cout << \"YES\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n\tcout << \"NO\\n\";\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tstatic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint one = 0, two = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint ok = nextInt();\n\t\t\tif (ok == 1) {\n\t\t\t\t++one;\n\t\t\t}\n\t\t\tif (ok > 1) {\n\t\t\t\t++two;\n\t\t\t}\n\t\t}\n\t\tint answer = get1(one, two);\n\t\tout.println(answer);\n\t}\n\n\tprivate static int get1(int one, int two) {\n\t\tint[] a = new int[one + 1];\n\t\ta[0] = 1;\n\t\ta[1] = 1;\n\t\tfor (int i = 2; i < a.length; i++) {\n\t\t\ta[i] = (int) (((long) a[i - 1] + (i - 1L) * a[i - 2]) % MOD);\n\t\t}\n\n\t\tlong answer = a[one];\n\t\tfor (int i = one + 1; i <= one + two; i++) {\n\t\t\tanswer = answer * i % MOD;\n\t\t}\n\t\treturn (int) answer;\n\t}\n\n\tprivate static int get(int one, int two) {\n\n\t\tint[][] dp = new int[one + 1][two + 1];\n\t\tint[] fact = new int[one + two + 1];\n\t\tfact[0] = 1;\n\t\tfor (int i = 0; i < fact.length - 1; i++) {\n\t\t\tfact[i + 1] = (int) (fact[i] * (i + 1L) % MOD);\n\t\t}\n\t\tint[][] c = new int[two + 1][two + 1];\n\t\tfor (int i = 0; i <= two; i++) {\n\t\t\tc[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tc[i][j] = (int) ((long) c[i][j - 1] * (i - j + 1L) % MOD);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= one; i++) {\n\t\t\tfor (int j = 0; j <= two; j++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tdp[i][j] = fact[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong ok = 0;\n\t\t\t\tfor (int ones = 1; ones <= i && ones <= 2; ones++) {\n\t\t\t\t\tfor (int twos = 0; twos <= j; twos++) {\n\t\t\t\t\t\tlong add;\n\t\t\t\t\t\tif (twos == 0) {\n\t\t\t\t\t\t\tadd = dp[i - ones][j];\n\t\t\t\t\t\t\tif (ones == 2) {\n\t\t\t\t\t\t\t\tadd *= i - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// ++ok;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadd = (long) c[j][twos] * dp[i - ones][j - twos];\n\t\t\t\t\t\t\tif (ones == 2) {\n\t\t\t\t\t\t\t\tadd %= MOD;\n\t\t\t\t\t\t\t\tadd *= i - 1;\n\t\t\t\t\t\t\t\tadd *= twos + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok += add;\n\t\t\t\t\t\tif (ok < 0) {\n\t\t\t\t\t\t\tok -= MODMOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j] = (int) (ok % MOD);\n\t\t\t}\n\t\t}\n\t\t// for (int i = 0; i < one; i++) {\n\t\t// System.err.println(dp[i][0] + \" \" + a[i]);\n\t\t// }\n\t\tSystem.err.println(Arrays.toString(dp[5]));\n\t\treturn dp[one][two];\n\t}\n\n\tstatic int add(int a, int b) {\n\t\ta += b;\n\t\tif (a >= MOD) {\n\t\t\ta -= MOD;\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic final int MOD = 1000000007;\n\tstatic final long MODMOD = Long.MAX_VALUE / MOD * MOD;\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream input = System.in;\n\t\tPrintStream output = System.out;\n\t\tFile file = new File(\"d.in\");\n\t\tif (file.exists() && file.canRead()) {\n\t\t\tinput = new FileInputStream(file);\n\t\t}\n\t\tbr = new BufferedReader(new InputStreamReader(input));\n\t\tout = new PrintWriter(output);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n}\n",
        "fixed_code": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tstatic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint one = 0, two = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint ok = nextInt();\n\t\t\tif (ok == 1) {\n\t\t\t\t++one;\n\t\t\t}\n\t\t\tif (ok > 1) {\n\t\t\t\t++two;\n\t\t\t}\n\t\t}\n\t\tint answer = get1(one, two);\n\t\tout.println(answer);\n\t}\n\n\tprivate static int get1(int one, int two) {\n\t\tint[] a = new int[Math.max(one + 1, 10)];\n\t\ta[0] = 1;\n\t\ta[1] = 1;\n\t\tfor (int i = 2; i < a.length; i++) {\n\t\t\ta[i] = (int) (((long) a[i - 1] + (i - 1L) * a[i - 2]) % MOD);\n\t\t}\n\n\t\tlong answer = a[one];\n\t\tfor (int i = one + 1; i <= one + two; i++) {\n\t\t\tanswer = answer * i % MOD;\n\t\t}\n\t\treturn (int) answer;\n\t}\n\n\tprivate static int get(int one, int two) {\n\n\t\tint[][] dp = new int[one + 1][two + 1];\n\t\tint[] fact = new int[one + two + 1];\n\t\tfact[0] = 1;\n\t\tfor (int i = 0; i < fact.length - 1; i++) {\n\t\t\tfact[i + 1] = (int) (fact[i] * (i + 1L) % MOD);\n\t\t}\n\t\tint[][] c = new int[two + 1][two + 1];\n\t\tfor (int i = 0; i <= two; i++) {\n\t\t\tc[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tc[i][j] = (int) ((long) c[i][j - 1] * (i - j + 1L) % MOD);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= one; i++) {\n\t\t\tfor (int j = 0; j <= two; j++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tdp[i][j] = fact[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong ok = 0;\n\t\t\t\tfor (int ones = 1; ones <= i && ones <= 2; ones++) {\n\t\t\t\t\tfor (int twos = 0; twos <= j; twos++) {\n\t\t\t\t\t\tlong add;\n\t\t\t\t\t\tif (twos == 0) {\n\t\t\t\t\t\t\tadd = dp[i - ones][j];\n\t\t\t\t\t\t\tif (ones == 2) {\n\t\t\t\t\t\t\t\tadd *= i - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// ++ok;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadd = (long) c[j][twos] * dp[i - ones][j - twos];\n\t\t\t\t\t\t\tif (ones == 2) {\n\t\t\t\t\t\t\t\tadd %= MOD;\n\t\t\t\t\t\t\t\tadd *= i - 1;\n\t\t\t\t\t\t\t\tadd *= twos + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok += add;\n\t\t\t\t\t\tif (ok < 0) {\n\t\t\t\t\t\t\tok -= MODMOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j] = (int) (ok % MOD);\n\t\t\t}\n\t\t}\n\t\t// for (int i = 0; i < one; i++) {\n\t\t// System.err.println(dp[i][0] + \" \" + a[i]);\n\t\t// }\n\t\tSystem.err.println(Arrays.toString(dp[5]));\n\t\treturn dp[one][two];\n\t}\n\n\tstatic int add(int a, int b) {\n\t\ta += b;\n\t\tif (a >= MOD) {\n\t\t\ta -= MOD;\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic final int MOD = 1000000007;\n\tstatic final long MODMOD = Long.MAX_VALUE / MOD * MOD;\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream input = System.in;\n\t\tPrintStream output = System.out;\n\t\tFile file = new File(\"d.in\");\n\t\tif (file.exists() && file.canRead()) {\n\t\t\tinput = new FileInputStream(file);\n\t\t}\n\t\tbr = new BufferedReader(new InputStreamReader(input));\n\t\tout = new PrintWriter(output);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\n// #define testPrint  \r\nusing namespace std;\r\nbool testing = false;\r\nbool stress = false;\r\nbool recursion = false;\r\n#define templatify template<typename T>\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing ld = long double;\r\n\r\ntemplate<typename T1,typename T2> ostream& operator<<(ostream &os,pair<T1,T2> &p){os<<p.first<<\" \"<<p.second;return os;}\r\ntemplate<typename T1,typename T2> istream& operator>>(istream &is,pair<T1,T2> &p){is>>p.first>>p.second;return is;}\r\ntemplatify istream& operator>>(istream &is,vector<T>&vec){for(int i =0;i<vec.size();i++){ cin>>vec[i]; }  return is;}\r\ntemplatify void print(T var){\r\n    cerr<<var<<\" \";\r\n}\r\ntemplatify void print(vector<T> vec){\r\nfor(auto itr = vec.begin();itr!=vec.end();itr++){\r\n    print(*itr);\r\n}\r\n}\r\n\r\ntemplatify void print(T arr[],ll n){\r\n    for(ll i = 0;i<n;i++){\r\n        print(arr[i]);\r\n    }\r\n}\r\n\r\ntemplatify void print(set<T> st){\r\n    for(auto itr = st.begin();itr!=st.end();itr++){\r\n        print(*itr);\r\n    }\r\n}\r\n\r\ntemplate<class T1,class T2> void print(map<T1,T2> mp){\r\n    for(auto itr = mp.begin();itr!=mp.end();itr++){\r\n        print(\"key: \"); print(itr->first);\r\n        print(\"value: \");print(itr->second);\r\n    }\r\n\r\n}\r\n\r\ntemplatify class Debugger{\r\nvoid print(T var){\r\n    cerr<<var<<\" \";\r\n}\r\nvoid print(vector<T> vec){\r\nfor(auto itr = vec.begin();itr!=vec.end();itr++){\r\n    print(*itr);\r\n}\r\n}\r\n\r\n\r\nDebugger operator<<(T var){\r\n print(var);\r\n return Debugger();\r\n}\r\n\r\n};\r\n\r\n\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr<<#x<<\" \";print(x);cerr<<endl;\r\n#define debArr(x,y) cerr<<#x<<\" \";print(x,y);cerr<<endl;\r\n#else\r\n#define debug(x) \r\n#define debArr(x,y) \r\n#endif\r\n\r\ntemplate<class T> void arrInput(T arr[], int n)\r\n{\r\n    \r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        T el;\r\n        cin >> el;\r\n        arr[i] = el;\r\n    }\r\n}\r\n\r\ntemplate<class T1,class T2> void arrInput(pair<T1,T2> arr[],int n){\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        pair<T1,T2> el;\r\n        cin >> el;\r\n        arr[i] = el;\r\n    }\r\n\r\n}\r\n\r\ntemplate<class T> void arrInput(vector<T> &arr, int n)\r\n{\r\n    \r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        T el;\r\n        cin >> el;\r\n        arr.push_back(el);\r\n    }\r\n}\r\n\r\ntemplate<class T> void arrInput(vector<T> &arr)\r\n{\r\n    \r\n    \r\n    for (int i = 0; i < arr.size(); i++)\r\n    {\r\n        T el;\r\n        cin >> el;\r\n        arr[i] = el;\r\n    }\r\n}\r\n\r\n// void printMap(map<int, float> infected[], int n, string message = \"printing map function\")\r\n// {\r\n//     if (testing)\r\n//     {\r\n//         cout << message << \" \"\r\n//              << \"new print\" << endl\r\n//              << endl;\r\n\r\n//         for (int i = 0; i < n; i++)\r\n//         {\r\n//             cout << endl\r\n//                  << \"map \" << i << \" \" << endl;\r\n//             for (auto j = infected[i].begin(); j != infected[i].end(); j++)\r\n//             {\r\n//                 cout << j->first << \" \" << j->second << endl;\r\n//             }\r\n//         }\r\n//         cout << endl;\r\n//     }\r\n// }\r\n\r\n// void printArray(int n, int arr[], bool forcePrint = false, string message = \"printing array\")\r\n// {\r\n//     if (testing)\r\n//     { \r\n//         cout<<message<<\" \";\r\n//     }\r\n//     if( testing ||forcePrint)\r\n//         for (int j = 0; j < n; j++)\r\n//         {\r\n//             cout << arr[j] << \" \";\r\n//         }\r\n    \r\n// }\r\n\r\n// void printSet(set<int,greater<int>> arr){\r\n// if(testing)\r\n// {for(auto i = arr.begin();i!=arr.end();i++){\r\n//     cout<<*i<<\" \";\r\n// }\r\n// cout<<endl;}\r\n// }\r\n\r\nint placeHigh(int arr[],int low,int high){\r\n    int less = low;\r\n    for(low;low<high;low++){\r\n        if (arr[low]<=arr[high])\r\n        {\r\n            swap(arr[less],arr[low]);\r\n            less++;\r\n        }\r\n        \r\n    }\r\n    swap(arr[less],arr[high]);\r\n    return less;\r\n}\r\n\r\nvoid quicksort(int arr[],int low,int high){\r\n    if(low<high){\r\n        int pi = placeHigh(arr,low,high);\r\n        quicksort(arr,low,pi-1);\r\n        quicksort(arr,pi+1,high);\r\n    }\r\n}\r\n\r\n// void printValue(string value,string message = \"value = \"){\r\n//  if(testing)\r\n//  cout<<message<<value<<endl;\r\n// }\r\n\r\nvoid inputSet(set<int,greater<int>> *mySet,int n){\r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {   int el;\r\n    cin>>el;\r\n        (*mySet).insert(el);\r\n    }\r\n    \r\n}\r\n\r\ntemplatify long long binarySearch(vector<T> vec,T el){\r\n    long long low = 0,high = vec.size()-1;\r\n    while(low<=high){\r\n        long long mid = low + abs((high-low)/2);\r\n        if(vec[mid]==el){\r\n            return mid;\r\n        }\r\n        if(el<vec[mid]){\r\n            high = mid-1;\r\n        }else{\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nint maxi;\r\nmap<int,int> mp;\r\nint k = 100;\r\nint ask(int n){\r\n    if(n<=0 || n>=maxi){\r\n        return INT_MAX;\r\n    }\r\n    // if(mp.find(n)!=mp.end()){\r\n    //     return mp[n];\r\n    // }\r\n    cout<<\"? \"<<n<<\"\\n\";\r\n    cout.flush();\r\n    int ai;\r\n    cin>>ai;\r\n    k--;\r\n    // mp[n] = ai;\r\n    return ai;\r\n}\r\n\r\nint solve()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    maxi = n+1;\r\n    int li =  ask(1);\r\n    int ri = ask(n);\r\n    if(li==1){\r\n        return 1;\r\n    }\r\n    if(ri==1){\r\n        return n;\r\n    }\r\n    int l = 1,r = n;\r\n    set<pair<int,int>> s;\r\n    while(l<r){\r\n        // if(s.find({l,r})!=s.end() ){\r\n        //     assert(false);\r\n        // }\r\n        // s.insert({l,r});\r\n        // assert(l<=r);\r\n        int m = l + ((r-l)/2);\r\n        int mi = ask(m);\r\n        int mi1 = ask(m-1);\r\n        \r\n        // debug(l);\r\n        // debug(r);\r\n        // debug(m);\r\n        if(mi>mi1){\r\n            r = m-1;\r\n        }else{\r\n            l = m;\r\n        }\r\n        // if(r-l==1){\r\n        //     li = ask(l);\r\n        //     ri = ask(r);\r\n        //     return li<ri?li:ri;\r\n        // }\r\n    }\r\n    return l;\r\n}\r\n\r\n\r\ntemplatify void resultPrinter(T var){\r\n    cout<<var<<\" \";\r\n}\r\ntemplatify void resultPrinter(vector<T> vec){\r\n    cout<<vec.size()<<endl;\r\n    for(int i =0;i<vec.size();i++){\r\n        resultPrinter(vec[i]);\r\n        // cout<<endl;\r\n    }\r\n}\r\n\r\n\r\nvoid resultPrinter(bool var){\r\n    cout<<(var?\"Yes\":\"No\");\r\n}\r\n\r\n\r\nvoid takeInput(){\r\n\r\n}\r\nbool test(){\r\n    return true;\r\n}\r\nsigned main(int arg, char **args)\r\n{\r\n    int ans = solve();\r\n        cout<<\"! \"<<ans<<\"\\n\";\r\n        cout.flush();\r\n    return 0;\r\n    for(long long i = 1;i<arg;i++){\r\n        char ar = *args[i];\r\n        if(ar =='d'){\r\n            testing = true;\r\n        }else{\r\n            if(ar == 's'){\r\n                stress = true;\r\n            }else{\r\n                if(ar == 'r'){\r\n                    recursion = true;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }\r\n    // if (arg > 1)\r\n    //     *args[1] == 'd' ? testing = true : testing = false;\r\n    // if(arg>2){\r\n    //     stress = (*args[2] == 's' );\r\n    // }\r\n    if(recursion){\r\n        takeInput();\r\n        return 0;\r\n    }\r\n    if(stress){\r\n        return test();\r\n    }else{\r\n    // ios_base::sync_with_stdio(false);\r\n    // cin.tie(NULL);\r\n    \r\n   \r\n        // resultPrinter(solve());\r\n        \r\n        int ans = solve();\r\n        cout<<\"! \"<<ans<<\"\\n\";\r\n        cout.flush();\r\n        // cout<<endl;\r\n    \r\n    }\r\n    return 0;\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\n// #define testPrint  \r\nusing namespace std;\r\nbool testing = false;\r\nbool stress = false;\r\nbool recursion = false;\r\n#define templatify template<typename T>\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing ld = long double;\r\n\r\ntemplate<typename T1,typename T2> ostream& operator<<(ostream &os,pair<T1,T2> &p){os<<p.first<<\" \"<<p.second;return os;}\r\ntemplate<typename T1,typename T2> istream& operator>>(istream &is,pair<T1,T2> &p){is>>p.first>>p.second;return is;}\r\ntemplatify istream& operator>>(istream &is,vector<T>&vec){for(int i =0;i<vec.size();i++){ cin>>vec[i]; }  return is;}\r\ntemplatify void print(T var){\r\n    cerr<<var<<\" \";\r\n}\r\ntemplatify void print(vector<T> vec){\r\nfor(auto itr = vec.begin();itr!=vec.end();itr++){\r\n    print(*itr);\r\n}\r\n}\r\n\r\ntemplatify void print(T arr[],ll n){\r\n    for(ll i = 0;i<n;i++){\r\n        print(arr[i]);\r\n    }\r\n}\r\n\r\ntemplatify void print(set<T> st){\r\n    for(auto itr = st.begin();itr!=st.end();itr++){\r\n        print(*itr);\r\n    }\r\n}\r\n\r\ntemplate<class T1,class T2> void print(map<T1,T2> mp){\r\n    for(auto itr = mp.begin();itr!=mp.end();itr++){\r\n        print(\"key: \"); print(itr->first);\r\n        print(\"value: \");print(itr->second);\r\n    }\r\n\r\n}\r\n\r\ntemplatify class Debugger{\r\nvoid print(T var){\r\n    cerr<<var<<\" \";\r\n}\r\nvoid print(vector<T> vec){\r\nfor(auto itr = vec.begin();itr!=vec.end();itr++){\r\n    print(*itr);\r\n}\r\n}\r\n\r\n\r\nDebugger operator<<(T var){\r\n print(var);\r\n return Debugger();\r\n}\r\n\r\n};\r\n\r\n\r\n\r\n#ifndef ONLINE_JUDGE\r\n#define debug(x) cerr<<#x<<\" \";print(x);cerr<<endl;\r\n#define debArr(x,y) cerr<<#x<<\" \";print(x,y);cerr<<endl;\r\n#else\r\n#define debug(x) \r\n#define debArr(x,y) \r\n#endif\r\n\r\ntemplate<class T> void arrInput(T arr[], int n)\r\n{\r\n    \r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        T el;\r\n        cin >> el;\r\n        arr[i] = el;\r\n    }\r\n}\r\n\r\ntemplate<class T1,class T2> void arrInput(pair<T1,T2> arr[],int n){\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        pair<T1,T2> el;\r\n        cin >> el;\r\n        arr[i] = el;\r\n    }\r\n\r\n}\r\n\r\ntemplate<class T> void arrInput(vector<T> &arr, int n)\r\n{\r\n    \r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        T el;\r\n        cin >> el;\r\n        arr.push_back(el);\r\n    }\r\n}\r\n\r\ntemplate<class T> void arrInput(vector<T> &arr)\r\n{\r\n    \r\n    \r\n    for (int i = 0; i < arr.size(); i++)\r\n    {\r\n        T el;\r\n        cin >> el;\r\n        arr[i] = el;\r\n    }\r\n}\r\n\r\n// void printMap(map<int, float> infected[], int n, string message = \"printing map function\")\r\n// {\r\n//     if (testing)\r\n//     {\r\n//         cout << message << \" \"\r\n//              << \"new print\" << endl\r\n//              << endl;\r\n\r\n//         for (int i = 0; i < n; i++)\r\n//         {\r\n//             cout << endl\r\n//                  << \"map \" << i << \" \" << endl;\r\n//             for (auto j = infected[i].begin(); j != infected[i].end(); j++)\r\n//             {\r\n//                 cout << j->first << \" \" << j->second << endl;\r\n//             }\r\n//         }\r\n//         cout << endl;\r\n//     }\r\n// }\r\n\r\n// void printArray(int n, int arr[], bool forcePrint = false, string message = \"printing array\")\r\n// {\r\n//     if (testing)\r\n//     { \r\n//         cout<<message<<\" \";\r\n//     }\r\n//     if( testing ||forcePrint)\r\n//         for (int j = 0; j < n; j++)\r\n//         {\r\n//             cout << arr[j] << \" \";\r\n//         }\r\n    \r\n// }\r\n\r\n// void printSet(set<int,greater<int>> arr){\r\n// if(testing)\r\n// {for(auto i = arr.begin();i!=arr.end();i++){\r\n//     cout<<*i<<\" \";\r\n// }\r\n// cout<<endl;}\r\n// }\r\n\r\nint placeHigh(int arr[],int low,int high){\r\n    int less = low;\r\n    for(low;low<high;low++){\r\n        if (arr[low]<=arr[high])\r\n        {\r\n            swap(arr[less],arr[low]);\r\n            less++;\r\n        }\r\n        \r\n    }\r\n    swap(arr[less],arr[high]);\r\n    return less;\r\n}\r\n\r\nvoid quicksort(int arr[],int low,int high){\r\n    if(low<high){\r\n        int pi = placeHigh(arr,low,high);\r\n        quicksort(arr,low,pi-1);\r\n        quicksort(arr,pi+1,high);\r\n    }\r\n}\r\n\r\n// void printValue(string value,string message = \"value = \"){\r\n//  if(testing)\r\n//  cout<<message<<value<<endl;\r\n// }\r\n\r\nvoid inputSet(set<int,greater<int>> *mySet,int n){\r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {   int el;\r\n    cin>>el;\r\n        (*mySet).insert(el);\r\n    }\r\n    \r\n}\r\n\r\ntemplatify long long binarySearch(vector<T> vec,T el){\r\n    long long low = 0,high = vec.size()-1;\r\n    while(low<=high){\r\n        long long mid = low + abs((high-low)/2);\r\n        if(vec[mid]==el){\r\n            return mid;\r\n        }\r\n        if(el<vec[mid]){\r\n            high = mid-1;\r\n        }else{\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nint maxi;\r\nmap<int,int> mp;\r\nint k = 100;\r\nint ask(int n){\r\n    if(n<=0 || n>=maxi){\r\n        return INT_MAX;\r\n    }\r\n    // if(mp.find(n)!=mp.end()){\r\n    //     return mp[n];\r\n    // }\r\n    cout<<\"? \"<<n<<\"\\n\";\r\n    cout.flush();\r\n    int ai;\r\n    cin>>ai;\r\n    k--;\r\n    // mp[n] = ai;\r\n    return ai;\r\n}\r\n\r\nint solve()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    maxi = n+1;\r\n    int li =  ask(1);\r\n    int ri = ask(n);\r\n    if(li==1){\r\n        return 1;\r\n    }\r\n    if(ri==1){\r\n        return n;\r\n    }\r\n    int l = 1,r = n;\r\n    set<pair<int,int>> s;\r\n    while(l<r){\r\n        // if(s.find({l,r})!=s.end() ){\r\n        //     assert(false);\r\n        // }\r\n        // s.insert({l,r});\r\n        // assert(l<=r);\r\n        int m = l + ((r-l)/2);\r\n        int mi = ask(m);\r\n        int mi1 = ask(m-1);\r\n        int mi2 = ask(m+1);\r\n        // debug(l);\r\n        // debug(r);\r\n        // debug(m);\r\n        if((mi<mi2)&&(mi<mi1)){\r\n            return m;\r\n        }\r\n        if(mi<mi1){\r\n            l = m+1;\r\n        }else{\r\n            r = m-1;\r\n        }\r\n        \r\n        // if(r-l==1){\r\n        //     li = ask(l);\r\n        //     ri = ask(r);\r\n        //     return li<ri?li:ri;\r\n        // }\r\n    }\r\n    return l;\r\n}\r\n\r\n\r\ntemplatify void resultPrinter(T var){\r\n    cout<<var<<\" \";\r\n}\r\ntemplatify void resultPrinter(vector<T> vec){\r\n    cout<<vec.size()<<endl;\r\n    for(int i =0;i<vec.size();i++){\r\n        resultPrinter(vec[i]);\r\n        // cout<<endl;\r\n    }\r\n}\r\n\r\n\r\nvoid resultPrinter(bool var){\r\n    cout<<(var?\"Yes\":\"No\");\r\n}\r\n\r\n\r\nvoid takeInput(){\r\n\r\n}\r\nbool test(){\r\n    return true;\r\n}\r\nsigned main(int arg, char **args)\r\n{\r\n    int ans = solve();\r\n        cout<<\"! \"<<ans<<\"\\n\";\r\n        cout.flush();\r\n    return 0;\r\n    for(long long i = 1;i<arg;i++){\r\n        char ar = *args[i];\r\n        if(ar =='d'){\r\n            testing = true;\r\n        }else{\r\n            if(ar == 's'){\r\n                stress = true;\r\n            }else{\r\n                if(ar == 'r'){\r\n                    recursion = true;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }\r\n    // if (arg > 1)\r\n    //     *args[1] == 'd' ? testing = true : testing = false;\r\n    // if(arg>2){\r\n    //     stress = (*args[2] == 's' );\r\n    // }\r\n    if(recursion){\r\n        takeInput();\r\n        return 0;\r\n    }\r\n    if(stress){\r\n        return test();\r\n    }else{\r\n    // ios_base::sync_with_stdio(false);\r\n    // cin.tie(NULL);\r\n    \r\n   \r\n        // resultPrinter(solve());\r\n        \r\n        int ans = solve();\r\n        cout<<\"! \"<<ans<<\"\\n\";\r\n        cout.flush();\r\n        // cout<<endl;\r\n    \r\n    }\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 300000;\n\nint n, k;\nint a[N + 5];\n\nll s[N + 5];\n\nint main()\n{\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n\n    s[0] = a[0];\n    for (int i = n - 1; i >= 0; i--)\n        s[i] = s[i + 1] + a[i];\n\n    ll maxSum = s[0];\n    sort(s, s + n, greater<ll>());\n    for (int i = 0; i < k - 1; i++)\n        maxSum += s[i];\n\n    printf(\"%lld\", maxSum);\n\n    return 0;\n}",
        "fixed_code": "#include <cstdio>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 300000;\n\nint n, k;\nint a[N + 5];\n\nll s[N + 5];\n\nint main()\n{\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n\n    s[0] = a[0];\n    for (int i = n - 1; i >= 0; i--)\n        s[i] = s[i + 1] + a[i];\n\n    sort(s + 1, s + n, greater<ll>());\n    ll maxSum = 0;\n    for (int i = 0; i < k; i++)\n        maxSum += s[i];\n\n    printf(\"%lld\", maxSum);\n\n    return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "//   __________________\n//  | ________________ |\n//  ||          ____  ||\n//  ||   /\\    |      ||\n//  ||  /__\\   |      ||\n//  || /    \\  |____  ||\n//  ||________________||\n//  |__________________|\n//  \\###################\\\n//   \\###################\\\n//    \\        ____       \\\n//     \\_______\\___\\_______\\\n// An AC a day keeps the doctor away.\n\n#pragma g++ optimize(\"Ofast\")\n#pragma loop_opt(on)\n#include <bits/extc++.h>\n#ifdef local\n#define debug(x) (cerr<<#x<<\" = \"<<(x)<<'\\n')\n#else\n#define debug(x) ((void)0)\n#endif // local\n#define all(v) begin(v),end(v)\n#define siz(v) (ll(v.size()))\n#define get_pos(v,x) (lower_bound(all(v),x)-begin(v))\n#define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v))\n#define pb emplace_back\n#define ff first\n#define ss second\n#define mem(v,x) memset(v,x,sizeof v)\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef int64_t ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pld;\ntemplate <typename T> using max_heap = __gnu_pbds::priority_queue<T,less<T> >;\ntemplate <typename T> using min_heap = __gnu_pbds::priority_queue<T,greater<T> >;\ntemplate <typename T> using rbt = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\nconstexpr ld PI = acos(-1), eps = 1e-5;\nconstexpr ll N = 500025, INF = 1e18, MOD = 20191126, K = 512, inf = 1e9;\nconstexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p>>=1,e=e*e%m) if(p&1) r=r*e%m; return r;}\nconstexpr inline ll cdiv(ll x, ll m) { return (x+m-1)/m; } // ceiling divide, x/m for flooring divide\n\nll n,L,v[N];\nsigned main() {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> v[i];\n    int pos = -1;\n    for(int i = 0; i < n; i++) if(v[i]==-1) pos = i;\n    L = __lg(n);\n    vector<ll> vv;\n    for(int i = 0; i < pos; i++) vv.pb(0);\n    for(int i = pos+1; i < n; i++) vv.pb(v[i]);\n    sort(all(vv));\n    ll sum = 0;\n    for(int i = 0; i < L; i++) sum += vv[i];\n    cout<<sum<<'\\n';\n}\n",
        "fixed_code": "//   __________________\n//  | ________________ |\n//  ||          ____  ||\n//  ||   /\\    |      ||\n//  ||  /__\\   |      ||\n//  || /    \\  |____  ||\n//  ||________________||\n//  |__________________|\n//  \\###################\\\n//   \\###################\\\n//    \\        ____       \\\n//     \\_______\\___\\_______\\\n// An AC a day keeps the doctor away.\n\n#pragma g++ optimize(\"Ofast\")\n#pragma loop_opt(on)\n#include <bits/extc++.h>\n#ifdef local\n#define debug(x) (cerr<<#x<<\" = \"<<(x)<<'\\n')\n#else\n#define debug(x) ((void)0)\n#endif // local\n#define all(v) begin(v),end(v)\n#define siz(v) (ll(v.size()))\n#define get_pos(v,x) (lower_bound(all(v),x)-begin(v))\n#define sort_uni(v) sort(begin(v),end(v)),v.erase(unique(begin(v),end(v)),end(v))\n#define pb emplace_back\n#define ff first\n#define ss second\n#define mem(v,x) memset(v,x,sizeof v)\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef int64_t ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pld;\ntemplate <typename T> using max_heap = __gnu_pbds::priority_queue<T,less<T> >;\ntemplate <typename T> using min_heap = __gnu_pbds::priority_queue<T,greater<T> >;\ntemplate <typename T> using rbt = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\nconstexpr ld PI = acos(-1), eps = 1e-5;\nconstexpr ll N = 500025, INF = 1e18, MOD = 20191126, K = 512, inf = 1e9;\nconstexpr ll modpow(ll e,ll p,ll m=MOD) {ll r=1; for(;p;p>>=1,e=e*e%m) if(p&1) r=r*e%m; return r;}\nconstexpr inline ll cdiv(ll x, ll m) { return (x+m-1)/m; } // ceiling divide, x/m for flooring divide\n\nll n,L,v[N];\nsigned main() {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> v[i];\n    int pos = -1;\n    for(int i = 0; i < n; i++) if(v[i]==-1) pos = i;\n    min_heap<ll> pq;\n    ll sum = 0;\n    for(int i = n-1; i > pos; i--) {\n        pq.push(v[i]);\n        if(i+1 == (1<<__lg(i+1))) {\n            sum += pq.top();\n            pq.pop();\n        }\n    }\n    cout<<sum<<'\\n';\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "/*\n * This is my code,\n * my code is amazing...\n */\n//Template v2.0\n//iostream is too mainstream\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<iomanip>\n//clibraries\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<ctime>\n//defines\n#define ll long long\n#define lld long double\n#define pll pair<ll,ll>\n#define pld pair<lld,lld>\n#define vll vector<ll>\n#define vvll vector<vll>\n#define INF 1000000000000000047\nconst char en='\\n';\n#define debug(x){cerr<<x<<en;}\n#define prime 47\n#define lprime 1000000000000000009\n#define lldmin LDBL_MIN\n#define MP make_pair\n#define PB push_back\nusing namespace std;\n\n\n\nbool valid(ll a,ll b,ll c,ll k){\n    if(a+b+c<=k){\n    if((k-a-b-c)%3==0)return true;\n    return false;\n    }\n    else return false;\n}\n\n\nbool check(ll a, ll b, ll c, ll n){\n    ll m=max(a,max(b,c));\n    ll x=m-a+m-b+m-c;\n    if((n-x)%3==0 && n-x>=0){cout<<\"yes\"<<en;return true;}\n    return false;\n}\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\n        int n;\n        cin>>n;\n\n        for(int i=1; i<=n; i++){\n            ll a,b,d,e;\n            cin>>a>>b>>d>>e;\n            ll h=a-b;\n\n            ll x=0,y=d,z=d+e;\n            \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b))\n                continue;\n            }\n            x=0; y=x+d;z=y-e;\n            if(z<0){\n                x+=abs(z);\n                y+=abs(z);\n                z=0;\n            }\n \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b));\n                continue;\n            }\n            \n\n            x=0; y=x-d;z=y-e;\n            if(z<0){\n                x+=abs(z);\n                y+=abs(z);\n                z=0;\n            }\n \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b));\n                continue;\n            }\n            \n            x=0; y=x-d;z=y+e;\n            if(y<0){\n                x+=abs(y);\n                z+=abs(y);\n                y=0;\n            }\n \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b));\n                continue;\n            }\n            \n\n\n\n\n\n\n    cout<<\"no\"<<en;\n\n\n        }\n\n\n\n}\n\n\n",
        "fixed_code": "/*\n * This is my code,\n * my code is amazing...\n */\n//Template v2.0\n//iostream is too mainstream\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<iomanip>\n//clibraries\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<ctime>\n//defines\n#define ll long long\n#define lld long double\n#define pll pair<ll,ll>\n#define pld pair<lld,lld>\n#define vll vector<ll>\n#define vvll vector<vll>\n#define INF 1000000000000000047\nconst char en='\\n';\n#define debug(x){cerr<<x<<en;}\n#define prime 47\n#define lprime 1000000000000000009\n#define lldmin LDBL_MIN\n#define MP make_pair\n#define PB push_back\nusing namespace std;\n\n\n\nbool valid(ll a,ll b,ll c,ll k){\n    if(a+b+c<=k){\n    if((k-a-b-c)%3==0)return true;\n    return false;\n    }\n    else return false;\n}\n\n\nbool check(ll a, ll b, ll c, ll n){\n    ll m=max(a,max(b,c));\n    ll x=m-a+m-b+m-c;\n    if((n-x)%3==0 && n-x>=0){cout<<\"yes\"<<en;return true;}\n    return false;\n}\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\n        int n;\n        cin>>n;\n\n        for(int i=1; i<=n; i++){\n            ll a,b,d,e;\n            cin>>a>>b>>d>>e;\n            ll h=a-b;\n\n            ll x=0,y=d,z=d+e;\n            \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b))\n                continue;\n            }\n            x=0; y=x+d;z=y-e;\n            if(z<0){\n                x+=abs(z);\n                y+=abs(z);\n                z=0;\n            }\n \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b))\n                continue;\n            }\n            \n\n            x=0; y=x-d;z=y-e;\n            if(z<0){\n                x+=abs(z);\n                y+=abs(z);\n                z=0;\n            }\n \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b))\n                continue;\n            }\n            \n            x=0; y=x-d;z=y+e;\n            if(y<0){\n                x+=abs(y);\n                z+=abs(y);\n                y=0;\n            }\n \n            if(valid(x,y,z,b)){\n                if(check(x,y,z,a-b))\n                continue;\n            }\n            \n\n\n\n\n\n\n    cout<<\"no\"<<en;\n\n\n        }\n\n\n\n}\n\n\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#define initdp(a,b) for(int i=0;i<=a;i++)for(int j=0;j<=b;j++)dp[i][j]=-1;\n#define fi first\n#define se second\n#define pb push_back\n#define pii pair<int,int>\n#define ll long long\n#define pll pair<ll,ll>\n#define rep(i,from,n) for(int i=from;i<n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define inf 1000000001\n#define inf1 1000000000000000001\n#define mod 1000000007\n#define pie 3.14159265358979323846\n#define N 1000005\n#define mid(l,r) l+(r-l)/2\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ddx[8]={1,1,0,-1,-1,-1,0,1},ddy[8]={0,1,1,1,0,-1,-1,-1};\nvoid mad(ll &a,ll b){a=(a+b)%mod;if(a<0)a+=mod;}\nll gcd(ll a,ll b){ if(a>b)swap(a,b);if(!a)return b;return gcd(b%a,a);}\n\nvoid solve(){\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n];\n\tint sum=0;\n\trep(i,0,n){cin>>a[i];sum+=a[i];}\n\tif(m<n){cout<<\"-1\"<<endl;return;}\n\tcout<<2*sum<<endl;\n\trep(i,1,n){\n\t\tcout<<i<<\" \"<<i+1<<endl;\n\t}\n\tcout<<n<<\" 1\"<<endl;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tint t;\n\tcin>>t;\n\t//t=1;\n\twhile(t--){\n\t\tsolve();\n\t}\n}",
        "fixed_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#define initdp(a,b) for(int i=0;i<=a;i++)for(int j=0;j<=b;j++)dp[i][j]=-1;\n#define fi first\n#define se second\n#define pb push_back\n#define pii pair<int,int>\n#define ll long long\n#define pll pair<ll,ll>\n#define rep(i,from,n) for(int i=from;i<n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define inf 1000000001\n#define inf1 1000000000000000001\n#define mod 1000000007\n#define pie 3.14159265358979323846\n#define N 1000005\n#define mid(l,r) l+(r-l)/2\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ddx[8]={1,1,0,-1,-1,-1,0,1},ddy[8]={0,1,1,1,0,-1,-1,-1};\nvoid mad(ll &a,ll b){a=(a+b)%mod;if(a<0)a+=mod;}\nll gcd(ll a,ll b){ if(a>b)swap(a,b);if(!a)return b;return gcd(b%a,a);}\n\nvoid solve(){\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n];\n\tint sum=0;\n\trep(i,0,n){cin>>a[i];sum+=a[i];}\n\tif(m<n||n==2){cout<<\"-1\"<<endl;return;}\n\tcout<<2*sum<<endl;\n\trep(i,1,n){\n\t\tcout<<i<<\" \"<<i+1<<endl;\n\t}\n\tcout<<n<<\" 1\"<<endl;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tint t;\n\tcin>>t;\n\t//t=1;\n\twhile(t--){\n\t\tsolve();\n\t}\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.*;\nimport java.util.*;\n\npublic class ParkingLot implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args) {\n        new ParkingLot().run();\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            if (System.getProperty(\"ONLINE_JUDGE\") != null) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            Locale.setDefault(Locale.US);\n            solve();\n            in.close();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Throwable t) {\n            t.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    // solution\n\n    public class Interval implements Comparable {\n        int start;\n        int end;\n        int size;\n        int nextPlace;\n\n        public Interval(int start, int end) {\n            this.start = start;\n            this.end   = end;\n            this.size = 0;\n            this.nextPlace = -1;\n            int realsize = end - start - 1;\n            if(realsize > 0){\n                if(start != 0 && end != n + 1){\n                    this.size = 1 + (realsize-1)/2;\n                    this.nextPlace = start + this.size;\n                }\n                else if(start == 0) {\n                    this.size = end - 1;\n                    this.nextPlace = 1;\n                }\n                else {\n                    this.nextPlace = n;\n                    this.size = n - start;\n                }\n            }\n        }\n\n\n        @Override\n        public int compareTo(Object o) {\n            Interval to = (Interval) o;\n            int ret = (to.size - this.size);\n            if(ret != 0)\n                return ret;\n            return(this.start - to.start);\n        }\n    }\n\n\n    PriorityQueue<Interval> pq = new PriorityQueue<Interval>();\n    Map<Integer,Interval> startMap = new HashMap<Integer,Interval>();\n    Map<Integer,Interval> endMap   = new HashMap<Integer, Interval>();\n    Map<Integer,Integer>  carMap  = new HashMap<Integer, Integer>();\n    int n ;\n    int m;\n\n    void add(Interval interval) {\n        pq.add(interval);\n        startMap.put(interval.start, interval);\n        endMap.put(interval.end, interval);\n    }\n\n    Interval remove(Interval it) {\n        startMap.remove(it.start);\n        endMap.remove(it.end);\n        return it;\n    }\n\n\n    void solve() throws IOException {\n        n = readInt();\n        m = readInt();\n        Interval it = new Interval(0, n+1);\n        add(it);\n        for(int i = 0 ; i < m; i ++) {\n            int action = readInt();\n            int car    = readInt();\n            if(action == 1) {\n                Interval interval= pq.poll();\n                remove(interval);\n                out.println(interval.nextPlace);\n                carMap.put(car, interval.nextPlace);\n                Interval left = new Interval(interval.start,  interval.nextPlace);\n                Interval right =new Interval(interval.nextPlace, interval.end);\n                add(left);\n                add(right);\n            }\n            else {\n                int place = carMap.remove(car);\n                Interval left = endMap.get(place);\n                Interval right = startMap.get(place);\n                remove(left);\n                remove(right);\n                Interval interval = new Interval(left.start, right.end);\n                add(interval);\n            }\n        }\n\n    }\n\n}",
        "fixed_code": "import java.io.*;\nimport java.util.*;\n\npublic class ParkingLot implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args) {\n        new ParkingLot().run();\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            if (System.getProperty(\"ONLINE_JUDGE\") != null) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            Locale.setDefault(Locale.US);\n            solve();\n            in.close();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Throwable t) {\n            t.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    // solution\n\n    public class Interval implements Comparable {\n        int start;\n        int end;\n        int size;\n        int nextPlace;\n\n        public Interval(int start, int end) {\n            this.start = start;\n            this.end   = end;\n            this.size = 0;\n            this.nextPlace = -1;\n            int realsize = end - start - 1;\n            if(realsize > 0){\n                if(start != 0 && end != n + 1){\n                    this.size = 1 + (realsize-1)/2;\n                    this.nextPlace = start + this.size;\n                }\n                else if(start == 0) {\n                    this.size = end - 1;\n                    this.nextPlace = 1;\n                }\n                else {\n                    this.nextPlace = n;\n                    this.size = n - start;\n                }\n            }\n        }\n\n\n        @Override\n        public int compareTo(Object o) {\n            Interval to = (Interval) o;\n            int ret = (to.size - this.size);\n            if(ret != 0)\n                return ret;\n            return(this.start - to.start);\n        }\n    }\n\n\n    TreeSet<Interval> pq = new TreeSet<Interval>();\n    Map<Integer,Interval> startMap = new HashMap<Integer,Interval>();\n    Map<Integer,Interval> endMap   = new HashMap<Integer, Interval>();\n    Map<Integer,Integer>  carMap  = new HashMap<Integer, Integer>();\n    int n ;\n    int m;\n\n    void add(Interval interval) {\n        pq.add(interval);\n        startMap.put(interval.start, interval);\n        endMap.put(interval.end, interval);\n    }\n\n    Interval remove(Interval it) {\n        pq.remove(it);\n        startMap.remove(it.start);\n        endMap.remove(it.end);\n        return it;\n    }\n\n\n    void solve() throws IOException {\n        n = readInt();\n        m = readInt();\n        Interval it = new Interval(0, n+1);\n        add(it);\n        for(int i = 0 ; i < m; i ++) {\n            int action = readInt();\n            int car    = readInt();\n            if(action == 1) {\n                Interval interval= pq.first();\n                pq.remove(interval);\n                remove(interval);\n                out.println(interval.nextPlace);\n                carMap.put(car, interval.nextPlace);\n                Interval left = new Interval(interval.start,  interval.nextPlace);\n                Interval right =new Interval(interval.nextPlace, interval.end);\n                add(left);\n                add(right);\n            }\n            else {\n                int place = carMap.remove(car);\n                Interval left = endMap.get(place);\n                Interval right = startMap.get(place);\n                remove(left);\n                remove(right);\n                Interval interval = new Interval(left.start, right.end);\n                add(interval);\n            }\n        }\n\n    }\n\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "@java.lang.Override\nprotected void doRun() {\n    getLocalProject().getModelElements().add(tournament);\n}",
        "fixed_code": "@org.junit.Test\npublic void testMultiReferenceRevertWithCommand() {\n    final org.eclipse.emf.emfstore.bowling.Tournament tournament = org.eclipse.emf.emfstore.client.test.common.dsl.Create.tournament(true);\n    final int numTrophies = 40;\n    org.eclipse.emf.emfstore.client.test.common.dsl.Add.toProject(getLocalProject(), tournament);\n    new org.eclipse.emf.emfstore.internal.client.model.util.EMFStoreCommand() {\n        @java.lang.Override\n        protected void doRun() {\n            for (int i = 0; i < numTrophies; i++) {\n                tournament.getReceivesTrophy().add(false);\n            }\n        }\n    }.run(false);\n    org.junit.Assert.assertEquals(numTrophies, tournament.getReceivesTrophy().size());\n    getLocalProject().revert();\n    org.junit.Assert.assertEquals(0, tournament.getReceivesTrophy().size());\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "@java.lang.Override\npublic int compare(com.modelingbrain.home.model.Model o1, com.modelingbrain.home.model.Model o2) {\n    if ((o1.getMillisecond_Date()) < (o2.getMillisecond_Date()))\n        return 1;\n    \n    if ((o1.getMillisecond_Date()) > (o2.getMillisecond_Date()))\n        return -1;\n    \n    return 0;\n}",
        "fixed_code": "@java.lang.Override\npublic int compare(com.modelingbrain.home.model.Model o1, com.modelingbrain.home.model.Model o2) {\n    if ((o1.getMillisecond_Date()) > (o2.getMillisecond_Date()))\n        return 1;\n    \n    if ((o1.getMillisecond_Date()) < (o2.getMillisecond_Date()))\n        return -1;\n    \n    return 0;\n}",
        "source": "BFP_Java_1190331.json"
    },
    {
        "source_code": "#include <iostream>\n#include <sstream>\n#include <stdio.h>\n#include <memory.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cassert>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define _(a,b) memset( (a), b, sizeof( a ) )\n#define all(a) a.begin(), a.end()\n#define sz(a) (int)a.size()\n\ntypedef unsigned long long ull;\ntypedef long long lint;\ntypedef pair < int , int > pii;\ntypedef long double ld;\n\nconst int inf = 1000 * 1000 * 1000;\nconst lint linf = 1000000000000000000LL;\nconst double eps = 1e-9;\n\nvoid prepare( )\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n}\n\nconst int pred = 350;\nconst int after = 360;\nint n;\nint w[105];\nint dp[105][355];\nint p[105][355];\nvector < int > q;\nbool used[105];\nvector < int > cost;\n\nbool solve( )\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i ++)\n\t\tcin >> w[i];\n\t_(dp,0);\n\tfor (int i = 0; i < n; i ++)\n\t{\n\t\tfor (int j = pred; j >= 0; j --)\n\t\t{\n\t\t\tif (j - w[i] >= 0)\n\t\t\t{\n\t\t\t\tif (dp[i+1][j] < dp[i][j - w[i]] + 1)\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j] = dp[i][j - w[i]] + 1;\n\t\t\t\t\tp[i+1][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint mx = 0;\n\tint bst = 0;\n\tfor (int i = 0; i <= pred; i ++)\n\t{\n\t\tif (dp[n][i] > mx)\n\t\t{\n\t\t\tmx = dp[n][i];\n\t\t\tbst = i;\n\t\t}\n\t}\n\n\tint v = n;\n\tint tt = bst;\n\t_(used,false);\n\twhile (v)\n\t{\n\t\tif (p[v][tt])\n\t\t{\n\t\t\tused[v-1] = true;\n\t\t\tq.pb(v-1);\n\t\t\ttt = tt - w[v - 1];\n\t\t}\n\t\tv--;\n\t}\n\n\tfor (int i = 0; i < n; i ++)\n\t\tif (!used[i])\n\t\t\tcost.pb(w[i]);\n\tsort(all(cost));\n\n\tint sum = 0;\n\tfor (int i = 0; i < sz(cost); i ++)\n\t{\n\t\tbst += cost[i];\n\t\tif (bst <= pred + after)\n\t\t{\n\t\t\tmx++;\n\t\t\tsum += max(0,bst - pred);\n\t\t}\n\t}\n\n\tcout << mx << \" \" << sum << endl;\n\n\treturn false;\n}\n\nint main()\n{\n\tprepare( );\n\twhile ( solve() );\n\treturn 0;\n}",
        "fixed_code": "#include <iostream>\n#include <sstream>\n#include <stdio.h>\n#include <memory.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cassert>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define _(a,b) memset( (a), b, sizeof( a ) )\n#define all(a) a.begin(), a.end()\n#define sz(a) (int)a.size()\n\ntypedef unsigned long long ull;\ntypedef long long lint;\ntypedef pair < int , int > pii;\ntypedef long double ld;\n\nconst int inf = 1000 * 1000 * 1000;\nconst lint linf = 1000000000000000000LL;\nconst double eps = 1e-9;\n\nvoid prepare( )\n{\n#ifdef _DEBUG\n        freopen(\"input.txt\", \"r\", stdin);\n#endif\n}\n\nconst int pred = 350;\nconst int after = 360;\nint n;\nint w[105];\nint dp[105][355];\nint p[105][355];\nvector < int > q;\nbool used[105];\nvector < int > cost;\n\nbool solve( )\n{\n        cin >> n;\n        for (int i = 0; i < n; i ++)\n                cin >> w[i];\n\t\t /*_(used,false);\n        _(dp,0);\n        for (int i = 0; i < n; i ++)\n        {\n                for (int j = pred; j >= 0; j --)\n                {\n                        if (j - w[i] >= 0)\n                        {\n                                if (dp[i+1][j] < dp[i][j - w[i]] + 1)\n                                {\n                                        dp[i+1][j] = dp[i][j - w[i]] + 1;\n                                        p[i+1][j] = 1;\n                                }\n                        }\n                }\n        }\n           \n        int mx = 0;\n        int bst = 0;\n        for (int i = 0; i <= pred; i ++)\n        {\n                if (dp[n][i] > mx)\n                {\n                        mx = dp[n][i];\n                        bst = i;\n                }\n        }\n\n        int v = n;\n        int tt = bst;\n\n        while (v)\n        {\n                if (p[v][tt])\n                {\n                        used[v-1] = true;\n                        q.pb(v-1);\n                        tt = tt - w[v - 1];\n                }\n                v--;\n        }*/\n\n\t\tint mx = 0;\n\t\tint bst = 0;\n        for (int i = 0; i < n; i ++)\n                if (!used[i])\n                        cost.pb(w[i]);\n        sort(all(cost));\n\n        int sum = 0;\n        for (int i = 0; i < sz(cost); i ++)\n        {\n                bst += cost[i];\n                if (bst <= pred + after)\n                {\n                        mx++;\n                        sum += max(0,bst - pred);\n                }\n        }\n\n        cout << mx << \" \" << sum << endl;\n\n        return false;\n}\n\nint main()\n{\n        prepare( );\n        while ( solve() );\n        return 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\n#define fast { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n#define pb push_back\n#define ll long long\n#define ld long double\n#define sz(x) (ll)x.size()\n\n#define vi vector<int>\n#define vl vector<long>\n#define vll vector<long long>\n\n#define infi INT_MAX\n#define infl LONG_LONG_MAX\n#define infd LDBL_MAX\n#define f(i,a,b) for(ll i=a;i<b;i++)\n#define fi(i,a,b) for(ll i=(b-1);i>=a;i--)\n#define F first\n#define S second\n#define G(a,b) get<a>(b)\n#define MP make_pair\n#define MT make_tuple\n#define pll pair<ll,ll>\n//#define endl \"\\n\"\n#define ALL(v) v.begin(),v.end()\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<x;\n#define pr1(x) cout<<x<<\" \";\n#define pr2(x,y) cout<<x<<\" \"<<y;\n#define pr3(x,y,z) cout<<x<<\" \"<<y<<\" \"<<z;\n#define pr4(x,y,z,w) cout<<x<<\" \"<<y<<\" \"<<z<<\" \"<<w;\n#define deb printf(\"***************************************************************************************\\n\");\n#define moshi printf(\"moshi moshi ! \\n\");\n#define hi printf(\"hi ! \\n\");\n#define bye printf(\"bye bye ! \\n\");\n#define o_set(ll) tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>\n#define number_of_set_bits  __builtin_popcountll\nconst ld PI=3.1415926535897932384626433;\n\n//template<typename T>\n//#define o_set(T) tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>\n//member functions :\n//1. order_of_key(k) : number of elements strictly lesser than k\n//2. find_by_order(k) : k-th element in the set\n\n\n//const ll N=1e6+7;\nll p=1e9+7;\n//ll fac[N];\n\nll gcd(ll a, ll b)\n{\n   if (a == 0) return b;\n   return gcd(b % a, a);\n}\n\ninline ll ceil(ll a,ll b)\n{\n   return (a+b-1)/b;\n}\n\nll max(ll x,ll y,ll z)\n{\n   return max(x,max(y,z));\n}\n\nll min(ll x,ll y,ll z)\n{\n   return min(x,min(y,z));\n}\n\n\nll modpro(ll x,ll y,ll z=1)\n{\n   x%=p;\n   y%=p;\n   z%=p;\n   ll res=(x*y)%p;\n   res=(res*z)%p;\n   return res;\n}\n\nll modadd(ll x,ll y,ll z=0)\n{\n   x%=p;\n   y%=p;\n   z%=p;\n   ll res=(x+y)%p;\n   res=(res+z)%p;\n   return res;\n}\n\n\nll pow_mod_p(ll a,ll b)\n{\n   a=a%p;\n   ll res=1;\n   while(b>0)\n   {\n     if(b&1) res=(res*a)%p;\n     b=b>>1;\n     a=(a*a)%p;\n   }\n   return res;\n}\n\ninline ll mod_inv(ll x)\n{\n   return pow_mod_p(x,p-2);\n}\n\n\n// Don't forget to set fac[0]=1\n/*ll nCr(ll x,ll y)\n{\n   if(x<y) return 0;\n   ll res=fac[x];\n   ll den=(fac[y]*fac[x-y])%p;\n   ll deni=mod_inv(den);\n   res=(res*deni)%p;\n   return res;\n}*/\n\n\n\nll is_set(ll a,ll i)\n{\n   if( ( a & ((ll)1<<i) ) == 0 ) return 0;\n   else return 1;\n}\n\n\n\n//  Comparator should follow :\n//  1: x<=y or y<=x uniquely\n//  2: Transitivity : a<=b and b<=c implies a<=c\n//  3: Anti-Symmetry: a<=b and b<=a implies a=b\n// return 1 to put x before y in sorted order\ninline bool comp(pll &x,pll &y)\n{\n   if(x.F<y.F) return 1;\n   else if(x.F==y.F)\n   {\n      if(x.S>y.S) return 1;\n      else return 0;\n   }\n   return 0;\n}\n\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\n// resize : str.resize(new_size)   new size <= old size\n\n// for Vector :\n// lower_bound(starting iterator , iterator next to end , value)  :  iterator to first element greater than or equal to value\n// upper_bound(starting iterator , iterator next to end , value)  :  iterator to first element strictly greater than value\n\n// For Set :      s.lower_bound(value)\n// if no such element exists they return  vector.end() or s.end()\n\n\n// x bits : [x-1 , x-2 , .... , 1(1st bit) , 0(0th bit)] =>   leftmost 1 at 2^(x-1)    max number that can be represented : 2^(x) -1\n// 63 bits is greater than 10^18\n\n// 1<<x  :  2 ^ x  (left shift)\n\n// Min heap :  priority_queue < ll , vector<ll>, greater<ll> > q\n// Max heap :  priority_queue < ll > q\n    // Set in descending order  :   set< ll,greater <ll> >\n\n\n// While debugging :\n// 1 : check if array size is correct  :  It may give unexpected results\n// 2 : check if you have swapped i and j at some part of program\n// 3 : for string check if you are trying to acces  index = -1\n\n\n// Bitwise Tricks :\n// 1 : While using 1<<i  use (ll)1<<i  because in former one \"1\" is considered as int\n// 2 : To flip first k-bits of a number :  x xor (2^k-1)  or x ^ (((ll)1<<k)-1)  : 2^k-1 is the largest number of k bits\n// 3 : To flip k-th bit (0-based)  :  x xor (2^k)  or  x ^ ((ll)1<<k)\n// 4 : To set k-th bit (0-based)   :  x or (2^k)   or  x | ((ll)1<<k)\n// 5 : To un-set k-th bit (0-based)   :  x & (~ ((ll)1<<k) )\n\n\n// To prove Greedy :\n// 1 : Optimal Choice at each step\n// 2 : Exchange Argument\n// 3 : Find a lower or upper bound on answer and then construct an answer for that bound\n// 4 : Find properties which Optimal Solution must satisfy ( This can be useful to deduce form of Optimal answer)\n\n// Erase one occurrence in multiset : it=s.find(element)   s.erase(it)\n// putchar('a'+j) : to print (j+1)th character\n// getline(cin,str) : To input string until newline\n\n\nvoid lps(string &pp,ll *lps)\n{\n   ll xx=pp.length();\n   //ll lps[xx]={};\n   f(i,1,xx)\n   {\n       ll j=lps[i-1];\n       while(j>0 && pp[j]!=pp[i]) j=lps[j-1];\n       if(pp[i]==pp[j]) j++;\n       lps[i]=j;\n   }\n}\n\n\n// Remember to take input string as  getline(cin,s)\nvoid stoi(string &s,vll &v)\n{\n   stringstream str(s);\n   ll x;\n   while(str>>x)\n   {\n       v.pb(x);\n   }\n}\n\n\n\n\nvoid Miden(ll **p1,ll n)\n{\n    ll (*x)[n]=(ll(*)[n]) p1;\n    f(i,0,n)\n    {\n        f(j,0,n)\n        {\n            x[i][j]=0;\n        }\n        x[i][i]=1;\n    }\n    return;\n}\n\nvoid Mmult(ll **p1,ll **p2,ll **ans,ll x,ll y,ll z,ll m)\n{\n    ll (*a)[y]=(ll (*)[y])p1;\n    ll (*b)[z]=(ll (*)[z])p2;\n    ll (*c)[z]=(ll (*)[z])ans;\n    f(i,0,x)\n    {\n        f(j,0,z)\n        {\n            c[i][j]=0;\n            f(k,0,y)\n            {\n                c[i][j]+=a[i][k]*b[k][j];\n                c[i][j]%=m;\n            }\n        }\n    }\n    return;\n}\n\nvoid Mpow(ll **p1,ll **ans,ll n,ll y,ll m)\n{\n    if(y==0)\n    {\n        Miden(ans,n);\n        return;\n    }\n    ll t[n][n];\n    Mpow(p1,(ll **)t,n,y/2,m);\n    ll z[n][n];\n    Mmult((ll **)t,(ll **)t,(ll **)z,n,n,n,m);\n    if(y%2)\n    {\n        Mmult((ll **)z,p1,ans,n,n,n,m);\n    }\n    else\n    {\n        Miden((ll **)t,n);\n        Mmult((ll **)z,(ll **)t,ans,n,n,n,m);\n    }\n    return;\n}\n\n\n\nvoid debg(ll *arr,ll l,ll r)\n{\n  f(i,l,r+1) pr1(arr[i])\n  nl\n}\n\nvoid exit()\n{\n  cout<<\"-1\\n\";\n  exit(0);\n}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n    template <typename Arg1>\n    void __f(const char* name, Arg1&& arg1){\n        cout << name << \" : \" << arg1 << std::endl;\n        //use cerr if u want to display at the bottom\n    }\n    template <typename Arg1, typename... Args>\n    void __f(const char* names, Arg1&& arg1, Args&&... args){\n        const char* comma = strchr(names + 1, ','); cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n    }\n#else\n#define trace(...)\n#endif\n\n#define endl \"\\n\"\n\nconst ll N=1e6+6;\nlist<pll>adj[N];\nlist<ll>revAdj[N];\nll n,m,s;\nbool consider[N];\n\nvoid dfs(ll v)\n{\n  consider[v]=1;\n  for(auto i:adj[v]) if(!consider[i.F]) dfs(i.F);\n}\n\nvll topo;\nbool visited[N];\nvoid dfs2(ll v)\n{\n  visited[v]=1;\n  for(auto i:revAdj[v]) if(!visited[i] && consider[i]) dfs2(i);\n  topo.pb(v);\n}\n\nll mark[N],zz;\nlist<ll> y;\nlist<ll> mp[N];\nvoid dfs3(ll v)\n{\n  mark[v]=zz;\n  for(auto i:adj[v]) if(!mark[i.F] && consider[i.F]) dfs3(i.F);\n  y.pb(v);\n}\n\nll calc(ll x)\n{\n   ll lef=0,rig=1e4,ans=-1;\n   while(lef<=rig)\n   {\n       ll mid=(lef+rig)>>1;\n       if(x- (mid* (mid+1) )/2 >=0) ans=mid,lef=mid+1;\n       else rig=mid-1;\n   }\n   ll res=(ans+1)*x-(ans*(ans+1)*(ans+2))/6;\n   return res;\n}\n\n\nll val[N],dp[N],mx;\n\n\nvoid dfs4(ll v)\n{\n  visited[mark[v]]=1;\n  ll temp=0;\n  list<ll> &vec=mp[mark[v]];\n  for(auto i:vec) \n  {\n      for(auto j:adj[i])\n      {\n          ll u=j.F,w=j.S;\n          if(!visited[mark[u]]) dfs4(mark[u]);\n          if(mark[u]!=mark[v]) temp=max(temp,w+dp[mark[u]]);\n      }\n  }\n  dp[v]=temp+val[mark[v]];\n  mx=max(mx,dp[v]);\n}\n\n\nvoid func()\n{\n  cin>>n>>m;\n  f(i,1,m+1)\n  {\n      ll u,v,w;\n      cin>>u>>v>>w;\n      adj[u].pb(MP(v,w));\n      revAdj[v].pb(u);\n  }\n  cin>>s;\n  dfs(s);\n  f(i,1,n+1) if(!visited[i] && consider[i]) dfs2(i);\n  reverse(ALL(topo));\n  \n  for(auto i:topo)\n  {\n      if(!mark[i])\n      {\n         y.clear();\n         zz=i;\n         dfs3(i);\n         ll temp=0;\n         for(auto j:y)\n         {\n            for(auto z:adj[j])\n            {\n                if(mark[z.F]==zz) temp+=calc(z.S);\n            }\n         }\n         val[i]=temp;\n         mp[i]=y;\n      }\n  }\n  \n  f(i,1,n+1) visited[i]=0;\n  dfs4(s);\n  cout<<mx<<\"\\n\";\n}\n\n\nint main()\n{\n    fast\n\n    //#ifndef ONLINE_JUDGE\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    //#endif // ONLINE_JUDGE\n\n    ll ntc=1;\n    //cin>>ntc;\n\n    f(i,1,ntc+1)\n    {\n      //cout<<\"Case #\"<<i<<\": \";\n      func();\n    }\n    return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\n#define fast { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n#define pb push_back\n#define ll long long\n#define ld long double\n#define sz(x) (ll)x.size()\n\n#define vi vector<int>\n#define vl vector<long>\n#define vll vector<long long>\n\n#define infi INT_MAX\n#define infl LONG_LONG_MAX\n#define infd LDBL_MAX\n#define f(i,a,b) for(ll i=a;i<b;i++)\n#define fi(i,a,b) for(ll i=(b-1);i>=a;i--)\n#define F first\n#define S second\n#define G(a,b) get<a>(b)\n#define MP make_pair\n#define MT make_tuple\n#define pll pair<ll,ll>\n//#define endl \"\\n\"\n#define ALL(v) v.begin(),v.end()\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<x;\n#define pr1(x) cout<<x<<\" \";\n#define pr2(x,y) cout<<x<<\" \"<<y;\n#define pr3(x,y,z) cout<<x<<\" \"<<y<<\" \"<<z;\n#define pr4(x,y,z,w) cout<<x<<\" \"<<y<<\" \"<<z<<\" \"<<w;\n#define deb printf(\"***************************************************************************************\\n\");\n#define moshi printf(\"moshi moshi ! \\n\");\n#define hi printf(\"hi ! \\n\");\n#define bye printf(\"bye bye ! \\n\");\n#define o_set(ll) tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>\n#define number_of_set_bits  __builtin_popcountll\nconst ld PI=3.1415926535897932384626433;\n\n//template<typename T>\n//#define o_set(T) tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>\n//member functions :\n//1. order_of_key(k) : number of elements strictly lesser than k\n//2. find_by_order(k) : k-th element in the set\n\n\n//const ll N=1e6+7;\nll p=1e9+7;\n//ll fac[N];\n\nll gcd(ll a, ll b)\n{\n   if (a == 0) return b;\n   return gcd(b % a, a);\n}\n\ninline ll ceil(ll a,ll b)\n{\n   return (a+b-1)/b;\n}\n\nll max(ll x,ll y,ll z)\n{\n   return max(x,max(y,z));\n}\n\nll min(ll x,ll y,ll z)\n{\n   return min(x,min(y,z));\n}\n\n\nll modpro(ll x,ll y,ll z=1)\n{\n   x%=p;\n   y%=p;\n   z%=p;\n   ll res=(x*y)%p;\n   res=(res*z)%p;\n   return res;\n}\n\nll modadd(ll x,ll y,ll z=0)\n{\n   x%=p;\n   y%=p;\n   z%=p;\n   ll res=(x+y)%p;\n   res=(res+z)%p;\n   return res;\n}\n\n\nll pow_mod_p(ll a,ll b)\n{\n   a=a%p;\n   ll res=1;\n   while(b>0)\n   {\n     if(b&1) res=(res*a)%p;\n     b=b>>1;\n     a=(a*a)%p;\n   }\n   return res;\n}\n\ninline ll mod_inv(ll x)\n{\n   return pow_mod_p(x,p-2);\n}\n\n\n// Don't forget to set fac[0]=1\n/*ll nCr(ll x,ll y)\n{\n   if(x<y) return 0;\n   ll res=fac[x];\n   ll den=(fac[y]*fac[x-y])%p;\n   ll deni=mod_inv(den);\n   res=(res*deni)%p;\n   return res;\n}*/\n\n\n\nll is_set(ll a,ll i)\n{\n   if( ( a & ((ll)1<<i) ) == 0 ) return 0;\n   else return 1;\n}\n\n\n\n//  Comparator should follow :\n//  1: x<=y or y<=x uniquely\n//  2: Transitivity : a<=b and b<=c implies a<=c\n//  3: Anti-Symmetry: a<=b and b<=a implies a=b\n// return 1 to put x before y in sorted order\ninline bool comp(pll &x,pll &y)\n{\n   if(x.F<y.F) return 1;\n   else if(x.F==y.F)\n   {\n      if(x.S>y.S) return 1;\n      else return 0;\n   }\n   return 0;\n}\n\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\n// resize : str.resize(new_size)   new size <= old size\n\n// for Vector :\n// lower_bound(starting iterator , iterator next to end , value)  :  iterator to first element greater than or equal to value\n// upper_bound(starting iterator , iterator next to end , value)  :  iterator to first element strictly greater than value\n\n// For Set :      s.lower_bound(value)\n// if no such element exists they return  vector.end() or s.end()\n\n\n// x bits : [x-1 , x-2 , .... , 1(1st bit) , 0(0th bit)] =>   leftmost 1 at 2^(x-1)    max number that can be represented : 2^(x) -1\n// 63 bits is greater than 10^18\n\n// 1<<x  :  2 ^ x  (left shift)\n\n// Min heap :  priority_queue < ll , vector<ll>, greater<ll> > q\n// Max heap :  priority_queue < ll > q\n    // Set in descending order  :   set< ll,greater <ll> >\n\n\n// While debugging :\n// 1 : check if array size is correct  :  It may give unexpected results\n// 2 : check if you have swapped i and j at some part of program\n// 3 : for string check if you are trying to acces  index = -1\n\n\n// Bitwise Tricks :\n// 1 : While using 1<<i  use (ll)1<<i  because in former one \"1\" is considered as int\n// 2 : To flip first k-bits of a number :  x xor (2^k-1)  or x ^ (((ll)1<<k)-1)  : 2^k-1 is the largest number of k bits\n// 3 : To flip k-th bit (0-based)  :  x xor (2^k)  or  x ^ ((ll)1<<k)\n// 4 : To set k-th bit (0-based)   :  x or (2^k)   or  x | ((ll)1<<k)\n// 5 : To un-set k-th bit (0-based)   :  x & (~ ((ll)1<<k) )\n\n\n// To prove Greedy :\n// 1 : Optimal Choice at each step\n// 2 : Exchange Argument\n// 3 : Find a lower or upper bound on answer and then construct an answer for that bound\n// 4 : Find properties which Optimal Solution must satisfy ( This can be useful to deduce form of Optimal answer)\n\n// Erase one occurrence in multiset : it=s.find(element)   s.erase(it)\n// putchar('a'+j) : to print (j+1)th character\n// getline(cin,str) : To input string until newline\n\n\nvoid lps(string &pp,ll *lps)\n{\n   ll xx=pp.length();\n   //ll lps[xx]={};\n   f(i,1,xx)\n   {\n       ll j=lps[i-1];\n       while(j>0 && pp[j]!=pp[i]) j=lps[j-1];\n       if(pp[i]==pp[j]) j++;\n       lps[i]=j;\n   }\n}\n\n\n// Remember to take input string as  getline(cin,s)\nvoid stoi(string &s,vll &v)\n{\n   stringstream str(s);\n   ll x;\n   while(str>>x)\n   {\n       v.pb(x);\n   }\n}\n\n\n\n\nvoid Miden(ll **p1,ll n)\n{\n    ll (*x)[n]=(ll(*)[n]) p1;\n    f(i,0,n)\n    {\n        f(j,0,n)\n        {\n            x[i][j]=0;\n        }\n        x[i][i]=1;\n    }\n    return;\n}\n\nvoid Mmult(ll **p1,ll **p2,ll **ans,ll x,ll y,ll z,ll m)\n{\n    ll (*a)[y]=(ll (*)[y])p1;\n    ll (*b)[z]=(ll (*)[z])p2;\n    ll (*c)[z]=(ll (*)[z])ans;\n    f(i,0,x)\n    {\n        f(j,0,z)\n        {\n            c[i][j]=0;\n            f(k,0,y)\n            {\n                c[i][j]+=a[i][k]*b[k][j];\n                c[i][j]%=m;\n            }\n        }\n    }\n    return;\n}\n\nvoid Mpow(ll **p1,ll **ans,ll n,ll y,ll m)\n{\n    if(y==0)\n    {\n        Miden(ans,n);\n        return;\n    }\n    ll t[n][n];\n    Mpow(p1,(ll **)t,n,y/2,m);\n    ll z[n][n];\n    Mmult((ll **)t,(ll **)t,(ll **)z,n,n,n,m);\n    if(y%2)\n    {\n        Mmult((ll **)z,p1,ans,n,n,n,m);\n    }\n    else\n    {\n        Miden((ll **)t,n);\n        Mmult((ll **)z,(ll **)t,ans,n,n,n,m);\n    }\n    return;\n}\n\n\n\nvoid debg(ll *arr,ll l,ll r)\n{\n  f(i,l,r+1) pr1(arr[i])\n  nl\n}\n\nvoid exit()\n{\n  cout<<\"-1\\n\";\n  exit(0);\n}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n    template <typename Arg1>\n    void __f(const char* name, Arg1&& arg1){\n        cout << name << \" : \" << arg1 << std::endl;\n        //use cerr if u want to display at the bottom\n    }\n    template <typename Arg1, typename... Args>\n    void __f(const char* names, Arg1&& arg1, Args&&... args){\n        const char* comma = strchr(names + 1, ','); cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n    }\n#else\n#define trace(...)\n#endif\n\n#define endl \"\\n\"\n\nconst ll N=1e6+6;\nlist<pll>adj[N];\nlist<ll>revAdj[N];\nll n,m,s;\nbool consider[N];\n\nvoid dfs(ll v)\n{\n  consider[v]=1;\n  for(auto i:adj[v]) if(!consider[i.F]) dfs(i.F);\n}\n\nvll topo;\nbool visited[N];\nvoid dfs2(ll v)\n{\n  visited[v]=1;\n  for(auto i:revAdj[v]) if(!visited[i] && consider[i]) dfs2(i);\n  topo.pb(v);\n}\n\nll mark[N],zz;\nlist<ll> y;\nlist<ll> mp[N];\nvoid dfs3(ll v)\n{\n  mark[v]=zz;\n  for(auto i:adj[v]) if(!mark[i.F] && consider[i.F]) dfs3(i.F);\n  y.pb(v);\n}\n\nll calc(ll x)\n{\n   ll lef=0,rig=2e4,ans=-1;\n   while(lef<=rig)\n   {\n       ll mid=(lef+rig)>>1;\n       if(x- (mid* (mid+1) )/2 >=0) ans=mid,lef=mid+1;\n       else rig=mid-1;\n   }\n   ll res=(ans+1)*x-(ans*(ans+1)*(ans+2))/6;\n   return res;\n}\n\n\nll val[N],dp[N],mx;\n\n\nvoid dfs4(ll v)\n{\n  visited[mark[v]]=1;\n  ll temp=0;\n  list<ll> &vec=mp[mark[v]];\n  for(auto i:vec) \n  {\n      for(auto j:adj[i])\n      {\n          ll u=j.F,w=j.S;\n          if(!visited[mark[u]]) dfs4(mark[u]);\n          if(mark[u]!=mark[v]) temp=max(temp,w+dp[mark[u]]);\n      }\n  }\n  dp[v]=temp+val[mark[v]];\n  mx=max(mx,dp[v]);\n}\n\n\nvoid func()\n{\n  cin>>n>>m;\n  f(i,1,m+1)\n  {\n      ll u,v,w;\n      cin>>u>>v>>w;\n      adj[u].pb(MP(v,w));\n      revAdj[v].pb(u);\n  }\n  cin>>s;\n  dfs(s);\n  f(i,1,n+1) if(!visited[i] && consider[i]) dfs2(i);\n  reverse(ALL(topo));\n  \n  for(auto i:topo)\n  {\n      if(!mark[i])\n      {\n         y.clear();\n         zz=i;\n         dfs3(i);\n         ll temp=0;\n         for(auto j:y)\n         {\n            for(auto z:adj[j])\n            {\n                if(mark[z.F]==zz) temp+=calc(z.S);\n            }\n         }\n         val[i]=temp;\n         mp[i]=y;\n      }\n  }\n  \n  f(i,1,n+1) visited[i]=0;\n  dfs4(s);\n  cout<<mx<<\"\\n\";\n}\n\n\nint main()\n{\n    fast\n\n    //#ifndef ONLINE_JUDGE\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    //#endif // ONLINE_JUDGE\n\n    ll ntc=1;\n    //cin>>ntc;\n\n    f(i,1,ntc+1)\n    {\n      //cout<<\"Case #\"<<i<<\": \";\n      func();\n    }\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\n#define forOneToN(i, n)         for(int i = 1; i <= n; i++)\n#define forZeroToNminus(i, n)   for(int i = 0; i < n; i++)\n#define forNToOne(i, n)         for(int i = n; i >= 1; i--)\n#define forNminusToZero(i, n)   for(int i = n-1; i >= 0; i--)\n\n\n#define makepair                make_pair\n#define pushback                push_back\n\n//Test Code\n#define test                    cout <<\"I am here\" << endl;\n\nusing namespace std;\nvoid fastInputOutput(){ios_base::sync_with_stdio(false);cin.tie(NULL);}\n\ntypedef long long ll;\ntypedef double db;\n\n\ntypedef vector<int>                                                             vii;\ntypedef vector<long long>                                                       vll;\ntypedef vector< pair<int, int> >                                                vpii;\ntypedef vector< pair<long long, long long> >                                    vpll;\ntypedef vector< pair<long long, int> >                                          vpli;\ntypedef vector< pair<int, long long> >                                          vpil;\ntypedef pair<int, int>                                                          pii;\ntypedef pair<long long, long long>                                              pll;\ntypedef pair<long long, int>                                                    pli;\ntypedef pair<int, long long>                                                    pil;\ntypedef map<int, int>                                                           mii;\ntypedef map<long long, long long>                                               mll;\ntypedef map<long long, int>                                                     mli;\ntypedef map<int, long long>                                                     mil;\ntypedef multimap<int, int>                                                      mmii;\ntypedef multimap<long long, int>                                                mmli;\ntypedef multimap<int, long long>                                                mmil;\ntypedef multimap<long long, long long>                                          mmll;\ntypedef set<int>                                                                si;\ntypedef set<long long>                                                          sll;\ntypedef multiset<int>                                                           msi;\ntypedef multiset<long long>                                                     msll;\ntypedef set<long long, greater<long long> >                                     slld;\ntypedef set<int, greater<int> >                                                 sid;\ntypedef multiset<int, greater<int> >                                            msid;\ntypedef multiset<long long, greater<long long> >                                mslld;\ntypedef stack<long long>                                                        stll;\ntypedef stack<int>                                                              sti;\ntypedef queue<long long>                                                        qll;\ntypedef queue<int>                                                              qi;\ntypedef priority_queue<long long>                                               maxpqll;\ntypedef priority_queue<int>                                                     maxpqi;\ntypedef priority_queue<long long, vector<long long>, greater<long long> >       minpqll;\ntypedef priority_queue<int, vector<int>, greater<int> >                         minmpqi;\ntypedef priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Minpairpq;\n\n\nll GCD(ll a, ll b){ll gcd, g;g = __gcd(a, b);return g;}\nll gcd(ll a, ll b){if(b == 0){return a;}else{return gcd(b, a%b);}}\nll extended_gcd(ll a, ll b, ll *x, ll *y){if(a == 0){*x = 0;*y = 1;return b;}ll x1, y1;ll d = extended_gcd(b%a, a, &x1, &y1);*x = y1-(b/a)*x1;*y = x1;return d;}\nll LCM(ll a, ll b){ll gcd, g;g = __gcd(a, b);return (a/g)*b;}\nll PowFun(ll base, ll power){ll ans = 1;for(int i = 1; i <= power; i++){ans *= base;}return ans;}\n/*This is better power function here used binary exponentiation*/\nll MadeFun(ll b, ll p){if(p == 0){return 1;}else if(p%2 == 0){return MadeFun(b*b, p/2);}else{return b*MadeFun(b*b, (p-1)/2);}}\nll Set(ll n, ll pos){return n = n|(1<<pos);}\nll Reset(ll n, ll pos){return n = n& ~(1<<pos);}\nbool Check(ll n, ll pos){return (bool)(n&(1<<pos));}\n\nconst ll INF_LONG = 1LL<<61;\nconst unsigned int inf_int = 1<<31;\nconst ll mod = 1e9+7;\ndouble phi = acos(-1);\n\n\n//own compare function structure for set\nstruct cmp_for_set_and_Semilar\n{\n    bool operator()(pair<int, int> a, pair<int, int> b)\n    {\n        return (a.first > b.first);\n    }\n};\n//own compare function structure for vector pair\nbool cmp(const pair<int, int> &a, const pair<int, int> &b)\n{\n    if(a.first != b.first)\n    {\n        return a.first < b.first;\n    }\n    return a.second > b.second;\n}\n\nlong long BinaryEx(long long a, long long b)\n{\n    long long ans = 1;\n    while(b)\n    {\n        if(b%2 == 0)\n        {\n            a = (a*a);\n            b /= 2;\n        }\n        else\n        {\n            ans = (ans*a);\n            b--;\n        }\n    }\n    return ans;\n}\n\nlong long mod_inverse(long long a)\n{\n    return BinaryEx(a, mod-2);\n}\n\nvector<pair<int, int>>vp;\nint mark[3000005] = {1};\nint index[3][3000005] = {};\nint pos = 0;\nint m = 0;\nbool isSubsequence(string str1, string str2, int pos1, int pos2)\n{\n    //int m = str1.size();\n    int n = str2.size();\n    int j = pos1;\n    int t1 = 0, t2 = 0;\n    for(int i = pos2; i < n && j < m; i++)\n    {\n        if(str1[j] == str2[i] && j < m)\n        {\n            //j++;\n            //vp.push_back(make_pair(j, i));\n            pos++;\n            index[0][pos] = j; index[1][pos] = i;\n            //pos++;\n            j++;\n            //pos1 = j; pos2 = i;\n            //t1 = j-1; t2 = i-1;\n        }\n    }\n    //pos1 = t1; pos2 = t2;\n    return (j == m);\n}\nvoid solve()\n{\n    string str; cin >> str;\n    int n = str.size();\n    cout << 3 << endl;\n    cout << \"R 2\" << endl;\n    cout << \"L \" << n+(n-2)-1 << endl;\n    cout << \"L \" << n+(n-2) << endl;\n}\nint main()\n{\n    fastInputOutput();\n    //int t; cin >> t;while(t--) solve();\n    solve();\n    return 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\n#define forOneToN(i, n)         for(int i = 1; i <= n; i++)\n#define forZeroToNminus(i, n)   for(int i = 0; i < n; i++)\n#define forNToOne(i, n)         for(int i = n; i >= 1; i--)\n#define forNminusToZero(i, n)   for(int i = n-1; i >= 0; i--)\n\n\n#define makepair                make_pair\n#define pushback                push_back\n\n//Test Code\n#define test                    cout <<\"I am here\" << endl;\n\nusing namespace std;\nvoid fastInputOutput(){ios_base::sync_with_stdio(false);cin.tie(NULL);}\n\ntypedef long long ll;\ntypedef double db;\n\n\ntypedef vector<int>                                                             vii;\ntypedef vector<long long>                                                       vll;\ntypedef vector< pair<int, int> >                                                vpii;\ntypedef vector< pair<long long, long long> >                                    vpll;\ntypedef vector< pair<long long, int> >                                          vpli;\ntypedef vector< pair<int, long long> >                                          vpil;\ntypedef pair<int, int>                                                          pii;\ntypedef pair<long long, long long>                                              pll;\ntypedef pair<long long, int>                                                    pli;\ntypedef pair<int, long long>                                                    pil;\ntypedef map<int, int>                                                           mii;\ntypedef map<long long, long long>                                               mll;\ntypedef map<long long, int>                                                     mli;\ntypedef map<int, long long>                                                     mil;\ntypedef multimap<int, int>                                                      mmii;\ntypedef multimap<long long, int>                                                mmli;\ntypedef multimap<int, long long>                                                mmil;\ntypedef multimap<long long, long long>                                          mmll;\ntypedef set<int>                                                                si;\ntypedef set<long long>                                                          sll;\ntypedef multiset<int>                                                           msi;\ntypedef multiset<long long>                                                     msll;\ntypedef set<long long, greater<long long> >                                     slld;\ntypedef set<int, greater<int> >                                                 sid;\ntypedef multiset<int, greater<int> >                                            msid;\ntypedef multiset<long long, greater<long long> >                                mslld;\ntypedef stack<long long>                                                        stll;\ntypedef stack<int>                                                              sti;\ntypedef queue<long long>                                                        qll;\ntypedef queue<int>                                                              qi;\ntypedef priority_queue<long long>                                               maxpqll;\ntypedef priority_queue<int>                                                     maxpqi;\ntypedef priority_queue<long long, vector<long long>, greater<long long> >       minpqll;\ntypedef priority_queue<int, vector<int>, greater<int> >                         minmpqi;\ntypedef priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Minpairpq;\n\n\nll GCD(ll a, ll b){ll gcd, g;g = __gcd(a, b);return g;}\nll gcd(ll a, ll b){if(b == 0){return a;}else{return gcd(b, a%b);}}\nll extended_gcd(ll a, ll b, ll *x, ll *y){if(a == 0){*x = 0;*y = 1;return b;}ll x1, y1;ll d = extended_gcd(b%a, a, &x1, &y1);*x = y1-(b/a)*x1;*y = x1;return d;}\nll LCM(ll a, ll b){ll gcd, g;g = __gcd(a, b);return (a/g)*b;}\nll PowFun(ll base, ll power){ll ans = 1;for(int i = 1; i <= power; i++){ans *= base;}return ans;}\n/*This is better power function here used binary exponentiation*/\nll MadeFun(ll b, ll p){if(p == 0){return 1;}else if(p%2 == 0){return MadeFun(b*b, p/2);}else{return b*MadeFun(b*b, (p-1)/2);}}\nll Set(ll n, ll pos){return n = n|(1<<pos);}\nll Reset(ll n, ll pos){return n = n& ~(1<<pos);}\nbool Check(ll n, ll pos){return (bool)(n&(1<<pos));}\n\nconst ll INF_LONG = 1LL<<61;\nconst unsigned int inf_int = 1<<31;\nconst ll mod = 1e9+7;\ndouble phi = acos(-1);\n\n\n//own compare function structure for set\nstruct cmp_for_set_and_Semilar\n{\n    bool operator()(pair<int, int> a, pair<int, int> b)\n    {\n        return (a.first > b.first);\n    }\n};\n//own compare function structure for vector pair\nbool cmp(const pair<int, int> &a, const pair<int, int> &b)\n{\n    if(a.first != b.first)\n    {\n        return a.first < b.first;\n    }\n    return a.second > b.second;\n}\n\nlong long BinaryEx(long long a, long long b)\n{\n    long long ans = 1;\n    while(b)\n    {\n        if(b%2 == 0)\n        {\n            a = (a*a);\n            b /= 2;\n        }\n        else\n        {\n            ans = (ans*a);\n            b--;\n        }\n    }\n    return ans;\n}\n\nlong long mod_inverse(long long a)\n{\n    return BinaryEx(a, mod-2);\n}\n\nvector<pair<int, int>>vp;\nint mark[3000005] = {1};\nint index[3][3000005] = {};\nint pos = 0;\nint m = 0;\nbool isSubsequence(string str1, string str2, int pos1, int pos2)\n{\n    //int m = str1.size();\n    int n = str2.size();\n    int j = pos1;\n    int t1 = 0, t2 = 0;\n    for(int i = pos2; i < n && j < m; i++)\n    {\n        if(str1[j] == str2[i] && j < m)\n        {\n            //j++;\n            //vp.push_back(make_pair(j, i));\n            pos++;\n            index[0][pos] = j; index[1][pos] = i;\n            //pos++;\n            j++;\n            //pos1 = j; pos2 = i;\n            //t1 = j-1; t2 = i-1;\n        }\n    }\n    //pos1 = t1; pos2 = t2;\n    return (j == m);\n}\nvoid solve()\n{\n    string str; cin >> str;\n    int n = str.size();\n    cout << 3 << endl;\n    cout << \"R \" << n-1 << endl;\n    cout << \"L \" << n << endl;\n    cout << \"L \" << 2 << endl;\n}\nint main()\n{\n    fastInputOutput();\n    //int t; cin >> t;while(t--) solve();\n    solve();\n    return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n#define ll long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define GOD_SPEED ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define out(a) for(int i = 0; i < (int)a.size(); ++i) cout << a[i] << \" \" ; cout << \"\\n\";\n#define pb push_back\n#define len(x) (int)x.size()\n#define ee \"\\n\"\nconst int MOD = 1e9 + 7;\nusing namespace std;\n// check for constrains, maybe bruteforce ?\nvoid solve(){\n    int n;\n    string s, t;\n    cin >> n >> s >> t;\n    n *= 2;\n    int first = 0, second = 0, overlap = 0;\n    for(int i = 0; i < n; ++i){\n        if(s[i] == '1') ++first;\n        if(t[i] == '1') ++second;\n        if(s[i] == '1' && t[i] == '1') ++overlap;\n    }\n    if(first > second && !overlap){\n        cout << \"First\";\n        return;\n    }\n    if(overlap % 2){\n        if(first >= second) {cout << \"First\"; return;}\n        else {cout << \"Second\"; return;}\n    }\n    else {\n        if(first > second) {cout << \"First\"; return;}\n        else if(first < second) {cout << \"Second\"; return;}\n        else cout << \"Draw\";\n    }\n\n}\n\nint main()\n{\n    GOD_SPEED;\n        solve();\n    \n}\n",
        "fixed_code": "#include <bits/stdc++.h>\n#define ll long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define GOD_SPEED ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define out(a) for(int i = 0; i < (int)a.size(); ++i) cout << a[i] << \" \" ; cout << \"\\n\";\n#define pb push_back\n#define len(x) (int)x.size()\n#define ee \"\\n\"\nconst int MOD = 1e9 + 7;\nusing namespace std;\n// check for constrains, maybe bruteforce ?\nvoid solve(){\n    int n;\n    string s, t;\n    cin >> n >> s >> t;\n    n *= 2;\n    int first = 0, second = 0, overlap = 0;\n    for(int i = 0; i < n; ++i){\n        if(s[i] == '1') ++first;\n        if(t[i] == '1') ++second;\n        if(s[i] == '1' && t[i] == '1') ++overlap;\n    }\n    if(first > second && !overlap){\n        cout << \"First\";\n        return;\n    }\n    first -= overlap, second -= overlap;\n    if(overlap % 2){\n        cout << (first >= second ? \"First\" : (first == second - 1 || first == second - 2 ? \"Draw\" : \"Second\"));\n    }\n    else {\n        cout << (first > second ? \"First\" : (first == second || first == second - 1? \"Draw\" : \"Second\"));\n    }\n\n}\n\nint main()\n{\n    GOD_SPEED;\n        solve();\n    \n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include<cstdio>\r\n#include<algorithm>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<cmath>\r\n#include<map>\r\n#include<vector>\r\n#include<queue>\r\n#include<stack>\r\n#include<string>\r\n#include<ctime>\r\n#include<list>\r\n#include<ctime>\r\n#define ll long long\r\nusing namespace std;\r\nconst int mo=998244353;\r\nconst int maxn=1e4+10;\r\nint n,t,a[maxn][maxn],ans,num[maxn][maxn];\r\n\r\nvoid choose(int x,int y){\r\n\tans^=a[x][y];\r\n\tnum[x-1][y]++;\r\n\tnum[x+1][y]++;\r\n\tnum[x][y-1]++;\r\n\tnum[x][y+1]++; \r\n}\r\n\r\nint main(){\r\n\tcin>>t;\r\n\twhile(t--){\r\n\t\tcin>>n;\r\n\t\tfor(int i=1;i<=n;i++) \r\n\t\t\tfor(int j=1;j<=n;j++) \r\n\t\t\t\tcin>>a[i][j];\r\n\t\tmemset(num,0,sizeof(num));\r\n\t\tans=0;\r\n\t\tfor(int i=2;i<=n;i++) \r\n\t\t\tfor(int j=1;j<=n;j++)\r\n\t\t\t\tif(num[i-1][j]%2==0)\r\n\t\t\t\t\tchoose(i,j);\r\n\t\tcout<<ans<<endl;\r\n\t}\r\n}\r\n",
        "fixed_code": "#include<cstdio>\r\n#include<algorithm>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<cmath>\r\n#include<map>\r\n#include<vector>\r\n#include<queue>\r\n#include<stack>\r\n#include<string>\r\n#include<ctime>\r\n#include<list>\r\n#include<ctime>\r\n#define ll long long\r\nusing namespace std;\r\nconst int mo=998244353;\r\nconst int maxn=1e3+10;\r\nint n,t,a[maxn][maxn],ans,num[maxn][maxn];\r\n\r\nvoid choose(int x,int y){\r\n\tans^=a[x][y];\r\n\tnum[x-1][y]++;\r\n\tnum[x+1][y]++;\r\n\tnum[x][y-1]++;\r\n\tnum[x][y+1]++; \r\n}\r\n\r\nint main(){\r\n\tcin>>t;\r\n\twhile(t--){\r\n\t\tcin>>n;\r\n\t\tfor(int i=1;i<=n;i++) \r\n\t\t\tfor(int j=1;j<=n;j++) \r\n\t\t\t\tcin>>a[i][j];\r\n\t\tmemset(num,0,sizeof(num));\r\n\t\tans=0;\r\n\t\tfor(int i=2;i<=n;i++) \r\n\t\t\tfor(int j=1;j<=n;j++)\r\n\t\t\t\tif(num[i-1][j]%2==0)\r\n\t\t\t\t\tchoose(i,j);\r\n\t\tcout<<ans<<endl;\r\n\t}\r\n}\r\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "##n+m>a+b than NO\n##at the end mereko type 1 ko khilana hai\n## agar type 2 wale sare kha le than type 1 walo ko bulaya jaye to always true\n\nt=int(input())\nfor _ in range(t):\n    a,b,n,m=map(int,input().split())\n    if m<min(a,b) and a+b>=m+n\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "fixed_code": "##n+m>a+b than NO\n##at the end mereko type 1 ko khilana hai\n## agar type 2 wale sare kha le than type 1 walo ko bulaya jaye to always true\n\nt=int(input())\nfor _ in range(t):\n    a,b,n,m=map(int,input().split())\n    if m<=min(a,b) and a+b>=m+n:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing INT  = long long;\n\nconst int NN = 202020;\n\nINT A[NN], B[NN], C[NN];\nset<int> a, b, c;\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\", \"r\", stdin);\n\tfreopen(\"out.out\", \"w\", stdout);\n#endif\n\tint n, k; cin>>n>>k;\n\tfor(int i=1; i<=n; i++) {\n\t\tint t, aa, bb;\n\t\tcin>>t>>aa>>bb;\n\t\tif(aa && bb) c.insert(t);\n\t\telse if(aa) a.insert(t);\n\t\telse if(bb) b.insert(t);\n\t}\n\tint na=0;\n\twhile(!a.empty()) {\n\t\tint u=*a.begin();\n\t\ta.erase(a.begin()); na++;\n\t\tA[na] = A[na-1] + u;\n\t}\n\tint nb=0;\n\twhile(!b.empty()) {\n\t\tint u=*b.begin();\n\t\tb.erase(b.begin()); nb++;\n\t\tB[nb] = B[nb-1] + u;\n\t}\n\t\n\tINT ans=1e15;\n\tINT sum=0;\n\tint len = min(na, nb);\n\tint p=k;\n\twhile(!c.empty()) {\n\t\tint u=*c.begin(); sum+=u;\n\t\tc.erase(c.begin());\n\t\tp--;\n\t\tif(len<p) continue;\n\t\tans = min(ans, A[p]+B[p]+sum);\n\t}\n\tif(ans==1e15) puts(\"-1\");\n\telse cout<<ans<<endl;\n\t\n    return 0;\n}\n         ",
        "fixed_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NN = 202020;\n\nint A[NN], B[NN], C[NN];\nmultiset<int> a, b, c;\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\", \"r\", stdin);\n\tfreopen(\"out.out\", \"w\", stdout);\n#endif\n\tint n, k; cin>>n>>k;\n\tfor(int i=1; i<=n; i++) {\n\t\tint t, aa, bb;\n\t\tscanf(\"%d %d %d\", &t, &aa, &bb);\n\t\tif(aa && bb) c.insert(t);\n\t\telse if(aa) a.insert(t);\n\t\telse if(bb) b.insert(t);\n\t}\n\tint na=0;\n\twhile(!a.empty()) {\n\t\tint u=*a.begin();\n\t\ta.erase(a.begin()); na++;\n\t\tA[na] = A[na-1] + u;\n\t}\n\tint nb=0;\n\twhile(!b.empty()) {\n\t\tint u=*b.begin();\n\t\tb.erase(b.begin()); nb++;\n\t\tB[nb] = B[nb-1] + u;\n\t}\n\tint ans=2e9+5;\n\tint sum=0;\n\tint len = min(na, nb);\n\tint p=k;\n\tif(len>=p) {\n\t\tans = min(ans, A[p]+B[p]);\n\t}\n\twhile(!c.empty()) {\n\t\tint u=*c.begin(); sum+=u;\n\t\tc.erase(c.begin());\n\t\tp--;\n\t\tif(len<p) continue;\n\t\tans = min(ans, A[p]+B[p]+sum);\n\t}\n\tif(ans==2e9+5) puts(\"-1\");\n\telse cout<<ans<<endl;\n\t\n    return 0;\n}\n             ",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class Codeforces {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int t = Integer.parseInt(br.readLine());\r\n        while (t-- > 0) {\r\n            int n = Integer.parseInt(br.readLine());\r\n            if ((n & 2) == 0) {\r\n                System.out.println(2 + \" \" + (n - 2 - 1) + \" \" + 1);\r\n            } else {\r\n                int x = (n - 1) / 2;\r\n                System.out.println((x + 1) + \" \" + (x - 1) + \" \" + 1);\r\n            }\r\n        }\r\n    }\r\n}",
        "fixed_code": "import java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class CodeforcesPractice {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        int t = Integer.parseInt(br.readLine());\r\n        while (t-- > 0) {\r\n            int n = Integer.parseInt(br.readLine());\r\n            if ((n & 1) == 0) {\r\n                System.out.println(2 + \" \" + (n - 3) + \" \" + 1);\r\n            } else {\r\n                int x = (n - 1) / 2;\r\n                if ((x & 1) == 0) {\r\n                    System.out.println((x + 1) + \" \" + (x - 1) + \" \" + 1);\r\n                } else {\r\n                    System.out.println((x + 2) + \" \" + (x - 2) + \" \" + 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "//package cf577d2;\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\t// ------------------------\n\t\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t// ------------------------\n\t\tint n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt(), q = sc.nextInt();\n\t\tint[][] minMax = new int[n][2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tminMax[i][0] = Integer.MAX_VALUE;\n\t\t\tminMax[i][1] = Integer.MIN_VALUE;\n\t\t}\n\t\tminMax[0][0] = 0;\n\t\tminMax[0][1] = 0;\n\t\tint maxRow = 0;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tint r = sc.nextInt() - 1, c = sc.nextInt() - 1;\n\t\t\tminMax[r][0] = Math.min(minMax[r][0], c);\n\t\t\tminMax[r][1] = Math.max(minMax[r][1], c);\n\t\t\tmaxRow = Math.max(r, maxRow);\n\t\t}\n\t\tTreeSet<Integer> b = new TreeSet<Integer>();\n\t\tint[]nextRow = new int[n];\n\t\tfor(int i = maxRow - 1; i >= 0; i--)\n\t\t\tnextRow[i] = (minMax[i + 1][0] == Integer.MAX_VALUE ? nextRow[i + 1] : i + 1);\n\t\tfor(int i = 0; i < q; i++)\n\t\t\tb.add(sc.nextInt() - 1);\n\t\tlong[]dp = new long[n];\n\t\tdp[maxRow] = minMax[maxRow][1] - minMax[maxRow][0];\n\t\tfor(int i = maxRow - 1; i >= 0; i--) \n\t\t\tif(minMax[i][0] != Integer.MAX_VALUE) {\n\t\t\t\tdp[i] = Long.MAX_VALUE;\n\t\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\t\tint st = minMax[i][j];\n\t\t\t\t\tint d = Math.abs(minMax[i][1 - j] - st);\n\t\t\t\t\tboolean okC = st <= b.last();\n\t\t\t\t\tboolean okF = st >= b.first();\n\t\t\t\t\tif(okC) {\n\t\t\t\t\t\tint ce = b.ceiling(st);\n\t\t\t\t\t\tint dC = Math.abs(st - ce);\n\t\t\t\t\t\tint dC2 = Math.min(Math.abs(minMax[nextRow[i]][0] - ce), Math.abs(minMax[nextRow[i]][1] - ce));\n\t\t\t\t\t\tif(j > 0 || i > 0)\n\t\t\t\t\t\t\tdp[i] = Math.min(dp[i], d + dC + dC2 + dp[nextRow[i]] + nextRow[i] - i);\n\t\t\t\t\t}\n\t\t\t\t\tif(okF) {\n\t\t\t\t\t\tint fl = b.floor(st);\n\t\t\t\t\t\tint dF = Math.abs(st - fl);\n\t\t\t\t\t\tint dF2 = Math.min(Math.abs(minMax[nextRow[i]][0] - fl), Math.abs(minMax[nextRow[i]][1] - fl));\n\t\t\t\t\t\tif(j > 0 || i > 0) \n\t\t\t\t\t\t\tdp[i] = Math.min(dp[i], d + dF + dF2 + dp[nextRow[i]] + nextRow[i] - i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tout.println(dp[0]);\n\t\t// ------------------------\n\t\tout.close();\n\t}\n\t//------------------------\n\t\n\tpublic static PrintWriter out;\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}",
        "fixed_code": "//package cf577d2;\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\t// ------------------------\n\t\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t// ------------------------\n\t\tint n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt(), q = sc.nextInt();\n\t\tint[][] minMax = new int[n][2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tminMax[i][0] = Integer.MAX_VALUE;\n\t\t\tminMax[i][1] = Integer.MIN_VALUE;\n\t\t}\n\t\tminMax[0][0] = 0;\n\t\tminMax[0][1] = 0;\n\t\tint maxRow = 0;\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tint r = sc.nextInt() - 1, c = sc.nextInt() - 1;\n\t\t\tminMax[r][0] = Math.min(minMax[r][0], c);\n\t\t\tminMax[r][1] = Math.max(minMax[r][1], c);\n\t\t\tmaxRow = Math.max(r, maxRow);\n\t\t}\n\t\tTreeSet<Integer> b = new TreeSet<Integer>();\n\t\tint[]nextRow = new int[n];\n\t\tfor(int i = maxRow - 1; i >= 0; i--)\n\t\t\tnextRow[i] = (minMax[i + 1][0] == Integer.MAX_VALUE ? nextRow[i + 1] : i + 1);\n\t\tfor(int i = 0; i < q; i++)\n\t\t\tb.add(sc.nextInt() - 1);\n\t\tlong[][]dp = new long[n][2];\n\t\tdp[maxRow][0] = minMax[maxRow][1] - minMax[maxRow][0];\n\t\tdp[maxRow][1] = minMax[maxRow][1] - minMax[maxRow][0];\n\t\tfor(int i = maxRow - 1; i >= 0; i--) \n\t\t\tif(minMax[i][0] != Integer.MAX_VALUE) {\n\t\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\t\t\tdp[i][j] = Long.MAX_VALUE;\n\t\t\t\t\t\tint st = minMax[i][j];\n\t\t\t\t\t\tint d = Math.abs(minMax[i][1 - j] - st);\n\t\t\t\t\t\tboolean okC = st <= b.last();\n\t\t\t\t\t\tboolean okF = st >= b.first();\n\t\t\t\t\t\tif(okC) {\n\t\t\t\t\t\t\tint ce = b.ceiling(st);\n\t\t\t\t\t\t\tint dC = Math.abs(st - ce);\n\t\t\t\t\t\t\tfor(int l = 0; l < 2; l++) {\n\t\t\t\t\t\t\t\tint dC2 = Math.abs(minMax[nextRow[i]][l] - ce);\n\t\t\t\t\t\t\t\t//System.out.println(minMax[nextRow[i]][l] + \" \"+ce);\n\t\t\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], d + dC + dC2 + dp[nextRow[i]][1 - l] + nextRow[i] - i);\n\t\t\t\t\t\t\t\t//System.out.println(\"dp[\"+i+\"][\"+j+\"] = \"+d+\" + \"+dC+\" + \"+dC2+\" + \"+dp[nextRow[i]][1 - l]+\" + \"+ (nextRow[i] - i) +\" = \"+dp[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(okF) {\n\t\t\t\t\t\t\tint fl = b.floor(st);\n\t\t\t\t\t\t\tint dF = Math.abs(st - fl);\n\t\t\t\t\t\t\tfor(int l = 0; l < 2; l++) {\n\t\t\t\t\t\t\t\tint dF2 = Math.abs(minMax[nextRow[i]][l] - fl);\n\t\t\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], d + dF + dF2 + dp[nextRow[i]][1 - l] + nextRow[i] - i);\n\t\t\t\t\t\t\t\t//System.out.println(\"dp[\"+i+\"][\"+j+\"] = \"+d+\" + \"+dF+\" + \"+dF2+\" + \"+dp[nextRow[i]][1 - l]+\" + \"+ (nextRow[i] - i) +\" = \"+dp[i][j]);\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t//for(long[]i:dp)\n\t\t\t//out.println(i[0] + \" \"+i[1]);\n\t\tout.println(dp[0][1]);\n\t\t// ------------------------\n\t\tout.close();\n\t}\n\t//------------------------\n\t\n\tpublic static PrintWriter out;\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 2e5 + 5;\r\nconst int mod = 1e9 + 7;\r\nint n, m;\r\nint a[N], Lg[N], pw[22];\r\nvector<int> f[N];\r\npair<int, int> pr[N][22];\r\n\r\npair<int, int> query(int l, int r) {\r\n    int o = Lg[r - l + 1];\r\n    return min(pr[l][o], pr[r - pw[o] + 1][o]);\r\n}\r\nint solve(int l, int r, int v) {\r\n    if(l > r) return 1;\r\n    if(l == r) return v;\r\n    pair<int, int> mp = query(l, r);\r\n    int u = mp.second;\r\n    int &F = f[u][v];\r\n    if(F != -1) return F;\r\n    F = 0;\r\n    for(int i = 1; i <= v; ++i) {\r\n        F = (F + 1LL * solve(l, u - 1, i - 1) * solve(u + 1, r, i)) % mod;\r\n    }\r\n    return F;\r\n}\r\n\r\nint main() {\r\n    pw[0] = 1;\r\n    for(int i = 1; i <= 20; ++i)\r\n        pw[i] = pw[i - 1] << 1;\r\n    for(int i = 2; i < N; ++i)\r\n        Lg[i] = Lg[i >> 1] + 1;\r\n    int T;\r\n    scanf(\"%d\", &T);\r\n    while(T--) {\r\n        scanf(\"%d %d\", &n, &m);\r\n        for(int i = 1; i <= n; ++i) {\r\n            scanf(\"%d\", &a[i]);\r\n            vector<int>().swap(f[i]);\r\n            f[i].resize(m + 1);\r\n            for(int j = 1; j <= m; ++j)\r\n                f[i][j] = -1;\r\n        }\r\n        for(int i = n; i >= 1; --i) {\r\n            for(int j = 0; j <= 20; ++j)\r\n                pr[i][j] = make_pair(m + 1, i);\r\n            pr[i][0] = make_pair(-a[i], i);\r\n            for(int j = 0; i + pw[j] <= n; ++j) {\r\n                pr[i][j + 1] = min(pr[i][j], pr[i + pw[j]][j]);\r\n            }\r\n        }\r\n        printf(\"%d\\n\", solve(1, n, m));\r\n    }\r\n    system(\"pause\");\r\n    return 0;\r\n}",
        "fixed_code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 2e5 + 5;\r\nconst int mod = 1e9 + 7;\r\nint n, m;\r\nint a[N], Lg[N], pw[22];\r\nvector<int> f[N];\r\npair<int, int> pr[N][22];\r\n\r\npair<int, int> query(int l, int r) {\r\n    int o = Lg[r - l + 1];\r\n    return min(pr[l][o], pr[r - pw[o] + 1][o]);\r\n}\r\nint solve(int l, int r, int v) {\r\n    if(l > r) return -1; \r\n    if(l == r) {\r\n        for(int i = 1; i <= v; ++i)\r\n            f[l][i] = 1;\r\n        return l;\r\n    }\r\n    pair<int, int> mp = query(l, r);\r\n    int u = mp.second;\r\n    int lu = solve(l, u - 1, v - 1), ru = solve(u + 1, r, v);\r\n    int lsum = 0, rsum = 0; \r\n    for(int i = 1; i <= v; ++i) {\r\n        if(lu == -1) lsum = 1;\r\n        else lsum = (lsum + f[lu][i - 1]) % mod;\r\n        if(ru == -1) rsum = 1;\r\n        else rsum = (rsum + f[ru][i]) % mod;\r\n        f[u][i] = 1LL * lsum * rsum % mod;\r\n    }\r\n    return u;\r\n}\r\n\r\nint main() {\r\n    pw[0] = 1;\r\n    for(int i = 1; i <= 20; ++i)\r\n        pw[i] = pw[i - 1] << 1;\r\n    for(int i = 2; i < N; ++i)\r\n        Lg[i] = Lg[i >> 1] + 1;\r\n    int T;\r\n    scanf(\"%d\", &T);\r\n    while(T--) {\r\n        scanf(\"%d %d\", &n, &m);\r\n        for(int i = 1; i <= n; ++i) {\r\n            scanf(\"%d\", &a[i]);\r\n            vector<int>().swap(f[i]);\r\n            f[i].resize(m + 1);\r\n            for(int j = 1; j <= m; ++j)\r\n                f[i][j] = 0;\r\n        }\r\n        for(int i = n; i >= 1; --i) {\r\n            for(int j = 0; j <= 20; ++j)\r\n                pr[i][j] = make_pair(m + 1, i);\r\n            pr[i][0] = make_pair(-a[i], i);\r\n            for(int j = 0; i + pw[j] <= n; ++j) {\r\n                pr[i][j + 1] = min(pr[i][j], pr[i + pw[j]][j]);\r\n            }\r\n        }\r\n        int u = solve(1, n, m);\r\n        int ans = 0;\r\n        for(int i = 1; i <= m; ++i)\r\n            ans = (ans + f[u][i]) % mod;\r\n        printf(\"%d\\n\", ans);\r\n    }\r\n    system(\"pause\");\r\n    return 0;\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define TR(i,v) \t\tfor(__typeof((v).begin())i=(v).begin();i!=(v).end();++i)\n#define DEBUG(x) \t\tcout << #x << \" = \"; cout << x << endl;\n#define SIZE(p) \t\t(int)(p).size()\n#define MP(a, b)\t\tmake_pair((a), (b))\n#define ALL(p)\t\t\t(p).begin(), (p).end()\n#define rep(i, n)\t\tfor(int (i)=0; (i)<(int)(n); ++(i))\n#define REP(i, a, n)\tfor(int (i)=(a); (i)<(int)(n); ++(i))\n#define FOR(i, a, b)   \tfor(int (i)=(int)(a); (i)<=(int)(b); ++(i))\n#define FORD(i, b, a)  \tfor(int (i)=(int)(b); (i)>=(int)(a); --(i)) \ntypedef long long LL;\ntypedef pair<int, int> pii;\nint D[550][550], C[550], fa[100005], psum[550], getid[100005];\nint find(int x)\n{\n\treturn !fa[x] ? x : fa[x] = find(fa[x]);\n}\ninline void checkmin(int &x, int y)\t\t{if(x==-1 || x>y)\tx=y;}\n\nint main(int argc, char const *argv[])\n{\n\t#ifndef ONLINE_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\t\n    // freopen(\"out\", \"w\", stdout);\n    #endif\n\t// ios::sync_with_stdio(false);    cin.tie(0);\n\tint n, m, K;\n\tcin>>n>>m>>K;\n\tFOR(i, 1, K)\t\tcin>>C[i], psum[i]=psum[i-1]+C[i];\n\tint sid = 1;\n\tFOR(i, 1, K)\n\tFOR(j, 1, C[i])\t\tgetid[sid++] = i;\t\n\tmemset(D, -1, sizeof(D));\n\tFOR(i, 1, K)\t\tD[i][i] = 0;\n\t// FOR(i, 1, n)\t\tassert(find(i) == i);\n\trep(i, m)\n\t{\n\t\tint u, v, x;\tcin>>u>>v>>x;\n\t\tint fu = find(u), fv = find(v);\n\t\tif(fu != fv)\n\t\t\tfa[fv] = fu;\n\t\tint uu = getid[u], vv = getid[v];\n\t\tcheckmin(D[uu][vv], x), checkmin(D[vv][uu], x);\n\t}\n\tint id = 1;\n\tFOR(i, 1, K)\n\t{\n\t\tint f1 = find(id);\t\t\n\t\tint id1 = getid[id];\n\t\trep(j, C[i])\n\t\t{\t\t\t\n\t\t\tint id2 = getid[id];\n\t\t\tassert(id1 == id2);\n\t\t\tint f2 = find(id++);\t\t\t\n\t\t\tif(f1 != f2)\n\t\t\t\treturn puts(\"No\"), 0;\t\t\t\n\t\t}\t\t\n\t}\n\tassert(--id == n);\t\n\tputs(\"Yes\");\n\tFOR(k, 1, K)\n\tFOR(i, 1, K)\n\tFOR(j, 1, K)\tif(~D[i][k] && ~D[k][j] && (D[i][j]==-1 || D[i][j]>D[i][k]+D[k][j]))\n\t\tD[i][j] = D[i][k]+D[k][j];\n\tFOR(i, 1, K)\n\tFOR(j, 1, K)\n\t\tprintf(\"%d%c\", D[i][j], \" \\n\"[j==K]);\n\treturn 0;\n}",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define TR(i,v) \t\tfor(__typeof((v).begin())i=(v).begin();i!=(v).end();++i)\n#define DEBUG(x) \t\tcout << #x << \" = \"; cout << x << endl;\n#define SIZE(p) \t\t(int)(p).size()\n#define MP(a, b)\t\tmake_pair((a), (b))\n#define ALL(p)\t\t\t(p).begin(), (p).end()\n#define rep(i, n)\t\tfor(int (i)=0; (i)<(int)(n); ++(i))\n#define REP(i, a, n)\tfor(int (i)=(a); (i)<(int)(n); ++(i))\n#define FOR(i, a, b)   \tfor(int (i)=(int)(a); (i)<=(int)(b); ++(i))\n#define FORD(i, b, a)  \tfor(int (i)=(int)(b); (i)>=(int)(a); --(i)) \ntypedef long long LL;\ntypedef pair<int, int> pii;\nint D[550][550], C[550], fa[100005], psum[550], getid[100005];\nint find(int x)\n{\n\treturn !fa[x] ? x : fa[x] = find(fa[x]);\n}\ninline void checkmin(int &x, int y)\t\t{if(x==-1 || x>y)\tx=y;}\n\nint main(int argc, char const *argv[])\n{\n\t#ifndef ONLINE_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\t\n    // freopen(\"out\", \"w\", stdout);\n    #endif\n\t// ios::sync_with_stdio(false);    cin.tie(0);\n\tint n, m, K;\n\tcin>>n>>m>>K;\n\tFOR(i, 1, K)\t\tcin>>C[i], psum[i]=psum[i-1]+C[i];\n\tint sid = 1;\n\tFOR(i, 1, K)\n\tFOR(j, 1, C[i])\t\tgetid[sid++] = i;\t\n\tmemset(D, -1, sizeof(D));\n\tFOR(i, 1, K)\t\tD[i][i] = 0;\n\t// FOR(i, 1, n)\t\tassert(find(i) == i);\n\trep(i, m)\n\t{\n\t\tint u, v, x;\tcin>>u>>v>>x;\n\t\tint fu = find(u), fv = find(v);\n\t\tif(fu != fv && !x)\n\t\t\tfa[fv] = fu;\n\t\tint uu = getid[u], vv = getid[v];\n\t\tcheckmin(D[uu][vv], x), checkmin(D[vv][uu], x);\n\t}\n\tint id = 1;\n\tFOR(i, 1, K)\n\t{\n\t\tint f1 = find(id);\t\t\n\t\tint id1 = getid[id];\n\t\trep(j, C[i])\n\t\t{\t\t\t\n\t\t\tint id2 = getid[id];\n\t\t\tassert(id1 == id2);\n\t\t\tint f2 = find(id++);\t\t\t\n\t\t\tif(f1 != f2)\n\t\t\t\treturn puts(\"No\"), 0;\t\t\t\n\t\t}\t\t\n\t}\n\tassert(--id == n);\t\n\tputs(\"Yes\");\n\tFOR(k, 1, K)\n\tFOR(i, 1, K)\n\tFOR(j, 1, K)\tif(~D[i][k] && ~D[k][j] && (D[i][j]==-1 || D[i][j]>D[i][k]+D[k][j]))\n\t\tD[i][j] = D[i][k]+D[k][j];\n\tFOR(i, 1, K)\n\tFOR(j, 1, K)\n\t\tprintf(\"%d%c\", D[i][j], \" \\n\"[j==K]);\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.math.BigInteger;\r\n\r\nimport java.io.*;\r\n\r\npublic class Main implements Runnable {\r\n\r\n    public static void main(String[] args) {\r\n        new Thread(null, new Main(), \"whatever\", 1 << 26).start();\r\n    }\r\n//\r\n\r\n    private FastScanner sc;\r\n    private PrintWriter pw;\r\n\r\n    public void run() {\r\n        try {\r\n            boolean isSumitting = true;\r\n            // isSumitting = false;\r\n            if (isSumitting) {\r\n                pw = new PrintWriter(System.out);\r\n                sc = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\r\n            } else {\r\n                pw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\r\n                sc = new FastScanner(new BufferedReader(new FileReader(\"input.txt\")));\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException();\r\n        }\r\n\r\n        int t = sc.nextInt();\r\n        // int t = 1;\r\n        while (t-- > 0) {\r\n            // sc.nextLine();\r\n            // System.out.println(\"for t=\" + t);\r\n            solve();\r\n        }\r\n        pw.close();\r\n    }\r\n\r\n    // public long mod = 1_000_000_007;\r\n    public long mod = 998_244_353;\r\n    private class Pair {\r\n        int first, second;\r\n        Pair(int first, int second) {\r\n            this.first = first - 1;\r\n            this.second = second - 1;\r\n        }\r\n    }\r\n\r\n    public void solve() {\r\n        int n = sc.nextInt();\r\n        int m = sc.nextInt();\r\n        int k = sc.nextInt();\r\n        int q = sc.nextInt();\r\n        if (q == 0) {\r\n            pw.println(0);\r\n            return;\r\n        }\r\n        HashSet<Integer> rows = new HashSet<Integer>();\r\n        HashSet<Integer> columns = new HashSet<Integer>();\r\n        for (int i = 0; i < n; i++) rows.add(i);\r\n        for (int i = 0; i < m; i++) columns.add(i);\r\n        Stack<Pair> queries = new Stack<Pair>();\r\n        for (int i = 0; i < q; i++) {\r\n            queries.add(new Pair(sc.nextInt(), sc.nextInt()));\r\n        }\r\n        int x, y;\r\n        int ans = 0;\r\n        boolean found = false;\r\n        while (queries.size() != 0) {\r\n            x = queries.peek().first;\r\n            y = queries.pop().second;\r\n            found = false;\r\n            if (rows.contains(x) && columns.size() > 0) {\r\n                rows.remove(x);\r\n                found = true;\r\n            }\r\n            if (columns.contains(y) && rows.size() > 0) {\r\n                columns.remove(y);\r\n                found = true;\r\n            }\r\n            if (found) ans++;\r\n        }\r\n        pw.println(fastPow((long)k, (long)ans, mod));\r\n    }\r\n\r\n\r\n\r\n    class FastScanner {\r\n        private BufferedReader reader = null;\r\n        private StringTokenizer tokenizer = null;\r\n\r\n        public FastScanner(BufferedReader bf) {\r\n            reader = bf;\r\n            tokenizer = null;\r\n        }\r\n\r\n        public String next() {\r\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n                try {\r\n                    tokenizer = new StringTokenizer(reader.readLine());\r\n                } catch (IOException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            return tokenizer.nextToken();\r\n        }\r\n\r\n        public String nextLine() {\r\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n                try {\r\n                    return reader.readLine();\r\n                } catch (IOException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            return tokenizer.nextToken(\"\\n\");\r\n        }\r\n\r\n        public long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n\r\n        public int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        public float nextFloat() {\r\n            return Float.parseFloat(next());\r\n        }\r\n\r\n        public int[] nextIntArray(int n) {\r\n            int[] a = new int[n];\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = nextInt();\r\n            }\r\n            return a;\r\n        }\r\n\r\n        public String[] nextStringArray(int n) {\r\n            String[] a = new String[n];\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = next();\r\n            }\r\n            return a;\r\n        }\r\n\r\n        public long[] nextLongArray(int n) {\r\n            long[] a = new long[n];\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = nextLong();\r\n            }\r\n            return a;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private static class Sorter {\r\n        public static <T extends Comparable<? super T>> void sort(T[] arr) {\r\n            Arrays.sort(arr);\r\n        }\r\n        public static <T> void sort(T[] arr, Comparator<T> c) {\r\n            Arrays.sort(arr, c);\r\n        }\r\n        public static <T> void sort(T[][] arr, Comparator<T[]> c) {\r\n            Arrays.sort(arr, c);\r\n        }\r\n        public static <T extends Comparable<? super T>> void sort(ArrayList<T> arr) {\r\n            Collections.sort(arr);\r\n        }\r\n        public static <T> void sort(ArrayList<T> arr, Comparator<T> c) {\r\n            Collections.sort(arr, c);\r\n        }\r\n        public static void normalSort(int[] arr) {\r\n            Arrays.sort(arr);\r\n        }\r\n        public static void normalSort(long[] arr) {\r\n            Arrays.sort(arr);\r\n        }\r\n        public static void sort(int[] arr) {\r\n            timSort(arr);\r\n        }\r\n        public static void sort(int[] arr, Comparator<Integer> c) {\r\n            timSort(arr, c);\r\n        }\r\n        public static void sort(int[][] arr, Comparator<Integer[]> c) {\r\n            timSort(arr, c);\r\n        }\r\n        public static void sort(long[] arr) {\r\n            timSort(arr);\r\n        }\r\n        public static void sort(long[] arr, Comparator<Long> c) {\r\n            timSort(arr, c);\r\n        }\r\n        public static void sort(long[][] arr, Comparator<Long[]> c) {\r\n            timSort(arr, c);\r\n        }\r\n        private static void timSort(int[] arr) {\r\n            Integer[] temp = new Integer[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(int[] arr, Comparator<Integer> c) {\r\n            Integer[] temp = new Integer[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(int[][] arr, Comparator<Integer[]> c) {\r\n            Integer[][] temp = new Integer[arr.length][arr[0].length];\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n        }\r\n        private static void timSort(long[] arr) {\r\n            Long[] temp = new Long[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(long[] arr, Comparator<Long> c) {\r\n            Long[] temp = new Long[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(long[][] arr, Comparator<Long[]> c) {\r\n            Long[][] temp = new Long[arr.length][arr[0].length];\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n        }\r\n    }\r\n\r\n\r\n    public long fastPow(long x, long y, long mod) {\r\n        if (y == 0) return 1;\r\n        if (y == 1) return x % mod;\r\n\r\n        long temp = fastPow(x, y / 2, mod);\r\n        long ans = (temp * temp) % mod;\r\n\r\n        return (y % 2 == 1) ? (ans * (x % mod)) % mod : ans;\r\n    }\r\n\r\n    public long fastPow(long x, long y) {\r\n        if (y == 0) return 1;\r\n        if (y == 1) return x;\r\n\r\n        long temp = fastPow(x, y / 2);\r\n        long ans = (temp * temp);\r\n\r\n        return (y % 2 == 1) ? (ans * x) : ans;\r\n    }\r\n\r\n}\r\n",
        "fixed_code": "import java.util.*;\r\nimport java.lang.*;\r\nimport java.math.BigInteger;\r\n\r\nimport java.io.*;\r\n\r\npublic class Main implements Runnable {\r\n\r\n    public static void main(String[] args) {\r\n        new Thread(null, new Main(), \"whatever\", 1 << 26).start();\r\n    }\r\n//\r\n\r\n    private FastScanner sc;\r\n    private PrintWriter pw;\r\n\r\n    public void run() {\r\n        try {\r\n            boolean isSumitting = true;\r\n            // isSumitting = false;\r\n            if (isSumitting) {\r\n                pw = new PrintWriter(System.out);\r\n                sc = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\r\n            } else {\r\n                pw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\r\n                sc = new FastScanner(new BufferedReader(new FileReader(\"input.txt\")));\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException();\r\n        }\r\n\r\n        int t = sc.nextInt();\r\n        // int t = 1;\r\n        while (t-- > 0) {\r\n            // sc.nextLine();\r\n            // System.out.println(\"for t=\" + t);\r\n            solve();\r\n        }\r\n        pw.close();\r\n    }\r\n\r\n    // public long mod = 1_000_000_007;\r\n    public long mod = 998_244_353;\r\n    private class Pair {\r\n        int first, second;\r\n        Pair(int first, int second) {\r\n            this.first = first - 1;\r\n            this.second = second - 1;\r\n        }\r\n    }\r\n\r\n    public void solve() {\r\n        int n = sc.nextInt();\r\n        int m = sc.nextInt();\r\n        int k = sc.nextInt();\r\n        int q = sc.nextInt();\r\n        if (q == 0) {\r\n            pw.println(0);\r\n            return;\r\n        }\r\n        int rowsCount = n;\r\n        int columnsCount = m;\r\n        boolean[] rows = new boolean[n];\r\n        boolean[] columns = new boolean[m];\r\n        Stack<Pair> queries = new Stack<Pair>();\r\n        for (int i = 0; i < q; i++) {\r\n            queries.add(new Pair(sc.nextInt(), sc.nextInt()));\r\n        }\r\n        int x, y;\r\n        int ans = 0;\r\n        boolean found = false;\r\n        Pair p;\r\n        while (queries.size() != 0) {\r\n            p = queries.pop();\r\n            x = p.first;\r\n            y = p.second;\r\n            found = false;\r\n            if (!rows[x] && columnsCount > 0) {\r\n                rows[x] = true;\r\n                rowsCount--;\r\n                found = true;\r\n            }\r\n            if (!columns[y] && rowsCount > 0) {\r\n                columns[y] = true;\r\n                columnsCount--;\r\n                found = true;\r\n            }\r\n            if (found) ans++;\r\n        }\r\n        pw.println(fastPow((long)k, (long)ans, mod));\r\n    }\r\n\r\n\r\n\r\n    class FastScanner {\r\n        private BufferedReader reader = null;\r\n        private StringTokenizer tokenizer = null;\r\n\r\n        public FastScanner(BufferedReader bf) {\r\n            reader = bf;\r\n            tokenizer = null;\r\n        }\r\n\r\n        public String next() {\r\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n                try {\r\n                    tokenizer = new StringTokenizer(reader.readLine());\r\n                } catch (IOException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            return tokenizer.nextToken();\r\n        }\r\n\r\n        public String nextLine() {\r\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n                try {\r\n                    return reader.readLine();\r\n                } catch (IOException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            return tokenizer.nextToken(\"\\n\");\r\n        }\r\n\r\n        public long nextLong() {\r\n            return Long.parseLong(next());\r\n        }\r\n\r\n        public int nextInt() {\r\n            return Integer.parseInt(next());\r\n        }\r\n\r\n        public double nextDouble() {\r\n            return Double.parseDouble(next());\r\n        }\r\n\r\n        public float nextFloat() {\r\n            return Float.parseFloat(next());\r\n        }\r\n\r\n        public int[] nextIntArray(int n) {\r\n            int[] a = new int[n];\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = nextInt();\r\n            }\r\n            return a;\r\n        }\r\n\r\n        public String[] nextStringArray(int n) {\r\n            String[] a = new String[n];\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = next();\r\n            }\r\n            return a;\r\n        }\r\n\r\n        public long[] nextLongArray(int n) {\r\n            long[] a = new long[n];\r\n            for (int i = 0; i < n; i++) {\r\n                a[i] = nextLong();\r\n            }\r\n            return a;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private static class Sorter {\r\n        public static <T extends Comparable<? super T>> void sort(T[] arr) {\r\n            Arrays.sort(arr);\r\n        }\r\n        public static <T> void sort(T[] arr, Comparator<T> c) {\r\n            Arrays.sort(arr, c);\r\n        }\r\n        public static <T> void sort(T[][] arr, Comparator<T[]> c) {\r\n            Arrays.sort(arr, c);\r\n        }\r\n        public static <T extends Comparable<? super T>> void sort(ArrayList<T> arr) {\r\n            Collections.sort(arr);\r\n        }\r\n        public static <T> void sort(ArrayList<T> arr, Comparator<T> c) {\r\n            Collections.sort(arr, c);\r\n        }\r\n        public static void normalSort(int[] arr) {\r\n            Arrays.sort(arr);\r\n        }\r\n        public static void normalSort(long[] arr) {\r\n            Arrays.sort(arr);\r\n        }\r\n        public static void sort(int[] arr) {\r\n            timSort(arr);\r\n        }\r\n        public static void sort(int[] arr, Comparator<Integer> c) {\r\n            timSort(arr, c);\r\n        }\r\n        public static void sort(int[][] arr, Comparator<Integer[]> c) {\r\n            timSort(arr, c);\r\n        }\r\n        public static void sort(long[] arr) {\r\n            timSort(arr);\r\n        }\r\n        public static void sort(long[] arr, Comparator<Long> c) {\r\n            timSort(arr, c);\r\n        }\r\n        public static void sort(long[][] arr, Comparator<Long[]> c) {\r\n            timSort(arr, c);\r\n        }\r\n        private static void timSort(int[] arr) {\r\n            Integer[] temp = new Integer[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(int[] arr, Comparator<Integer> c) {\r\n            Integer[] temp = new Integer[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(int[][] arr, Comparator<Integer[]> c) {\r\n            Integer[][] temp = new Integer[arr.length][arr[0].length];\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n        }\r\n        private static void timSort(long[] arr) {\r\n            Long[] temp = new Long[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(long[] arr, Comparator<Long> c) {\r\n            Long[] temp = new Long[arr.length];\r\n            for (int i = 0; i < arr.length; i++) temp[i] = arr[i];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++) arr[i] = temp[i];\r\n        }\r\n        private static void timSort(long[][] arr, Comparator<Long[]> c) {\r\n            Long[][] temp = new Long[arr.length][arr[0].length];\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n            Arrays.sort(temp, c);\r\n            for (int i = 0; i < arr.length; i++)\r\n                for (int j = 0; j < arr[0].length; j++)\r\n                    temp[i][j] = arr[i][j];\r\n        }\r\n    }\r\n\r\n\r\n    public long fastPow(long x, long y, long mod) {\r\n        if (y == 0) return 1;\r\n        if (y == 1) return x % mod;\r\n\r\n        long temp = fastPow(x, y / 2, mod);\r\n        long ans = (temp * temp) % mod;\r\n\r\n        return (y % 2 == 1) ? (ans * (x % mod)) % mod : ans;\r\n    }\r\n\r\n    public long fastPow(long x, long y) {\r\n        if (y == 0) return 1;\r\n        if (y == 1) return x;\r\n\r\n        long temp = fastPow(x, y / 2);\r\n        long ans = (temp * temp);\r\n\r\n        return (y % 2 == 1) ? (ans * x) : ans;\r\n    }\r\n\r\n}\r\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define f(i,n) for(int i=0;i<n;i++)\n#define HI for(int i=0;i<n;i++)cin>>a[i]\nll t,n,m,x,r,d,sum;\nstring s;\nll hcf(int a,int b)\n{\n    if(a%b==0)return b;\n    return hcf(b,a%b);\n}\n\nint main() {\n\n cin>>n;\n ll a[n];\n HI;\n set<int>v;\n sort(a,a+n);\n if(n==1){cout<<-1;return 0;}\n m=INT_MAX;\n f(i,n-1)\n {\n     v.insert(a[i+1]-a[i]);\n     m=min(m,a[i+1]-a[i]);\n }\n if(v.size()==1)\n {\n     if(m==0)cout<<\"1\\n\"<<a[0];\n     else\n     if(n==2&&(a[1]-a[0])%2==0)cout<<2*a[0]-a[1]<<\" \"<<(a[0]+a[1])/2<<\" \"<<2*a[1]-a[0];\n     else\n     cout<<\"2\\n\"<< a[0]-(a[1]-a[0])<<\" \"<< a[n-1]+(a[1]-a[0]);\n }\n else if(v.size()==2)\n {\n     int c=0,p=0;\n\n     f(i,n-1)\n     {\n         if(a[i+1]-a[i]==2*m&&m!=0){c++;p=i;}\n     }\n     if(c==1)cout<<\"1\\n\"<<a[p]+m;\n     else cout<<\"0\";\n }\n else cout<<\"0\";\n return 0;\n}\n",
        "fixed_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define f(i,n) for(int i=0;i<n;i++)\n#define HI for(int i=0;i<n;i++)cin>>a[i]\nll t,n,m,x,r,d,sum;\nstring s;\nll hcf(int a,int b)\n{\n    if(a%b==0)return b;\n    return hcf(b,a%b);\n}\n\nint main() {\n\n cin>>n;\n ll a[n];\n HI;\n set<int>v;\n sort(a,a+n);\n if(n==1){cout<<-1;return 0;}\n m=INT_MAX;\n f(i,n-1)\n {\n     v.insert(a[i+1]-a[i]);\n     m=min(m,a[i+1]-a[i]);\n }\n if(v.size()==1)\n {\n     if(m==0)cout<<\"1\\n\"<<a[0];\n     else\n     if(n==2&&(a[1]-a[0])%2==0)cout<<\"3\\n\"<< 2*a[0]-a[1]<<\" \"<<(a[0]+a[1])/2<<\" \"<<2*a[1]-a[0];\n     else\n     cout<<\"2\\n\"<< a[0]-(a[1]-a[0])<<\" \"<< a[n-1]+(a[1]-a[0]);\n }\n else if(v.size()==2)\n {\n     int c=0,p=0;\n\n     f(i,n-1)\n     {\n         if(a[i+1]-a[i]==2*m&&m!=0){c++;p=i;}\n     }\n     if(c==1)cout<<\"1\\n\"<<a[p]+m;\n     else cout<<\"0\";\n }\n else cout<<\"0\";\n return 0;\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "n, m = map(int, input().split())\nnames = {}\n\nfor i in range(n):\n    name, ip = input().split()\n    names[ip] = name\n\nfor j in range(m):\n    op, ip = input().split()\n    print(op, ip, '#' + names[ip])\n    \n",
        "fixed_code": "n, m = map(int, input().split())\nnames = {}\n\nfor i in range(n):\n    name, ip = input().split()\n    names[ip] = name\n\nfor j in range(m):\n    op, ip = input().split()\n    print(op, ip, '#' + names[ip[:-1]])",
        "source": "Python_461356.json"
    },
    {
        "source_code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.lang.Integer;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author toghru\n */\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException, IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        InputReader in = new InputReader(inputStream);\n\n        int n = in.nextInt(), m = in.nextInt();\n        int b = in.nextInt();\n        \n        \n        boolean[] x = new boolean[n];\n        for(int i = 0; i < b; i++)\n            x[in.nextInt()] = true;\n        \n        int g = in.nextInt();\n        boolean[] y = new boolean[m];\n        for(int i = 0; i < g; i++)\n            y[in.nextInt()] = true;\n        \n        \n        boolean[] hb = new boolean[n];\n        boolean[] hg = new boolean[m];\n        for(int i = 0; i < 10000000; i++) {\n            if(x[i % n] || y[i % m]) {\n                hb[i % n] = true;\n                hg[i % m] = true;\n            }\n        }\n        boolean ok = true;\n        for(int i = 0; i < n; i++) {\n            ok &= hb[i];\n        }\n        for(int i = 0; i < m; i++) {\n            ok &= hg[i];\n        }\n        out.println(ok ? \"Yes\" : \"No\");\n        out.close();\n    }\n\n    static class InputReader {\n\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream), 32624);\n            tokenizer = null;\n        }\n        // suigns dasndasdas\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException ex) {\n                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        private long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        private BigInteger nextBigInteger() {\n            return new BigInteger(next());\n        }\n    }\n\n}\n",
        "fixed_code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.lang.Integer;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author toghru\n */\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException, IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        InputReader in = new InputReader(inputStream);\n\n        int n = in.nextInt(), m = in.nextInt();\n        int b = in.nextInt();\n        \n        \n        boolean[] x = new boolean[n];\n        for(int i = 0; i < b; i++)\n            x[in.nextInt()] = true;\n        \n        int g = in.nextInt();\n        boolean[] y = new boolean[m];\n        for(int i = 0; i < g; i++)\n            y[in.nextInt()] = true;\n        \n        \n        \n        for(int i = 0; i < 1000000; i++) {\n            if(x[i % n] || y[i % m]) {\n                x[i % n] = true;\n                y[i % m] = true;\n                //out.println(i);\n            }\n        }\n        boolean ok = true;\n        for(int i = 0; i < n; i++) {\n            ok &= x[i];\n        }\n        for(int i = 0; i < m; i++) {\n            ok &= y[i];\n        }\n        out.println(ok ? \"Yes\" : \"No\");\n        out.close();\n    }\n\n    static class InputReader {\n\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream), 32624);\n            tokenizer = null;\n        }\n        // suigns dasndasdas\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException ex) {\n                    Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        private long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        private BigInteger nextBigInteger() {\n            return new BigInteger(next());\n        }\n    }\n\n}\n",
        "source": "Java_574448.json"
    },
    {
        "source_code": "function(fmt, buf, pos) {\n  pos = +pos || 0;\n  var data = null, // data to push onto return object\n      flag,        // flag to denote a variable length type was found\n      i,           // counter to step through the fmt string\n      length,      // used when a variable length type is found\n      ret = [],    // return object\n      type;        // the current char in fmt\n\n  for (i = 0; i < fmt.length; i++) {\n    // Get the letter from fmt and the size\n    type = fmt.charAt(i);\n\n    // Check if dealing with variable length data\n    if (flag) {\n      if (type == +type) {\n        // A length is given\n        length = (length) ? length+type : ''+type;\n        continue;\n      }\n      length = +length || 1;\n\n      // Split at the null byte if 'Z'\n      data = (flag === 'Z')\n             ? buf.toString('ascii', pos, pos + length).split('\\u0000')[0]\n             : buf.slice(pos, pos + length);\n      pos += length;\n\n      // Push the data\n      ret.push(data);\n      // reset\n      flag = null, length = null, data = null;\n    }\n\n    // Switch over it\n    switch (type) {\n      case 's':\n        data = buf.readInt16LE(pos);\n        break;\n      case 'S':\n        data = buf.readUInt16LE(pos);\n        break;\n      case 'i': case 'l':\n        data = buf.readInt32LE(pos);\n        break;\n      case 'I': case 'L':\n        data = buf.readUInt32LE(pos);\n        break;\n      case 'f':\n        data = buf.readFloatLE(pos);\n        break;\n      case 'd':\n        data = buf.readDoubleLE(pos);\n        break;\n      case 'Z': case 'a': case 'A':\n        flag = type;\n        break;\n    }\n\n    // Set the new pos\n    pos += +size[type] || 0;\n\n    // Reset data\n    length = null;\n\n    // Push the data\n    if (data !== null) ret.push(data);\n    data = null;\n  }\n  return ret;\n}",
        "fixed_code": "function(fmt, buf, pos) {\n  pos = +pos || 0;\n  var data = null, // data to push onto return object\n      flag,        // flag to denote a variable length type was found\n      i,           // counter to step through the fmt string\n      length,      // used when a variable length type is found\n      ret = [],    // return object\n      type;        // the current char in fmt\n\n  for (i = 0; i < fmt.length; i++) {\n    // Get the letter from fmt and the size\n    type = fmt.charAt(i);\n\n    // Check if dealing with variable length data\n    if (flag) {\n      if (type == +type) {\n        // A length is given\n        length = (length) ? length+type : ''+type;\n        if (i !== fmt.length - 1) continue;\n      }\n      length = +length || 1;\n\n      // Split at the null byte if 'Z'\n      data = (flag === 'Z')\n             ? buf.toString('ascii', pos, pos + length).split('\\u0000')[0]\n             : buf.slice(pos, pos + length);\n      pos += length;\n\n      // Push the data\n      ret.push(data);\n      if (i === fmt.length - 1) return ret;\n      // reset\n      flag = null, length = null, data = null;\n    }\n\n    // Switch over it\n    switch (type) {\n      case 's':\n        data = buf.readInt16LE(pos);\n        break;\n      case 'S':\n        data = buf.readUInt16LE(pos);\n        break;\n      case 'i': case 'l':\n        data = buf.readInt32LE(pos);\n        break;\n      case 'I': case 'L':\n        data = buf.readUInt32LE(pos);\n        break;\n      case 'f':\n        data = buf.readFloatLE(pos);\n        break;\n      case 'd':\n        data = buf.readDoubleLE(pos);\n        break;\n      case 'Z': case 'a': case 'A':\n        flag = type;\n        break;\n    }\n\n    // Set the new pos\n    pos += +size[type] || 0;\n\n    // Reset data\n    length = null;\n\n    // Push the data\n    if (data !== null) ret.push(data);\n    data = null;\n  }\n  return ret;\n}",
        "source": "FixJs_55551.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\r\n#define ll long long\r\n#define pll pair<ll,ll>\r\n#define pii pair<int,int>\r\n#define rep(i,a,b) for(int i=a;i<=b;++i)\r\n#define per(i,a,b) for(int i=a;i>=b;--i)\r\n#define mem0(x) memset(x,0,sizeof(x))\r\n#define meminf(x) memset(x,0x3f,sizeof(x))\r\n#define VI vector<int>\r\n#define VL vector<ll>\r\n#define pb push_back\r\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\r\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\r\n\r\n#define pb push_back\r\n#define fi first \r\n#define se second\r\n \r\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\r\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\r\n//#define DEBUG\r\nusing namespace std;\r\n\r\nconst int N = 1e5+5;\r\nconst ll modd = 1e9+7;\r\nll n;\r\nll a[N];\r\nll invf[N+5];\r\nll f[N+5];\r\nll qpow(ll a, ll b){ll ans=1,bs=a;while(b){if(b&1) ans=(ans*bs)%modd; \r\nbs = (bs*bs)%modd; b>>=1;} return ans;}\r\n\r\nvoid pre(){\r\n\tf[0] = 1;\r\n\trep(i,1,N){\r\n\t\tf[i] = (f[i-1]*i)%modd;\r\n\t}\r\n\t\r\n\tinvf[N] = qpow(f[N], modd-2); dump(invf[N]);\r\n\tper(i,N-1,0){\r\n\t\tinvf[i] = (invf[i+1]*(i+1LL))%modd;//dump(invf[i]);\r\n\t}\r\n\t//dump(invf[N-5]);\r\n}\r\n\r\n// void pre() {\r\n\t// f[0] = 1;\r\n\t// for(int i=1;i<N;i++) f[i] = (f[i-1]*i)%modd;\r\n\t// invf[N-1] = qpow(f[N-1], modd-2);\r\n\t// for(int i=N-2;i>=0;i--) invf[i] = (invf[i+1]*(i+1)) % modd;\r\n// \r\n\t// for(int i=0;i<N;i++) assert(invf[i]==qpow(f[i],modd-2));\r\n// }\r\n\r\nll ncr(ll nn, ll r){\r\n\tif(r<0 || nn < r) return 0;\r\n\tll res = f[n]*invf[r]%modd*invf[n-r]%modd;\r\n\treturn res;\r\n}\r\n\r\nmap<ll,ll> mp;\r\n\r\nll ccnt[N];\r\nll rmp[N];\r\n\r\nvoid solve(){\r\n\tcin>>n;dump(n);\r\n\tll sum = 0;\r\n\trep(i,1,n){\r\n\t\tcin>>a[i];\r\n\t\tsum += a[i];\r\n\t}\r\n\tif(n == 1){\r\n\t\tcout << 1 <<endl; return;\r\n\t}\r\n\tll jd = sum / n; dump(sum); dump(n);\r\n\tif(sum%n){\r\n\t\t\r\n\t\tcout << 0 <<endl; return;\r\n\t}\r\n\tsort(a+1,a+1+n);\r\n\tint idx = 0;\r\n\trep(i,1,n){\r\n\t\tif(!mp[a[i]]){\r\n\t\t\tmp[a[i]] = ++idx;\r\n\t\t\trmp[idx] = a[i];\r\n\t\t\tccnt[idx]++;\r\n\t\t}else{\r\n\t\t\tccnt[mp[a[i]]]++;\r\n\t\t}\r\n\t}\r\n\t\r\n\tll src = 0, snk = 0;\r\n\t\r\n\trep(i,1,idx){\r\n\t\tif(rmp[i]<jd){\r\n\t\t\tsrc += ccnt[i];\r\n\t\t}else if(rmp[i] > jd){\r\n\t\t\tsnk += ccnt[i];\r\n\t\t}\r\n\t}\r\n\t// rep(i,1,5){\r\n\t\t// dump(invf[N-i]);\r\n\t// }\r\n\t\r\n\tif(src == 0 || snk == 0){\r\n\t\tcout << 1 <<endl; return;\r\n\t}\r\n\t\r\n\tif(src == 1|| snk == 1){\r\n\t\tll ans = f[n];\r\n\t\trep(i,1,idx){\r\n\t\t\tif(rmp[i]<jd){\r\n\t\t\t\tans *= invf[ccnt[i]]; \r\n\t\t\t\tans %= modd;\r\n\t\t\t}else if(rmp[i] > jd){\r\n\t\t\t\tans *= invf[ccnt[i]];\r\n\t\t\t\tans %= modd;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tcout << ans <<endl;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t\r\n\tll ans = 2*f[src]%modd*f[snk]%modd;\r\n\trep(i,1,idx){\r\n\t\tif(rmp[i]<jd){\r\n\t\t\tans *= invf[ccnt[i]];\r\n\t\t\tans %= modd;\r\n\t\t}else if(rmp[i] > jd){\r\n\t\t\tans *= invf[ccnt[i]];\r\n\t\t\tans %= modd;\r\n\t\t}\r\n\t}\r\n\t\r\n\tans = (ans * ncr(n,src+snk))%modd;\r\n\tcout << ans <<endl;\r\n\t\r\n\t\r\n}\r\n\r\nint main(){\r\n    \r\n    int t; t=1;\r\n\tpre();\r\n    while(t--){\r\n    \tsolve();\r\n    }\r\n\r\n}",
        "fixed_code": "#include<bits/stdc++.h>\r\n#define ll long long\r\n#define pll pair<ll,ll>\r\n#define pii pair<int,int>\r\n#define rep(i,a,b) for(int i=a;i<=b;++i)\r\n#define per(i,a,b) for(int i=a;i>=b;--i)\r\n#define mem0(x) memset(x,0,sizeof(x))\r\n#define meminf(x) memset(x,0x3f,sizeof(x))\r\n#define VI vector<int>\r\n#define VL vector<ll>\r\n#define pb push_back\r\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\r\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\r\n\r\n#define pb push_back\r\n#define fi first \r\n#define se second\r\n \r\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\r\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\r\n//#define DEBUG\r\nusing namespace std;\r\n\r\nconst int N = 1e5+5;\r\nconst ll modd = 1e9+7;\r\nll n;\r\nll a[N];\r\nll invf[N+5];\r\nll f[N+5];\r\nll qpow(ll a, ll b){ll ans=1,bs=a;while(b){if(b&1) ans=(ans*bs)%modd; \r\nbs = (bs*bs)%modd; b>>=1;} return ans;}\r\n\r\nvoid pre(){\r\n\tf[0] = 1;\r\n\trep(i,1,N){\r\n\t\tf[i] = (f[i-1]*i)%modd;\r\n\t}\r\n\t\r\n\tinvf[N] = qpow(f[N], modd-2); dump(invf[N]);\r\n\tper(i,N-1,0){\r\n\t\tinvf[i] = (invf[i+1]*(i+1LL))%modd;//dump(invf[i]);\r\n\t}\r\n\t//dump(invf[N-5]);\r\n}\r\n\r\n// void pre() {\r\n\t// f[0] = 1;\r\n\t// for(int i=1;i<N;i++) f[i] = (f[i-1]*i)%modd;\r\n\t// invf[N-1] = qpow(f[N-1], modd-2);\r\n\t// for(int i=N-2;i>=0;i--) invf[i] = (invf[i+1]*(i+1)) % modd;\r\n// \r\n\t// for(int i=0;i<N;i++) assert(invf[i]==qpow(f[i],modd-2));\r\n// }\r\n\r\nll ncr(ll nn, ll r){\r\n\tif(r<0 || nn < r) return 0;\r\n\tll res = f[n]*invf[r]%modd*invf[n-r]%modd;\r\n\treturn res;\r\n}\r\n\r\nmap<ll,ll> mp;\r\n\r\nll ccnt[N];\r\nll rmp[N];\r\n\r\nvoid solve(){\r\n\tcin>>n;dump(n);\r\n\tll sum = 0;\r\n\trep(i,1,n){\r\n\t\tcin>>a[i];\r\n\t\tsum += a[i];\r\n\t}\r\n\tif(n == 1){\r\n\t\tcout << 1 <<endl; return;\r\n\t}\r\n\tll jd = sum / n; dump(sum); dump(n);\r\n\tif(sum%n){\r\n\t\t\r\n\t\tcout << 0 <<endl; return;\r\n\t}\r\n\tsort(a+1,a+1+n);\r\n\tint idx = 0;\r\n\trep(i,1,n){\r\n\t\tif(!mp[a[i]]){\r\n\t\t\tmp[a[i]] = ++idx;\r\n\t\t\trmp[idx] = a[i];\r\n\t\t\tccnt[idx]++;\r\n\t\t}else{\r\n\t\t\tccnt[mp[a[i]]]++;\r\n\t\t}\r\n\t}\r\n\t\r\n\tll src = 0, snk = 0;\r\n\t\r\n\trep(i,1,idx){\r\n\t\tif(rmp[i]<jd){\r\n\t\t\tsrc += ccnt[i];\r\n\t\t}else if(rmp[i] > jd){\r\n\t\t\tsnk += ccnt[i];\r\n\t\t}\r\n\t}\r\n\t// rep(i,1,5){\r\n\t\t// dump(invf[N-i]);\r\n\t// }\r\n\t\r\n\tif(src == 0 || snk == 0){\r\n\t\tcout << 1 <<endl; return;\r\n\t}\r\n\t\r\n\tif(src == 1|| snk == 1){\r\n\t\tll ans = f[n];\r\n\t\trep(i,1,idx){\r\n\t\t\tif(rmp[i]<jd){\r\n\t\t\t\tans *= invf[ccnt[i]]; \r\n\t\t\t\tans %= modd;\r\n\t\t\t}else if(rmp[i] > jd){\r\n\t\t\t\tans *= invf[ccnt[i]];\r\n\t\t\t\tans %= modd;\r\n\t\t\t}\r\n\t\t}\r\n\t\tans = (ans * invf[n-src-snk])%modd;\r\n\t\tcout << ans <<endl;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t\r\n\tll ans = 2*f[src]%modd*f[snk]%modd;\r\n\trep(i,1,idx){\r\n\t\tif(rmp[i]<jd){\r\n\t\t\tans *= invf[ccnt[i]];\r\n\t\t\tans %= modd;\r\n\t\t}else if(rmp[i] > jd){\r\n\t\t\tans *= invf[ccnt[i]];\r\n\t\t\tans %= modd;\r\n\t\t}\r\n\t}\r\n\t\r\n\tans = (ans * ncr(n,src+snk))%modd;\r\n\tcout << ans <<endl;\r\n\t\r\n\t\r\n}\r\n\r\nint main(){\r\n    \r\n    int t; t=1;\r\n\tpre();\r\n    while(t--){\r\n    \tsolve();\r\n    }\r\n\r\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "#include <iostream>\n#include <stdio.h>\n#include <iomanip> \n#include <vector>\n#include <string>\n#include <algorithm>\n#define PI 3.14159265\n#define M 1000000009\n#define SQRT 1.414213562373095\nusing namespace std;\nlong long INF = 1000003 ;\nvector<int> p;\nstring s;\nvoid prime(){\n\tp.push_back(2);\n\tfor(int i = 3; ; ++i){\n\t\tif(p[p.size()-1] > 100000){\n\t\t\tbreak;\n\t\t}\n\t\tbool t =true;\n\t\tfor(int j = 0; j < p.size(); ++j){\n\t\t\tif(i % p[j] == 0){\n\t\t\t\tt = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(t){\n\t\t\tp.push_back(i);\n\t\t}\n\t}\n}\nbool first(){\n\tfor(int i = 0; i < s.size()-1; ++i){\n\t\tif(s[i] == 'y' && s[i+1] == 'x'){\n\t\t\tswap(s[i], s[i+1]);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool second(){\t\n\tfor(int i = 0; i < s.size()-1; ++i){\n\t\tif(s[i] == 'x' && s[i+1] == 'y'){\n\t\t\ts.erase(i, 2);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\tcin >> s;\n\t/*for(;;){\n\t\tif(first()){\n\t\t\tcontinue;\n\t\t}\n\t\tif(second()){\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}*/\n\tint t = 0;\n\tfor(int i = 0; i <s.size(); ++i){\n\t\tif(s[i] == 'x'){\n\t\t\t++t;\n\t\t}\n\t}\n\tif(s.size() - 2 * t > 0){\n\t\tfor(int i = 0; i < s.size()-2*t; ++i){\n\t\t\tcout << \"y\";\n\t\t}\n\t}\n\tif(s.size() - 2 * t < 0){\n\t\tfor(int i = 0; i < -s.size()+2*t; ++i){\n\t\t\tcout << \"x\";\n\t\t}\n\t}\n\treturn 0;\n}",
        "fixed_code": "#include <iostream>\n#include <stdio.h>\n#include <iomanip> \n#include <vector>\n#include <string>\n#include <algorithm>\n#define PI 3.14159265\n#define M 1000000009\n#define SQRT 1.414213562373095\nusing namespace std;\nlong long INF = 1000003 ;\nvector<int> p;\nstring s;\nvoid prime(){\n\tp.push_back(2);\n\tfor(int i = 3; ; ++i){\n\t\tif(p[p.size()-1] > 100000){\n\t\t\tbreak;\n\t\t}\n\t\tbool t =true;\n\t\tfor(int j = 0; j < p.size(); ++j){\n\t\t\tif(i % p[j] == 0){\n\t\t\t\tt = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(t){\n\t\t\tp.push_back(i);\n\t\t}\n\t}\n}\nbool first(){\n\tfor(int i = 0; i < s.size()-1; ++i){\n\t\tif(s[i] == 'y' && s[i+1] == 'x'){\n\t\t\tswap(s[i], s[i+1]);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool second(){\t\n\tfor(int i = 0; i < s.size()-1; ++i){\n\t\tif(s[i] == 'x' && s[i+1] == 'y'){\n\t\t\ts.erase(i, 2);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\tcin >> s;\n\t/*for(;;){\n\t\tif(first()){\n\t\t\tcontinue;\n\t\t}\n\t\tif(second()){\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}*/\n\tint t = 0;\n\tfor(int i = 0; i <s.size(); ++i){\n\t\tif(s[i] == 'x'){\n\t\t\t++t;\n\t\t}\n\t}\n\tint t1 = s.size()-t;\n\tif(t1>t){\n\t\tfor(int i = 0; i < t1-t; ++i){\n\t\t\tcout << \"y\";\n\t\t}\n\t}\n\tif(t1<t){\n\t\tfor(int i = 0; i < t-t1; ++i){\n\t\t\tcout << \"x\";\n\t\t}\n\t}\n\treturn 0;\n}",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\nfrom itertools import permutations as permu\ndef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n        \n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\n###########################---Test-Case---#################################\n\"\"\"\n\n\n\n\n\"\"\"\n###########################---START-CODING---##############################\n\nnum=1\n\nnum=int(z())\n\nfor _ in range( num ):\n    n,x=zzz()\n    arr=szzz()\n    lst=[]\n\n    for i in arr:\n        lst.append((i-x))\n    if len(set(lst))==1 and list(set(lst))[0]==0:\n        print(0)\n        continue\n    if sum(lst)==0:\n        print(1)\n        continue\n    print(2)\n    \n    \n    \n    \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    \n    \n            \n        \n            \n        \n        \n    \n    \n\n    \n    \n        \n\n\n    \n    \n        \n        \n    \n    \n    \n    \n        \n        \n        \n        \n    \n            \n    \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "fixed_code": "z,zz=input,lambda:list(map(int,z().split()))\nzzz=lambda:[int(i) for i in stdin.readline().split()]\nszz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())\nfrom string import *\nfrom re import *\nfrom collections import *\nfrom queue import *\nfrom sys import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom itertools import *\nfrom bisect import *\nfrom collections import Counter as cc\nfrom math import factorial as f\nfrom bisect import bisect as bs\nfrom bisect import bisect_left as bsl\nfrom itertools import accumulate as ac\nfrom itertools import permutations as permu\ndef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))\ndef prime(x):\n    p=ceil(x**.5)+1\n    for i in range(2,p):\n        if (x%i==0 and x!=2) or x==0:return 0\n        \n    return 1\ndef dfs(u,visit,graph):\n    visit[u]=True\n    for i in graph[u]:\n        if not visit[i]:\n            dfs(i,visit,graph)\n\n###########################---Test-Case---#################################\n\"\"\"\n\n\n\n\n\"\"\"\n###########################---START-CODING---##############################\n\nnum=1\n\nnum=int(z())\n\nfor _ in range( num ):\n    n,x=zzz()\n    arr=szzz()\n    lst=[]\n    \n\n    for i in arr:\n        lst.append((i-x))\n    if len(set(lst))==1 and list(set(lst))[0]==0:\n        print(0)\n        continue\n    if sum(lst)==0:\n        print(1)\n        continue\n    if x in arr:\n        print(1)\n        continue\n    print(2)\n    \n    \n    \n    \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    \n    \n            \n        \n            \n        \n        \n    \n    \n\n    \n    \n        \n\n\n    \n    \n        \n        \n    \n    \n    \n    \n        \n        \n        \n        \n    \n            \n    \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "source": "Python_461356.json"
    },
    {
        "source_code": "//HovalHaq!\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Mx = 3 << 17, Sq = 548;\n\nint W[Mx];\nvector<ll> S[Sq][Sq];\n\nint main() {\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) cin >> W[i];\n\tint sqc = n / Sq + (n % Sq ? 1 : 0);\n\tfor(int i = 0; i < sqc; i++) {\n\t\tfor(int j = 1; j < Sq; j++) {\n\t\t\tS[i][j].resize(j);\n\t\t\tfor(int k = 0; k < Sq; k++)\n\t\t\t\tS[i][j][k % j] += W[i * Sq + k];\n\t\t}\n\t}\n\tint q; cin >> q;\n\twhile(q--) {\n\t\tint a, b; cin >> a >> b; a--;\n\t\tif(b >= Sq) {\n\t\t\tll s = 0;\n\t\t\tfor(; a < n; a += b)\n\t\t\t\ts += W[a];\n\t\t\tcout << s << \"\\n\";\n\t\t} else {\n\t\t\tint sqa = a / Sq;\n\t\t\tll s = 0;\n\t\t\tfor(; a / Sq == sqa; a += b)\n\t\t\t\ts += W[a];\n\t\t\tsqa++;\n\t\t\ta = a % b;\n\t\t\tfor(; sqa < sqc; sqa++) {\n\t\t\t\ts += S[sqa][b][a];\n\t\t\t}\n\t\t\tcout << s << \"\\n\";\n\t\t}\n\t}\n}\n",
        "fixed_code": "//HovalHaq!\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int Mx = 3 << 17, Sq = 548;\n\nint W[Mx];\nll S[Mx], R[Mx];\n\nint main() {\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) cin >> W[i];\n//\tfor(int i = 1; i < Sq; i++)\n//\t\tfor(int j = n - 1; j >= 0; j--)\n//\t\t\tS[i][j] = W[j] + S[i][j + i];\n\tint q; cin >> q;\n\tunordered_map<int, vector<PII>> M;\n\tfor(int i = 0; i < q; i++) {\n\t\tint a, b; cin >> a >> b; a--;\n\t\tif(b >= Sq)\n\t\t\tfor(; a < n; a += b)\n\t\t\t\tR[i] += W[a];\n\t\telse\n\t\t\tM[b].push_back({i, a});\n\t}\n\tfor(auto p : M) {\n\t\tfor(int j = n - 1; j >= 0; j--)\n\t\t\tS[j] = W[j] + S[j + p.first];\n\t\tfor(auto q : p.second)\n\t\t\tR[q.first] = S[q.second];\n\t}\n\tfor(int i = 0; i < q; i++)\n\t\tcout << R[i] << \"\\n\";\n//\twhile(q--) {\n//\t\tint a, b; cin >> a >> b; a--;\n//\t\tif(b >= Sq) {\n//\t\t\tfor(; a < n; a += b)\n//\t\t\t\ts += W[a];\n//\t\t} else {\n//\t\t\tcout << S[b][a] << \"\\n\";\n//\t\t}\n//\t}\n}\n",
        "source": "C++_3409220.json"
    },
    {
        "source_code": "n=int(input())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nsol=set(p+q0\nfor i in range(1,n+1):\n    if i not in sol:\n        print(\"Oh, my keyboard!\")\n        exit() \nprint(\"I become the guy.\")\n\n'''\n3\n1 2\n2 2 3\n'''",
        "fixed_code": "n=int(input())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nx,y=p[0],q[0]\nq.remove(y)\np.remove(x)\nsol=p+q \nfor i in range(1,n+1):\n    if i not in sol:\n        print(\"Oh, my keyboard!\")\n        exit() \nprint(\"I become the guy.\")\n\n\n\n\n'''\n\n\n\n3\n1 2\n2 2 3\n\n\n\n\n'''",
        "source": "Python_461356.json"
    },
    {
        "source_code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+5;\nint mark1[maxn]={0},mark2[maxn]={0};\nint main()\n{\n\tint m,h1,h2,a1,a2,x1,x2,y1,y2;\n\tcin>>m>>h1>>a1>>x1>>y1>>h2>>a2>>x2>>y2;\n\tint ans=0,flag=0,c1=a1,c2=a2;\n\tmark1[h1]=1;mark2[h2]=1;\n\twhile(1){\n\t\th1=(x1*h1+y1)%m;\n\t\th2=(x2*h2+y2)%m;\n\t\tans++;\n\t\tif(h1==a1&&h2==a2){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}//cout<<h1<<' '<<h2<<endl;\n\t\tif(h1==c1&&h2==c2)\n\t\t\tbreak;\n\t\tif(!mark1[h1])\tmark1[h1]=1;\n\t\tif(!mark2[h2])\tmark2[h2]=1;\n\t}\n\tif(flag)\tcout<<ans<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}\n",
        "fixed_code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100010;\nint mark1[maxn]={0},mark2[maxn]={0};\nint main()\n{\n\tlong long m,h1,h2,a1,a2,x1,x2,y1,y2;\n\tcin>>m>>h1>>a1>>x1>>y1>>h2>>a2>>x2>>y2;\n\tlong long r1=-1,r2=-1,p1=-1,p2=-1;\n\tfor(int i=1;i<=2*m;i++){\n\t\th1=(h1*x1+y1)%m;\n\t\tif(h1==a1){\n\t\t\tif(p1==-1)\n\t\t\t\tp1=i;\n\t\t\telse if(r1==-1)\n\t\t\t\tr1=i-p1;\n\t\t}\n\t\th2=(h2*x2+y2)%m;\n\t\tif(h2==a2){\n\t\t\tif(p2==-1)\n\t\t\t\tp2=i;\n\t\t\telse if(r2==-1)\n\t\t\t\tr2=i-p2;\n\t\t}\n\t}\n\tif(p1==-1||p2==-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=2*m;i++){\n\t\tif(p1==p2){\n\t\t\tcout<<p1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(p1<p2)\tp1+=r1;\n\t\telse\t\tp2+=r2;\n\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}\n",
        "source": "C++_3409220.json"
    }
]